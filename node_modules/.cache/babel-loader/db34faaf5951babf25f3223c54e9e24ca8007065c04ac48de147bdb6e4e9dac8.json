{"ast":null,"code":"import { nanoid } from \"nanoid\";\nimport { cleanAppStateForExport } from \"../appState\";\nimport { IMAGE_MIME_TYPES, MIME_TYPES } from \"../constants\";\nimport { clearElementsForExport } from \"../element\";\nimport { CanvasError } from \"../errors\";\nimport { t } from \"../i18n\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { bytesToHexString } from \"../utils\";\nimport { nativeFileSystemSupported } from \"./filesystem\";\nimport { isValidExcalidrawData, isValidLibrary } from \"./json\";\nimport { restore, restoreLibraryItems } from \"./restore\";\nconst parseFileContents = async blob => {\n  let contents;\n  if (blob.type === MIME_TYPES.png) {\n    try {\n      return await (await import( /* webpackChunkName: \"image\" */\"./image\")).decodePngMetadata(blob);\n    } catch (error) {\n      if (error.message === \"INVALID\") {\n        throw new DOMException(t(\"alerts.imageDoesNotContainScene\"), \"EncodingError\");\n      } else {\n        throw new DOMException(t(\"alerts.cannotRestoreFromImage\"), \"EncodingError\");\n      }\n    }\n  } else {\n    if (\"text\" in Blob) {\n      contents = await blob.text();\n    } else {\n      contents = await new Promise(resolve => {\n        const reader = new FileReader();\n        reader.readAsText(blob, \"utf8\");\n        reader.onloadend = () => {\n          if (reader.readyState === FileReader.DONE) {\n            resolve(reader.result);\n          }\n        };\n      });\n    }\n    if (blob.type === MIME_TYPES.svg) {\n      try {\n        return await (await import( /* webpackChunkName: \"image\" */\"./image\")).decodeSvgMetadata({\n          svg: contents\n        });\n      } catch (error) {\n        if (error.message === \"INVALID\") {\n          throw new DOMException(t(\"alerts.imageDoesNotContainScene\"), \"EncodingError\");\n        } else {\n          throw new DOMException(t(\"alerts.cannotRestoreFromImage\"), \"EncodingError\");\n        }\n      }\n    }\n  }\n  return contents;\n};\nexport const getMimeType = blob => {\n  let name;\n  if (typeof blob === \"string\") {\n    name = blob;\n  } else {\n    if (blob.type) {\n      return blob.type;\n    }\n    name = blob.name || \"\";\n  }\n  if (/\\.(excalidraw|json)$/.test(name)) {\n    return MIME_TYPES.json;\n  } else if (/\\.png$/.test(name)) {\n    return MIME_TYPES.png;\n  } else if (/\\.jpe?g$/.test(name)) {\n    return MIME_TYPES.jpg;\n  } else if (/\\.svg$/.test(name)) {\n    return MIME_TYPES.svg;\n  }\n  return \"\";\n};\nexport const getFileHandleType = handle => {\n  var _handle$name$match;\n  if (!handle) {\n    return null;\n  }\n  return ((_handle$name$match = handle.name.match(/\\.(json|excalidraw|png|svg)$/)) === null || _handle$name$match === void 0 ? void 0 : _handle$name$match[1]) || null;\n};\nexport const isImageFileHandleType = type => {\n  return type === \"png\" || type === \"svg\";\n};\nexport const isImageFileHandle = handle => {\n  const type = getFileHandleType(handle);\n  return type === \"png\" || type === \"svg\";\n};\nexport const isSupportedImageFile = blob => {\n  const {\n    type\n  } = blob || {};\n  return !!type && Object.values(IMAGE_MIME_TYPES).includes(type);\n};\nexport const loadSceneOrLibraryFromBlob = async (blob, localAppState, localElements, fileHandle) => {\n  const contents = await parseFileContents(blob);\n  try {\n    const data = JSON.parse(contents);\n    if (isValidExcalidrawData(data)) {\n      return {\n        type: MIME_TYPES.excalidraw,\n        data: restore({\n          elements: clearElementsForExport(data.elements || []),\n          appState: {\n            theme: localAppState === null || localAppState === void 0 ? void 0 : localAppState.theme,\n            fileHandle: fileHandle || blob.handle || null,\n            ...cleanAppStateForExport(data.appState || {}),\n            ...(localAppState ? calculateScrollCenter(data.elements || [], localAppState, null) : {})\n          },\n          files: data.files\n        }, localAppState, localElements, {\n          repairBindings: true,\n          refreshDimensions: false\n        })\n      };\n    } else if (isValidLibrary(data)) {\n      return {\n        type: MIME_TYPES.excalidrawlib,\n        data\n      };\n    }\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  } catch (error) {\n    console.error(error.message);\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n};\nexport const loadFromBlob = async (blob, localAppState, localElements, fileHandle) => {\n  const ret = await loadSceneOrLibraryFromBlob(blob, localAppState, localElements, fileHandle);\n  if (ret.type !== MIME_TYPES.excalidraw) {\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n  return ret.data;\n};\nexport const parseLibraryJSON = function (json) {\n  let defaultStatus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"unpublished\";\n  const data = JSON.parse(json);\n  if (!isValidLibrary(data)) {\n    throw new Error(\"Invalid library\");\n  }\n  const libraryItems = data.libraryItems || data.library;\n  return restoreLibraryItems(libraryItems, defaultStatus);\n};\nexport const loadLibraryFromBlob = async function (blob) {\n  let defaultStatus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"unpublished\";\n  return parseLibraryJSON(await parseFileContents(blob), defaultStatus);\n};\nexport const canvasToBlob = async canvas => {\n  return new Promise((resolve, reject) => {\n    try {\n      canvas.toBlob(blob => {\n        if (!blob) {\n          return reject(new CanvasError(t(\"canvasError.canvasTooBig\"), \"CANVAS_POSSIBLY_TOO_BIG\"));\n        }\n        resolve(blob);\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n\n/** generates SHA-1 digest from supplied file (if not supported, falls back\n    to a 40-char base64 random id) */\nexport const generateIdFromFile = async file => {\n  try {\n    const hashBuffer = await window.crypto.subtle.digest(\"SHA-1\", await blobToArrayBuffer(file));\n    return bytesToHexString(new Uint8Array(hashBuffer));\n  } catch (error) {\n    console.error(error);\n    // length 40 to align with the HEX length of SHA-1 (which is 160 bit)\n    return nanoid(40);\n  }\n};\nexport const getDataURL = async file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const dataURL = reader.result;\n      resolve(dataURL);\n    };\n    reader.onerror = error => reject(error);\n    reader.readAsDataURL(file);\n  });\n};\nexport const dataURLToFile = function (dataURL) {\n  let filename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  const dataIndexStart = dataURL.indexOf(\",\");\n  const byteString = atob(dataURL.slice(dataIndexStart + 1));\n  const mimeType = dataURL.slice(0, dataIndexStart).split(\":\")[1].split(\";\")[0];\n  const ab = new ArrayBuffer(byteString.length);\n  const ia = new Uint8Array(ab);\n  for (let i = 0; i < byteString.length; i++) {\n    ia[i] = byteString.charCodeAt(i);\n  }\n  return new File([ab], filename, {\n    type: mimeType\n  });\n};\nexport const resizeImageFile = async (file, opts) => {\n  // SVG files shouldn't a can't be resized\n  if (file.type === MIME_TYPES.svg) {\n    return file;\n  }\n  const [pica, imageBlobReduce] = await Promise.all([import(\"pica\").then(res => res.default),\n  // a wrapper for pica for better API\n  import(\"image-blob-reduce\").then(res => res.default)]);\n\n  // CRA's minification settings break pica in WebWorkers, so let's disable\n  // them for now\n  // https://github.com/nodeca/image-blob-reduce/issues/21#issuecomment-757365513\n  const reduce = imageBlobReduce({\n    pica: pica({\n      features: [\"js\", \"wasm\"]\n    })\n  });\n  if (opts.outputType) {\n    const {\n      outputType\n    } = opts;\n    reduce._create_blob = function (env) {\n      return this.pica.toBlob(env.out_canvas, outputType, 0.8).then(blob => {\n        env.out_blob = blob;\n        return env;\n      });\n    };\n  }\n  if (!isSupportedImageFile(file)) {\n    throw new Error(t(\"errors.unsupportedFileType\"));\n  }\n  return new File([await reduce.toBlob(file, {\n    max: opts.maxWidthOrHeight\n  })], file.name, {\n    type: opts.outputType || file.type\n  });\n};\nexport const SVGStringToFile = function (SVGString) {\n  let filename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  return new File([new TextEncoder().encode(SVGString)], filename, {\n    type: MIME_TYPES.svg\n  });\n};\nexport const getFileFromEvent = async event => {\n  const file = event.dataTransfer.files.item(0);\n  const fileHandle = await getFileHandle(event);\n  return {\n    file: file ? await normalizeFile(file) : null,\n    fileHandle\n  };\n};\nexport const getFileHandle = async event => {\n  if (nativeFileSystemSupported) {\n    try {\n      const item = event.dataTransfer.items[0];\n      const handle = (await item.getAsFileSystemHandle()) || null;\n      return handle;\n    } catch (error) {\n      console.warn(error.name, error.message);\n      return null;\n    }\n  }\n  return null;\n};\n\n/**\n * attempts to detect if a buffer is a valid image by checking its leading bytes\n */\nconst getActualMimeTypeFromImage = buffer => {\n  let mimeType = null;\n  const first8Bytes = `${[...new Uint8Array(buffer).slice(0, 8)].join(\" \")} `;\n\n  // uint8 leading bytes\n  const headerBytes = {\n    // https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\n    png: \"137 80 78 71 13 10 26 10 \",\n    // https://en.wikipedia.org/wiki/JPEG#Syntax_and_structure\n    // jpg is a bit wonky. Checking the first three bytes should be enough,\n    // but may yield false positives. (https://stackoverflow.com/a/23360709/927631)\n    jpg: \"255 216 255 \",\n    // https://en.wikipedia.org/wiki/GIF#Example_GIF_file\n    gif: \"71 73 70 56 57 97 \"\n  };\n  if (first8Bytes === headerBytes.png) {\n    mimeType = MIME_TYPES.png;\n  } else if (first8Bytes.startsWith(headerBytes.jpg)) {\n    mimeType = MIME_TYPES.jpg;\n  } else if (first8Bytes.startsWith(headerBytes.gif)) {\n    mimeType = MIME_TYPES.gif;\n  }\n  return mimeType;\n};\nexport const createFile = (blob, mimeType, name) => {\n  return new File([blob], name || \"\", {\n    type: mimeType\n  });\n};\n\n/** attempts to detect correct mimeType if none is set, or if an image\n * has an incorrect extension.\n * Note: doesn't handle missing .excalidraw/.excalidrawlib extension  */\nexport const normalizeFile = async file => {\n  if (!file.type) {\n    var _file, _file$name, _file2, _file2$name;\n    if ((_file = file) !== null && _file !== void 0 && (_file$name = _file.name) !== null && _file$name !== void 0 && _file$name.endsWith(\".excalidrawlib\")) {\n      file = createFile(await blobToArrayBuffer(file), MIME_TYPES.excalidrawlib, file.name);\n    } else if ((_file2 = file) !== null && _file2 !== void 0 && (_file2$name = _file2.name) !== null && _file2$name !== void 0 && _file2$name.endsWith(\".excalidraw\")) {\n      file = createFile(await blobToArrayBuffer(file), MIME_TYPES.excalidraw, file.name);\n    } else {\n      const buffer = await blobToArrayBuffer(file);\n      const mimeType = getActualMimeTypeFromImage(buffer);\n      if (mimeType) {\n        file = createFile(buffer, mimeType, file.name);\n      }\n    }\n    // when the file is an image, make sure the extension corresponds to the\n    // actual mimeType (this is an edge case, but happens sometime)\n  } else if (isSupportedImageFile(file)) {\n    const buffer = await blobToArrayBuffer(file);\n    const mimeType = getActualMimeTypeFromImage(buffer);\n    if (mimeType && mimeType !== file.type) {\n      file = createFile(buffer, mimeType, file.name);\n    }\n  }\n  return file;\n};\nexport const blobToArrayBuffer = blob => {\n  if (\"arrayBuffer\" in blob) {\n    return blob.arrayBuffer();\n  }\n  // Safari\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = event => {\n      var _event$target;\n      if (!((_event$target = event.target) !== null && _event$target !== void 0 && _event$target.result)) {\n        return reject(new Error(\"Couldn't convert blob to ArrayBuffer\"));\n      }\n      resolve(event.target.result);\n    };\n    reader.readAsArrayBuffer(blob);\n  });\n};","map":{"version":3,"names":["nanoid","cleanAppStateForExport","IMAGE_MIME_TYPES","MIME_TYPES","clearElementsForExport","CanvasError","t","calculateScrollCenter","bytesToHexString","nativeFileSystemSupported","isValidExcalidrawData","isValidLibrary","restore","restoreLibraryItems","parseFileContents","blob","contents","type","png","decodePngMetadata","error","message","DOMException","Blob","text","Promise","resolve","reader","FileReader","readAsText","onloadend","readyState","DONE","result","svg","decodeSvgMetadata","getMimeType","name","test","json","jpg","getFileHandleType","handle","_handle$name$match","match","isImageFileHandleType","isImageFileHandle","isSupportedImageFile","Object","values","includes","loadSceneOrLibraryFromBlob","localAppState","localElements","fileHandle","data","JSON","parse","excalidraw","elements","appState","theme","files","repairBindings","refreshDimensions","excalidrawlib","Error","console","loadFromBlob","ret","parseLibraryJSON","defaultStatus","arguments","length","undefined","libraryItems","library","loadLibraryFromBlob","canvasToBlob","canvas","reject","toBlob","generateIdFromFile","file","hashBuffer","window","crypto","subtle","digest","blobToArrayBuffer","Uint8Array","getDataURL","onload","dataURL","onerror","readAsDataURL","dataURLToFile","filename","dataIndexStart","indexOf","byteString","atob","slice","mimeType","split","ab","ArrayBuffer","ia","i","charCodeAt","File","resizeImageFile","opts","pica","imageBlobReduce","all","then","res","default","reduce","features","outputType","_create_blob","env","out_canvas","out_blob","max","maxWidthOrHeight","SVGStringToFile","SVGString","TextEncoder","encode","getFileFromEvent","event","dataTransfer","item","getFileHandle","normalizeFile","items","getAsFileSystemHandle","warn","getActualMimeTypeFromImage","buffer","first8Bytes","join","headerBytes","gif","startsWith","createFile","_file","_file$name","_file2","_file2$name","endsWith","arrayBuffer","_event$target","target","readAsArrayBuffer"],"sources":["D:/project/excalidraw-cn/src/data/blob.ts"],"sourcesContent":["import { nanoid } from \"nanoid\";\nimport { cleanAppStateForExport } from \"../appState\";\nimport { IMAGE_MIME_TYPES, MIME_TYPES } from \"../constants\";\nimport { clearElementsForExport } from \"../element\";\nimport { ExcalidrawElement, FileId } from \"../element/types\";\nimport { CanvasError } from \"../errors\";\nimport { t } from \"../i18n\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { AppState, DataURL, LibraryItem } from \"../types\";\nimport { ValueOf } from \"../utility-types\";\nimport { bytesToHexString } from \"../utils\";\nimport { FileSystemHandle, nativeFileSystemSupported } from \"./filesystem\";\nimport { isValidExcalidrawData, isValidLibrary } from \"./json\";\nimport { restore, restoreLibraryItems } from \"./restore\";\nimport { ImportedLibraryData } from \"./types\";\n\nconst parseFileContents = async (blob: Blob | File) => {\n  let contents: string;\n\n  if (blob.type === MIME_TYPES.png) {\n    try {\n      return await (\n        await import(/* webpackChunkName: \"image\" */ \"./image\")\n      ).decodePngMetadata(blob);\n    } catch (error: any) {\n      if (error.message === \"INVALID\") {\n        throw new DOMException(\n          t(\"alerts.imageDoesNotContainScene\"),\n          \"EncodingError\",\n        );\n      } else {\n        throw new DOMException(\n          t(\"alerts.cannotRestoreFromImage\"),\n          \"EncodingError\",\n        );\n      }\n    }\n  } else {\n    if (\"text\" in Blob) {\n      contents = await blob.text();\n    } else {\n      contents = await new Promise((resolve) => {\n        const reader = new FileReader();\n        reader.readAsText(blob, \"utf8\");\n        reader.onloadend = () => {\n          if (reader.readyState === FileReader.DONE) {\n            resolve(reader.result as string);\n          }\n        };\n      });\n    }\n    if (blob.type === MIME_TYPES.svg) {\n      try {\n        return await (\n          await import(/* webpackChunkName: \"image\" */ \"./image\")\n        ).decodeSvgMetadata({\n          svg: contents,\n        });\n      } catch (error: any) {\n        if (error.message === \"INVALID\") {\n          throw new DOMException(\n            t(\"alerts.imageDoesNotContainScene\"),\n            \"EncodingError\",\n          );\n        } else {\n          throw new DOMException(\n            t(\"alerts.cannotRestoreFromImage\"),\n            \"EncodingError\",\n          );\n        }\n      }\n    }\n  }\n  return contents;\n};\n\nexport const getMimeType = (blob: Blob | string): string => {\n  let name: string;\n  if (typeof blob === \"string\") {\n    name = blob;\n  } else {\n    if (blob.type) {\n      return blob.type;\n    }\n    name = blob.name || \"\";\n  }\n  if (/\\.(excalidraw|json)$/.test(name)) {\n    return MIME_TYPES.json;\n  } else if (/\\.png$/.test(name)) {\n    return MIME_TYPES.png;\n  } else if (/\\.jpe?g$/.test(name)) {\n    return MIME_TYPES.jpg;\n  } else if (/\\.svg$/.test(name)) {\n    return MIME_TYPES.svg;\n  }\n  return \"\";\n};\n\nexport const getFileHandleType = (handle: FileSystemHandle | null) => {\n  if (!handle) {\n    return null;\n  }\n\n  return handle.name.match(/\\.(json|excalidraw|png|svg)$/)?.[1] || null;\n};\n\nexport const isImageFileHandleType = (\n  type: string | null,\n): type is \"png\" | \"svg\" => {\n  return type === \"png\" || type === \"svg\";\n};\n\nexport const isImageFileHandle = (handle: FileSystemHandle | null) => {\n  const type = getFileHandleType(handle);\n  return type === \"png\" || type === \"svg\";\n};\n\nexport const isSupportedImageFile = (\n  blob: Blob | null | undefined,\n): blob is Blob & { type: ValueOf<typeof IMAGE_MIME_TYPES> } => {\n  const { type } = blob || {};\n  return !!type && (Object.values(IMAGE_MIME_TYPES) as string[]).includes(type);\n};\n\nexport const loadSceneOrLibraryFromBlob = async (\n  blob: Blob | File,\n  /** @see restore.localAppState */\n  localAppState: AppState | null,\n  localElements: readonly ExcalidrawElement[] | null,\n  /** FileSystemHandle. Defaults to `blob.handle` if defined, otherwise null. */\n  fileHandle?: FileSystemHandle | null,\n) => {\n  const contents = await parseFileContents(blob);\n  try {\n    const data = JSON.parse(contents);\n    if (isValidExcalidrawData(data)) {\n      return {\n        type: MIME_TYPES.excalidraw,\n        data: restore(\n          {\n            elements: clearElementsForExport(data.elements || []),\n            appState: {\n              theme: localAppState?.theme,\n              fileHandle: fileHandle || blob.handle || null,\n              ...cleanAppStateForExport(data.appState || {}),\n              ...(localAppState\n                ? calculateScrollCenter(\n                    data.elements || [],\n                    localAppState,\n                    null,\n                  )\n                : {}),\n            },\n            files: data.files,\n          },\n          localAppState,\n          localElements,\n          { repairBindings: true, refreshDimensions: false },\n        ),\n      };\n    } else if (isValidLibrary(data)) {\n      return {\n        type: MIME_TYPES.excalidrawlib,\n        data,\n      };\n    }\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  } catch (error: any) {\n    console.error(error.message);\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n};\n\nexport const loadFromBlob = async (\n  blob: Blob,\n  /** @see restore.localAppState */\n  localAppState: AppState | null,\n  localElements: readonly ExcalidrawElement[] | null,\n  /** FileSystemHandle. Defaults to `blob.handle` if defined, otherwise null. */\n  fileHandle?: FileSystemHandle | null,\n) => {\n  const ret = await loadSceneOrLibraryFromBlob(\n    blob,\n    localAppState,\n    localElements,\n    fileHandle,\n  );\n  if (ret.type !== MIME_TYPES.excalidraw) {\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n  return ret.data;\n};\n\nexport const parseLibraryJSON = (\n  json: string,\n  defaultStatus: LibraryItem[\"status\"] = \"unpublished\",\n) => {\n  const data: ImportedLibraryData | undefined = JSON.parse(json);\n  if (!isValidLibrary(data)) {\n    throw new Error(\"Invalid library\");\n  }\n  const libraryItems = data.libraryItems || data.library;\n  return restoreLibraryItems(libraryItems, defaultStatus);\n};\n\nexport const loadLibraryFromBlob = async (\n  blob: Blob,\n  defaultStatus: LibraryItem[\"status\"] = \"unpublished\",\n) => {\n  return parseLibraryJSON(await parseFileContents(blob), defaultStatus);\n};\n\nexport const canvasToBlob = async (\n  canvas: HTMLCanvasElement,\n): Promise<Blob> => {\n  return new Promise((resolve, reject) => {\n    try {\n      canvas.toBlob((blob) => {\n        if (!blob) {\n          return reject(\n            new CanvasError(\n              t(\"canvasError.canvasTooBig\"),\n              \"CANVAS_POSSIBLY_TOO_BIG\",\n            ),\n          );\n        }\n        resolve(blob);\n      });\n    } catch (error: any) {\n      reject(error);\n    }\n  });\n};\n\n/** generates SHA-1 digest from supplied file (if not supported, falls back\n    to a 40-char base64 random id) */\nexport const generateIdFromFile = async (file: File): Promise<FileId> => {\n  try {\n    const hashBuffer = await window.crypto.subtle.digest(\n      \"SHA-1\",\n      await blobToArrayBuffer(file),\n    );\n    return bytesToHexString(new Uint8Array(hashBuffer)) as FileId;\n  } catch (error: any) {\n    console.error(error);\n    // length 40 to align with the HEX length of SHA-1 (which is 160 bit)\n    return nanoid(40) as FileId;\n  }\n};\n\nexport const getDataURL = async (file: Blob | File): Promise<DataURL> => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const dataURL = reader.result as DataURL;\n      resolve(dataURL);\n    };\n    reader.onerror = (error) => reject(error);\n    reader.readAsDataURL(file);\n  });\n};\n\nexport const dataURLToFile = (dataURL: DataURL, filename = \"\") => {\n  const dataIndexStart = dataURL.indexOf(\",\");\n  const byteString = atob(dataURL.slice(dataIndexStart + 1));\n  const mimeType = dataURL.slice(0, dataIndexStart).split(\":\")[1].split(\";\")[0];\n\n  const ab = new ArrayBuffer(byteString.length);\n  const ia = new Uint8Array(ab);\n  for (let i = 0; i < byteString.length; i++) {\n    ia[i] = byteString.charCodeAt(i);\n  }\n  return new File([ab], filename, { type: mimeType });\n};\n\nexport const resizeImageFile = async (\n  file: File,\n  opts: {\n    /** undefined indicates auto */\n    outputType?: typeof MIME_TYPES[\"jpg\"];\n    maxWidthOrHeight: number;\n  },\n): Promise<File> => {\n  // SVG files shouldn't a can't be resized\n  if (file.type === MIME_TYPES.svg) {\n    return file;\n  }\n\n  const [pica, imageBlobReduce] = await Promise.all([\n    import(\"pica\").then((res) => res.default),\n    // a wrapper for pica for better API\n    import(\"image-blob-reduce\").then((res) => res.default),\n  ]);\n\n  // CRA's minification settings break pica in WebWorkers, so let's disable\n  // them for now\n  // https://github.com/nodeca/image-blob-reduce/issues/21#issuecomment-757365513\n  const reduce = imageBlobReduce({\n    pica: pica({ features: [\"js\", \"wasm\"] }),\n  });\n\n  if (opts.outputType) {\n    const { outputType } = opts;\n    reduce._create_blob = function (env) {\n      return this.pica.toBlob(env.out_canvas, outputType, 0.8).then((blob) => {\n        env.out_blob = blob;\n        return env;\n      });\n    };\n  }\n\n  if (!isSupportedImageFile(file)) {\n    throw new Error(t(\"errors.unsupportedFileType\"));\n  }\n\n  return new File(\n    [await reduce.toBlob(file, { max: opts.maxWidthOrHeight })],\n    file.name,\n    {\n      type: opts.outputType || file.type,\n    },\n  );\n};\n\nexport const SVGStringToFile = (SVGString: string, filename: string = \"\") => {\n  return new File([new TextEncoder().encode(SVGString)], filename, {\n    type: MIME_TYPES.svg,\n  }) as File & { type: typeof MIME_TYPES.svg };\n};\n\nexport const getFileFromEvent = async (\n  event: React.DragEvent<HTMLDivElement>,\n) => {\n  const file = event.dataTransfer.files.item(0);\n  const fileHandle = await getFileHandle(event);\n\n  return { file: file ? await normalizeFile(file) : null, fileHandle };\n};\n\nexport const getFileHandle = async (\n  event: React.DragEvent<HTMLDivElement>,\n): Promise<FileSystemHandle | null> => {\n  if (nativeFileSystemSupported) {\n    try {\n      const item = event.dataTransfer.items[0];\n      const handle: FileSystemHandle | null =\n        (await (item as any).getAsFileSystemHandle()) || null;\n\n      return handle;\n    } catch (error: any) {\n      console.warn(error.name, error.message);\n      return null;\n    }\n  }\n  return null;\n};\n\n/**\n * attempts to detect if a buffer is a valid image by checking its leading bytes\n */\nconst getActualMimeTypeFromImage = (buffer: ArrayBuffer) => {\n  let mimeType: ValueOf<Pick<typeof MIME_TYPES, \"png\" | \"jpg\" | \"gif\">> | null =\n    null;\n\n  const first8Bytes = `${[...new Uint8Array(buffer).slice(0, 8)].join(\" \")} `;\n\n  // uint8 leading bytes\n  const headerBytes = {\n    // https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\n    png: \"137 80 78 71 13 10 26 10 \",\n    // https://en.wikipedia.org/wiki/JPEG#Syntax_and_structure\n    // jpg is a bit wonky. Checking the first three bytes should be enough,\n    // but may yield false positives. (https://stackoverflow.com/a/23360709/927631)\n    jpg: \"255 216 255 \",\n    // https://en.wikipedia.org/wiki/GIF#Example_GIF_file\n    gif: \"71 73 70 56 57 97 \",\n  };\n\n  if (first8Bytes === headerBytes.png) {\n    mimeType = MIME_TYPES.png;\n  } else if (first8Bytes.startsWith(headerBytes.jpg)) {\n    mimeType = MIME_TYPES.jpg;\n  } else if (first8Bytes.startsWith(headerBytes.gif)) {\n    mimeType = MIME_TYPES.gif;\n  }\n  return mimeType;\n};\n\nexport const createFile = (\n  blob: File | Blob | ArrayBuffer,\n  mimeType: ValueOf<typeof MIME_TYPES>,\n  name: string | undefined,\n) => {\n  return new File([blob], name || \"\", {\n    type: mimeType,\n  });\n};\n\n/** attempts to detect correct mimeType if none is set, or if an image\n * has an incorrect extension.\n * Note: doesn't handle missing .excalidraw/.excalidrawlib extension  */\nexport const normalizeFile = async (file: File) => {\n  if (!file.type) {\n    if (file?.name?.endsWith(\".excalidrawlib\")) {\n      file = createFile(\n        await blobToArrayBuffer(file),\n        MIME_TYPES.excalidrawlib,\n        file.name,\n      );\n    } else if (file?.name?.endsWith(\".excalidraw\")) {\n      file = createFile(\n        await blobToArrayBuffer(file),\n        MIME_TYPES.excalidraw,\n        file.name,\n      );\n    } else {\n      const buffer = await blobToArrayBuffer(file);\n      const mimeType = getActualMimeTypeFromImage(buffer);\n      if (mimeType) {\n        file = createFile(buffer, mimeType, file.name);\n      }\n    }\n    // when the file is an image, make sure the extension corresponds to the\n    // actual mimeType (this is an edge case, but happens sometime)\n  } else if (isSupportedImageFile(file)) {\n    const buffer = await blobToArrayBuffer(file);\n    const mimeType = getActualMimeTypeFromImage(buffer);\n    if (mimeType && mimeType !== file.type) {\n      file = createFile(buffer, mimeType, file.name);\n    }\n  }\n\n  return file;\n};\n\nexport const blobToArrayBuffer = (blob: Blob): Promise<ArrayBuffer> => {\n  if (\"arrayBuffer\" in blob) {\n    return blob.arrayBuffer();\n  }\n  // Safari\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = (event) => {\n      if (!event.target?.result) {\n        return reject(new Error(\"Couldn't convert blob to ArrayBuffer\"));\n      }\n      resolve(event.target.result as ArrayBuffer);\n    };\n    reader.readAsArrayBuffer(blob);\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}