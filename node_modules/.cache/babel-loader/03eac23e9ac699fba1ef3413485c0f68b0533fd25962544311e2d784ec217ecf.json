{"ast":null,"code":"import _toConsumableArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _createForOfIteratorHelper from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import _slicedToArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import _classCallCheck from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createClass.js\";import{distance2d,rotate,rotatePoint}from\"../math\";import rough from\"roughjs/bin/rough\";import{getShapeForElement,generateRoughOptions}from\"../renderer/renderElement\";import{isArrowElement,isFreeDrawElement,isLinearElement,isTextElement}from\"./typeChecks\";import{rescalePoints}from\"../points\";import{getBoundTextElement,getContainerElement}from\"./textElement\";import{LinearElementEditor}from\"./linearElementEditor\";// x and y position of top left corner, x and y position of bottom right corner\nexport var ElementBounds=/*#__PURE__*/function(){function ElementBounds(){_classCallCheck(this,ElementBounds);}_createClass(ElementBounds,null,[{key:\"getBounds\",value:function getBounds(element){var cachedBounds=ElementBounds.boundsCache.get(element);if(cachedBounds!==null&&cachedBounds!==void 0&&cachedBounds.version&&cachedBounds.version===element.version){return cachedBounds.bounds;}var bounds=ElementBounds.calculateBounds(element);ElementBounds.boundsCache.set(element,{version:element.version,bounds:bounds});return bounds;}},{key:\"calculateBounds\",value:function calculateBounds(element){var bounds;var _getElementAbsoluteCo=getElementAbsoluteCoords(element),_getElementAbsoluteCo2=_slicedToArray(_getElementAbsoluteCo,6),x1=_getElementAbsoluteCo2[0],y1=_getElementAbsoluteCo2[1],x2=_getElementAbsoluteCo2[2],y2=_getElementAbsoluteCo2[3],cx=_getElementAbsoluteCo2[4],cy=_getElementAbsoluteCo2[5];if(isFreeDrawElement(element)){var _getBoundsFromPoints=getBoundsFromPoints(element.points.map(function(_ref){var _ref2=_slicedToArray(_ref,2),x=_ref2[0],y=_ref2[1];return rotate(x,y,cx-element.x,cy-element.y,element.angle);})),_getBoundsFromPoints2=_slicedToArray(_getBoundsFromPoints,4),minX=_getBoundsFromPoints2[0],minY=_getBoundsFromPoints2[1],maxX=_getBoundsFromPoints2[2],maxY=_getBoundsFromPoints2[3];return[minX+element.x,minY+element.y,maxX+element.x,maxY+element.y];}else if(isLinearElement(element)){bounds=getLinearElementRotatedBounds(element,cx,cy);}else if(element.type===\"diamond\"){var _rotate=rotate(cx,y1,cx,cy,element.angle),_rotate2=_slicedToArray(_rotate,2),x11=_rotate2[0],y11=_rotate2[1];var _rotate3=rotate(cx,y2,cx,cy,element.angle),_rotate4=_slicedToArray(_rotate3,2),x12=_rotate4[0],y12=_rotate4[1];var _rotate5=rotate(x1,cy,cx,cy,element.angle),_rotate6=_slicedToArray(_rotate5,2),x22=_rotate6[0],y22=_rotate6[1];var _rotate7=rotate(x2,cy,cx,cy,element.angle),_rotate8=_slicedToArray(_rotate7,2),x21=_rotate8[0],y21=_rotate8[1];var _minX=Math.min(x11,x12,x22,x21);var _minY=Math.min(y11,y12,y22,y21);var _maxX=Math.max(x11,x12,x22,x21);var _maxY=Math.max(y11,y12,y22,y21);bounds=[_minX,_minY,_maxX,_maxY];}else if(element.type===\"ellipse\"){var w=(x2-x1)/2;var h=(y2-y1)/2;var cos=Math.cos(element.angle);var sin=Math.sin(element.angle);var ww=Math.hypot(w*cos,h*sin);var hh=Math.hypot(h*cos,w*sin);bounds=[cx-ww,cy-hh,cx+ww,cy+hh];}else{var _rotate9=rotate(x1,y1,cx,cy,element.angle),_rotate10=_slicedToArray(_rotate9,2),_x=_rotate10[0],_y=_rotate10[1];var _rotate11=rotate(x1,y2,cx,cy,element.angle),_rotate12=_slicedToArray(_rotate11,2),_x2=_rotate12[0],_y2=_rotate12[1];var _rotate13=rotate(x2,y2,cx,cy,element.angle),_rotate14=_slicedToArray(_rotate13,2),_x3=_rotate14[0],_y3=_rotate14[1];var _rotate15=rotate(x2,y1,cx,cy,element.angle),_rotate16=_slicedToArray(_rotate15,2),_x4=_rotate16[0],_y4=_rotate16[1];var _minX2=Math.min(_x,_x2,_x3,_x4);var _minY2=Math.min(_y,_y2,_y3,_y4);var _maxX2=Math.max(_x,_x2,_x3,_x4);var _maxY2=Math.max(_y,_y2,_y3,_y4);bounds=[_minX2,_minY2,_maxX2,_maxY2];}return bounds;}}]);return ElementBounds;}();// Scene -> Scene coords, but in x1,x2,y1,y2 format.\n//\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nElementBounds.boundsCache=new WeakMap();export var getElementAbsoluteCoords=function getElementAbsoluteCoords(element){var includeBoundText=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(isFreeDrawElement(element)){return getFreeDrawElementAbsoluteCoords(element);}else if(isLinearElement(element)){return LinearElementEditor.getElementAbsoluteCoords(element,includeBoundText);}else if(isTextElement(element)){var container=getContainerElement(element);if(isArrowElement(container)){var coords=LinearElementEditor.getBoundTextElementPosition(container,element);return[coords.x,coords.y,coords.x+element.width,coords.y+element.height,coords.x+element.width/2,coords.y+element.height/2];}}return[element.x,element.y,element.x+element.width,element.y+element.height,element.x+element.width/2,element.y+element.height/2];};/**\n * for a given element, `getElementLineSegments` returns line segments\n * that can be used for visual collision detection (useful for frames)\n * as opposed to bounding box collision detection\n */export var getElementLineSegments=function getElementLineSegments(element){var _getElementAbsoluteCo3=getElementAbsoluteCoords(element),_getElementAbsoluteCo4=_slicedToArray(_getElementAbsoluteCo3,6),x1=_getElementAbsoluteCo4[0],y1=_getElementAbsoluteCo4[1],x2=_getElementAbsoluteCo4[2],y2=_getElementAbsoluteCo4[3],cx=_getElementAbsoluteCo4[4],cy=_getElementAbsoluteCo4[5];var center=[cx,cy];if(isLinearElement(element)||isFreeDrawElement(element)){var segments=[];var i=0;while(i<element.points.length-1){segments.push([rotatePoint([element.points[i][0]+element.x,element.points[i][1]+element.y],center,element.angle),rotatePoint([element.points[i+1][0]+element.x,element.points[i+1][1]+element.y],center,element.angle)]);i++;}return segments;}var _map=[[x1,y1],[x2,y1],[x1,y2],[x2,y2],[cx,y1],[cx,y2],[x1,cy],[x2,cy]].map(function(point){return rotatePoint(point,center,element.angle);}),_map2=_slicedToArray(_map,8),nw=_map2[0],ne=_map2[1],sw=_map2[2],se=_map2[3],n=_map2[4],s=_map2[5],w=_map2[6],e=_map2[7];if(element.type===\"diamond\"){return[[n,w],[n,e],[s,w],[s,e]];}if(element.type===\"ellipse\"){return[[n,w],[n,e],[s,w],[s,e],[n,w],[n,e],[s,w],[s,e]];}return[[nw,ne],[sw,se],[nw,sw],[ne,se],[nw,e],[sw,e],[ne,w],[se,w]];};/**\n * Scene -> Scene coords, but in x1,x2,y1,y2 format.\n *\n * Rectangle here means any rectangular frame, not an excalidraw element.\n */export var getRectangleBoxAbsoluteCoords=function getRectangleBoxAbsoluteCoords(boxSceneCoords){return[boxSceneCoords.x,boxSceneCoords.y,boxSceneCoords.x+boxSceneCoords.width,boxSceneCoords.y+boxSceneCoords.height,boxSceneCoords.x+boxSceneCoords.width/2,boxSceneCoords.y+boxSceneCoords.height/2];};export var pointRelativeTo=function pointRelativeTo(element,absoluteCoords){return[absoluteCoords[0]-element.x,absoluteCoords[1]-element.y];};export var getDiamondPoints=function getDiamondPoints(element){// Here we add +1 to avoid these numbers to be 0\n// otherwise rough.js will throw an error complaining about it\nvar topX=Math.floor(element.width/2)+1;var topY=0;var rightX=element.width;var rightY=Math.floor(element.height/2)+1;var bottomX=topX;var bottomY=element.height;var leftX=0;var leftY=rightY;return[topX,topY,rightX,rightY,bottomX,bottomY,leftX,leftY];};export var getCurvePathOps=function getCurvePathOps(shape){var _iterator=_createForOfIteratorHelper(shape.sets),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var set=_step.value;if(set.type===\"path\"){return set.ops;}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return shape.sets[0].ops;};// reference: https://eliot-jones.com/2019/12/cubic-bezier-curve-bounding-boxes\nvar getBezierValueForT=function getBezierValueForT(t,p0,p1,p2,p3){var oneMinusT=1-t;return Math.pow(oneMinusT,3)*p0+3*Math.pow(oneMinusT,2)*t*p1+3*oneMinusT*Math.pow(t,2)*p2+Math.pow(t,3)*p3;};var solveQuadratic=function solveQuadratic(p0,p1,p2,p3){var i=p1-p0;var j=p2-p1;var k=p3-p2;var a=3*i-6*j+3*k;var b=6*j-6*i;var c=3*i;var sqrtPart=b*b-4*a*c;var hasSolution=sqrtPart>=0;if(!hasSolution){return false;}var s1=null;var s2=null;var t1=Infinity;var t2=Infinity;if(a===0){t1=t2=-c/b;}else{t1=(-b+Math.sqrt(sqrtPart))/(2*a);t2=(-b-Math.sqrt(sqrtPart))/(2*a);}if(t1>=0&&t1<=1){s1=getBezierValueForT(t1,p0,p1,p2,p3);}if(t2>=0&&t2<=1){s2=getBezierValueForT(t2,p0,p1,p2,p3);}return[s1,s2];};var getCubicBezierCurveBound=function getCubicBezierCurveBound(p0,p1,p2,p3){var solX=solveQuadratic(p0[0],p1[0],p2[0],p3[0]);var solY=solveQuadratic(p0[1],p1[1],p2[1],p3[1]);var minX=Math.min(p0[0],p3[0]);var maxX=Math.max(p0[0],p3[0]);if(solX){var xs=solX.filter(function(x){return x!==null;});minX=Math.min.apply(Math,[minX].concat(_toConsumableArray(xs)));maxX=Math.max.apply(Math,[maxX].concat(_toConsumableArray(xs)));}var minY=Math.min(p0[1],p3[1]);var maxY=Math.max(p0[1],p3[1]);if(solY){var ys=solY.filter(function(y){return y!==null;});minY=Math.min.apply(Math,[minY].concat(_toConsumableArray(ys)));maxY=Math.max.apply(Math,[maxY].concat(_toConsumableArray(ys)));}return[minX,minY,maxX,maxY];};export var getMinMaxXYFromCurvePathOps=function getMinMaxXYFromCurvePathOps(ops,transformXY){var currentP=[0,0];var _ops$reduce=ops.reduce(function(limits,_ref3){var op=_ref3.op,data=_ref3.data;// There are only four operation types:\n// move, bcurveTo, lineTo, and curveTo\nif(op===\"move\"){// change starting point\ncurrentP=data;// move operation does not draw anything; so, it always\n// returns false\n}else if(op===\"bcurveTo\"){var _p1=[data[0],data[1]];var _p2=[data[2],data[3]];var _p3=[data[4],data[5]];var p1=transformXY?transformXY.apply(void 0,_p1):_p1;var p2=transformXY?transformXY.apply(void 0,_p2):_p2;var p3=transformXY?transformXY.apply(void 0,_p3):_p3;var p0=transformXY?transformXY.apply(void 0,_toConsumableArray(currentP)):currentP;currentP=_p3;var _getCubicBezierCurveB=getCubicBezierCurveBound(p0,p1,p2,p3),_getCubicBezierCurveB2=_slicedToArray(_getCubicBezierCurveB,4),_minX3=_getCubicBezierCurveB2[0],_minY3=_getCubicBezierCurveB2[1],_maxX3=_getCubicBezierCurveB2[2],_maxY3=_getCubicBezierCurveB2[3];limits.minX=Math.min(limits.minX,_minX3);limits.minY=Math.min(limits.minY,_minY3);limits.maxX=Math.max(limits.maxX,_maxX3);limits.maxY=Math.max(limits.maxY,_maxY3);}else if(op===\"lineTo\"){// TODO: Implement this\n}else if(op===\"qcurveTo\"){// TODO: Implement this\n}return limits;},{minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity}),minX=_ops$reduce.minX,minY=_ops$reduce.minY,maxX=_ops$reduce.maxX,maxY=_ops$reduce.maxY;return[minX,minY,maxX,maxY];};var getBoundsFromPoints=function getBoundsFromPoints(points){var minX=Infinity;var minY=Infinity;var maxX=-Infinity;var maxY=-Infinity;var _iterator2=_createForOfIteratorHelper(points),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var _step2$value=_slicedToArray(_step2.value,2),_x5=_step2$value[0],_y5=_step2$value[1];minX=Math.min(minX,_x5);minY=Math.min(minY,_y5);maxX=Math.max(maxX,_x5);maxY=Math.max(maxY,_y5);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return[minX,minY,maxX,maxY];};var getFreeDrawElementAbsoluteCoords=function getFreeDrawElementAbsoluteCoords(element){var _getBoundsFromPoints3=getBoundsFromPoints(element.points),_getBoundsFromPoints4=_slicedToArray(_getBoundsFromPoints3,4),minX=_getBoundsFromPoints4[0],minY=_getBoundsFromPoints4[1],maxX=_getBoundsFromPoints4[2],maxY=_getBoundsFromPoints4[3];var x1=minX+element.x;var y1=minY+element.y;var x2=maxX+element.x;var y2=maxY+element.y;return[x1,y1,x2,y2,(x1+x2)/2,(y1+y2)/2];};export var getArrowheadPoints=function getArrowheadPoints(element,shape,position,arrowhead){var ops=getCurvePathOps(shape[0]);if(ops.length<1){return null;}// The index of the bCurve operation to examine.\nvar index=position===\"start\"?1:ops.length-1;var data=ops[index].data;var p3=[data[4],data[5]];var p2=[data[2],data[3]];var p1=[data[0],data[1]];// We need to find p0 of the bezier curve.\n// It is typically the last point of the previous\n// curve; it can also be the position of moveTo operation.\nvar prevOp=ops[index-1];var p0=[0,0];if(prevOp.op===\"move\"){p0=prevOp.data;}else if(prevOp.op===\"bcurveTo\"){p0=[prevOp.data[4],prevOp.data[5]];}// B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\nvar equation=function equation(t,idx){return Math.pow(1-t,3)*p3[idx]+3*t*Math.pow(1-t,2)*p2[idx]+3*Math.pow(t,2)*(1-t)*p1[idx]+p0[idx]*Math.pow(t,3);};// Ee know the last point of the arrow (or the first, if start arrowhead).\nvar _ref4=position===\"start\"?p0:p3,_ref5=_slicedToArray(_ref4,2),x2=_ref5[0],y2=_ref5[1];// By using cubic bezier equation (B(t)) and the given parameters,\n// we calculate a point that is closer to the last point.\n// The value 0.3 is chosen arbitrarily and it works best for all\n// the tested cases.\nvar _ref6=[equation(0.3,0),equation(0.3,1)],x1=_ref6[0],y1=_ref6[1];// Find the normalized direction vector based on the\n// previously calculated points.\nvar distance=Math.hypot(x2-x1,y2-y1);var nx=(x2-x1)/distance;var ny=(y2-y1)/distance;var size={arrow:30,bar:15,dot:15,triangle:15}[arrowhead];// pixels (will differ for each arrowhead)\nvar length=0;if(arrowhead===\"arrow\"){// Length for -> arrows is based on the length of the last section\nvar _element$points=_slicedToArray(element.points[element.points.length-1],2),cx=_element$points[0],cy=_element$points[1];var _ref7=element.points.length>1?element.points[element.points.length-2]:[0,0],_ref8=_slicedToArray(_ref7,2),px=_ref8[0],py=_ref8[1];length=Math.hypot(cx-px,cy-py);}else{// Length for other arrowhead types is based on the total length of the line\nfor(var i=0;i<element.points.length;i++){var _ref9=element.points[i-1]||[0,0],_ref10=_slicedToArray(_ref9,2),_px=_ref10[0],_py=_ref10[1];var _element$points$i=_slicedToArray(element.points[i],2),_cx=_element$points$i[0],_cy=_element$points$i[1];length+=Math.hypot(_cx-_px,_cy-_py);}}// Scale down the arrowhead until we hit a certain size so that it doesn't look weird.\n// This value is selected by minimizing a minimum size with the last segment of the arrowhead\nvar minSize=Math.min(size,length/2);var xs=x2-nx*minSize;var ys=y2-ny*minSize;if(arrowhead===\"dot\"){var r=Math.hypot(ys-y2,xs-x2)+element.strokeWidth;return[x2,y2,r];}var angle={arrow:20,bar:90,triangle:25}[arrowhead];// degrees\n// Return points\nvar _rotate17=rotate(xs,ys,x2,y2,-angle*Math.PI/180),_rotate18=_slicedToArray(_rotate17,2),x3=_rotate18[0],y3=_rotate18[1];var _rotate19=rotate(xs,ys,x2,y2,angle*Math.PI/180),_rotate20=_slicedToArray(_rotate19,2),x4=_rotate20[0],y4=_rotate20[1];return[x2,y2,x3,y3,x4,y4];};var generateLinearElementShape=function generateLinearElementShape(element){var generator=rough.generator();var options=generateRoughOptions(element);var method=function(){if(element.roundness){return\"curve\";}if(options.fill){return\"polygon\";}return\"linearPath\";}();return generator[method](element.points,options);};var getLinearElementRotatedBounds=function getLinearElementRotatedBounds(element,cx,cy){var _getShapeForElement;if(element.points.length<2){var _element$points$=_slicedToArray(element.points[0],2),pointX=_element$points$[0],pointY=_element$points$[1];var _rotate21=rotate(element.x+pointX,element.y+pointY,cx,cy,element.angle),_rotate22=_slicedToArray(_rotate21,2),_x6=_rotate22[0],_y6=_rotate22[1];var _coords=[_x6,_y6,_x6,_y6];var _boundTextElement=getBoundTextElement(element);if(_boundTextElement){var coordsWithBoundText=LinearElementEditor.getMinMaxXYWithBoundText(element,[_x6,_y6,_x6,_y6],_boundTextElement);_coords=[coordsWithBoundText[0],coordsWithBoundText[1],coordsWithBoundText[2],coordsWithBoundText[3]];}return _coords;}// first element is always the curve\nvar cachedShape=(_getShapeForElement=getShapeForElement(element))===null||_getShapeForElement===void 0?void 0:_getShapeForElement[0];var shape=cachedShape!==null&&cachedShape!==void 0?cachedShape:generateLinearElementShape(element);var ops=getCurvePathOps(shape);var transformXY=function transformXY(x,y){return rotate(element.x+x,element.y+y,cx,cy,element.angle);};var res=getMinMaxXYFromCurvePathOps(ops,transformXY);var coords=[res[0],res[1],res[2],res[3]];var boundTextElement=getBoundTextElement(element);if(boundTextElement){var _coordsWithBoundText=LinearElementEditor.getMinMaxXYWithBoundText(element,coords,boundTextElement);coords=[_coordsWithBoundText[0],_coordsWithBoundText[1],_coordsWithBoundText[2],_coordsWithBoundText[3]];}return coords;};export var getElementBounds=function getElementBounds(element){return ElementBounds.getBounds(element);};export var getCommonBounds=function getCommonBounds(elements){if(!elements.length){return[0,0,0,0];}var minX=Infinity;var maxX=-Infinity;var minY=Infinity;var maxY=-Infinity;elements.forEach(function(element){var _getElementBounds=getElementBounds(element),_getElementBounds2=_slicedToArray(_getElementBounds,4),x1=_getElementBounds2[0],y1=_getElementBounds2[1],x2=_getElementBounds2[2],y2=_getElementBounds2[3];minX=Math.min(minX,x1);minY=Math.min(minY,y1);maxX=Math.max(maxX,x2);maxY=Math.max(maxY,y2);});return[minX,minY,maxX,maxY];};export var getResizedElementAbsoluteCoords=function getResizedElementAbsoluteCoords(element,nextWidth,nextHeight,normalizePoints){if(!(isLinearElement(element)||isFreeDrawElement(element))){return[element.x,element.y,element.x+nextWidth,element.y+nextHeight];}var points=rescalePoints(0,nextWidth,rescalePoints(1,nextHeight,element.points,normalizePoints),normalizePoints);var bounds;if(isFreeDrawElement(element)){// Free Draw\nbounds=getBoundsFromPoints(points);}else{// Line\nvar gen=rough.generator();var curve=!element.roundness?gen.linearPath(points,generateRoughOptions(element)):gen.curve(points,generateRoughOptions(element));var ops=getCurvePathOps(curve);bounds=getMinMaxXYFromCurvePathOps(ops);}var _bounds=bounds,_bounds2=_slicedToArray(_bounds,4),minX=_bounds2[0],minY=_bounds2[1],maxX=_bounds2[2],maxY=_bounds2[3];return[minX+element.x,minY+element.y,maxX+element.x,maxY+element.y];};export var getElementPointsCoords=function getElementPointsCoords(element,points){// This might be computationally heavey\nvar gen=rough.generator();var curve=element.roundness==null?gen.linearPath(points,generateRoughOptions(element)):gen.curve(points,generateRoughOptions(element));var ops=getCurvePathOps(curve);var _getMinMaxXYFromCurve=getMinMaxXYFromCurvePathOps(ops),_getMinMaxXYFromCurve2=_slicedToArray(_getMinMaxXYFromCurve,4),minX=_getMinMaxXYFromCurve2[0],minY=_getMinMaxXYFromCurve2[1],maxX=_getMinMaxXYFromCurve2[2],maxY=_getMinMaxXYFromCurve2[3];return[minX+element.x,minY+element.y,maxX+element.x,maxY+element.y];};export var getClosestElementBounds=function getClosestElementBounds(elements,from){if(!elements.length){return[0,0,0,0];}var minDistance=Infinity;var closestElement=elements[0];elements.forEach(function(element){var _getElementBounds3=getElementBounds(element),_getElementBounds4=_slicedToArray(_getElementBounds3,4),x1=_getElementBounds4[0],y1=_getElementBounds4[1],x2=_getElementBounds4[2],y2=_getElementBounds4[3];var distance=distance2d((x1+x2)/2,(y1+y2)/2,from.x,from.y);if(distance<minDistance){minDistance=distance;closestElement=element;}});return getElementBounds(closestElement);};export var getCommonBoundingBox=function getCommonBoundingBox(elements){var _getCommonBounds=getCommonBounds(elements),_getCommonBounds2=_slicedToArray(_getCommonBounds,4),minX=_getCommonBounds2[0],minY=_getCommonBounds2[1],maxX=_getCommonBounds2[2],maxY=_getCommonBounds2[3];return{minX:minX,minY:minY,maxX:maxX,maxY:maxY,width:maxX-minX,height:maxY-minY,midX:(minX+maxX)/2,midY:(minY+maxY)/2};};","map":{"version":3,"names":["distance2d","rotate","rotatePoint","rough","getShapeForElement","generateRoughOptions","isArrowElement","isFreeDrawElement","isLinearElement","isTextElement","rescalePoints","getBoundTextElement","getContainerElement","LinearElementEditor","ElementBounds","_classCallCheck","_createClass","key","value","getBounds","element","cachedBounds","boundsCache","get","version","bounds","calculateBounds","set","_getElementAbsoluteCo","getElementAbsoluteCoords","_getElementAbsoluteCo2","_slicedToArray","x1","y1","x2","y2","cx","cy","_getBoundsFromPoints","getBoundsFromPoints","points","map","_ref","_ref2","x","y","angle","_getBoundsFromPoints2","minX","minY","maxX","maxY","getLinearElementRotatedBounds","type","_rotate","_rotate2","x11","y11","_rotate3","_rotate4","x12","y12","_rotate5","_rotate6","x22","y22","_rotate7","_rotate8","x21","y21","Math","min","max","w","h","cos","sin","ww","hypot","hh","_rotate9","_rotate10","_rotate11","_rotate12","_rotate13","_rotate14","_rotate15","_rotate16","WeakMap","includeBoundText","arguments","length","undefined","getFreeDrawElementAbsoluteCoords","container","coords","getBoundTextElementPosition","width","height","getElementLineSegments","_getElementAbsoluteCo3","_getElementAbsoluteCo4","center","segments","i","push","_map","point","_map2","nw","ne","sw","se","n","s","e","getRectangleBoxAbsoluteCoords","boxSceneCoords","pointRelativeTo","absoluteCoords","getDiamondPoints","topX","floor","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","getCurvePathOps","shape","_iterator","_createForOfIteratorHelper","sets","_step","done","ops","err","f","getBezierValueForT","t","p0","p1","p2","p3","oneMinusT","pow","solveQuadratic","j","k","a","b","c","sqrtPart","hasSolution","s1","s2","t1","Infinity","t2","sqrt","getCubicBezierCurveBound","solX","solY","xs","filter","apply","concat","_toConsumableArray","ys","getMinMaxXYFromCurvePathOps","transformXY","currentP","_ops$reduce","reduce","limits","_ref3","op","data","_p1","_p2","_p3","_getCubicBezierCurveB","_getCubicBezierCurveB2","_iterator2","_step2","_step2$value","_getBoundsFromPoints3","_getBoundsFromPoints4","getArrowheadPoints","position","arrowhead","index","prevOp","equation","idx","_ref4","_ref5","_ref6","distance","nx","ny","size","arrow","bar","dot","triangle","_element$points","_ref7","_ref8","px","py","_ref9","_ref10","_element$points$i","minSize","r","strokeWidth","_rotate17","PI","_rotate18","x3","y3","_rotate19","_rotate20","x4","y4","generateLinearElementShape","generator","options","method","roundness","fill","_getShapeForElement","_element$points$","pointX","pointY","_rotate21","_rotate22","boundTextElement","coordsWithBoundText","getMinMaxXYWithBoundText","cachedShape","res","getElementBounds","getCommonBounds","elements","forEach","_getElementBounds","_getElementBounds2","getResizedElementAbsoluteCoords","nextWidth","nextHeight","normalizePoints","gen","curve","linearPath","_bounds","_bounds2","getElementPointsCoords","_getMinMaxXYFromCurve","_getMinMaxXYFromCurve2","getClosestElementBounds","from","minDistance","closestElement","_getElementBounds3","_getElementBounds4","getCommonBoundingBox","_getCommonBounds","_getCommonBounds2","midX","midY"],"sources":["D:/project/excalidraw-cn/src/element/bounds.ts"],"sourcesContent":["import {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  Arrowhead,\n  ExcalidrawFreeDrawElement,\n  NonDeleted,\n  ExcalidrawTextElementWithContainer,\n} from \"./types\";\nimport { distance2d, rotate, rotatePoint } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { Drawable, Op } from \"roughjs/bin/core\";\nimport { Point } from \"../types\";\nimport {\n  getShapeForElement,\n  generateRoughOptions,\n} from \"../renderer/renderElement\";\nimport {\n  isArrowElement,\n  isFreeDrawElement,\n  isLinearElement,\n  isTextElement,\n} from \"./typeChecks\";\nimport { rescalePoints } from \"../points\";\nimport { getBoundTextElement, getContainerElement } from \"./textElement\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { Mutable } from \"../utility-types\";\n\nexport type RectangleBox = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  angle: number;\n};\n\ntype MaybeQuadraticSolution = [number | null, number | null] | false;\n\n// x and y position of top left corner, x and y position of bottom right corner\nexport type Bounds = readonly [x1: number, y1: number, x2: number, y2: number];\n\nexport class ElementBounds {\n  private static boundsCache = new WeakMap<\n    ExcalidrawElement,\n    {\n      bounds: Bounds;\n      version: ExcalidrawElement[\"version\"];\n    }\n  >();\n\n  static getBounds(element: ExcalidrawElement) {\n    const cachedBounds = ElementBounds.boundsCache.get(element);\n\n    if (cachedBounds?.version && cachedBounds.version === element.version) {\n      return cachedBounds.bounds;\n    }\n\n    const bounds = ElementBounds.calculateBounds(element);\n\n    ElementBounds.boundsCache.set(element, {\n      version: element.version,\n      bounds,\n    });\n\n    return bounds;\n  }\n\n  private static calculateBounds(element: ExcalidrawElement): Bounds {\n    let bounds: [number, number, number, number];\n\n    const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(element);\n\n    if (isFreeDrawElement(element)) {\n      const [minX, minY, maxX, maxY] = getBoundsFromPoints(\n        element.points.map(([x, y]) =>\n          rotate(x, y, cx - element.x, cy - element.y, element.angle),\n        ),\n      );\n\n      return [\n        minX + element.x,\n        minY + element.y,\n        maxX + element.x,\n        maxY + element.y,\n      ];\n    } else if (isLinearElement(element)) {\n      bounds = getLinearElementRotatedBounds(element, cx, cy);\n    } else if (element.type === \"diamond\") {\n      const [x11, y11] = rotate(cx, y1, cx, cy, element.angle);\n      const [x12, y12] = rotate(cx, y2, cx, cy, element.angle);\n      const [x22, y22] = rotate(x1, cy, cx, cy, element.angle);\n      const [x21, y21] = rotate(x2, cy, cx, cy, element.angle);\n      const minX = Math.min(x11, x12, x22, x21);\n      const minY = Math.min(y11, y12, y22, y21);\n      const maxX = Math.max(x11, x12, x22, x21);\n      const maxY = Math.max(y11, y12, y22, y21);\n      bounds = [minX, minY, maxX, maxY];\n    } else if (element.type === \"ellipse\") {\n      const w = (x2 - x1) / 2;\n      const h = (y2 - y1) / 2;\n      const cos = Math.cos(element.angle);\n      const sin = Math.sin(element.angle);\n      const ww = Math.hypot(w * cos, h * sin);\n      const hh = Math.hypot(h * cos, w * sin);\n      bounds = [cx - ww, cy - hh, cx + ww, cy + hh];\n    } else {\n      const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n      const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n      const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n      const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n      const minX = Math.min(x11, x12, x22, x21);\n      const minY = Math.min(y11, y12, y22, y21);\n      const maxX = Math.max(x11, x12, x22, x21);\n      const maxY = Math.max(y11, y12, y22, y21);\n      bounds = [minX, minY, maxX, maxY];\n    }\n\n    return bounds;\n  }\n}\n\n// Scene -> Scene coords, but in x1,x2,y1,y2 format.\n//\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport const getElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  includeBoundText: boolean = false,\n): [number, number, number, number, number, number] => {\n  if (isFreeDrawElement(element)) {\n    return getFreeDrawElementAbsoluteCoords(element);\n  } else if (isLinearElement(element)) {\n    return LinearElementEditor.getElementAbsoluteCoords(\n      element,\n      includeBoundText,\n    );\n  } else if (isTextElement(element)) {\n    const container = getContainerElement(element);\n    if (isArrowElement(container)) {\n      const coords = LinearElementEditor.getBoundTextElementPosition(\n        container,\n        element as ExcalidrawTextElementWithContainer,\n      );\n      return [\n        coords.x,\n        coords.y,\n        coords.x + element.width,\n        coords.y + element.height,\n        coords.x + element.width / 2,\n        coords.y + element.height / 2,\n      ];\n    }\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n    element.x + element.width / 2,\n    element.y + element.height / 2,\n  ];\n};\n\n/**\n * for a given element, `getElementLineSegments` returns line segments\n * that can be used for visual collision detection (useful for frames)\n * as opposed to bounding box collision detection\n */\nexport const getElementLineSegments = (\n  element: ExcalidrawElement,\n): [Point, Point][] => {\n  const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(element);\n\n  const center: Point = [cx, cy];\n\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    const segments: [Point, Point][] = [];\n\n    let i = 0;\n\n    while (i < element.points.length - 1) {\n      segments.push([\n        rotatePoint(\n          [\n            element.points[i][0] + element.x,\n            element.points[i][1] + element.y,\n          ] as Point,\n          center,\n          element.angle,\n        ),\n        rotatePoint(\n          [\n            element.points[i + 1][0] + element.x,\n            element.points[i + 1][1] + element.y,\n          ] as Point,\n          center,\n          element.angle,\n        ),\n      ]);\n      i++;\n    }\n\n    return segments;\n  }\n\n  const [nw, ne, sw, se, n, s, w, e] = (\n    [\n      [x1, y1],\n      [x2, y1],\n      [x1, y2],\n      [x2, y2],\n      [cx, y1],\n      [cx, y2],\n      [x1, cy],\n      [x2, cy],\n    ] as Point[]\n  ).map((point) => rotatePoint(point, center, element.angle));\n\n  if (element.type === \"diamond\") {\n    return [\n      [n, w],\n      [n, e],\n      [s, w],\n      [s, e],\n    ];\n  }\n\n  if (element.type === \"ellipse\") {\n    return [\n      [n, w],\n      [n, e],\n      [s, w],\n      [s, e],\n      [n, w],\n      [n, e],\n      [s, w],\n      [s, e],\n    ];\n  }\n\n  return [\n    [nw, ne],\n    [sw, se],\n    [nw, sw],\n    [ne, se],\n    [nw, e],\n    [sw, e],\n    [ne, w],\n    [se, w],\n  ];\n};\n\n/**\n * Scene -> Scene coords, but in x1,x2,y1,y2 format.\n *\n * Rectangle here means any rectangular frame, not an excalidraw element.\n */\nexport const getRectangleBoxAbsoluteCoords = (boxSceneCoords: RectangleBox) => {\n  return [\n    boxSceneCoords.x,\n    boxSceneCoords.y,\n    boxSceneCoords.x + boxSceneCoords.width,\n    boxSceneCoords.y + boxSceneCoords.height,\n    boxSceneCoords.x + boxSceneCoords.width / 2,\n    boxSceneCoords.y + boxSceneCoords.height / 2,\n  ];\n};\n\nexport const pointRelativeTo = (\n  element: ExcalidrawElement,\n  absoluteCoords: Point,\n): Point => {\n  return [absoluteCoords[0] - element.x, absoluteCoords[1] - element.y];\n};\n\nexport const getDiamondPoints = (element: ExcalidrawElement) => {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = 0;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n};\n\nexport const getCurvePathOps = (shape: Drawable): Op[] => {\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n  return shape.sets[0].ops;\n};\n\n// reference: https://eliot-jones.com/2019/12/cubic-bezier-curve-bounding-boxes\nconst getBezierValueForT = (\n  t: number,\n  p0: number,\n  p1: number,\n  p2: number,\n  p3: number,\n) => {\n  const oneMinusT = 1 - t;\n  return (\n    Math.pow(oneMinusT, 3) * p0 +\n    3 * Math.pow(oneMinusT, 2) * t * p1 +\n    3 * oneMinusT * Math.pow(t, 2) * p2 +\n    Math.pow(t, 3) * p3\n  );\n};\n\nconst solveQuadratic = (\n  p0: number,\n  p1: number,\n  p2: number,\n  p3: number,\n): MaybeQuadraticSolution => {\n  const i = p1 - p0;\n  const j = p2 - p1;\n  const k = p3 - p2;\n\n  const a = 3 * i - 6 * j + 3 * k;\n  const b = 6 * j - 6 * i;\n  const c = 3 * i;\n\n  const sqrtPart = b * b - 4 * a * c;\n  const hasSolution = sqrtPart >= 0;\n\n  if (!hasSolution) {\n    return false;\n  }\n\n  let s1 = null;\n  let s2 = null;\n\n  let t1 = Infinity;\n  let t2 = Infinity;\n\n  if (a === 0) {\n    t1 = t2 = -c / b;\n  } else {\n    t1 = (-b + Math.sqrt(sqrtPart)) / (2 * a);\n    t2 = (-b - Math.sqrt(sqrtPart)) / (2 * a);\n  }\n\n  if (t1 >= 0 && t1 <= 1) {\n    s1 = getBezierValueForT(t1, p0, p1, p2, p3);\n  }\n\n  if (t2 >= 0 && t2 <= 1) {\n    s2 = getBezierValueForT(t2, p0, p1, p2, p3);\n  }\n\n  return [s1, s2];\n};\n\nconst getCubicBezierCurveBound = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  p3: Point,\n): Bounds => {\n  const solX = solveQuadratic(p0[0], p1[0], p2[0], p3[0]);\n  const solY = solveQuadratic(p0[1], p1[1], p2[1], p3[1]);\n\n  let minX = Math.min(p0[0], p3[0]);\n  let maxX = Math.max(p0[0], p3[0]);\n\n  if (solX) {\n    const xs = solX.filter((x) => x !== null) as number[];\n    minX = Math.min(minX, ...xs);\n    maxX = Math.max(maxX, ...xs);\n  }\n\n  let minY = Math.min(p0[1], p3[1]);\n  let maxY = Math.max(p0[1], p3[1]);\n  if (solY) {\n    const ys = solY.filter((y) => y !== null) as number[];\n    minY = Math.min(minY, ...ys);\n    maxY = Math.max(maxY, ...ys);\n  }\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getMinMaxXYFromCurvePathOps = (\n  ops: Op[],\n  transformXY?: (x: number, y: number) => [number, number],\n): [number, number, number, number] => {\n  let currentP: Point = [0, 0];\n\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        currentP = data as unknown as Point;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        const _p1 = [data[0], data[1]] as Point;\n        const _p2 = [data[2], data[3]] as Point;\n        const _p3 = [data[4], data[5]] as Point;\n\n        const p1 = transformXY ? transformXY(..._p1) : _p1;\n        const p2 = transformXY ? transformXY(..._p2) : _p2;\n        const p3 = transformXY ? transformXY(..._p3) : _p3;\n\n        const p0 = transformXY ? transformXY(...currentP) : currentP;\n        currentP = _p3;\n\n        const [minX, minY, maxX, maxY] = getCubicBezierCurveBound(\n          p0,\n          p1,\n          p2,\n          p3,\n        );\n\n        limits.minX = Math.min(limits.minX, minX);\n        limits.minY = Math.min(limits.minY, minY);\n\n        limits.maxX = Math.max(limits.maxX, maxX);\n        limits.maxY = Math.max(limits.maxY, maxY);\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n  return [minX, minY, maxX, maxY];\n};\n\nconst getBoundsFromPoints = (\n  points: ExcalidrawFreeDrawElement[\"points\"],\n): [number, number, number, number] => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (const [x, y] of points) {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getFreeDrawElementAbsoluteCoords = (\n  element: ExcalidrawFreeDrawElement,\n): [number, number, number, number, number, number] => {\n  const [minX, minY, maxX, maxY] = getBoundsFromPoints(element.points);\n  const x1 = minX + element.x;\n  const y1 = minY + element.y;\n  const x2 = maxX + element.x;\n  const y2 = maxY + element.y;\n  return [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2];\n};\n\nexport const getArrowheadPoints = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n  position: \"start\" | \"end\",\n  arrowhead: Arrowhead,\n) => {\n  const ops = getCurvePathOps(shape[0]);\n  if (ops.length < 1) {\n    return null;\n  }\n\n  // The index of the bCurve operation to examine.\n  const index = position === \"start\" ? 1 : ops.length - 1;\n\n  const data = ops[index].data;\n  const p3 = [data[4], data[5]] as Point;\n  const p2 = [data[2], data[3]] as Point;\n  const p1 = [data[0], data[1]] as Point;\n\n  // We need to find p0 of the bezier curve.\n  // It is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation.\n  const prevOp = ops[index - 1];\n  let p0: Point = [0, 0];\n  if (prevOp.op === \"move\") {\n    p0 = prevOp.data as unknown as Point;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // Ee know the last point of the arrow (or the first, if start arrowhead).\n  const [x2, y2] = position === \"start\" ? p0 : p3;\n\n  // By using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point.\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases.\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // Find the normalized direction vector based on the\n  // previously calculated points.\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n\n  const size = {\n    arrow: 30,\n    bar: 15,\n    dot: 15,\n    triangle: 15,\n  }[arrowhead]; // pixels (will differ for each arrowhead)\n\n  let length = 0;\n\n  if (arrowhead === \"arrow\") {\n    // Length for -> arrows is based on the length of the last section\n    const [cx, cy] = element.points[element.points.length - 1];\n    const [px, py] =\n      element.points.length > 1\n        ? element.points[element.points.length - 2]\n        : [0, 0];\n\n    length = Math.hypot(cx - px, cy - py);\n  } else {\n    // Length for other arrowhead types is based on the total length of the line\n    for (let i = 0; i < element.points.length; i++) {\n      const [px, py] = element.points[i - 1] || [0, 0];\n      const [cx, cy] = element.points[i];\n      length += Math.hypot(cx - px, cy - py);\n    }\n  }\n\n  // Scale down the arrowhead until we hit a certain size so that it doesn't look weird.\n  // This value is selected by minimizing a minimum size with the last segment of the arrowhead\n  const minSize = Math.min(size, length / 2);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  if (arrowhead === \"dot\") {\n    const r = Math.hypot(ys - y2, xs - x2) + element.strokeWidth;\n    return [x2, y2, r];\n  }\n\n  const angle = {\n    arrow: 20,\n    bar: 90,\n    triangle: 25,\n  }[arrowhead]; // degrees\n\n  // Return points\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n  return [x2, y2, x3, y3, x4, y4];\n};\n\nconst generateLinearElementShape = (\n  element: ExcalidrawLinearElement,\n): Drawable => {\n  const generator = rough.generator();\n  const options = generateRoughOptions(element);\n\n  const method = (() => {\n    if (element.roundness) {\n      return \"curve\";\n    }\n    if (options.fill) {\n      return \"polygon\";\n    }\n    return \"linearPath\";\n  })();\n\n  return generator[method](element.points as Mutable<Point>[], options);\n};\n\nconst getLinearElementRotatedBounds = (\n  element: ExcalidrawLinearElement,\n  cx: number,\n  cy: number,\n): [number, number, number, number] => {\n  if (element.points.length < 2) {\n    const [pointX, pointY] = element.points[0];\n    const [x, y] = rotate(\n      element.x + pointX,\n      element.y + pointY,\n      cx,\n      cy,\n      element.angle,\n    );\n\n    let coords: [number, number, number, number] = [x, y, x, y];\n    const boundTextElement = getBoundTextElement(element);\n    if (boundTextElement) {\n      const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(\n        element,\n        [x, y, x, y],\n        boundTextElement,\n      );\n      coords = [\n        coordsWithBoundText[0],\n        coordsWithBoundText[1],\n        coordsWithBoundText[2],\n        coordsWithBoundText[3],\n      ];\n    }\n    return coords;\n  }\n\n  // first element is always the curve\n  const cachedShape = getShapeForElement(element)?.[0];\n  const shape = cachedShape ?? generateLinearElementShape(element);\n  const ops = getCurvePathOps(shape);\n  const transformXY = (x: number, y: number) =>\n    rotate(element.x + x, element.y + y, cx, cy, element.angle);\n  const res = getMinMaxXYFromCurvePathOps(ops, transformXY);\n  let coords: [number, number, number, number] = [\n    res[0],\n    res[1],\n    res[2],\n    res[3],\n  ];\n  const boundTextElement = getBoundTextElement(element);\n  if (boundTextElement) {\n    const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(\n      element,\n      coords,\n      boundTextElement,\n    );\n    coords = [\n      coordsWithBoundText[0],\n      coordsWithBoundText[1],\n      coordsWithBoundText[2],\n      coordsWithBoundText[3],\n    ];\n  }\n  return coords;\n};\n\nexport const getElementBounds = (element: ExcalidrawElement): Bounds => {\n  return ElementBounds.getBounds(element);\n};\nexport const getCommonBounds = (\n  elements: readonly ExcalidrawElement[],\n): Bounds => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getResizedElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  nextWidth: number,\n  nextHeight: number,\n  normalizePoints: boolean,\n): [number, number, number, number] => {\n  if (!(isLinearElement(element) || isFreeDrawElement(element))) {\n    return [\n      element.x,\n      element.y,\n      element.x + nextWidth,\n      element.y + nextHeight,\n    ];\n  }\n\n  const points = rescalePoints(\n    0,\n    nextWidth,\n    rescalePoints(1, nextHeight, element.points, normalizePoints),\n    normalizePoints,\n  );\n\n  let bounds: [number, number, number, number];\n\n  if (isFreeDrawElement(element)) {\n    // Free Draw\n    bounds = getBoundsFromPoints(points);\n  } else {\n    // Line\n    const gen = rough.generator();\n    const curve = !element.roundness\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n\n    const ops = getCurvePathOps(curve);\n    bounds = getMinMaxXYFromCurvePathOps(ops);\n  }\n\n  const [minX, minY, maxX, maxY] = bounds;\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getElementPointsCoords = (\n  element: ExcalidrawLinearElement,\n  points: readonly (readonly [number, number])[],\n): [number, number, number, number] => {\n  // This might be computationally heavey\n  const gen = rough.generator();\n  const curve =\n    element.roundness == null\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getClosestElementBounds = (\n  elements: readonly ExcalidrawElement[],\n  from: { x: number; y: number },\n): Bounds => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minDistance = Infinity;\n  let closestElement = elements[0];\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    const distance = distance2d((x1 + x2) / 2, (y1 + y2) / 2, from.x, from.y);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElement = element;\n    }\n  });\n\n  return getElementBounds(closestElement);\n};\n\nexport interface BoundingBox {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n  midX: number;\n  midY: number;\n  width: number;\n  height: number;\n}\n\nexport const getCommonBoundingBox = (\n  elements: ExcalidrawElement[] | readonly NonDeleted<ExcalidrawElement>[],\n): BoundingBox => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n    midX: (minX + maxX) / 2,\n    midY: (minY + maxY) / 2,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}