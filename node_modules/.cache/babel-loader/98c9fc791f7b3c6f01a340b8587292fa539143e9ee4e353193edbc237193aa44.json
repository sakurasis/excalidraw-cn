{"ast":null,"code":"import { distance2d, rotate, isPathALoop, getGridPoint, rotatePoint, centerPoint, getControlPointsForBezierCurve, getBezierXY, getBezierCurveLength, mapIntervalToBezierT, arePointsEqual } from \"../math\";\nimport { getElementAbsoluteCoords, getLockedLinearCursorAlignSize } from \".\";\nimport { getCurvePathOps, getElementPointsCoords, getMinMaxXYFromCurvePathOps } from \"./bounds\";\nimport { mutateElement } from \"./mutateElement\";\nimport Scene from \"../scene/Scene\";\nimport { bindOrUnbindLinearElement, getHoveredElementForBinding, isBindingEnabled } from \"./binding\";\nimport { tupleToCoors } from \"../utils\";\nimport { isBindingElement } from \"./typeChecks\";\nimport { shouldRotateWithDiscreteAngle } from \"../keys\";\nimport { getBoundTextElement, handleBindTextResize } from \"./textElement\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\nimport { DRAGGING_THRESHOLD } from \"../constants\";\nconst editorMidPointsCache = {\n  version: null,\n  points: [],\n  zoom: null\n};\nexport class LinearElementEditor {\n  constructor(element, scene) {\n    this.elementId = void 0;\n    /** indices */\n    this.selectedPointsIndices = void 0;\n    this.pointerDownState = void 0;\n    /** whether you're dragging a point */\n    this.isDragging = void 0;\n    this.lastUncommittedPoint = void 0;\n    this.pointerOffset = void 0;\n    this.startBindingElement = void 0;\n    this.endBindingElement = void 0;\n    this.hoverPointIndex = void 0;\n    this.segmentMidPointHoveredCoords = void 0;\n    this.elementId = element.id;\n    Scene.mapElementToScene(this.elementId, scene);\n    LinearElementEditor.normalizePoints(element);\n    this.selectedPointsIndices = null;\n    this.lastUncommittedPoint = null;\n    this.isDragging = false;\n    this.pointerOffset = {\n      x: 0,\n      y: 0\n    };\n    this.startBindingElement = \"keep\";\n    this.endBindingElement = \"keep\";\n    this.pointerDownState = {\n      prevSelectedPointsIndices: null,\n      lastClickedPoint: -1,\n      origin: null,\n      segmentMidpoint: {\n        value: null,\n        index: null,\n        added: false\n      }\n    };\n    this.hoverPointIndex = -1;\n    this.segmentMidPointHoveredCoords = null;\n  }\n\n  // ---------------------------------------------------------------------------\n  // static methods\n  // ---------------------------------------------------------------------------\n\n  /**\n   * @param id the `elementId` from the instance of this class (so that we can\n   *  statically guarantee this method returns an ExcalidrawLinearElement)\n   */\n  static getElement(id) {\n    var _Scene$getScene;\n    const element = (_Scene$getScene = Scene.getScene(id)) === null || _Scene$getScene === void 0 ? void 0 : _Scene$getScene.getNonDeletedElement(id);\n    if (element) {\n      return element;\n    }\n    return null;\n  }\n  static handleBoxSelection(event, appState, setState) {\n    var _appState$draggingEle;\n    if (!appState.editingLinearElement || ((_appState$draggingEle = appState.draggingElement) === null || _appState$draggingEle === void 0 ? void 0 : _appState$draggingEle.type) !== \"selection\") {\n      return false;\n    }\n    const {\n      editingLinearElement\n    } = appState;\n    const {\n      selectedPointsIndices,\n      elementId\n    } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return false;\n    }\n    const [selectionX1, selectionY1, selectionX2, selectionY2] = getElementAbsoluteCoords(appState.draggingElement);\n    const pointsSceneCoords = LinearElementEditor.getPointsGlobalCoordinates(element);\n    const nextSelectedPoints = pointsSceneCoords.reduce((acc, point, index) => {\n      if (point[0] >= selectionX1 && point[0] <= selectionX2 && point[1] >= selectionY1 && point[1] <= selectionY2 || event.shiftKey && selectedPointsIndices !== null && selectedPointsIndices !== void 0 && selectedPointsIndices.includes(index)) {\n        acc.push(index);\n      }\n      return acc;\n    }, []);\n    setState({\n      editingLinearElement: {\n        ...editingLinearElement,\n        selectedPointsIndices: nextSelectedPoints.length ? nextSelectedPoints : null\n      }\n    });\n  }\n\n  /** @returns whether point was dragged */\n  static handlePointDragging(event, appState, scenePointerX, scenePointerY, maybeSuggestBinding, linearElementEditor) {\n    if (!linearElementEditor) {\n      return false;\n    }\n    const {\n      selectedPointsIndices,\n      elementId\n    } = linearElementEditor;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return false;\n    }\n\n    // point that's being dragged (out of all selected points)\n    const draggingPoint = element.points[linearElementEditor.pointerDownState.lastClickedPoint];\n    if (selectedPointsIndices && draggingPoint) {\n      if (shouldRotateWithDiscreteAngle(event) && selectedPointsIndices.length === 1 && element.points.length > 1) {\n        const selectedIndex = selectedPointsIndices[0];\n        const referencePoint = element.points[selectedIndex === 0 ? 1 : selectedIndex - 1];\n        const [width, height] = LinearElementEditor._getShiftLockedDelta(element, referencePoint, [scenePointerX, scenePointerY], appState.gridSize);\n        LinearElementEditor.movePoints(element, [{\n          index: selectedIndex,\n          point: [width + referencePoint[0], height + referencePoint[1]],\n          isDragging: selectedIndex === linearElementEditor.pointerDownState.lastClickedPoint\n        }]);\n      } else {\n        const newDraggingPointPosition = LinearElementEditor.createPointAt(element, scenePointerX - linearElementEditor.pointerOffset.x, scenePointerY - linearElementEditor.pointerOffset.y, appState.gridSize);\n        const deltaX = newDraggingPointPosition[0] - draggingPoint[0];\n        const deltaY = newDraggingPointPosition[1] - draggingPoint[1];\n        LinearElementEditor.movePoints(element, selectedPointsIndices.map(pointIndex => {\n          const newPointPosition = pointIndex === linearElementEditor.pointerDownState.lastClickedPoint ? LinearElementEditor.createPointAt(element, scenePointerX - linearElementEditor.pointerOffset.x, scenePointerY - linearElementEditor.pointerOffset.y, appState.gridSize) : [element.points[pointIndex][0] + deltaX, element.points[pointIndex][1] + deltaY];\n          return {\n            index: pointIndex,\n            point: newPointPosition,\n            isDragging: pointIndex === linearElementEditor.pointerDownState.lastClickedPoint\n          };\n        }));\n        const boundTextElement = getBoundTextElement(element);\n        if (boundTextElement) {\n          handleBindTextResize(element, false);\n        }\n      }\n\n      // suggest bindings for first and last point if selected\n      if (isBindingElement(element, false)) {\n        const coords = [];\n        const firstSelectedIndex = selectedPointsIndices[0];\n        if (firstSelectedIndex === 0) {\n          coords.push(tupleToCoors(LinearElementEditor.getPointGlobalCoordinates(element, element.points[0])));\n        }\n        const lastSelectedIndex = selectedPointsIndices[selectedPointsIndices.length - 1];\n        if (lastSelectedIndex === element.points.length - 1) {\n          coords.push(tupleToCoors(LinearElementEditor.getPointGlobalCoordinates(element, element.points[lastSelectedIndex])));\n        }\n        if (coords.length) {\n          maybeSuggestBinding(element, coords);\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  static handlePointerUp(event, editingLinearElement, appState) {\n    var _pointerDownState$pre;\n    const {\n      elementId,\n      selectedPointsIndices,\n      isDragging,\n      pointerDownState\n    } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n    const bindings = {};\n    if (isDragging && selectedPointsIndices) {\n      for (const selectedPoint of selectedPointsIndices) {\n        if (selectedPoint === 0 || selectedPoint === element.points.length - 1) {\n          if (isPathALoop(element.points, appState.zoom.value)) {\n            LinearElementEditor.movePoints(element, [{\n              index: selectedPoint,\n              point: selectedPoint === 0 ? element.points[element.points.length - 1] : element.points[0]\n            }]);\n          }\n          const bindingElement = isBindingEnabled(appState) ? getHoveredElementForBinding(tupleToCoors(LinearElementEditor.getPointAtIndexGlobalCoordinates(element, selectedPoint)), Scene.getScene(element)) : null;\n          bindings[selectedPoint === 0 ? \"startBindingElement\" : \"endBindingElement\"] = bindingElement;\n        }\n      }\n    }\n    return {\n      ...editingLinearElement,\n      ...bindings,\n      // if clicking without previously dragging a point(s), and not holding\n      // shift, deselect all points except the one clicked. If holding shift,\n      // toggle the point.\n      selectedPointsIndices: isDragging || event.shiftKey ? !isDragging && event.shiftKey && (_pointerDownState$pre = pointerDownState.prevSelectedPointsIndices) !== null && _pointerDownState$pre !== void 0 && _pointerDownState$pre.includes(pointerDownState.lastClickedPoint) ? selectedPointsIndices && selectedPointsIndices.filter(pointIndex => pointIndex !== pointerDownState.lastClickedPoint) : selectedPointsIndices : selectedPointsIndices !== null && selectedPointsIndices !== void 0 && selectedPointsIndices.includes(pointerDownState.lastClickedPoint) ? [pointerDownState.lastClickedPoint] : selectedPointsIndices,\n      isDragging: false,\n      pointerOffset: {\n        x: 0,\n        y: 0\n      }\n    };\n  }\n  static isSegmentTooShort(element, startPoint, endPoint, zoom) {\n    let distance = distance2d(startPoint[0], startPoint[1], endPoint[0], endPoint[1]);\n    if (element.points.length > 2 && element.roundness) {\n      distance = getBezierCurveLength(element, endPoint);\n    }\n    return distance * zoom.value < LinearElementEditor.POINT_HANDLE_SIZE * 4;\n  }\n  static getSegmentMidPoint(element, startPoint, endPoint, endPointIndex) {\n    let segmentMidPoint = centerPoint(startPoint, endPoint);\n    if (element.points.length > 2 && element.roundness) {\n      const controlPoints = getControlPointsForBezierCurve(element, element.points[endPointIndex]);\n      if (controlPoints) {\n        const t = mapIntervalToBezierT(element, element.points[endPointIndex], 0.5);\n        const [tx, ty] = getBezierXY(controlPoints[0], controlPoints[1], controlPoints[2], controlPoints[3], t);\n        segmentMidPoint = LinearElementEditor.getPointGlobalCoordinates(element, [tx, ty]);\n      }\n    }\n    return segmentMidPoint;\n  }\n  static getSegmentMidPointIndex(linearElementEditor, appState, midPoint) {\n    const element = LinearElementEditor.getElement(linearElementEditor.elementId);\n    if (!element) {\n      return -1;\n    }\n    const midPoints = LinearElementEditor.getEditorMidPoints(element, appState);\n    let index = 0;\n    while (index < midPoints.length) {\n      if (LinearElementEditor.arePointsEqual(midPoint, midPoints[index])) {\n        return index + 1;\n      }\n      index++;\n    }\n    return -1;\n  }\n  static handlePointerDown(event, appState, history, scenePointer, linearElementEditor) {\n    var _linearElementEditor$;\n    const ret = {\n      didAddPoint: false,\n      hitElement: null,\n      linearElementEditor: null\n    };\n    if (!linearElementEditor) {\n      return ret;\n    }\n    const {\n      elementId\n    } = linearElementEditor;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return ret;\n    }\n    const segmentMidpoint = LinearElementEditor.getSegmentMidpointHitCoords(linearElementEditor, scenePointer, appState);\n    let segmentMidpointIndex = null;\n    if (segmentMidpoint) {\n      segmentMidpointIndex = LinearElementEditor.getSegmentMidPointIndex(linearElementEditor, appState, segmentMidpoint);\n    }\n    if (event.altKey && appState.editingLinearElement) {\n      if (linearElementEditor.lastUncommittedPoint == null) {\n        mutateElement(element, {\n          points: [...element.points, LinearElementEditor.createPointAt(element, scenePointer.x, scenePointer.y, appState.gridSize)]\n        });\n        ret.didAddPoint = true;\n      }\n      history.resumeRecording();\n      ret.linearElementEditor = {\n        ...linearElementEditor,\n        pointerDownState: {\n          prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,\n          lastClickedPoint: -1,\n          origin: {\n            x: scenePointer.x,\n            y: scenePointer.y\n          },\n          segmentMidpoint: {\n            value: segmentMidpoint,\n            index: segmentMidpointIndex,\n            added: false\n          }\n        },\n        selectedPointsIndices: [element.points.length - 1],\n        lastUncommittedPoint: null,\n        endBindingElement: getHoveredElementForBinding(scenePointer, Scene.getScene(element))\n      };\n      ret.didAddPoint = true;\n      return ret;\n    }\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(element, appState.zoom, scenePointer.x, scenePointer.y);\n    // if we clicked on a point, set the element as hitElement otherwise\n    // it would get deselected if the point is outside the hitbox area\n    if (clickedPointIndex >= 0 || segmentMidpoint) {\n      ret.hitElement = element;\n    } else {\n      // You might be wandering why we are storing the binding elements on\n      // LinearElementEditor and passing them in, instead of calculating them\n      // from the end points of the `linearElement` - this is to allow disabling\n      // binding (which needs to happen at the point the user finishes moving\n      // the point).\n      const {\n        startBindingElement,\n        endBindingElement\n      } = linearElementEditor;\n      if (isBindingEnabled(appState) && isBindingElement(element)) {\n        bindOrUnbindLinearElement(element, startBindingElement, endBindingElement);\n      }\n    }\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const targetPoint = clickedPointIndex > -1 && rotate(element.x + element.points[clickedPointIndex][0], element.y + element.points[clickedPointIndex][1], cx, cy, element.angle);\n    const nextSelectedPointsIndices = clickedPointIndex > -1 || event.shiftKey ? event.shiftKey || (_linearElementEditor$ = linearElementEditor.selectedPointsIndices) !== null && _linearElementEditor$ !== void 0 && _linearElementEditor$.includes(clickedPointIndex) ? normalizeSelectedPoints([...(linearElementEditor.selectedPointsIndices || []), clickedPointIndex]) : [clickedPointIndex] : null;\n    ret.linearElementEditor = {\n      ...linearElementEditor,\n      pointerDownState: {\n        prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,\n        lastClickedPoint: clickedPointIndex,\n        origin: {\n          x: scenePointer.x,\n          y: scenePointer.y\n        },\n        segmentMidpoint: {\n          value: segmentMidpoint,\n          index: segmentMidpointIndex,\n          added: false\n        }\n      },\n      selectedPointsIndices: nextSelectedPointsIndices,\n      pointerOffset: targetPoint ? {\n        x: scenePointer.x - targetPoint[0],\n        y: scenePointer.y - targetPoint[1]\n      } : {\n        x: 0,\n        y: 0\n      }\n    };\n    return ret;\n  }\n  static arePointsEqual(point1, point2) {\n    if (!point1 && !point2) {\n      return true;\n    }\n    if (!point1 || !point2) {\n      return false;\n    }\n    return arePointsEqual(point1, point2);\n  }\n  static handlePointerMove(event, scenePointerX, scenePointerY, appState) {\n    if (!appState.editingLinearElement) {\n      return null;\n    }\n    const {\n      elementId,\n      lastUncommittedPoint\n    } = appState.editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return appState.editingLinearElement;\n    }\n    const {\n      points\n    } = element;\n    const lastPoint = points[points.length - 1];\n    if (!event.altKey) {\n      if (lastPoint === lastUncommittedPoint) {\n        LinearElementEditor.deletePoints(element, [points.length - 1]);\n      }\n      return {\n        ...appState.editingLinearElement,\n        lastUncommittedPoint: null\n      };\n    }\n    let newPoint;\n    if (shouldRotateWithDiscreteAngle(event) && points.length >= 2) {\n      const lastCommittedPoint = points[points.length - 2];\n      const [width, height] = LinearElementEditor._getShiftLockedDelta(element, lastCommittedPoint, [scenePointerX, scenePointerY], appState.gridSize);\n      newPoint = [width + lastCommittedPoint[0], height + lastCommittedPoint[1]];\n    } else {\n      newPoint = LinearElementEditor.createPointAt(element, scenePointerX - appState.editingLinearElement.pointerOffset.x, scenePointerY - appState.editingLinearElement.pointerOffset.y, appState.gridSize);\n    }\n    if (lastPoint === lastUncommittedPoint) {\n      LinearElementEditor.movePoints(element, [{\n        index: element.points.length - 1,\n        point: newPoint\n      }]);\n    } else {\n      LinearElementEditor.addPoints(element, appState, [{\n        point: newPoint\n      }]);\n    }\n    return {\n      ...appState.editingLinearElement,\n      lastUncommittedPoint: element.points[element.points.length - 1]\n    };\n  }\n\n  /** scene coords */\n  static getPointGlobalCoordinates(element, point) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    let {\n      x,\n      y\n    } = element;\n    [x, y] = rotate(x + point[0], y + point[1], cx, cy, element.angle);\n    return [x, y];\n  }\n\n  /** scene coords */\n  static getPointsGlobalCoordinates(element) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return element.points.map(point => {\n      let {\n        x,\n        y\n      } = element;\n      [x, y] = rotate(x + point[0], y + point[1], cx, cy, element.angle);\n      return [x, y];\n    });\n  }\n  static getPointAtIndexGlobalCoordinates(element, indexMaybeFromEnd // -1 for last element\n  ) {\n    const index = indexMaybeFromEnd < 0 ? element.points.length + indexMaybeFromEnd : indexMaybeFromEnd;\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const point = element.points[index];\n    const {\n      x,\n      y\n    } = element;\n    return point ? rotate(x + point[0], y + point[1], cx, cy, element.angle) : rotate(x, y, cx, cy, element.angle);\n  }\n  static pointFromAbsoluteCoords(element, absoluteCoords) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [x, y] = rotate(absoluteCoords[0], absoluteCoords[1], cx, cy, -element.angle);\n    return [x - element.x, y - element.y];\n  }\n  static getPointIndexUnderCursor(element, zoom, x, y) {\n    const pointHandles = LinearElementEditor.getPointsGlobalCoordinates(element);\n    let idx = pointHandles.length;\n    // loop from right to left because points on the right are rendered over\n    // points on the left, thus should take precedence when clicking, if they\n    // overlap\n    while (--idx > -1) {\n      const point = pointHandles[idx];\n      if (distance2d(x, y, point[0], point[1]) * zoom.value <\n      // +1px to account for outline stroke\n      LinearElementEditor.POINT_HANDLE_SIZE + 1) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n  static createPointAt(element, scenePointerX, scenePointerY, gridSize) {\n    const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [rotatedX, rotatedY] = rotate(pointerOnGrid[0], pointerOnGrid[1], cx, cy, -element.angle);\n    return [rotatedX - element.x, rotatedY - element.y];\n  }\n\n  /**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   * expected in various parts of the codebase. Also returns new x/y to account\n   * for the potential normalization.\n   */\n  static getNormalizedPoints(element) {\n    const {\n      points\n    } = element;\n    const offsetX = points[0][0];\n    const offsetY = points[0][1];\n    return {\n      points: points.map((point, _idx) => {\n        return [point[0] - offsetX, point[1] - offsetY];\n      }),\n      x: element.x + offsetX,\n      y: element.y + offsetY\n    };\n  }\n\n  // element-mutating methods\n  // ---------------------------------------------------------------------------\n\n  static normalizePoints(element) {\n    mutateElement(element, LinearElementEditor.getNormalizedPoints(element));\n  }\n  static duplicateSelectedPoints(appState) {\n    if (!appState.editingLinearElement) {\n      return false;\n    }\n    const {\n      selectedPointsIndices,\n      elementId\n    } = appState.editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element || selectedPointsIndices === null) {\n      return false;\n    }\n    const {\n      points\n    } = element;\n    const nextSelectedIndices = [];\n    let pointAddedToEnd = false;\n    let indexCursor = -1;\n    const nextPoints = points.reduce((acc, point, index) => {\n      ++indexCursor;\n      acc.push(point);\n      const isSelected = selectedPointsIndices.includes(index);\n      if (isSelected) {\n        const nextPoint = points[index + 1];\n        if (!nextPoint) {\n          pointAddedToEnd = true;\n        }\n        acc.push(nextPoint ? [(point[0] + nextPoint[0]) / 2, (point[1] + nextPoint[1]) / 2] : [point[0], point[1]]);\n        nextSelectedIndices.push(indexCursor + 1);\n        ++indexCursor;\n      }\n      return acc;\n    }, []);\n    mutateElement(element, {\n      points: nextPoints\n    });\n\n    // temp hack to ensure the line doesn't move when adding point to the end,\n    // potentially expanding the bounding box\n    if (pointAddedToEnd) {\n      const lastPoint = element.points[element.points.length - 1];\n      LinearElementEditor.movePoints(element, [{\n        index: element.points.length - 1,\n        point: [lastPoint[0] + 30, lastPoint[1] + 30]\n      }]);\n    }\n    return {\n      appState: {\n        ...appState,\n        editingLinearElement: {\n          ...appState.editingLinearElement,\n          selectedPointsIndices: nextSelectedIndices\n        }\n      }\n    };\n  }\n  static deletePoints(element, pointIndices) {\n    let offsetX = 0;\n    let offsetY = 0;\n    const isDeletingOriginPoint = pointIndices.includes(0);\n\n    // if deleting first point, make the next to be [0,0] and recalculate\n    // positions of the rest with respect to it\n    if (isDeletingOriginPoint) {\n      const firstNonDeletedPoint = element.points.find((point, idx) => {\n        return !pointIndices.includes(idx);\n      });\n      if (firstNonDeletedPoint) {\n        offsetX = firstNonDeletedPoint[0];\n        offsetY = firstNonDeletedPoint[1];\n      }\n    }\n    const nextPoints = element.points.reduce((acc, point, idx) => {\n      if (!pointIndices.includes(idx)) {\n        acc.push(!acc.length ? [0, 0] : [point[0] - offsetX, point[1] - offsetY]);\n      }\n      return acc;\n    }, []);\n    LinearElementEditor._updatePoints(element, nextPoints, offsetX, offsetY);\n  }\n  static addPoints(element, appState, targetPoints) {\n    const offsetX = 0;\n    const offsetY = 0;\n    const nextPoints = [...element.points, ...targetPoints.map(x => x.point)];\n    LinearElementEditor._updatePoints(element, nextPoints, offsetX, offsetY);\n  }\n  static movePoints(element, targetPoints, otherUpdates) {\n    const {\n      points\n    } = element;\n\n    // in case we're moving start point, instead of modifying its position\n    // which would break the invariant of it being at [0,0], we move\n    // all the other points in the opposite direction by delta to\n    // offset it. We do the same with actual element.x/y position, so\n    // this hacks are completely transparent to the user.\n    let offsetX = 0;\n    let offsetY = 0;\n    const selectedOriginPoint = targetPoints.find(_ref => {\n      let {\n        index\n      } = _ref;\n      return index === 0;\n    });\n    if (selectedOriginPoint) {\n      offsetX = selectedOriginPoint.point[0] + points[selectedOriginPoint.index][0];\n      offsetY = selectedOriginPoint.point[1] + points[selectedOriginPoint.index][1];\n    }\n    const nextPoints = points.map((point, idx) => {\n      const selectedPointData = targetPoints.find(p => p.index === idx);\n      if (selectedPointData) {\n        if (selectedOriginPoint) {\n          return point;\n        }\n        const deltaX = selectedPointData.point[0] - points[selectedPointData.index][0];\n        const deltaY = selectedPointData.point[1] - points[selectedPointData.index][1];\n        return [point[0] + deltaX, point[1] + deltaY];\n      }\n      return offsetX || offsetY ? [point[0] - offsetX, point[1] - offsetY] : point;\n    });\n    LinearElementEditor._updatePoints(element, nextPoints, offsetX, offsetY, otherUpdates);\n  }\n  static shouldAddMidpoint(linearElementEditor, pointerCoords, appState) {\n    const element = LinearElementEditor.getElement(linearElementEditor.elementId);\n    if (!element) {\n      return false;\n    }\n    const {\n      segmentMidpoint\n    } = linearElementEditor.pointerDownState;\n    if (segmentMidpoint.added || segmentMidpoint.value === null || segmentMidpoint.index === null || linearElementEditor.pointerDownState.origin === null) {\n      return false;\n    }\n    const origin = linearElementEditor.pointerDownState.origin;\n    const dist = distance2d(origin.x, origin.y, pointerCoords.x, pointerCoords.y);\n    if (!appState.editingLinearElement && dist < DRAGGING_THRESHOLD / appState.zoom.value) {\n      return false;\n    }\n    return true;\n  }\n  static addMidpoint(linearElementEditor, pointerCoords, appState) {\n    const element = LinearElementEditor.getElement(linearElementEditor.elementId);\n    if (!element) {\n      return;\n    }\n    const {\n      segmentMidpoint\n    } = linearElementEditor.pointerDownState;\n    const ret = {\n      pointerDownState: linearElementEditor.pointerDownState,\n      selectedPointsIndices: linearElementEditor.selectedPointsIndices\n    };\n    const midpoint = LinearElementEditor.createPointAt(element, pointerCoords.x, pointerCoords.y, appState.gridSize);\n    const points = [...element.points.slice(0, segmentMidpoint.index), midpoint, ...element.points.slice(segmentMidpoint.index)];\n    mutateElement(element, {\n      points\n    });\n    ret.pointerDownState = {\n      ...linearElementEditor.pointerDownState,\n      segmentMidpoint: {\n        ...linearElementEditor.pointerDownState.segmentMidpoint,\n        added: true\n      },\n      lastClickedPoint: segmentMidpoint.index\n    };\n    ret.selectedPointsIndices = [segmentMidpoint.index];\n    return ret;\n  }\n  static _updatePoints(element, nextPoints, offsetX, offsetY, otherUpdates) {\n    const nextCoords = getElementPointsCoords(element, nextPoints);\n    const prevCoords = getElementPointsCoords(element, element.points);\n    const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;\n    const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;\n    const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;\n    const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;\n    const dX = prevCenterX - nextCenterX;\n    const dY = prevCenterY - nextCenterY;\n    const rotated = rotate(offsetX, offsetY, dX, dY, element.angle);\n    mutateElement(element, {\n      ...otherUpdates,\n      points: nextPoints,\n      x: element.x + rotated[0],\n      y: element.y + rotated[1]\n    });\n  }\n  static _getShiftLockedDelta(element, referencePoint, scenePointer, gridSize) {\n    const referencePointCoords = LinearElementEditor.getPointGlobalCoordinates(element, referencePoint);\n    const [gridX, gridY] = getGridPoint(scenePointer[0], scenePointer[1], gridSize);\n    const {\n      width,\n      height\n    } = getLockedLinearCursorAlignSize(referencePointCoords[0], referencePointCoords[1], gridX, gridY);\n    return rotatePoint([width, height], [0, 0], -element.angle);\n  }\n}\nLinearElementEditor.POINT_HANDLE_SIZE = 10;\nLinearElementEditor.getEditorMidPoints = (element, appState) => {\n  const boundText = getBoundTextElement(element);\n\n  // Since its not needed outside editor unless 2 pointer lines or bound text\n  if (!appState.editingLinearElement && element.points.length > 2 && !boundText) {\n    return [];\n  }\n  if (editorMidPointsCache.version === element.version && editorMidPointsCache.zoom === appState.zoom.value) {\n    return editorMidPointsCache.points;\n  }\n  LinearElementEditor.updateEditorMidPointsCache(element, appState);\n  return editorMidPointsCache.points;\n};\nLinearElementEditor.updateEditorMidPointsCache = (element, appState) => {\n  const points = LinearElementEditor.getPointsGlobalCoordinates(element);\n  let index = 0;\n  const midpoints = [];\n  while (index < points.length - 1) {\n    if (LinearElementEditor.isSegmentTooShort(element, element.points[index], element.points[index + 1], appState.zoom)) {\n      midpoints.push(null);\n      index++;\n      continue;\n    }\n    const segmentMidPoint = LinearElementEditor.getSegmentMidPoint(element, points[index], points[index + 1], index + 1);\n    midpoints.push(segmentMidPoint);\n    index++;\n  }\n  editorMidPointsCache.points = midpoints;\n  editorMidPointsCache.version = element.version;\n  editorMidPointsCache.zoom = appState.zoom.value;\n};\nLinearElementEditor.getSegmentMidpointHitCoords = (linearElementEditor, scenePointer, appState) => {\n  const {\n    elementId\n  } = linearElementEditor;\n  const element = LinearElementEditor.getElement(elementId);\n  if (!element) {\n    return null;\n  }\n  const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(element, appState.zoom, scenePointer.x, scenePointer.y);\n  if (clickedPointIndex >= 0) {\n    return null;\n  }\n  const points = LinearElementEditor.getPointsGlobalCoordinates(element);\n  if (points.length >= 3 && !appState.editingLinearElement) {\n    return null;\n  }\n  const threshold = LinearElementEditor.POINT_HANDLE_SIZE / appState.zoom.value;\n  const existingSegmentMidpointHitCoords = linearElementEditor.segmentMidPointHoveredCoords;\n  if (existingSegmentMidpointHitCoords) {\n    const distance = distance2d(existingSegmentMidpointHitCoords[0], existingSegmentMidpointHitCoords[1], scenePointer.x, scenePointer.y);\n    if (distance <= threshold) {\n      return existingSegmentMidpointHitCoords;\n    }\n  }\n  let index = 0;\n  const midPoints = LinearElementEditor.getEditorMidPoints(element, appState);\n  while (index < midPoints.length) {\n    if (midPoints[index] !== null) {\n      const distance = distance2d(midPoints[index][0], midPoints[index][1], scenePointer.x, scenePointer.y);\n      if (distance <= threshold) {\n        return midPoints[index];\n      }\n    }\n    index++;\n  }\n  return null;\n};\nLinearElementEditor.getBoundTextElementPosition = (element, boundTextElement) => {\n  const points = LinearElementEditor.getPointsGlobalCoordinates(element);\n  if (points.length < 2) {\n    mutateElement(boundTextElement, {\n      isDeleted: true\n    });\n  }\n  let x = 0;\n  let y = 0;\n  if (element.points.length % 2 === 1) {\n    const index = Math.floor(element.points.length / 2);\n    const midPoint = LinearElementEditor.getPointGlobalCoordinates(element, element.points[index]);\n    x = midPoint[0] - boundTextElement.width / 2;\n    y = midPoint[1] - boundTextElement.height / 2;\n  } else {\n    const index = element.points.length / 2 - 1;\n    let midSegmentMidpoint = editorMidPointsCache.points[index];\n    if (element.points.length === 2) {\n      midSegmentMidpoint = centerPoint(points[0], points[1]);\n    }\n    if (!midSegmentMidpoint || editorMidPointsCache.version !== element.version) {\n      midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(element, points[index], points[index + 1], index + 1);\n    }\n    x = midSegmentMidpoint[0] - boundTextElement.width / 2;\n    y = midSegmentMidpoint[1] - boundTextElement.height / 2;\n  }\n  return {\n    x,\n    y\n  };\n};\nLinearElementEditor.getMinMaxXYWithBoundText = (element, elementBounds, boundTextElement) => {\n  let [x1, y1, x2, y2] = elementBounds;\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  const {\n    x: boundTextX1,\n    y: boundTextY1\n  } = LinearElementEditor.getBoundTextElementPosition(element, boundTextElement);\n  const boundTextX2 = boundTextX1 + boundTextElement.width;\n  const boundTextY2 = boundTextY1 + boundTextElement.height;\n  const topLeftRotatedPoint = rotatePoint([x1, y1], [cx, cy], element.angle);\n  const topRightRotatedPoint = rotatePoint([x2, y1], [cx, cy], element.angle);\n  const counterRotateBoundTextTopLeft = rotatePoint([boundTextX1, boundTextY1], [cx, cy], -element.angle);\n  const counterRotateBoundTextTopRight = rotatePoint([boundTextX2, boundTextY1], [cx, cy], -element.angle);\n  const counterRotateBoundTextBottomLeft = rotatePoint([boundTextX1, boundTextY2], [cx, cy], -element.angle);\n  const counterRotateBoundTextBottomRight = rotatePoint([boundTextX2, boundTextY2], [cx, cy], -element.angle);\n  if (topLeftRotatedPoint[0] < topRightRotatedPoint[0] && topLeftRotatedPoint[1] >= topRightRotatedPoint[1]) {\n    x1 = Math.min(x1, counterRotateBoundTextBottomLeft[0]);\n    x2 = Math.max(x2, Math.max(counterRotateBoundTextTopRight[0], counterRotateBoundTextBottomRight[0]));\n    y1 = Math.min(y1, counterRotateBoundTextTopLeft[1]);\n    y2 = Math.max(y2, counterRotateBoundTextBottomRight[1]);\n  } else if (topLeftRotatedPoint[0] >= topRightRotatedPoint[0] && topLeftRotatedPoint[1] > topRightRotatedPoint[1]) {\n    x1 = Math.min(x1, counterRotateBoundTextBottomRight[0]);\n    x2 = Math.max(x2, Math.max(counterRotateBoundTextTopLeft[0], counterRotateBoundTextTopRight[0]));\n    y1 = Math.min(y1, counterRotateBoundTextBottomLeft[1]);\n    y2 = Math.max(y2, counterRotateBoundTextTopRight[1]);\n  } else if (topLeftRotatedPoint[0] >= topRightRotatedPoint[0]) {\n    x1 = Math.min(x1, counterRotateBoundTextTopRight[0]);\n    x2 = Math.max(x2, counterRotateBoundTextBottomLeft[0]);\n    y1 = Math.min(y1, counterRotateBoundTextBottomRight[1]);\n    y2 = Math.max(y2, counterRotateBoundTextTopLeft[1]);\n  } else if (topLeftRotatedPoint[1] <= topRightRotatedPoint[1]) {\n    x1 = Math.min(x1, Math.min(counterRotateBoundTextTopRight[0], counterRotateBoundTextTopLeft[0]));\n    x2 = Math.max(x2, counterRotateBoundTextBottomRight[0]);\n    y1 = Math.min(y1, counterRotateBoundTextTopRight[1]);\n    y2 = Math.max(y2, counterRotateBoundTextBottomLeft[1]);\n  }\n  return [x1, y1, x2, y2, cx, cy];\n};\nLinearElementEditor.getElementAbsoluteCoords = function (element) {\n  let includeBoundText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let coords;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const {\n      minX,\n      minY,\n      maxX,\n      maxY\n    } = element.points.reduce((limits, _ref2) => {\n      let [x, y] = _ref2;\n      limits.minY = Math.min(limits.minY, y);\n      limits.minX = Math.min(limits.minX, x);\n      limits.maxX = Math.max(limits.maxX, x);\n      limits.maxY = Math.max(limits.maxY, y);\n      return limits;\n    }, {\n      minX: Infinity,\n      minY: Infinity,\n      maxX: -Infinity,\n      maxY: -Infinity\n    });\n    x1 = minX + element.x;\n    y1 = minY + element.y;\n    x2 = maxX + element.x;\n    y2 = maxY + element.y;\n  } else {\n    const shape = getShapeForElement(element);\n\n    // first element is always the curve\n    const ops = getCurvePathOps(shape[0]);\n    const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n    x1 = minX + element.x;\n    y1 = minY + element.y;\n    x2 = maxX + element.x;\n    y2 = maxY + element.y;\n  }\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  coords = [x1, y1, x2, y2, cx, cy];\n  if (!includeBoundText) {\n    return coords;\n  }\n  const boundTextElement = getBoundTextElement(element);\n  if (boundTextElement) {\n    coords = LinearElementEditor.getMinMaxXYWithBoundText(element, [x1, y1, x2, y2], boundTextElement);\n  }\n  return coords;\n};\nconst normalizeSelectedPoints = points => {\n  let nextPoints = [...new Set(points.filter(p => p !== null && p !== -1))];\n  nextPoints = nextPoints.sort((a, b) => a - b);\n  return nextPoints.length ? nextPoints : null;\n};","map":{"version":3,"names":["distance2d","rotate","isPathALoop","getGridPoint","rotatePoint","centerPoint","getControlPointsForBezierCurve","getBezierXY","getBezierCurveLength","mapIntervalToBezierT","arePointsEqual","getElementAbsoluteCoords","getLockedLinearCursorAlignSize","getCurvePathOps","getElementPointsCoords","getMinMaxXYFromCurvePathOps","mutateElement","Scene","bindOrUnbindLinearElement","getHoveredElementForBinding","isBindingEnabled","tupleToCoors","isBindingElement","shouldRotateWithDiscreteAngle","getBoundTextElement","handleBindTextResize","getShapeForElement","DRAGGING_THRESHOLD","editorMidPointsCache","version","points","zoom","LinearElementEditor","constructor","element","scene","elementId","selectedPointsIndices","pointerDownState","isDragging","lastUncommittedPoint","pointerOffset","startBindingElement","endBindingElement","hoverPointIndex","segmentMidPointHoveredCoords","id","mapElementToScene","normalizePoints","x","y","prevSelectedPointsIndices","lastClickedPoint","origin","segmentMidpoint","value","index","added","getElement","_Scene$getScene","getScene","getNonDeletedElement","handleBoxSelection","event","appState","setState","_appState$draggingEle","editingLinearElement","draggingElement","type","selectionX1","selectionY1","selectionX2","selectionY2","pointsSceneCoords","getPointsGlobalCoordinates","nextSelectedPoints","reduce","acc","point","shiftKey","includes","push","length","handlePointDragging","scenePointerX","scenePointerY","maybeSuggestBinding","linearElementEditor","draggingPoint","selectedIndex","referencePoint","width","height","_getShiftLockedDelta","gridSize","movePoints","newDraggingPointPosition","createPointAt","deltaX","deltaY","map","pointIndex","newPointPosition","boundTextElement","coords","firstSelectedIndex","getPointGlobalCoordinates","lastSelectedIndex","handlePointerUp","_pointerDownState$pre","bindings","selectedPoint","bindingElement","getPointAtIndexGlobalCoordinates","filter","isSegmentTooShort","startPoint","endPoint","distance","roundness","POINT_HANDLE_SIZE","getSegmentMidPoint","endPointIndex","segmentMidPoint","controlPoints","t","tx","ty","getSegmentMidPointIndex","midPoint","midPoints","getEditorMidPoints","handlePointerDown","history","scenePointer","_linearElementEditor$","ret","didAddPoint","hitElement","getSegmentMidpointHitCoords","segmentMidpointIndex","altKey","resumeRecording","clickedPointIndex","getPointIndexUnderCursor","x1","y1","x2","y2","cx","cy","targetPoint","angle","nextSelectedPointsIndices","normalizeSelectedPoints","point1","point2","handlePointerMove","lastPoint","deletePoints","newPoint","lastCommittedPoint","addPoints","indexMaybeFromEnd","pointFromAbsoluteCoords","absoluteCoords","pointHandles","idx","pointerOnGrid","rotatedX","rotatedY","getNormalizedPoints","offsetX","offsetY","_idx","duplicateSelectedPoints","nextSelectedIndices","pointAddedToEnd","indexCursor","nextPoints","isSelected","nextPoint","pointIndices","isDeletingOriginPoint","firstNonDeletedPoint","find","_updatePoints","targetPoints","otherUpdates","selectedOriginPoint","_ref","selectedPointData","p","shouldAddMidpoint","pointerCoords","dist","addMidpoint","midpoint","slice","nextCoords","prevCoords","nextCenterX","nextCenterY","prevCenterX","prevCenterY","dX","dY","rotated","referencePointCoords","gridX","gridY","boundText","updateEditorMidPointsCache","midpoints","threshold","existingSegmentMidpointHitCoords","getBoundTextElementPosition","isDeleted","Math","floor","midSegmentMidpoint","getMinMaxXYWithBoundText","elementBounds","boundTextX1","boundTextY1","boundTextX2","boundTextY2","topLeftRotatedPoint","topRightRotatedPoint","counterRotateBoundTextTopLeft","counterRotateBoundTextTopRight","counterRotateBoundTextBottomLeft","counterRotateBoundTextBottomRight","min","max","includeBoundText","arguments","undefined","minX","minY","maxX","maxY","limits","_ref2","Infinity","shape","ops","Set","sort","a","b"],"sources":["D:/project/excalidraw-cn/src/element/linearElementEditor.ts"],"sourcesContent":["import {\n  NonDeleted,\n  ExcalidrawLinearElement,\n  ExcalidrawElement,\n  PointBinding,\n  ExcalidrawBindableElement,\n  ExcalidrawTextElementWithContainer,\n} from \"./types\";\nimport {\n  distance2d,\n  rotate,\n  isPathALoop,\n  getGridPoint,\n  rotatePoint,\n  centerPoint,\n  getControlPointsForBezierCurve,\n  getBezierXY,\n  getBezierCurveLength,\n  mapIntervalToBezierT,\n  arePointsEqual,\n} from \"../math\";\nimport { getElementAbsoluteCoords, getLockedLinearCursorAlignSize } from \".\";\nimport {\n  getCurvePathOps,\n  getElementPointsCoords,\n  getMinMaxXYFromCurvePathOps,\n} from \"./bounds\";\nimport { Point, AppState, PointerCoords } from \"../types\";\nimport { mutateElement } from \"./mutateElement\";\nimport History from \"../history\";\n\nimport Scene from \"../scene/Scene\";\nimport {\n  bindOrUnbindLinearElement,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n} from \"./binding\";\nimport { tupleToCoors } from \"../utils\";\nimport { isBindingElement } from \"./typeChecks\";\nimport { shouldRotateWithDiscreteAngle } from \"../keys\";\nimport { getBoundTextElement, handleBindTextResize } from \"./textElement\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\nimport { DRAGGING_THRESHOLD } from \"../constants\";\nimport { Mutable } from \"../utility-types\";\n\nconst editorMidPointsCache: {\n  version: number | null;\n  points: (Point | null)[];\n  zoom: number | null;\n} = { version: null, points: [], zoom: null };\nexport class LinearElementEditor {\n  public readonly elementId: ExcalidrawElement[\"id\"] & {\n    _brand: \"excalidrawLinearElementId\";\n  };\n  /** indices */\n  public readonly selectedPointsIndices: readonly number[] | null;\n\n  public readonly pointerDownState: Readonly<{\n    prevSelectedPointsIndices: readonly number[] | null;\n    /** index */\n    lastClickedPoint: number;\n    origin: Readonly<{ x: number; y: number }> | null;\n    segmentMidpoint: {\n      value: Point | null;\n      index: number | null;\n      added: boolean;\n    };\n  }>;\n\n  /** whether you're dragging a point */\n  public readonly isDragging: boolean;\n  public readonly lastUncommittedPoint: Point | null;\n  public readonly pointerOffset: Readonly<{ x: number; y: number }>;\n  public readonly startBindingElement:\n    | ExcalidrawBindableElement\n    | null\n    | \"keep\";\n  public readonly endBindingElement: ExcalidrawBindableElement | null | \"keep\";\n  public readonly hoverPointIndex: number;\n  public readonly segmentMidPointHoveredCoords: Point | null;\n\n  constructor(element: NonDeleted<ExcalidrawLinearElement>, scene: Scene) {\n    this.elementId = element.id as string & {\n      _brand: \"excalidrawLinearElementId\";\n    };\n    Scene.mapElementToScene(this.elementId, scene);\n    LinearElementEditor.normalizePoints(element);\n\n    this.selectedPointsIndices = null;\n    this.lastUncommittedPoint = null;\n    this.isDragging = false;\n    this.pointerOffset = { x: 0, y: 0 };\n    this.startBindingElement = \"keep\";\n    this.endBindingElement = \"keep\";\n    this.pointerDownState = {\n      prevSelectedPointsIndices: null,\n      lastClickedPoint: -1,\n      origin: null,\n\n      segmentMidpoint: {\n        value: null,\n        index: null,\n        added: false,\n      },\n    };\n    this.hoverPointIndex = -1;\n    this.segmentMidPointHoveredCoords = null;\n  }\n\n  // ---------------------------------------------------------------------------\n  // static methods\n  // ---------------------------------------------------------------------------\n\n  static POINT_HANDLE_SIZE = 10;\n  /**\n   * @param id the `elementId` from the instance of this class (so that we can\n   *  statically guarantee this method returns an ExcalidrawLinearElement)\n   */\n  static getElement(id: InstanceType<typeof LinearElementEditor>[\"elementId\"]) {\n    const element = Scene.getScene(id)?.getNonDeletedElement(id);\n    if (element) {\n      return element as NonDeleted<ExcalidrawLinearElement>;\n    }\n    return null;\n  }\n\n  static handleBoxSelection(\n    event: PointerEvent,\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n  ) {\n    if (\n      !appState.editingLinearElement ||\n      appState.draggingElement?.type !== \"selection\"\n    ) {\n      return false;\n    }\n    const { editingLinearElement } = appState;\n    const { selectedPointsIndices, elementId } = editingLinearElement;\n\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return false;\n    }\n\n    const [selectionX1, selectionY1, selectionX2, selectionY2] =\n      getElementAbsoluteCoords(appState.draggingElement);\n\n    const pointsSceneCoords =\n      LinearElementEditor.getPointsGlobalCoordinates(element);\n\n    const nextSelectedPoints = pointsSceneCoords.reduce(\n      (acc: number[], point, index) => {\n        if (\n          (point[0] >= selectionX1 &&\n            point[0] <= selectionX2 &&\n            point[1] >= selectionY1 &&\n            point[1] <= selectionY2) ||\n          (event.shiftKey && selectedPointsIndices?.includes(index))\n        ) {\n          acc.push(index);\n        }\n\n        return acc;\n      },\n      [],\n    );\n\n    setState({\n      editingLinearElement: {\n        ...editingLinearElement,\n        selectedPointsIndices: nextSelectedPoints.length\n          ? nextSelectedPoints\n          : null,\n      },\n    });\n  }\n\n  /** @returns whether point was dragged */\n  static handlePointDragging(\n    event: PointerEvent,\n    appState: AppState,\n    scenePointerX: number,\n    scenePointerY: number,\n    maybeSuggestBinding: (\n      element: NonDeleted<ExcalidrawLinearElement>,\n      pointSceneCoords: { x: number; y: number }[],\n    ) => void,\n    linearElementEditor: LinearElementEditor,\n  ): boolean {\n    if (!linearElementEditor) {\n      return false;\n    }\n    const { selectedPointsIndices, elementId } = linearElementEditor;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return false;\n    }\n\n    // point that's being dragged (out of all selected points)\n    const draggingPoint = element.points[\n      linearElementEditor.pointerDownState.lastClickedPoint\n    ] as [number, number] | undefined;\n\n    if (selectedPointsIndices && draggingPoint) {\n      if (\n        shouldRotateWithDiscreteAngle(event) &&\n        selectedPointsIndices.length === 1 &&\n        element.points.length > 1\n      ) {\n        const selectedIndex = selectedPointsIndices[0];\n        const referencePoint =\n          element.points[selectedIndex === 0 ? 1 : selectedIndex - 1];\n\n        const [width, height] = LinearElementEditor._getShiftLockedDelta(\n          element,\n          referencePoint,\n          [scenePointerX, scenePointerY],\n          appState.gridSize,\n        );\n\n        LinearElementEditor.movePoints(element, [\n          {\n            index: selectedIndex,\n            point: [width + referencePoint[0], height + referencePoint[1]],\n            isDragging:\n              selectedIndex ===\n              linearElementEditor.pointerDownState.lastClickedPoint,\n          },\n        ]);\n      } else {\n        const newDraggingPointPosition = LinearElementEditor.createPointAt(\n          element,\n          scenePointerX - linearElementEditor.pointerOffset.x,\n          scenePointerY - linearElementEditor.pointerOffset.y,\n          appState.gridSize,\n        );\n\n        const deltaX = newDraggingPointPosition[0] - draggingPoint[0];\n        const deltaY = newDraggingPointPosition[1] - draggingPoint[1];\n\n        LinearElementEditor.movePoints(\n          element,\n          selectedPointsIndices.map((pointIndex) => {\n            const newPointPosition =\n              pointIndex ===\n              linearElementEditor.pointerDownState.lastClickedPoint\n                ? LinearElementEditor.createPointAt(\n                    element,\n                    scenePointerX - linearElementEditor.pointerOffset.x,\n                    scenePointerY - linearElementEditor.pointerOffset.y,\n                    appState.gridSize,\n                  )\n                : ([\n                    element.points[pointIndex][0] + deltaX,\n                    element.points[pointIndex][1] + deltaY,\n                  ] as const);\n            return {\n              index: pointIndex,\n              point: newPointPosition,\n              isDragging:\n                pointIndex ===\n                linearElementEditor.pointerDownState.lastClickedPoint,\n            };\n          }),\n        );\n\n        const boundTextElement = getBoundTextElement(element);\n        if (boundTextElement) {\n          handleBindTextResize(element, false);\n        }\n      }\n\n      // suggest bindings for first and last point if selected\n      if (isBindingElement(element, false)) {\n        const coords: { x: number; y: number }[] = [];\n\n        const firstSelectedIndex = selectedPointsIndices[0];\n        if (firstSelectedIndex === 0) {\n          coords.push(\n            tupleToCoors(\n              LinearElementEditor.getPointGlobalCoordinates(\n                element,\n                element.points[0],\n              ),\n            ),\n          );\n        }\n\n        const lastSelectedIndex =\n          selectedPointsIndices[selectedPointsIndices.length - 1];\n        if (lastSelectedIndex === element.points.length - 1) {\n          coords.push(\n            tupleToCoors(\n              LinearElementEditor.getPointGlobalCoordinates(\n                element,\n                element.points[lastSelectedIndex],\n              ),\n            ),\n          );\n        }\n\n        if (coords.length) {\n          maybeSuggestBinding(element, coords);\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  static handlePointerUp(\n    event: PointerEvent,\n    editingLinearElement: LinearElementEditor,\n    appState: AppState,\n  ): LinearElementEditor {\n    const { elementId, selectedPointsIndices, isDragging, pointerDownState } =\n      editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    const bindings: Mutable<\n      Partial<\n        Pick<\n          InstanceType<typeof LinearElementEditor>,\n          \"startBindingElement\" | \"endBindingElement\"\n        >\n      >\n    > = {};\n\n    if (isDragging && selectedPointsIndices) {\n      for (const selectedPoint of selectedPointsIndices) {\n        if (\n          selectedPoint === 0 ||\n          selectedPoint === element.points.length - 1\n        ) {\n          if (isPathALoop(element.points, appState.zoom.value)) {\n            LinearElementEditor.movePoints(element, [\n              {\n                index: selectedPoint,\n                point:\n                  selectedPoint === 0\n                    ? element.points[element.points.length - 1]\n                    : element.points[0],\n              },\n            ]);\n          }\n\n          const bindingElement = isBindingEnabled(appState)\n            ? getHoveredElementForBinding(\n                tupleToCoors(\n                  LinearElementEditor.getPointAtIndexGlobalCoordinates(\n                    element,\n                    selectedPoint!,\n                  ),\n                ),\n                Scene.getScene(element)!,\n              )\n            : null;\n\n          bindings[\n            selectedPoint === 0 ? \"startBindingElement\" : \"endBindingElement\"\n          ] = bindingElement;\n        }\n      }\n    }\n\n    return {\n      ...editingLinearElement,\n      ...bindings,\n      // if clicking without previously dragging a point(s), and not holding\n      // shift, deselect all points except the one clicked. If holding shift,\n      // toggle the point.\n      selectedPointsIndices:\n        isDragging || event.shiftKey\n          ? !isDragging &&\n            event.shiftKey &&\n            pointerDownState.prevSelectedPointsIndices?.includes(\n              pointerDownState.lastClickedPoint,\n            )\n            ? selectedPointsIndices &&\n              selectedPointsIndices.filter(\n                (pointIndex) =>\n                  pointIndex !== pointerDownState.lastClickedPoint,\n              )\n            : selectedPointsIndices\n          : selectedPointsIndices?.includes(pointerDownState.lastClickedPoint)\n          ? [pointerDownState.lastClickedPoint]\n          : selectedPointsIndices,\n      isDragging: false,\n      pointerOffset: { x: 0, y: 0 },\n    };\n  }\n\n  static getEditorMidPoints = (\n    element: NonDeleted<ExcalidrawLinearElement>,\n    appState: AppState,\n  ): typeof editorMidPointsCache[\"points\"] => {\n    const boundText = getBoundTextElement(element);\n\n    // Since its not needed outside editor unless 2 pointer lines or bound text\n    if (\n      !appState.editingLinearElement &&\n      element.points.length > 2 &&\n      !boundText\n    ) {\n      return [];\n    }\n    if (\n      editorMidPointsCache.version === element.version &&\n      editorMidPointsCache.zoom === appState.zoom.value\n    ) {\n      return editorMidPointsCache.points;\n    }\n    LinearElementEditor.updateEditorMidPointsCache(element, appState);\n    return editorMidPointsCache.points!;\n  };\n\n  static updateEditorMidPointsCache = (\n    element: NonDeleted<ExcalidrawLinearElement>,\n    appState: AppState,\n  ) => {\n    const points = LinearElementEditor.getPointsGlobalCoordinates(element);\n\n    let index = 0;\n    const midpoints: (Point | null)[] = [];\n    while (index < points.length - 1) {\n      if (\n        LinearElementEditor.isSegmentTooShort(\n          element,\n          element.points[index],\n          element.points[index + 1],\n          appState.zoom,\n        )\n      ) {\n        midpoints.push(null);\n        index++;\n        continue;\n      }\n      const segmentMidPoint = LinearElementEditor.getSegmentMidPoint(\n        element,\n        points[index],\n        points[index + 1],\n        index + 1,\n      );\n      midpoints.push(segmentMidPoint);\n      index++;\n    }\n    editorMidPointsCache.points = midpoints;\n    editorMidPointsCache.version = element.version;\n    editorMidPointsCache.zoom = appState.zoom.value;\n  };\n\n  static getSegmentMidpointHitCoords = (\n    linearElementEditor: LinearElementEditor,\n    scenePointer: { x: number; y: number },\n    appState: AppState,\n  ) => {\n    const { elementId } = linearElementEditor;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return null;\n    }\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n    if (clickedPointIndex >= 0) {\n      return null;\n    }\n    const points = LinearElementEditor.getPointsGlobalCoordinates(element);\n    if (points.length >= 3 && !appState.editingLinearElement) {\n      return null;\n    }\n\n    const threshold =\n      LinearElementEditor.POINT_HANDLE_SIZE / appState.zoom.value;\n\n    const existingSegmentMidpointHitCoords =\n      linearElementEditor.segmentMidPointHoveredCoords;\n    if (existingSegmentMidpointHitCoords) {\n      const distance = distance2d(\n        existingSegmentMidpointHitCoords[0],\n        existingSegmentMidpointHitCoords[1],\n        scenePointer.x,\n        scenePointer.y,\n      );\n      if (distance <= threshold) {\n        return existingSegmentMidpointHitCoords;\n      }\n    }\n    let index = 0;\n    const midPoints: typeof editorMidPointsCache[\"points\"] =\n      LinearElementEditor.getEditorMidPoints(element, appState);\n    while (index < midPoints.length) {\n      if (midPoints[index] !== null) {\n        const distance = distance2d(\n          midPoints[index]![0],\n          midPoints[index]![1],\n          scenePointer.x,\n          scenePointer.y,\n        );\n        if (distance <= threshold) {\n          return midPoints[index];\n        }\n      }\n\n      index++;\n    }\n    return null;\n  };\n\n  static isSegmentTooShort(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    startPoint: Point,\n    endPoint: Point,\n    zoom: AppState[\"zoom\"],\n  ) {\n    let distance = distance2d(\n      startPoint[0],\n      startPoint[1],\n      endPoint[0],\n      endPoint[1],\n    );\n    if (element.points.length > 2 && element.roundness) {\n      distance = getBezierCurveLength(element, endPoint);\n    }\n\n    return distance * zoom.value < LinearElementEditor.POINT_HANDLE_SIZE * 4;\n  }\n\n  static getSegmentMidPoint(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    startPoint: Point,\n    endPoint: Point,\n    endPointIndex: number,\n  ) {\n    let segmentMidPoint = centerPoint(startPoint, endPoint);\n    if (element.points.length > 2 && element.roundness) {\n      const controlPoints = getControlPointsForBezierCurve(\n        element,\n        element.points[endPointIndex],\n      );\n      if (controlPoints) {\n        const t = mapIntervalToBezierT(\n          element,\n          element.points[endPointIndex],\n          0.5,\n        );\n\n        const [tx, ty] = getBezierXY(\n          controlPoints[0],\n          controlPoints[1],\n          controlPoints[2],\n          controlPoints[3],\n          t,\n        );\n        segmentMidPoint = LinearElementEditor.getPointGlobalCoordinates(\n          element,\n          [tx, ty],\n        );\n      }\n    }\n\n    return segmentMidPoint;\n  }\n\n  static getSegmentMidPointIndex(\n    linearElementEditor: LinearElementEditor,\n    appState: AppState,\n    midPoint: Point,\n  ) {\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n    );\n    if (!element) {\n      return -1;\n    }\n    const midPoints = LinearElementEditor.getEditorMidPoints(element, appState);\n    let index = 0;\n    while (index < midPoints.length) {\n      if (LinearElementEditor.arePointsEqual(midPoint, midPoints[index])) {\n        return index + 1;\n      }\n      index++;\n    }\n    return -1;\n  }\n\n  static handlePointerDown(\n    event: React.PointerEvent<HTMLElement>,\n    appState: AppState,\n    history: History,\n    scenePointer: { x: number; y: number },\n    linearElementEditor: LinearElementEditor,\n  ): {\n    didAddPoint: boolean;\n    hitElement: NonDeleted<ExcalidrawElement> | null;\n    linearElementEditor: LinearElementEditor | null;\n  } {\n    const ret: ReturnType<typeof LinearElementEditor[\"handlePointerDown\"]> = {\n      didAddPoint: false,\n      hitElement: null,\n      linearElementEditor: null,\n    };\n\n    if (!linearElementEditor) {\n      return ret;\n    }\n\n    const { elementId } = linearElementEditor;\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element) {\n      return ret;\n    }\n    const segmentMidpoint = LinearElementEditor.getSegmentMidpointHitCoords(\n      linearElementEditor,\n      scenePointer,\n      appState,\n    );\n    let segmentMidpointIndex = null;\n    if (segmentMidpoint) {\n      segmentMidpointIndex = LinearElementEditor.getSegmentMidPointIndex(\n        linearElementEditor,\n        appState,\n        segmentMidpoint,\n      );\n    }\n    if (event.altKey && appState.editingLinearElement) {\n      if (linearElementEditor.lastUncommittedPoint == null) {\n        mutateElement(element, {\n          points: [\n            ...element.points,\n            LinearElementEditor.createPointAt(\n              element,\n              scenePointer.x,\n              scenePointer.y,\n              appState.gridSize,\n            ),\n          ],\n        });\n        ret.didAddPoint = true;\n      }\n      history.resumeRecording();\n      ret.linearElementEditor = {\n        ...linearElementEditor,\n        pointerDownState: {\n          prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,\n          lastClickedPoint: -1,\n          origin: { x: scenePointer.x, y: scenePointer.y },\n          segmentMidpoint: {\n            value: segmentMidpoint,\n            index: segmentMidpointIndex,\n            added: false,\n          },\n        },\n        selectedPointsIndices: [element.points.length - 1],\n        lastUncommittedPoint: null,\n        endBindingElement: getHoveredElementForBinding(\n          scenePointer,\n          Scene.getScene(element)!,\n        ),\n      };\n\n      ret.didAddPoint = true;\n      return ret;\n    }\n\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n    // if we clicked on a point, set the element as hitElement otherwise\n    // it would get deselected if the point is outside the hitbox area\n    if (clickedPointIndex >= 0 || segmentMidpoint) {\n      ret.hitElement = element;\n    } else {\n      // You might be wandering why we are storing the binding elements on\n      // LinearElementEditor and passing them in, instead of calculating them\n      // from the end points of the `linearElement` - this is to allow disabling\n      // binding (which needs to happen at the point the user finishes moving\n      // the point).\n      const { startBindingElement, endBindingElement } = linearElementEditor;\n      if (isBindingEnabled(appState) && isBindingElement(element)) {\n        bindOrUnbindLinearElement(\n          element,\n          startBindingElement,\n          endBindingElement,\n        );\n      }\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const targetPoint =\n      clickedPointIndex > -1 &&\n      rotate(\n        element.x + element.points[clickedPointIndex][0],\n        element.y + element.points[clickedPointIndex][1],\n        cx,\n        cy,\n        element.angle,\n      );\n\n    const nextSelectedPointsIndices =\n      clickedPointIndex > -1 || event.shiftKey\n        ? event.shiftKey ||\n          linearElementEditor.selectedPointsIndices?.includes(clickedPointIndex)\n          ? normalizeSelectedPoints([\n              ...(linearElementEditor.selectedPointsIndices || []),\n              clickedPointIndex,\n            ])\n          : [clickedPointIndex]\n        : null;\n    ret.linearElementEditor = {\n      ...linearElementEditor,\n      pointerDownState: {\n        prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,\n        lastClickedPoint: clickedPointIndex,\n        origin: { x: scenePointer.x, y: scenePointer.y },\n        segmentMidpoint: {\n          value: segmentMidpoint,\n          index: segmentMidpointIndex,\n          added: false,\n        },\n      },\n      selectedPointsIndices: nextSelectedPointsIndices,\n      pointerOffset: targetPoint\n        ? {\n            x: scenePointer.x - targetPoint[0],\n            y: scenePointer.y - targetPoint[1],\n          }\n        : { x: 0, y: 0 },\n    };\n\n    return ret;\n  }\n\n  static arePointsEqual(point1: Point | null, point2: Point | null) {\n    if (!point1 && !point2) {\n      return true;\n    }\n    if (!point1 || !point2) {\n      return false;\n    }\n    return arePointsEqual(point1, point2);\n  }\n\n  static handlePointerMove(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    appState: AppState,\n  ): LinearElementEditor | null {\n    if (!appState.editingLinearElement) {\n      return null;\n    }\n    const { elementId, lastUncommittedPoint } = appState.editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return appState.editingLinearElement;\n    }\n\n    const { points } = element;\n    const lastPoint = points[points.length - 1];\n\n    if (!event.altKey) {\n      if (lastPoint === lastUncommittedPoint) {\n        LinearElementEditor.deletePoints(element, [points.length - 1]);\n      }\n      return {\n        ...appState.editingLinearElement,\n        lastUncommittedPoint: null,\n      };\n    }\n\n    let newPoint: Point;\n\n    if (shouldRotateWithDiscreteAngle(event) && points.length >= 2) {\n      const lastCommittedPoint = points[points.length - 2];\n\n      const [width, height] = LinearElementEditor._getShiftLockedDelta(\n        element,\n        lastCommittedPoint,\n        [scenePointerX, scenePointerY],\n        appState.gridSize,\n      );\n\n      newPoint = [\n        width + lastCommittedPoint[0],\n        height + lastCommittedPoint[1],\n      ];\n    } else {\n      newPoint = LinearElementEditor.createPointAt(\n        element,\n        scenePointerX - appState.editingLinearElement.pointerOffset.x,\n        scenePointerY - appState.editingLinearElement.pointerOffset.y,\n        appState.gridSize,\n      );\n    }\n\n    if (lastPoint === lastUncommittedPoint) {\n      LinearElementEditor.movePoints(element, [\n        {\n          index: element.points.length - 1,\n          point: newPoint,\n        },\n      ]);\n    } else {\n      LinearElementEditor.addPoints(element, appState, [{ point: newPoint }]);\n    }\n    return {\n      ...appState.editingLinearElement,\n      lastUncommittedPoint: element.points[element.points.length - 1],\n    };\n  }\n\n  /** scene coords */\n  static getPointGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    point: Point,\n  ) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    let { x, y } = element;\n    [x, y] = rotate(x + point[0], y + point[1], cx, cy, element.angle);\n    return [x, y] as const;\n  }\n\n  /** scene coords */\n  static getPointsGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n  ): Point[] {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return element.points.map((point) => {\n      let { x, y } = element;\n      [x, y] = rotate(x + point[0], y + point[1], cx, cy, element.angle);\n      return [x, y] as const;\n    });\n  }\n\n  static getPointAtIndexGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    indexMaybeFromEnd: number, // -1 for last element\n  ): Point {\n    const index =\n      indexMaybeFromEnd < 0\n        ? element.points.length + indexMaybeFromEnd\n        : indexMaybeFromEnd;\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    const point = element.points[index];\n    const { x, y } = element;\n    return point\n      ? rotate(x + point[0], y + point[1], cx, cy, element.angle)\n      : rotate(x, y, cx, cy, element.angle);\n  }\n\n  static pointFromAbsoluteCoords(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    absoluteCoords: Point,\n  ): Point {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [x, y] = rotate(\n      absoluteCoords[0],\n      absoluteCoords[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n    return [x - element.x, y - element.y];\n  }\n\n  static getPointIndexUnderCursor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    zoom: AppState[\"zoom\"],\n    x: number,\n    y: number,\n  ) {\n    const pointHandles =\n      LinearElementEditor.getPointsGlobalCoordinates(element);\n    let idx = pointHandles.length;\n    // loop from right to left because points on the right are rendered over\n    // points on the left, thus should take precedence when clicking, if they\n    // overlap\n    while (--idx > -1) {\n      const point = pointHandles[idx];\n      if (\n        distance2d(x, y, point[0], point[1]) * zoom.value <\n        // +1px to account for outline stroke\n        LinearElementEditor.POINT_HANDLE_SIZE + 1\n      ) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n\n  static createPointAt(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    gridSize: number | null,\n  ): Point {\n    const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [rotatedX, rotatedY] = rotate(\n      pointerOnGrid[0],\n      pointerOnGrid[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n\n    return [rotatedX - element.x, rotatedY - element.y];\n  }\n\n  /**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   * expected in various parts of the codebase. Also returns new x/y to account\n   * for the potential normalization.\n   */\n  static getNormalizedPoints(element: ExcalidrawLinearElement) {\n    const { points } = element;\n\n    const offsetX = points[0][0];\n    const offsetY = points[0][1];\n\n    return {\n      points: points.map((point, _idx) => {\n        return [point[0] - offsetX, point[1] - offsetY] as const;\n      }),\n      x: element.x + offsetX,\n      y: element.y + offsetY,\n    };\n  }\n\n  // element-mutating methods\n  // ---------------------------------------------------------------------------\n\n  static normalizePoints(element: NonDeleted<ExcalidrawLinearElement>) {\n    mutateElement(element, LinearElementEditor.getNormalizedPoints(element));\n  }\n\n  static duplicateSelectedPoints(appState: AppState) {\n    if (!appState.editingLinearElement) {\n      return false;\n    }\n\n    const { selectedPointsIndices, elementId } = appState.editingLinearElement;\n\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element || selectedPointsIndices === null) {\n      return false;\n    }\n\n    const { points } = element;\n\n    const nextSelectedIndices: number[] = [];\n\n    let pointAddedToEnd = false;\n    let indexCursor = -1;\n    const nextPoints = points.reduce((acc: Point[], point, index) => {\n      ++indexCursor;\n      acc.push(point);\n\n      const isSelected = selectedPointsIndices.includes(index);\n      if (isSelected) {\n        const nextPoint = points[index + 1];\n\n        if (!nextPoint) {\n          pointAddedToEnd = true;\n        }\n        acc.push(\n          nextPoint\n            ? [(point[0] + nextPoint[0]) / 2, (point[1] + nextPoint[1]) / 2]\n            : [point[0], point[1]],\n        );\n\n        nextSelectedIndices.push(indexCursor + 1);\n        ++indexCursor;\n      }\n\n      return acc;\n    }, []);\n\n    mutateElement(element, { points: nextPoints });\n\n    // temp hack to ensure the line doesn't move when adding point to the end,\n    // potentially expanding the bounding box\n    if (pointAddedToEnd) {\n      const lastPoint = element.points[element.points.length - 1];\n      LinearElementEditor.movePoints(element, [\n        {\n          index: element.points.length - 1,\n          point: [lastPoint[0] + 30, lastPoint[1] + 30],\n        },\n      ]);\n    }\n\n    return {\n      appState: {\n        ...appState,\n        editingLinearElement: {\n          ...appState.editingLinearElement,\n          selectedPointsIndices: nextSelectedIndices,\n        },\n      },\n    };\n  }\n\n  static deletePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    pointIndices: readonly number[],\n  ) {\n    let offsetX = 0;\n    let offsetY = 0;\n\n    const isDeletingOriginPoint = pointIndices.includes(0);\n\n    // if deleting first point, make the next to be [0,0] and recalculate\n    // positions of the rest with respect to it\n    if (isDeletingOriginPoint) {\n      const firstNonDeletedPoint = element.points.find((point, idx) => {\n        return !pointIndices.includes(idx);\n      });\n      if (firstNonDeletedPoint) {\n        offsetX = firstNonDeletedPoint[0];\n        offsetY = firstNonDeletedPoint[1];\n      }\n    }\n\n    const nextPoints = element.points.reduce((acc: Point[], point, idx) => {\n      if (!pointIndices.includes(idx)) {\n        acc.push(\n          !acc.length ? [0, 0] : [point[0] - offsetX, point[1] - offsetY],\n        );\n      }\n      return acc;\n    }, []);\n\n    LinearElementEditor._updatePoints(element, nextPoints, offsetX, offsetY);\n  }\n\n  static addPoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    appState: AppState,\n    targetPoints: { point: Point }[],\n  ) {\n    const offsetX = 0;\n    const offsetY = 0;\n\n    const nextPoints = [...element.points, ...targetPoints.map((x) => x.point)];\n    LinearElementEditor._updatePoints(element, nextPoints, offsetX, offsetY);\n  }\n\n  static movePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    targetPoints: { index: number; point: Point; isDragging?: boolean }[],\n    otherUpdates?: { startBinding?: PointBinding; endBinding?: PointBinding },\n  ) {\n    const { points } = element;\n\n    // in case we're moving start point, instead of modifying its position\n    // which would break the invariant of it being at [0,0], we move\n    // all the other points in the opposite direction by delta to\n    // offset it. We do the same with actual element.x/y position, so\n    // this hacks are completely transparent to the user.\n    let offsetX = 0;\n    let offsetY = 0;\n\n    const selectedOriginPoint = targetPoints.find(({ index }) => index === 0);\n\n    if (selectedOriginPoint) {\n      offsetX =\n        selectedOriginPoint.point[0] + points[selectedOriginPoint.index][0];\n      offsetY =\n        selectedOriginPoint.point[1] + points[selectedOriginPoint.index][1];\n    }\n\n    const nextPoints = points.map((point, idx) => {\n      const selectedPointData = targetPoints.find((p) => p.index === idx);\n      if (selectedPointData) {\n        if (selectedOriginPoint) {\n          return point;\n        }\n\n        const deltaX =\n          selectedPointData.point[0] - points[selectedPointData.index][0];\n        const deltaY =\n          selectedPointData.point[1] - points[selectedPointData.index][1];\n\n        return [point[0] + deltaX, point[1] + deltaY] as const;\n      }\n      return offsetX || offsetY\n        ? ([point[0] - offsetX, point[1] - offsetY] as const)\n        : point;\n    });\n\n    LinearElementEditor._updatePoints(\n      element,\n      nextPoints,\n      offsetX,\n      offsetY,\n      otherUpdates,\n    );\n  }\n\n  static shouldAddMidpoint(\n    linearElementEditor: LinearElementEditor,\n    pointerCoords: PointerCoords,\n    appState: AppState,\n  ) {\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n    );\n\n    if (!element) {\n      return false;\n    }\n\n    const { segmentMidpoint } = linearElementEditor.pointerDownState;\n\n    if (\n      segmentMidpoint.added ||\n      segmentMidpoint.value === null ||\n      segmentMidpoint.index === null ||\n      linearElementEditor.pointerDownState.origin === null\n    ) {\n      return false;\n    }\n\n    const origin = linearElementEditor.pointerDownState.origin!;\n    const dist = distance2d(\n      origin.x,\n      origin.y,\n      pointerCoords.x,\n      pointerCoords.y,\n    );\n    if (\n      !appState.editingLinearElement &&\n      dist < DRAGGING_THRESHOLD / appState.zoom.value\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  static addMidpoint(\n    linearElementEditor: LinearElementEditor,\n    pointerCoords: PointerCoords,\n    appState: AppState,\n  ) {\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n    );\n    if (!element) {\n      return;\n    }\n    const { segmentMidpoint } = linearElementEditor.pointerDownState;\n    const ret: {\n      pointerDownState: LinearElementEditor[\"pointerDownState\"];\n      selectedPointsIndices: LinearElementEditor[\"selectedPointsIndices\"];\n    } = {\n      pointerDownState: linearElementEditor.pointerDownState,\n      selectedPointsIndices: linearElementEditor.selectedPointsIndices,\n    };\n\n    const midpoint = LinearElementEditor.createPointAt(\n      element,\n      pointerCoords.x,\n      pointerCoords.y,\n      appState.gridSize,\n    );\n    const points = [\n      ...element.points.slice(0, segmentMidpoint.index!),\n      midpoint,\n      ...element.points.slice(segmentMidpoint.index!),\n    ];\n\n    mutateElement(element, {\n      points,\n    });\n\n    ret.pointerDownState = {\n      ...linearElementEditor.pointerDownState,\n      segmentMidpoint: {\n        ...linearElementEditor.pointerDownState.segmentMidpoint,\n        added: true,\n      },\n      lastClickedPoint: segmentMidpoint.index!,\n    };\n    ret.selectedPointsIndices = [segmentMidpoint.index!];\n    return ret;\n  }\n\n  private static _updatePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    nextPoints: readonly Point[],\n    offsetX: number,\n    offsetY: number,\n    otherUpdates?: { startBinding?: PointBinding; endBinding?: PointBinding },\n  ) {\n    const nextCoords = getElementPointsCoords(element, nextPoints);\n    const prevCoords = getElementPointsCoords(element, element.points);\n    const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;\n    const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;\n    const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;\n    const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;\n    const dX = prevCenterX - nextCenterX;\n    const dY = prevCenterY - nextCenterY;\n    const rotated = rotate(offsetX, offsetY, dX, dY, element.angle);\n    mutateElement(element, {\n      ...otherUpdates,\n      points: nextPoints,\n      x: element.x + rotated[0],\n      y: element.y + rotated[1],\n    });\n  }\n\n  private static _getShiftLockedDelta(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    referencePoint: Point,\n    scenePointer: Point,\n    gridSize: number | null,\n  ) {\n    const referencePointCoords = LinearElementEditor.getPointGlobalCoordinates(\n      element,\n      referencePoint,\n    );\n\n    const [gridX, gridY] = getGridPoint(\n      scenePointer[0],\n      scenePointer[1],\n      gridSize,\n    );\n\n    const { width, height } = getLockedLinearCursorAlignSize(\n      referencePointCoords[0],\n      referencePointCoords[1],\n      gridX,\n      gridY,\n    );\n\n    return rotatePoint([width, height], [0, 0], -element.angle);\n  }\n\n  static getBoundTextElementPosition = (\n    element: ExcalidrawLinearElement,\n    boundTextElement: ExcalidrawTextElementWithContainer,\n  ): { x: number; y: number } => {\n    const points = LinearElementEditor.getPointsGlobalCoordinates(element);\n    if (points.length < 2) {\n      mutateElement(boundTextElement, { isDeleted: true });\n    }\n    let x = 0;\n    let y = 0;\n    if (element.points.length % 2 === 1) {\n      const index = Math.floor(element.points.length / 2);\n      const midPoint = LinearElementEditor.getPointGlobalCoordinates(\n        element,\n        element.points[index],\n      );\n      x = midPoint[0] - boundTextElement.width / 2;\n      y = midPoint[1] - boundTextElement.height / 2;\n    } else {\n      const index = element.points.length / 2 - 1;\n\n      let midSegmentMidpoint = editorMidPointsCache.points[index];\n      if (element.points.length === 2) {\n        midSegmentMidpoint = centerPoint(points[0], points[1]);\n      }\n      if (\n        !midSegmentMidpoint ||\n        editorMidPointsCache.version !== element.version\n      ) {\n        midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(\n          element,\n          points[index],\n          points[index + 1],\n          index + 1,\n        );\n      }\n      x = midSegmentMidpoint[0] - boundTextElement.width / 2;\n      y = midSegmentMidpoint[1] - boundTextElement.height / 2;\n    }\n    return { x, y };\n  };\n\n  static getMinMaxXYWithBoundText = (\n    element: ExcalidrawLinearElement,\n    elementBounds: [number, number, number, number],\n    boundTextElement: ExcalidrawTextElementWithContainer,\n  ): [number, number, number, number, number, number] => {\n    let [x1, y1, x2, y2] = elementBounds;\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const { x: boundTextX1, y: boundTextY1 } =\n      LinearElementEditor.getBoundTextElementPosition(\n        element,\n        boundTextElement,\n      );\n    const boundTextX2 = boundTextX1 + boundTextElement.width;\n    const boundTextY2 = boundTextY1 + boundTextElement.height;\n\n    const topLeftRotatedPoint = rotatePoint([x1, y1], [cx, cy], element.angle);\n    const topRightRotatedPoint = rotatePoint([x2, y1], [cx, cy], element.angle);\n\n    const counterRotateBoundTextTopLeft = rotatePoint(\n      [boundTextX1, boundTextY1],\n\n      [cx, cy],\n\n      -element.angle,\n    );\n    const counterRotateBoundTextTopRight = rotatePoint(\n      [boundTextX2, boundTextY1],\n\n      [cx, cy],\n\n      -element.angle,\n    );\n    const counterRotateBoundTextBottomLeft = rotatePoint(\n      [boundTextX1, boundTextY2],\n\n      [cx, cy],\n\n      -element.angle,\n    );\n    const counterRotateBoundTextBottomRight = rotatePoint(\n      [boundTextX2, boundTextY2],\n\n      [cx, cy],\n\n      -element.angle,\n    );\n\n    if (\n      topLeftRotatedPoint[0] < topRightRotatedPoint[0] &&\n      topLeftRotatedPoint[1] >= topRightRotatedPoint[1]\n    ) {\n      x1 = Math.min(x1, counterRotateBoundTextBottomLeft[0]);\n      x2 = Math.max(\n        x2,\n        Math.max(\n          counterRotateBoundTextTopRight[0],\n          counterRotateBoundTextBottomRight[0],\n        ),\n      );\n      y1 = Math.min(y1, counterRotateBoundTextTopLeft[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextBottomRight[1]);\n    } else if (\n      topLeftRotatedPoint[0] >= topRightRotatedPoint[0] &&\n      topLeftRotatedPoint[1] > topRightRotatedPoint[1]\n    ) {\n      x1 = Math.min(x1, counterRotateBoundTextBottomRight[0]);\n      x2 = Math.max(\n        x2,\n        Math.max(\n          counterRotateBoundTextTopLeft[0],\n          counterRotateBoundTextTopRight[0],\n        ),\n      );\n      y1 = Math.min(y1, counterRotateBoundTextBottomLeft[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextTopRight[1]);\n    } else if (topLeftRotatedPoint[0] >= topRightRotatedPoint[0]) {\n      x1 = Math.min(x1, counterRotateBoundTextTopRight[0]);\n      x2 = Math.max(x2, counterRotateBoundTextBottomLeft[0]);\n      y1 = Math.min(y1, counterRotateBoundTextBottomRight[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextTopLeft[1]);\n    } else if (topLeftRotatedPoint[1] <= topRightRotatedPoint[1]) {\n      x1 = Math.min(\n        x1,\n        Math.min(\n          counterRotateBoundTextTopRight[0],\n          counterRotateBoundTextTopLeft[0],\n        ),\n      );\n\n      x2 = Math.max(x2, counterRotateBoundTextBottomRight[0]);\n      y1 = Math.min(y1, counterRotateBoundTextTopRight[1]);\n      y2 = Math.max(y2, counterRotateBoundTextBottomLeft[1]);\n    }\n\n    return [x1, y1, x2, y2, cx, cy];\n  };\n\n  static getElementAbsoluteCoords = (\n    element: ExcalidrawLinearElement,\n    includeBoundText: boolean = false,\n  ): [number, number, number, number, number, number] => {\n    let coords: [number, number, number, number, number, number];\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    if (element.points.length < 2 || !getShapeForElement(element)) {\n      // XXX this is just a poor estimate and not very useful\n      const { minX, minY, maxX, maxY } = element.points.reduce(\n        (limits, [x, y]) => {\n          limits.minY = Math.min(limits.minY, y);\n          limits.minX = Math.min(limits.minX, x);\n\n          limits.maxX = Math.max(limits.maxX, x);\n          limits.maxY = Math.max(limits.maxY, y);\n\n          return limits;\n        },\n        { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n      );\n      x1 = minX + element.x;\n      y1 = minY + element.y;\n      x2 = maxX + element.x;\n      y2 = maxY + element.y;\n    } else {\n      const shape = getShapeForElement(element)!;\n\n      // first element is always the curve\n      const ops = getCurvePathOps(shape[0]);\n\n      const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n      x1 = minX + element.x;\n      y1 = minY + element.y;\n      x2 = maxX + element.x;\n      y2 = maxY + element.y;\n    }\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    coords = [x1, y1, x2, y2, cx, cy];\n\n    if (!includeBoundText) {\n      return coords;\n    }\n    const boundTextElement = getBoundTextElement(element);\n    if (boundTextElement) {\n      coords = LinearElementEditor.getMinMaxXYWithBoundText(\n        element,\n        [x1, y1, x2, y2],\n        boundTextElement,\n      );\n    }\n\n    return coords;\n  };\n}\n\nconst normalizeSelectedPoints = (\n  points: (number | null)[],\n): number[] | null => {\n  let nextPoints = [\n    ...new Set(points.filter((p) => p !== null && p !== -1)),\n  ] as number[];\n  nextPoints = nextPoints.sort((a, b) => a - b);\n  return nextPoints.length ? nextPoints : null;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}