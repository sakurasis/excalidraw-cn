{"ast":null,"code":"import _toConsumableArray from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"loop\", \"trapped\", \"onMountAutoFocus\", \"onUnmountAutoFocus\"];\nimport $45QHv$babelruntimehelpersesmextends from \"@babel/runtime/helpers/esm/extends\";\nimport { forwardRef as $45QHv$forwardRef, useState as $45QHv$useState, useRef as $45QHv$useRef, useEffect as $45QHv$useEffect, useCallback as $45QHv$useCallback, createElement as $45QHv$createElement } from \"react\";\nimport { useComposedRefs as $45QHv$useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { Primitive as $45QHv$Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef as $45QHv$useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nvar $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nvar $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nvar $d3863c46a17e8a28$var$EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\nvar $d3863c46a17e8a28$var$FOCUS_SCOPE_NAME = 'FocusScope';\nvar $d3863c46a17e8a28$export$20e40289641fbbb6 = /*#__PURE__*/$45QHv$forwardRef(function (props, forwardedRef) {\n  var _props$loop = props.loop,\n    loop = _props$loop === void 0 ? false : _props$loop,\n    _props$trapped = props.trapped,\n    trapped = _props$trapped === void 0 ? false : _props$trapped,\n    onMountAutoFocusProp = props.onMountAutoFocus,\n    onUnmountAutoFocusProp = props.onUnmountAutoFocus,\n    scopeProps = _objectWithoutProperties(props, _excluded);\n  var _$45QHv$useState = $45QHv$useState(null),\n    _$45QHv$useState2 = _slicedToArray(_$45QHv$useState, 2),\n    container1 = _$45QHv$useState2[0],\n    setContainer = _$45QHv$useState2[1];\n  var onMountAutoFocus = $45QHv$useCallbackRef(onMountAutoFocusProp);\n  var onUnmountAutoFocus = $45QHv$useCallbackRef(onUnmountAutoFocusProp);\n  var lastFocusedElementRef = $45QHv$useRef(null);\n  var composedRefs = $45QHv$useComposedRefs(forwardedRef, function (node) {\n    return setContainer(node);\n  });\n  var focusScope = $45QHv$useRef({\n    paused: false,\n    pause: function pause() {\n      this.paused = true;\n    },\n    resume: function resume() {\n      this.paused = false;\n    }\n  }).current; // Takes care of trapping focus if focus is moved outside programmatically for example\n  $45QHv$useEffect(function () {\n    if (trapped) {\n      var handleFocusIn = function handleFocusIn(event) {\n        if (focusScope.paused || !container1) return;\n        var target = event.target;\n        if (container1.contains(target)) lastFocusedElementRef.current = target;else $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n          select: true\n        });\n      };\n      var handleFocusOut = function handleFocusOut(event) {\n        if (focusScope.paused || !container1) return;\n        if (!container1.contains(event.relatedTarget)) $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n          select: true\n        });\n      };\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      return function () {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n      };\n    }\n  }, [trapped, container1, focusScope.paused]);\n  $45QHv$useEffect(function () {\n    if (container1) {\n      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);\n      var previouslyFocusedElement = document.activeElement;\n      var hasFocusedCandidate = container1.contains(previouslyFocusedElement);\n      if (!hasFocusedCandidate) {\n        var mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container1.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {\n            select: true\n          });\n          if (document.activeElement === previouslyFocusedElement) $d3863c46a17e8a28$var$focus(container1);\n        }\n      }\n      return function () {\n        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus); // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(function () {\n          var unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container1.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {\n            select: true\n          });\n          // we need to remove the listener after we `dispatchEvent`\n          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container1, onMountAutoFocus, onUnmountAutoFocus, focusScope]); // Takes care of looping focus (when tabbing whilst at the edges)\n  var handleKeyDown = $45QHv$useCallback(function (event) {\n    if (!loop && !trapped) return;\n    if (focusScope.paused) return;\n    var isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n    var focusedElement = document.activeElement;\n    if (isTabKey && focusedElement) {\n      var container = event.currentTarget;\n      var _$d3863c46a17e8a28$va = $d3863c46a17e8a28$var$getTabbableEdges(container),\n        _$d3863c46a17e8a28$va2 = _slicedToArray(_$d3863c46a17e8a28$va, 2),\n        first = _$d3863c46a17e8a28$va2[0],\n        last = _$d3863c46a17e8a28$va2[1];\n      var hasTabbableElementsInside = first && last; // we can only wrap focus if we have tabbable edges\n      if (!hasTabbableElementsInside) {\n        if (focusedElement === container) event.preventDefault();\n      } else {\n        if (!event.shiftKey && focusedElement === last) {\n          event.preventDefault();\n          if (loop) $d3863c46a17e8a28$var$focus(first, {\n            select: true\n          });\n        } else if (event.shiftKey && focusedElement === first) {\n          event.preventDefault();\n          if (loop) $d3863c46a17e8a28$var$focus(last, {\n            select: true\n          });\n        }\n      }\n    }\n  }, [loop, trapped, focusScope.paused]);\n  return /*#__PURE__*/$45QHv$createElement($45QHv$Primitive.div, $45QHv$babelruntimehelpersesmextends({\n    tabIndex: -1\n  }, scopeProps, {\n    ref: composedRefs,\n    onKeyDown: handleKeyDown\n  }));\n});\n/*#__PURE__*/\nObject.assign($d3863c46a17e8a28$export$20e40289641fbbb6, {\n  displayName: $d3863c46a17e8a28$var$FOCUS_SCOPE_NAME\n});\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/ /**\n                                                                                                     * Attempts focusing the first element in a list of candidates.\n                                                                                                     * Stops when focus has actually moved.\n                                                                                                     */\nfunction $d3863c46a17e8a28$var$focusFirst(candidates) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$select = _ref.select,\n    select = _ref$select === void 0 ? false : _ref$select;\n  var previouslyFocusedElement = document.activeElement;\n  var _iterator = _createForOfIteratorHelper(candidates),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var candidate = _step.value;\n      $d3863c46a17e8a28$var$focus(candidate, {\n        select: select\n      });\n      if (document.activeElement !== previouslyFocusedElement) return;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction $d3863c46a17e8a28$var$getTabbableEdges(container) {\n  var candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);\n  var first = $d3863c46a17e8a28$var$findVisible(candidates, container);\n  var last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);\n  return [first, last];\n}\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction $d3863c46a17e8a28$var$getTabbableCandidates(container) {\n  var nodes = [];\n  var walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: function acceptNode(node) {\n      var isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP; // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode); // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction $d3863c46a17e8a28$var$findVisible(elements, container) {\n  var _iterator2 = _createForOfIteratorHelper(elements),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var element = _step2.value;\n      // we stop checking if it's hidden at the `container` level (excluding)\n      if (!$d3863c46a17e8a28$var$isHidden(element, {\n        upTo: container\n      })) return element;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\nfunction $d3863c46a17e8a28$var$isHidden(node, _ref2) {\n  var upTo = _ref2.upTo;\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement;\n  }\n  return false;\n}\nfunction $d3863c46a17e8a28$var$isSelectableInput(element) {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\nfunction $d3863c46a17e8a28$var$focus(element) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref3$select = _ref3.select,\n    select = _ref3$select === void 0 ? false : _ref3$select;\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    var previouslyFocusedElement = document.activeElement; // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({\n      preventScroll: true\n    }); // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select) element.select();\n  }\n}\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\nvar $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();\nfunction $d3863c46a17e8a28$var$createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */var stack = [];\n  return {\n    add: function add(focusScope) {\n      // pause the currently active focus scope (at the top of the stack)\n      var activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n    remove: function remove(focusScope) {\n      var _stack$;\n      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();\n    }\n  };\n}\nfunction $d3863c46a17e8a28$var$arrayRemove(array, item) {\n  var updatedArray = _toConsumableArray(array);\n  var index = updatedArray.indexOf(item);\n  if (index !== -1) updatedArray.splice(index, 1);\n  return updatedArray;\n}\nfunction $d3863c46a17e8a28$var$removeLinks(items) {\n  return items.filter(function (item) {\n    return item.tagName !== 'A';\n  });\n}\nvar $d3863c46a17e8a28$export$be92b6f5f03c0fe9 = $d3863c46a17e8a28$export$20e40289641fbbb6;\nexport { $d3863c46a17e8a28$export$20e40289641fbbb6 as FocusScope, $d3863c46a17e8a28$export$be92b6f5f03c0fe9 as Root };","map":{"version":3,"names":["$d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT","$d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT","$d3863c46a17e8a28$var$EVENT_OPTIONS","bubbles","cancelable","$d3863c46a17e8a28$var$FOCUS_SCOPE_NAME","$d3863c46a17e8a28$export$20e40289641fbbb6","$45QHv$forwardRef","props","forwardedRef","_props$loop","loop","_props$trapped","trapped","onMountAutoFocusProp","onMountAutoFocus","onUnmountAutoFocusProp","onUnmountAutoFocus","scopeProps","_objectWithoutProperties","_excluded","_$45QHv$useState","$45QHv$useState","_$45QHv$useState2","_slicedToArray","container1","setContainer","$45QHv$useCallbackRef","lastFocusedElementRef","$45QHv$useRef","composedRefs","$45QHv$useComposedRefs","node","focusScope","paused","pause","resume","current","$45QHv$useEffect","handleFocusIn","event","target","contains","$d3863c46a17e8a28$var$focus","select","handleFocusOut","relatedTarget","document","addEventListener","removeEventListener","$d3863c46a17e8a28$var$focusScopesStack","add","previouslyFocusedElement","activeElement","hasFocusedCandidate","mountEvent","CustomEvent","dispatchEvent","defaultPrevented","$d3863c46a17e8a28$var$focusFirst","$d3863c46a17e8a28$var$removeLinks","$d3863c46a17e8a28$var$getTabbableCandidates","setTimeout","unmountEvent","body","remove","handleKeyDown","$45QHv$useCallback","isTabKey","key","altKey","ctrlKey","metaKey","focusedElement","container","currentTarget","_$d3863c46a17e8a28$va","$d3863c46a17e8a28$var$getTabbableEdges","_$d3863c46a17e8a28$va2","first","last","hasTabbableElementsInside","preventDefault","shiftKey","$45QHv$createElement","$45QHv$Primitive","div","$45QHv$babelruntimehelpersesmextends","tabIndex","ref","onKeyDown","Object","assign","displayName","focusFirst","candidates","_ref","arguments","length","undefined","_ref$select","_iterator","_createForOfIteratorHelper","_step","s","n","done","candidate","value","err","e","f","getTabbableEdges","$d3863c46a17e8a28$var$findVisible","reverse","getTabbableCandidates","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","push","currentNode","findVisible","elements","_iterator2","_step2","element","$d3863c46a17e8a28$var$isHidden","upTo","isHidden","_ref2","getComputedStyle","visibility","display","parentElement","$d3863c46a17e8a28$var$isSelectableInput","isSelectableInput","HTMLInputElement","focus","_ref3","_ref3$select","preventScroll","$d3863c46a17e8a28$var$createFocusScopesStack","createFocusScopesStack","stack","activeFocusScope","$d3863c46a17e8a28$var$arrayRemove","unshift","_stack$","arrayRemove","array","item","updatedArray","_toConsumableArray","index","indexOf","splice","removeLinks","items","filter","$d3863c46a17e8a28$export$be92b6f5f03c0fe9"],"sources":["D:\\project\\excalidraw-cn\\node_modules\\@radix-ui\\react-focus-scope\\dist\\packages\\react\\focus-scope\\src\\index.ts","D:\\project\\excalidraw-cn\\node_modules\\@radix-ui\\react-focus-scope\\dist\\packages\\react\\focus-scope\\src\\FocusScope.tsx"],"sourcesContent":["export {\n  FocusScope,\n  //\n  Root,\n} from './FocusScope';\nexport type { FocusScopeProps } from './FocusScope';\n","import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        if (!container.contains(event.relatedTarget as HTMLElement | null)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nfunction removeLinks(items: HTMLElement[]) {\n  return items.filter((item) => item.tagName !== 'A');\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}