{"ast":null,"code":"import { line, solidFillPolygon, patternFillPolygons, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math.js';\nimport { curveToBezier } from 'points-on-curve/lib/curve-to-bezier.js';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { pointsOnPath } from 'points-on-path';\nconst NOS = 'none';\nexport class RoughGenerator {\n  constructor(config) {\n    this.defaultOptions = {\n      maxRandomnessOffset: 2,\n      roughness: 1,\n      bowing: 1,\n      stroke: '#000',\n      strokeWidth: 1,\n      curveTightness: 0,\n      curveFitting: 0.95,\n      curveStepCount: 9,\n      fillStyle: 'hachure',\n      fillWeight: -1,\n      hachureAngle: -41,\n      hachureGap: -1,\n      dashOffset: -1,\n      dashGap: -1,\n      zigzagOffset: -1,\n      seed: 0,\n      disableMultiStroke: false,\n      disableMultiStrokeFill: false,\n      preserveVertices: false\n    };\n    this.config = config || {};\n    if (this.config.options) {\n      this.defaultOptions = this._o(this.config.options);\n    }\n  }\n  static newSeed() {\n    return randomSeed();\n  }\n  _o(options) {\n    return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n  }\n  _d(shape, sets, options) {\n    return {\n      shape,\n      sets: sets || [],\n      options: options || this.defaultOptions\n    };\n  }\n  line(x1, y1, x2, y2, options) {\n    const o = this._o(options);\n    return this._d('line', [line(x1, y1, x2, y2, o)], o);\n  }\n  rectangle(x, y, width, height, options) {\n    const o = this._o(options);\n    const paths = [];\n    const outline = rectangle(x, y, width, height, o);\n    if (o.fill) {\n      const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n      if (o.fillStyle === 'solid') {\n        paths.push(solidFillPolygon([points], o));\n      } else {\n        paths.push(patternFillPolygons([points], o));\n      }\n    }\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n    return this._d('rectangle', paths, o);\n  }\n  ellipse(x, y, width, height, options) {\n    const o = this._o(options);\n    const paths = [];\n    const ellipseParams = generateEllipseParams(width, height, o);\n    const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n    if (o.fill) {\n      if (o.fillStyle === 'solid') {\n        const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n        shape.type = 'fillPath';\n        paths.push(shape);\n      } else {\n        paths.push(patternFillPolygons([ellipseResponse.estimatedPoints], o));\n      }\n    }\n    if (o.stroke !== NOS) {\n      paths.push(ellipseResponse.opset);\n    }\n    return this._d('ellipse', paths, o);\n  }\n  circle(x, y, diameter, options) {\n    const ret = this.ellipse(x, y, diameter, diameter, options);\n    ret.shape = 'circle';\n    return ret;\n  }\n  linearPath(points, options) {\n    const o = this._o(options);\n    return this._d('linearPath', [linearPath(points, false, o)], o);\n  }\n  arc(x, y, width, height, start, stop) {\n    let closed = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    let options = arguments.length > 7 ? arguments[7] : undefined;\n    const o = this._o(options);\n    const paths = [];\n    const outline = arc(x, y, width, height, start, stop, closed, true, o);\n    if (closed && o.fill) {\n      if (o.fillStyle === 'solid') {\n        const fillOptions = Object.assign({}, o);\n        fillOptions.disableMultiStroke = true;\n        const shape = arc(x, y, width, height, start, stop, true, false, fillOptions);\n        shape.type = 'fillPath';\n        paths.push(shape);\n      } else {\n        paths.push(patternFillArc(x, y, width, height, start, stop, o));\n      }\n    }\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n    return this._d('arc', paths, o);\n  }\n  curve(points, options) {\n    const o = this._o(options);\n    const paths = [];\n    const outline = curve(points, o);\n    if (o.fill && o.fill !== NOS && points.length >= 3) {\n      const bcurve = curveToBezier(points);\n      const polyPoints = pointsOnBezierCurves(bcurve, 10, (1 + o.roughness) / 2);\n      if (o.fillStyle === 'solid') {\n        paths.push(solidFillPolygon([polyPoints], o));\n      } else {\n        paths.push(patternFillPolygons([polyPoints], o));\n      }\n    }\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n    return this._d('curve', paths, o);\n  }\n  polygon(points, options) {\n    const o = this._o(options);\n    const paths = [];\n    const outline = linearPath(points, true, o);\n    if (o.fill) {\n      if (o.fillStyle === 'solid') {\n        paths.push(solidFillPolygon([points], o));\n      } else {\n        paths.push(patternFillPolygons([points], o));\n      }\n    }\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n    return this._d('polygon', paths, o);\n  }\n  path(d, options) {\n    const o = this._o(options);\n    const paths = [];\n    if (!d) {\n      return this._d('path', paths, o);\n    }\n    d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n    const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n    const hasStroke = o.stroke !== NOS;\n    const simplified = !!(o.simplification && o.simplification < 1);\n    const distance = simplified ? 4 - 4 * o.simplification : (1 + o.roughness) / 2;\n    const sets = pointsOnPath(d, 1, distance);\n    if (hasFill) {\n      if (o.fillStyle === 'solid') {\n        paths.push(solidFillPolygon(sets, o));\n      } else {\n        paths.push(patternFillPolygons(sets, o));\n      }\n    }\n    if (hasStroke) {\n      if (simplified) {\n        sets.forEach(set => {\n          paths.push(linearPath(set, false, o));\n        });\n      } else {\n        paths.push(svgPath(d, o));\n      }\n    }\n    return this._d('path', paths, o);\n  }\n  opsToPath(drawing, fixedDecimals) {\n    let path = '';\n    for (const item of drawing.ops) {\n      const data = typeof fixedDecimals === 'number' && fixedDecimals >= 0 ? item.data.map(d => +d.toFixed(fixedDecimals)) : item.data;\n      switch (item.op) {\n        case 'move':\n          path += `M${data[0]} ${data[1]} `;\n          break;\n        case 'bcurveTo':\n          path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n          break;\n        case 'lineTo':\n          path += `L${data[0]} ${data[1]} `;\n          break;\n      }\n    }\n    return path.trim();\n  }\n  toPaths(drawable) {\n    const sets = drawable.sets || [];\n    const o = drawable.options || this.defaultOptions;\n    const paths = [];\n    for (const drawing of sets) {\n      let path = null;\n      switch (drawing.type) {\n        case 'path':\n          path = {\n            d: this.opsToPath(drawing),\n            stroke: o.stroke,\n            strokeWidth: o.strokeWidth,\n            fill: NOS\n          };\n          break;\n        case 'fillPath':\n          path = {\n            d: this.opsToPath(drawing),\n            stroke: NOS,\n            strokeWidth: 0,\n            fill: o.fill || NOS\n          };\n          break;\n        case 'fillSketch':\n          path = this.fillSketch(drawing, o);\n          break;\n      }\n      if (path) {\n        paths.push(path);\n      }\n    }\n    return paths;\n  }\n  fillSketch(drawing, o) {\n    let fweight = o.fillWeight;\n    if (fweight < 0) {\n      fweight = o.strokeWidth / 2;\n    }\n    return {\n      d: this.opsToPath(drawing),\n      stroke: o.fill || NOS,\n      strokeWidth: fweight,\n      fill: NOS\n    };\n  }\n}","map":{"version":3,"names":["line","solidFillPolygon","patternFillPolygons","rectangle","ellipseWithParams","generateEllipseParams","linearPath","arc","patternFillArc","curve","svgPath","randomSeed","curveToBezier","pointsOnBezierCurves","pointsOnPath","NOS","RoughGenerator","constructor","config","defaultOptions","maxRandomnessOffset","roughness","bowing","stroke","strokeWidth","curveTightness","curveFitting","curveStepCount","fillStyle","fillWeight","hachureAngle","hachureGap","dashOffset","dashGap","zigzagOffset","seed","disableMultiStroke","disableMultiStrokeFill","preserveVertices","options","_o","newSeed","Object","assign","_d","shape","sets","x1","y1","x2","y2","o","x","y","width","height","paths","outline","fill","points","push","ellipse","ellipseParams","ellipseResponse","opset","type","estimatedPoints","circle","diameter","ret","start","stop","closed","arguments","length","undefined","fillOptions","bcurve","polyPoints","polygon","path","d","replace","hasFill","hasStroke","simplified","simplification","distance","forEach","set","opsToPath","drawing","fixedDecimals","item","ops","data","map","toFixed","op","trim","toPaths","drawable","fillSketch","fweight"],"sources":["D:/project/excalidraw-cn/node_modules/roughjs/bin/generator.js"],"sourcesContent":["import { line, solidFillPolygon, patternFillPolygons, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math.js';\nimport { curveToBezier } from 'points-on-curve/lib/curve-to-bezier.js';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { pointsOnPath } from 'points-on-path';\nconst NOS = 'none';\nexport class RoughGenerator {\n    constructor(config) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            disableMultiStroke: false,\n            disableMultiStrokeFill: false,\n            preserveVertices: false,\n        };\n        this.config = config || {};\n        if (this.config.options) {\n            this.defaultOptions = this._o(this.config.options);\n        }\n    }\n    static newSeed() {\n        return randomSeed();\n    }\n    _o(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _d(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._o(options);\n        return this._d('line', [line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = rectangle(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const ellipseParams = generateEllipseParams(width, height, o);\n        const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillPolygons([ellipseResponse.estimatedPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._d('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._o(options);\n        return this._d('linearPath', [linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = arc(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const fillOptions = Object.assign({}, o);\n                fillOptions.disableMultiStroke = true;\n                const shape = arc(x, y, width, height, start, stop, true, false, fillOptions);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = curve(points, o);\n        if (o.fill && o.fill !== NOS && points.length >= 3) {\n            const bcurve = curveToBezier(points);\n            const polyPoints = pointsOnBezierCurves(bcurve, 10, (1 + o.roughness) / 2);\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([polyPoints], o));\n            }\n            else {\n                paths.push(patternFillPolygons([polyPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('curve', paths, o);\n    }\n    polygon(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = linearPath(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._o(options);\n        const paths = [];\n        if (!d) {\n            return this._d('path', paths, o);\n        }\n        d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n        const hasStroke = o.stroke !== NOS;\n        const simplified = !!(o.simplification && (o.simplification < 1));\n        const distance = simplified ? (4 - 4 * (o.simplification)) : ((1 + o.roughness) / 2);\n        const sets = pointsOnPath(d, 1, distance);\n        if (hasFill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon(sets, o));\n            }\n            else {\n                paths.push(patternFillPolygons(sets, o));\n            }\n        }\n        if (hasStroke) {\n            if (simplified) {\n                sets.forEach((set) => {\n                    paths.push(linearPath(set, false, o));\n                });\n            }\n            else {\n                paths.push(svgPath(d, o));\n            }\n        }\n        return this._d('path', paths, o);\n    }\n    opsToPath(drawing, fixedDecimals) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS,\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS,\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS,\n        };\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}