{"ast":null,"code":"/** Deduplication filter */\nvar Dedupe = /** @class */function () {\n  function Dedupe() {\n    /**\n     * @inheritDoc\n     */\n    this.name = Dedupe.id;\n  }\n  /**\n   * @inheritDoc\n   */\n  Dedupe.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {\n    addGlobalEventProcessor(function (currentEvent) {\n      var self = getCurrentHub().getIntegration(Dedupe);\n      if (self) {\n        // Juuust in case something goes wrong\n        try {\n          if (self._shouldDropEvent(currentEvent, self._previousEvent)) {\n            return null;\n          }\n        } catch (_oO) {\n          return self._previousEvent = currentEvent;\n        }\n        return self._previousEvent = currentEvent;\n      }\n      return currentEvent;\n    });\n  };\n  /** JSDoc */\n  Dedupe.prototype._shouldDropEvent = function (currentEvent, previousEvent) {\n    if (!previousEvent) {\n      return false;\n    }\n    if (this._isSameMessageEvent(currentEvent, previousEvent)) {\n      return true;\n    }\n    if (this._isSameExceptionEvent(currentEvent, previousEvent)) {\n      return true;\n    }\n    return false;\n  };\n  /** JSDoc */\n  Dedupe.prototype._isSameMessageEvent = function (currentEvent, previousEvent) {\n    var currentMessage = currentEvent.message;\n    var previousMessage = previousEvent.message;\n    // If neither event has a message property, they were both exceptions, so bail out\n    if (!currentMessage && !previousMessage) {\n      return false;\n    }\n    // If only one event has a stacktrace, but not the other one, they are not the same\n    if (currentMessage && !previousMessage || !currentMessage && previousMessage) {\n      return false;\n    }\n    if (currentMessage !== previousMessage) {\n      return false;\n    }\n    if (!this._isSameFingerprint(currentEvent, previousEvent)) {\n      return false;\n    }\n    if (!this._isSameStacktrace(currentEvent, previousEvent)) {\n      return false;\n    }\n    return true;\n  };\n  /** JSDoc */\n  Dedupe.prototype._getFramesFromEvent = function (event) {\n    var exception = event.exception;\n    if (exception) {\n      try {\n        // @ts-ignore Object could be undefined\n        return exception.values[0].stacktrace.frames;\n      } catch (_oO) {\n        return undefined;\n      }\n    } else if (event.stacktrace) {\n      return event.stacktrace.frames;\n    }\n    return undefined;\n  };\n  /** JSDoc */\n  Dedupe.prototype._isSameStacktrace = function (currentEvent, previousEvent) {\n    var currentFrames = this._getFramesFromEvent(currentEvent);\n    var previousFrames = this._getFramesFromEvent(previousEvent);\n    // If neither event has a stacktrace, they are assumed to be the same\n    if (!currentFrames && !previousFrames) {\n      return true;\n    }\n    // If only one event has a stacktrace, but not the other one, they are not the same\n    if (currentFrames && !previousFrames || !currentFrames && previousFrames) {\n      return false;\n    }\n    currentFrames = currentFrames;\n    previousFrames = previousFrames;\n    // If number of frames differ, they are not the same\n    if (previousFrames.length !== currentFrames.length) {\n      return false;\n    }\n    // Otherwise, compare the two\n    for (var i = 0; i < previousFrames.length; i++) {\n      var frameA = previousFrames[i];\n      var frameB = currentFrames[i];\n      if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /** JSDoc */\n  Dedupe.prototype._getExceptionFromEvent = function (event) {\n    return event.exception && event.exception.values && event.exception.values[0];\n  };\n  /** JSDoc */\n  Dedupe.prototype._isSameExceptionEvent = function (currentEvent, previousEvent) {\n    var previousException = this._getExceptionFromEvent(previousEvent);\n    var currentException = this._getExceptionFromEvent(currentEvent);\n    if (!previousException || !currentException) {\n      return false;\n    }\n    if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n      return false;\n    }\n    if (!this._isSameFingerprint(currentEvent, previousEvent)) {\n      return false;\n    }\n    if (!this._isSameStacktrace(currentEvent, previousEvent)) {\n      return false;\n    }\n    return true;\n  };\n  /** JSDoc */\n  Dedupe.prototype._isSameFingerprint = function (currentEvent, previousEvent) {\n    var currentFingerprint = currentEvent.fingerprint;\n    var previousFingerprint = previousEvent.fingerprint;\n    // If neither event has a fingerprint, they are assumed to be the same\n    if (!currentFingerprint && !previousFingerprint) {\n      return true;\n    }\n    // If only one event has a fingerprint, but not the other one, they are not the same\n    if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {\n      return false;\n    }\n    currentFingerprint = currentFingerprint;\n    previousFingerprint = previousFingerprint;\n    // Otherwise, compare the two\n    try {\n      return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n    } catch (_oO) {\n      return false;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  Dedupe.id = 'Dedupe';\n  return Dedupe;\n}();\nexport { Dedupe };","map":{"version":3,"names":["Dedupe","name","id","prototype","setupOnce","addGlobalEventProcessor","getCurrentHub","currentEvent","self","getIntegration","_shouldDropEvent","_previousEvent","_oO","previousEvent","_isSameMessageEvent","_isSameExceptionEvent","currentMessage","message","previousMessage","_isSameFingerprint","_isSameStacktrace","_getFramesFromEvent","event","exception","values","stacktrace","frames","undefined","currentFrames","previousFrames","length","i","frameA","frameB","filename","lineno","colno","function","_getExceptionFromEvent","previousException","currentException","type","value","currentFingerprint","fingerprint","previousFingerprint","join"],"sources":["D:\\project\\excalidraw-cn\\node_modules\\@sentry\\integrations\\src\\dedupe.ts"],"sourcesContent":["import { Event, EventProcessor, Exception, Hub, Integration, StackFrame } from '@sentry/types';\n\n/** Deduplication filter */\nexport class Dedupe implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Dedupe';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Dedupe.id;\n\n  /**\n   * @inheritDoc\n   */\n  private _previousEvent?: Event;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    addGlobalEventProcessor((currentEvent: Event) => {\n      const self = getCurrentHub().getIntegration(Dedupe);\n      if (self) {\n        // Juuust in case something goes wrong\n        try {\n          if (self._shouldDropEvent(currentEvent, self._previousEvent)) {\n            return null;\n          }\n        } catch (_oO) {\n          return (self._previousEvent = currentEvent);\n        }\n\n        return (self._previousEvent = currentEvent);\n      }\n      return currentEvent;\n    });\n  }\n\n  /** JSDoc */\n  private _shouldDropEvent(currentEvent: Event, previousEvent?: Event): boolean {\n    if (!previousEvent) {\n      return false;\n    }\n\n    if (this._isSameMessageEvent(currentEvent, previousEvent)) {\n      return true;\n    }\n\n    if (this._isSameExceptionEvent(currentEvent, previousEvent)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /** JSDoc */\n  private _isSameMessageEvent(currentEvent: Event, previousEvent: Event): boolean {\n    const currentMessage = currentEvent.message;\n    const previousMessage = previousEvent.message;\n\n    // If neither event has a message property, they were both exceptions, so bail out\n    if (!currentMessage && !previousMessage) {\n      return false;\n    }\n\n    // If only one event has a stacktrace, but not the other one, they are not the same\n    if ((currentMessage && !previousMessage) || (!currentMessage && previousMessage)) {\n      return false;\n    }\n\n    if (currentMessage !== previousMessage) {\n      return false;\n    }\n\n    if (!this._isSameFingerprint(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    if (!this._isSameStacktrace(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /** JSDoc */\n  private _getFramesFromEvent(event: Event): StackFrame[] | undefined {\n    const exception = event.exception;\n\n    if (exception) {\n      try {\n        // @ts-ignore Object could be undefined\n        return exception.values[0].stacktrace.frames;\n      } catch (_oO) {\n        return undefined;\n      }\n    } else if (event.stacktrace) {\n      return event.stacktrace.frames;\n    }\n    return undefined;\n  }\n\n  /** JSDoc */\n  private _isSameStacktrace(currentEvent: Event, previousEvent: Event): boolean {\n    let currentFrames = this._getFramesFromEvent(currentEvent);\n    let previousFrames = this._getFramesFromEvent(previousEvent);\n\n    // If neither event has a stacktrace, they are assumed to be the same\n    if (!currentFrames && !previousFrames) {\n      return true;\n    }\n\n    // If only one event has a stacktrace, but not the other one, they are not the same\n    if ((currentFrames && !previousFrames) || (!currentFrames && previousFrames)) {\n      return false;\n    }\n\n    currentFrames = currentFrames as StackFrame[];\n    previousFrames = previousFrames as StackFrame[];\n\n    // If number of frames differ, they are not the same\n    if (previousFrames.length !== currentFrames.length) {\n      return false;\n    }\n\n    // Otherwise, compare the two\n    for (let i = 0; i < previousFrames.length; i++) {\n      const frameA = previousFrames[i];\n      const frameB = currentFrames[i];\n\n      if (\n        frameA.filename !== frameB.filename ||\n        frameA.lineno !== frameB.lineno ||\n        frameA.colno !== frameB.colno ||\n        frameA.function !== frameB.function\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /** JSDoc */\n  private _getExceptionFromEvent(event: Event): Exception | undefined {\n    return event.exception && event.exception.values && event.exception.values[0];\n  }\n\n  /** JSDoc */\n  private _isSameExceptionEvent(currentEvent: Event, previousEvent: Event): boolean {\n    const previousException = this._getExceptionFromEvent(previousEvent);\n    const currentException = this._getExceptionFromEvent(currentEvent);\n\n    if (!previousException || !currentException) {\n      return false;\n    }\n\n    if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n      return false;\n    }\n\n    if (!this._isSameFingerprint(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    if (!this._isSameStacktrace(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /** JSDoc */\n  private _isSameFingerprint(currentEvent: Event, previousEvent: Event): boolean {\n    let currentFingerprint = currentEvent.fingerprint;\n    let previousFingerprint = previousEvent.fingerprint;\n\n    // If neither event has a fingerprint, they are assumed to be the same\n    if (!currentFingerprint && !previousFingerprint) {\n      return true;\n    }\n\n    // If only one event has a fingerprint, but not the other one, they are not the same\n    if ((currentFingerprint && !previousFingerprint) || (!currentFingerprint && previousFingerprint)) {\n      return false;\n    }\n\n    currentFingerprint = currentFingerprint as string[];\n    previousFingerprint = previousFingerprint as string[];\n\n    // Otherwise, compare the two\n    try {\n      return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n    } catch (_oO) {\n      return false;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}