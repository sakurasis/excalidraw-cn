{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { pointsOnBezierCurves, simplify } from 'points-on-curve';\nimport { parsePath, absolutize, normalize } from 'path-data-parser';\nexport function pointsOnPath(path, tolerance, distance) {\n  var segments = parsePath(path);\n  var normalized = normalize(absolutize(segments));\n  var sets = [];\n  var currentPoints = [];\n  var start = [0, 0];\n  var pendingCurve = [];\n  var appendPendingCurve = function appendPendingCurve() {\n    if (pendingCurve.length >= 4) {\n      var _currentPoints;\n      (_currentPoints = currentPoints).push.apply(_currentPoints, _toConsumableArray(pointsOnBezierCurves(pendingCurve, tolerance)));\n    }\n    pendingCurve = [];\n  };\n  var appendPendingPoints = function appendPendingPoints() {\n    appendPendingCurve();\n    if (currentPoints.length) {\n      sets.push(currentPoints);\n      currentPoints = [];\n    }\n  };\n  var _iterator = _createForOfIteratorHelper(normalized),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n        key = _step$value.key,\n        data = _step$value.data;\n      switch (key) {\n        case 'M':\n          appendPendingPoints();\n          start = [data[0], data[1]];\n          currentPoints.push(start);\n          break;\n        case 'L':\n          appendPendingCurve();\n          currentPoints.push([data[0], data[1]]);\n          break;\n        case 'C':\n          if (!pendingCurve.length) {\n            var lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;\n            pendingCurve.push([lastPoint[0], lastPoint[1]]);\n          }\n          pendingCurve.push([data[0], data[1]]);\n          pendingCurve.push([data[2], data[3]]);\n          pendingCurve.push([data[4], data[5]]);\n          break;\n        case 'Z':\n          appendPendingCurve();\n          currentPoints.push([start[0], start[1]]);\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  appendPendingPoints();\n  if (!distance) {\n    return sets;\n  }\n  var out = [];\n  for (var _i = 0, _sets = sets; _i < _sets.length; _i++) {\n    var set = _sets[_i];\n    var simplifiedSet = simplify(set, distance);\n    if (simplifiedSet.length) {\n      out.push(simplifiedSet);\n    }\n  }\n  return out;\n}","map":{"version":3,"names":["pointsOnBezierCurves","simplify","parsePath","absolutize","normalize","pointsOnPath","path","tolerance","distance","segments","normalized","sets","currentPoints","start","pendingCurve","appendPendingCurve","length","_currentPoints","push","apply","_toConsumableArray","appendPendingPoints","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","value","key","data","lastPoint","err","e","f","out","_i","_sets","set","simplifiedSet"],"sources":["D:/project/excalidraw-cn/node_modules/points-on-path/lib/index.js"],"sourcesContent":["import { pointsOnBezierCurves, simplify } from 'points-on-curve';\nimport { parsePath, absolutize, normalize } from 'path-data-parser';\nexport function pointsOnPath(path, tolerance, distance) {\n    const segments = parsePath(path);\n    const normalized = normalize(absolutize(segments));\n    const sets = [];\n    let currentPoints = [];\n    let start = [0, 0];\n    let pendingCurve = [];\n    const appendPendingCurve = () => {\n        if (pendingCurve.length >= 4) {\n            currentPoints.push(...pointsOnBezierCurves(pendingCurve, tolerance));\n        }\n        pendingCurve = [];\n    };\n    const appendPendingPoints = () => {\n        appendPendingCurve();\n        if (currentPoints.length) {\n            sets.push(currentPoints);\n            currentPoints = [];\n        }\n    };\n    for (const { key, data } of normalized) {\n        switch (key) {\n            case 'M':\n                appendPendingPoints();\n                start = [data[0], data[1]];\n                currentPoints.push(start);\n                break;\n            case 'L':\n                appendPendingCurve();\n                currentPoints.push([data[0], data[1]]);\n                break;\n            case 'C':\n                if (!pendingCurve.length) {\n                    const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;\n                    pendingCurve.push([lastPoint[0], lastPoint[1]]);\n                }\n                pendingCurve.push([data[0], data[1]]);\n                pendingCurve.push([data[2], data[3]]);\n                pendingCurve.push([data[4], data[5]]);\n                break;\n            case 'Z':\n                appendPendingCurve();\n                currentPoints.push([start[0], start[1]]);\n                break;\n        }\n    }\n    appendPendingPoints();\n    if (!distance) {\n        return sets;\n    }\n    const out = [];\n    for (const set of sets) {\n        const simplifiedSet = simplify(set, distance);\n        if (simplifiedSet.length) {\n            out.push(simplifiedSet);\n        }\n    }\n    return out;\n}\n"],"mappings":";;AAAA,SAASA,oBAAoB,EAAEC,QAAQ,QAAQ,iBAAiB;AAChE,SAASC,SAAS,EAAEC,UAAU,EAAEC,SAAS,QAAQ,kBAAkB;AACnE,OAAO,SAASC,YAAYA,CAACC,IAAI,EAAEC,SAAS,EAAEC,QAAQ,EAAE;EACpD,IAAMC,QAAQ,GAAGP,SAAS,CAACI,IAAI,CAAC;EAChC,IAAMI,UAAU,GAAGN,SAAS,CAACD,UAAU,CAACM,QAAQ,CAAC,CAAC;EAClD,IAAME,IAAI,GAAG,EAAE;EACf,IAAIC,aAAa,GAAG,EAAE;EACtB,IAAIC,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;EAClB,IAAIC,YAAY,GAAG,EAAE;EACrB,IAAMC,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAA,EAAS;IAC7B,IAAID,YAAY,CAACE,MAAM,IAAI,CAAC,EAAE;MAAA,IAAAC,cAAA;MAC1B,CAAAA,cAAA,GAAAL,aAAa,EAACM,IAAI,CAAAC,KAAA,CAAAF,cAAA,EAAAG,kBAAA,CAAIpB,oBAAoB,CAACc,YAAY,EAAEP,SAAS,CAAC,EAAC;IACxE;IACAO,YAAY,GAAG,EAAE;EACrB,CAAC;EACD,IAAMO,mBAAmB,GAAG,SAAtBA,mBAAmBA,CAAA,EAAS;IAC9BN,kBAAkB,EAAE;IACpB,IAAIH,aAAa,CAACI,MAAM,EAAE;MACtBL,IAAI,CAACO,IAAI,CAACN,aAAa,CAAC;MACxBA,aAAa,GAAG,EAAE;IACtB;EACJ,CAAC;EAAC,IAAAU,SAAA,GAAAC,0BAAA,CAC0Bb,UAAU;IAAAc,KAAA;EAAA;IAAtC,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAwC;MAAA,IAAAC,WAAA,GAAAJ,KAAA,CAAAK,KAAA;QAA3BC,GAAG,GAAAF,WAAA,CAAHE,GAAG;QAAEC,IAAI,GAAAH,WAAA,CAAJG,IAAI;MAClB,QAAQD,GAAG;QACP,KAAK,GAAG;UACJT,mBAAmB,EAAE;UACrBR,KAAK,GAAG,CAACkB,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;UAC1BnB,aAAa,CAACM,IAAI,CAACL,KAAK,CAAC;UACzB;QACJ,KAAK,GAAG;UACJE,kBAAkB,EAAE;UACpBH,aAAa,CAACM,IAAI,CAAC,CAACa,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;UACtC;QACJ,KAAK,GAAG;UACJ,IAAI,CAACjB,YAAY,CAACE,MAAM,EAAE;YACtB,IAAMgB,SAAS,GAAGpB,aAAa,CAACI,MAAM,GAAGJ,aAAa,CAACA,aAAa,CAACI,MAAM,GAAG,CAAC,CAAC,GAAGH,KAAK;YACxFC,YAAY,CAACI,IAAI,CAAC,CAACc,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;UACnD;UACAlB,YAAY,CAACI,IAAI,CAAC,CAACa,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;UACrCjB,YAAY,CAACI,IAAI,CAAC,CAACa,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;UACrCjB,YAAY,CAACI,IAAI,CAAC,CAACa,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;UACrC;QACJ,KAAK,GAAG;UACJhB,kBAAkB,EAAE;UACpBH,aAAa,CAACM,IAAI,CAAC,CAACL,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;UACxC;MAAM;IAElB;EAAC,SAAAoB,GAAA;IAAAX,SAAA,CAAAY,CAAA,CAAAD,GAAA;EAAA;IAAAX,SAAA,CAAAa,CAAA;EAAA;EACDd,mBAAmB,EAAE;EACrB,IAAI,CAACb,QAAQ,EAAE;IACX,OAAOG,IAAI;EACf;EACA,IAAMyB,GAAG,GAAG,EAAE;EACd,SAAAC,EAAA,MAAAC,KAAA,GAAkB3B,IAAI,EAAA0B,EAAA,GAAAC,KAAA,CAAAtB,MAAA,EAAAqB,EAAA,IAAE;IAAnB,IAAME,GAAG,GAAAD,KAAA,CAAAD,EAAA;IACV,IAAMG,aAAa,GAAGvC,QAAQ,CAACsC,GAAG,EAAE/B,QAAQ,CAAC;IAC7C,IAAIgC,aAAa,CAACxB,MAAM,EAAE;MACtBoB,GAAG,CAAClB,IAAI,CAACsB,aAAa,CAAC;IAC3B;EACJ;EACA,OAAOJ,GAAG;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}