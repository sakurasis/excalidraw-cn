{"ast":null,"code":"import { ImportedDataState } from \"./types\";\nimport { getNonDeletedElements, getNormalizedDimensions, isInvisiblySmallElement, refreshTextDimensions } from \"../element\";\nimport { isTextElement, isUsingAdaptiveRadius } from \"../element/typeChecks\";\nimport { randomId } from \"../random\";\nimport { DEFAULT_FONT_FAMILY, DEFAULT_TEXT_ALIGN, DEFAULT_VERTICAL_ALIGN, PRECEDING_ELEMENT_KEY, FONT_FAMILY, ROUNDNESS, DEFAULT_SIDEBAR } from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { bumpVersion } from \"../element/mutateElement\";\nimport { getFontString, getUpdatedTimestamp, updateActiveTool } from \"../utils\";\nimport { arrayToMap } from \"../utils\";\nimport { detectLineHeight, getDefaultLineHeight, measureBaseline } from \"../element/textElement\";\nimport { COLOR_PALETTE } from \"../colors\";\nimport { normalizeLink } from \"./url\";\nexport const AllowedExcalidrawActiveTools = {\n  selection: true,\n  text: true,\n  rectangle: true,\n  diamond: true,\n  ellipse: true,\n  line: true,\n  image: true,\n  arrow: true,\n  freedraw: true,\n  eraser: false,\n  custom: true,\n  frame: true,\n  hand: true\n};\nconst getFontFamilyByName = fontFamilyName => {\n  if (Object.keys(FONT_FAMILY).includes(fontFamilyName)) {\n    return FONT_FAMILY[fontFamilyName];\n  }\n  return DEFAULT_FONT_FAMILY;\n};\nconst restoreElementWithProperties = (element, extra) => {\n  var _element$versionNonce, _element$isDeleted, _element$strokeStyle, _element$roughness, _ref, _extra$x, _ref2, _extra$y, _element$seed, _element$groupIds, _element$frameId, _element$boundElement, _element$updated, _element$locked;\n  const base = {\n    type: extra.type || element.type,\n    // all elements must have version > 0 so getSceneVersion() will pick up\n    // newly added elements\n    version: element.version || 1,\n    versionNonce: (_element$versionNonce = element.versionNonce) !== null && _element$versionNonce !== void 0 ? _element$versionNonce : 0,\n    isDeleted: (_element$isDeleted = element.isDeleted) !== null && _element$isDeleted !== void 0 ? _element$isDeleted : false,\n    id: element.id || randomId(),\n    fillStyle: element.fillStyle || \"hachure\",\n    strokeWidth: element.strokeWidth || 1,\n    strokeStyle: (_element$strokeStyle = element.strokeStyle) !== null && _element$strokeStyle !== void 0 ? _element$strokeStyle : \"solid\",\n    roughness: (_element$roughness = element.roughness) !== null && _element$roughness !== void 0 ? _element$roughness : 1,\n    opacity: element.opacity == null ? 100 : element.opacity,\n    angle: element.angle || 0,\n    x: (_ref = (_extra$x = extra.x) !== null && _extra$x !== void 0 ? _extra$x : element.x) !== null && _ref !== void 0 ? _ref : 0,\n    y: (_ref2 = (_extra$y = extra.y) !== null && _extra$y !== void 0 ? _extra$y : element.y) !== null && _ref2 !== void 0 ? _ref2 : 0,\n    strokeColor: element.strokeColor || COLOR_PALETTE.black,\n    backgroundColor: element.backgroundColor || COLOR_PALETTE.transparent,\n    width: element.width || 0,\n    height: element.height || 0,\n    seed: (_element$seed = element.seed) !== null && _element$seed !== void 0 ? _element$seed : 1,\n    groupIds: (_element$groupIds = element.groupIds) !== null && _element$groupIds !== void 0 ? _element$groupIds : [],\n    frameId: (_element$frameId = element.frameId) !== null && _element$frameId !== void 0 ? _element$frameId : null,\n    roundness: element.roundness ? element.roundness : element.strokeSharpness === \"round\" ? {\n      // for old elements that would now use adaptive radius algo,\n      // use legacy algo instead\n      type: isUsingAdaptiveRadius(element.type) ? ROUNDNESS.LEGACY : ROUNDNESS.PROPORTIONAL_RADIUS\n    } : null,\n    boundElements: element.boundElementIds ? element.boundElementIds.map(id => ({\n      type: \"arrow\",\n      id\n    })) : (_element$boundElement = element.boundElements) !== null && _element$boundElement !== void 0 ? _element$boundElement : [],\n    updated: (_element$updated = element.updated) !== null && _element$updated !== void 0 ? _element$updated : getUpdatedTimestamp(),\n    link: element.link ? normalizeLink(element.link) : null,\n    locked: (_element$locked = element.locked) !== null && _element$locked !== void 0 ? _element$locked : false\n  };\n  if (\"customData\" in element) {\n    base.customData = element.customData;\n  }\n  if (PRECEDING_ELEMENT_KEY in element) {\n    base[PRECEDING_ELEMENT_KEY] = element[PRECEDING_ELEMENT_KEY];\n  }\n  return {\n    ...base,\n    ...getNormalizedDimensions(base),\n    ...extra\n  };\n};\nconst restoreElement = function (element) {\n  var _element$text, _element$containerId, _element$name;\n  let refreshDimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  switch (element.type) {\n    case \"text\":\n      let fontSize = element.fontSize;\n      let fontFamily = element.fontFamily;\n      if (\"font\" in element) {\n        const [fontPx, _fontFamily] = element.font.split(\" \");\n        fontSize = parseFloat(fontPx);\n        fontFamily = getFontFamilyByName(_fontFamily);\n      }\n      const text = (_element$text = element.text) !== null && _element$text !== void 0 ? _element$text : \"\";\n\n      // line-height might not be specified either when creating elements\n      // programmatically, or when importing old diagrams.\n      // For the latter we want to detect the original line height which\n      // will likely differ from our per-font fixed line height we now use,\n      // to maintain backward compatibility.\n      const lineHeight = element.lineHeight || (element.height ?\n      // detect line-height from current element height and font-size\n      detectLineHeight(element) :\n      // no element height likely means programmatic use, so default\n      // to a fixed line height\n      getDefaultLineHeight(element.fontFamily));\n      const baseline = measureBaseline(element.text, getFontString(element), lineHeight);\n      element = restoreElementWithProperties(element, {\n        fontSize,\n        fontFamily,\n        text,\n        textAlign: element.textAlign || DEFAULT_TEXT_ALIGN,\n        verticalAlign: element.verticalAlign || DEFAULT_VERTICAL_ALIGN,\n        containerId: (_element$containerId = element.containerId) !== null && _element$containerId !== void 0 ? _element$containerId : null,\n        originalText: element.originalText || text,\n        lineHeight,\n        baseline\n      });\n      if (refreshDimensions) {\n        element = {\n          ...element,\n          ...refreshTextDimensions(element)\n        };\n      }\n      return element;\n    case \"freedraw\":\n      {\n        return restoreElementWithProperties(element, {\n          points: element.points,\n          lastCommittedPoint: null,\n          simulatePressure: element.simulatePressure,\n          pressures: element.pressures\n        });\n      }\n    case \"image\":\n      return restoreElementWithProperties(element, {\n        status: element.status || \"pending\",\n        fileId: element.fileId,\n        scale: element.scale || [1, 1]\n      });\n    case \"line\":\n    // @ts-ignore LEGACY type\n    // eslint-disable-next-line no-fallthrough\n    case \"draw\":\n    case \"arrow\":\n      {\n        const {\n          startArrowhead = null,\n          endArrowhead = element.type === \"arrow\" ? \"arrow\" : null\n        } = element;\n        let x = element.x;\n        let y = element.y;\n        let points =\n        // migrate old arrow model to new one\n        !Array.isArray(element.points) || element.points.length < 2 ? [[0, 0], [element.width, element.height]] : element.points;\n        if (points[0][0] !== 0 || points[0][1] !== 0) {\n          ({\n            points,\n            x,\n            y\n          } = LinearElementEditor.getNormalizedPoints(element));\n        }\n        return restoreElementWithProperties(element, {\n          type: element.type === \"draw\" ? \"line\" : element.type,\n          startBinding: element.startBinding,\n          endBinding: element.endBinding,\n          lastCommittedPoint: null,\n          startArrowhead,\n          endArrowhead,\n          points,\n          x,\n          y\n        });\n      }\n\n    // generic elements\n    case \"ellipse\":\n      return restoreElementWithProperties(element, {});\n    case \"rectangle\":\n      return restoreElementWithProperties(element, {});\n    case \"diamond\":\n      return restoreElementWithProperties(element, {});\n    case \"frame\":\n      return restoreElementWithProperties(element, {\n        name: (_element$name = element.name) !== null && _element$name !== void 0 ? _element$name : null\n      });\n\n    // Don't use default case so as to catch a missing an element type case.\n    // We also don't want to throw, but instead return void so we filter\n    // out these unsupported elements from the restored array.\n  }\n};\n\n/**\n * Repairs contaienr element's boundElements array by removing duplicates and\n * fixing containerId of bound elements if not present. Also removes any\n * bound elements that do not exist in the elements array.\n *\n * NOTE mutates elements.\n */\nconst repairContainerElement = (container, elementsMap) => {\n  if (container.boundElements) {\n    // copy because we're not cloning on restore, and we don't want to mutate upstream\n    const boundElements = container.boundElements.slice();\n\n    // dedupe bindings & fix boundElement.containerId if not set already\n    const boundIds = new Set();\n    container.boundElements = boundElements.reduce((acc, binding) => {\n      const boundElement = elementsMap.get(binding.id);\n      if (boundElement && !boundIds.has(binding.id)) {\n        boundIds.add(binding.id);\n        if (boundElement.isDeleted) {\n          return acc;\n        }\n        acc.push(binding);\n        if (isTextElement(boundElement) &&\n        // being slightly conservative here, preserving existing containerId\n        // if defined, lest boundElements is stale\n        !boundElement.containerId) {\n          boundElement.containerId = container.id;\n        }\n      }\n      return acc;\n    }, []);\n  }\n};\n\n/**\n * Repairs target bound element's container's boundElements array,\n * or removes contaienrId if container does not exist.\n *\n * NOTE mutates elements.\n */\nconst repairBoundElement = (boundElement, elementsMap) => {\n  const container = boundElement.containerId ? elementsMap.get(boundElement.containerId) : null;\n  if (!container) {\n    boundElement.containerId = null;\n    return;\n  }\n  if (boundElement.isDeleted) {\n    return;\n  }\n  if (container.boundElements && !container.boundElements.find(binding => binding.id === boundElement.id)) {\n    // copy because we're not cloning on restore, and we don't want to mutate upstream\n    const boundElements = (container.boundElements || (container.boundElements = [])).slice();\n    boundElements.push({\n      type: \"text\",\n      id: boundElement.id\n    });\n    container.boundElements = boundElements;\n  }\n};\n\n/**\n * Remove an element's frameId if its containing frame is non-existent\n *\n * NOTE mutates elements.\n */\nconst repairFrameMembership = (element, elementsMap) => {\n  if (element.frameId) {\n    const containingFrame = elementsMap.get(element.frameId);\n    if (!containingFrame) {\n      element.frameId = null;\n    }\n  }\n};\nexport const restoreElements = (elements, localElements, opts) => {\n  // used to detect duplicate top-level element ids\n  const existingIds = new Set();\n  const localElementsMap = localElements ? arrayToMap(localElements) : null;\n  const restoredElements = (elements || []).reduce((elements, element) => {\n    // filtering out selection, which is legacy, no longer kept in elements,\n    // and causing issues if retained\n    if (element.type !== \"selection\" && !isInvisiblySmallElement(element)) {\n      let migratedElement = restoreElement(element, opts === null || opts === void 0 ? void 0 : opts.refreshDimensions);\n      if (migratedElement) {\n        const localElement = localElementsMap === null || localElementsMap === void 0 ? void 0 : localElementsMap.get(element.id);\n        if (localElement && localElement.version > migratedElement.version) {\n          migratedElement = bumpVersion(migratedElement, localElement.version);\n        }\n        if (existingIds.has(migratedElement.id)) {\n          migratedElement = {\n            ...migratedElement,\n            id: randomId()\n          };\n        }\n        existingIds.add(migratedElement.id);\n        elements.push(migratedElement);\n      }\n    }\n    return elements;\n  }, []);\n  if (!(opts !== null && opts !== void 0 && opts.repairBindings)) {\n    return restoredElements;\n  }\n\n  // repair binding. Mutates elements.\n  const restoredElementsMap = arrayToMap(restoredElements);\n  for (const element of restoredElements) {\n    if (element.frameId) {\n      repairFrameMembership(element, restoredElementsMap);\n    }\n    if (isTextElement(element) && element.containerId) {\n      repairBoundElement(element, restoredElementsMap);\n    } else if (element.boundElements) {\n      repairContainerElement(element, restoredElementsMap);\n    }\n  }\n  return restoredElements;\n};\nconst coalesceAppStateValue = (key, appState, defaultAppState) => {\n  const value = appState[key];\n  // NOTE the value! assertion is needed in TS 4.5.5 (fixed in newer versions)\n  return value !== undefined ? value : defaultAppState[key];\n};\nconst LegacyAppStateMigrations = {\n  isSidebarDocked: (appState, defaultAppState) => {\n    var _appState$isSidebarDo;\n    return [\"defaultSidebarDockedPreference\", (_appState$isSidebarDo = appState.isSidebarDocked) !== null && _appState$isSidebarDo !== void 0 ? _appState$isSidebarDo : coalesceAppStateValue(\"defaultSidebarDockedPreference\", appState, defaultAppState)];\n  }\n};\nexport const restoreAppState = (appState, localAppState) => {\n  var _localAppState$penDet, _appState$penDetected, _nextAppState$activeT, _appState$zoom;\n  appState = appState || {};\n  const defaultAppState = getDefaultAppState();\n  const nextAppState = {};\n\n  // first, migrate all legacy AppState properties to new ones. We do it\n  // in one go before migrate the rest of the properties in case the new ones\n  // depend on checking any other key (i.e. they are coupled)\n  for (const legacyKey of Object.keys(LegacyAppStateMigrations)) {\n    if (legacyKey in appState) {\n      const [nextKey, nextValue] = LegacyAppStateMigrations[legacyKey](appState, defaultAppState);\n      nextAppState[nextKey] = nextValue;\n    }\n  }\n  for (const [key, defaultValue] of Object.entries(defaultAppState)) {\n    // if AppState contains a legacy key, prefer that one and migrate its\n    // value to the new one\n    const suppliedValue = appState[key];\n    const localValue = localAppState ? localAppState[key] : undefined;\n    nextAppState[key] = suppliedValue !== undefined ? suppliedValue : localValue !== undefined ? localValue : defaultValue;\n  }\n  return {\n    ...nextAppState,\n    cursorButton: (localAppState === null || localAppState === void 0 ? void 0 : localAppState.cursorButton) || \"up\",\n    // reset on fresh restore so as to hide the UI button if penMode not active\n    penDetected: (_localAppState$penDet = localAppState === null || localAppState === void 0 ? void 0 : localAppState.penDetected) !== null && _localAppState$penDet !== void 0 ? _localAppState$penDet : appState.penMode ? (_appState$penDetected = appState.penDetected) !== null && _appState$penDetected !== void 0 ? _appState$penDetected : false : false,\n    activeTool: {\n      ...updateActiveTool(defaultAppState, nextAppState.activeTool.type && AllowedExcalidrawActiveTools[nextAppState.activeTool.type] ? nextAppState.activeTool : {\n        type: \"selection\"\n      }),\n      lastActiveTool: null,\n      locked: (_nextAppState$activeT = nextAppState.activeTool.locked) !== null && _nextAppState$activeT !== void 0 ? _nextAppState$activeT : false\n    },\n    // Migrates from previous version where appState.zoom was a number\n    zoom: typeof appState.zoom === \"number\" ? {\n      value: appState.zoom\n    } : (_appState$zoom = appState.zoom) !== null && _appState$zoom !== void 0 && _appState$zoom.value ? appState.zoom : defaultAppState.zoom,\n    openSidebar:\n    // string (legacy)\n    typeof appState.openSidebar === \"string\" ? {\n      name: DEFAULT_SIDEBAR.name\n    } : nextAppState.openSidebar\n  };\n};\nexport const restore = (data, localAppState, localElements, elementsConfig) => {\n  return {\n    elements: restoreElements(data === null || data === void 0 ? void 0 : data.elements, localElements, elementsConfig),\n    appState: restoreAppState(data === null || data === void 0 ? void 0 : data.appState, localAppState || null),\n    files: (data === null || data === void 0 ? void 0 : data.files) || {}\n  };\n};\nconst restoreLibraryItem = libraryItem => {\n  const elements = restoreElements(getNonDeletedElements(libraryItem.elements), null);\n  return elements.length ? {\n    ...libraryItem,\n    elements\n  } : null;\n};\nexport const restoreLibraryItems = function () {\n  let libraryItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let defaultStatus = arguments.length > 1 ? arguments[1] : undefined;\n  const restoredItems = [];\n  for (const item of libraryItems) {\n    // migrate older libraries\n    if (Array.isArray(item)) {\n      const restoredItem = restoreLibraryItem({\n        status: defaultStatus,\n        elements: item,\n        id: randomId(),\n        created: Date.now()\n      });\n      if (restoredItem) {\n        restoredItems.push(restoredItem);\n      }\n    } else {\n      const _item = item;\n      const restoredItem = restoreLibraryItem({\n        ..._item,\n        id: _item.id || randomId(),\n        status: _item.status || defaultStatus,\n        created: _item.created || Date.now()\n      });\n      if (restoredItem) {\n        restoredItems.push(restoredItem);\n      }\n    }\n  }\n  return restoredItems;\n};","map":{"version":3,"names":["ImportedDataState","getNonDeletedElements","getNormalizedDimensions","isInvisiblySmallElement","refreshTextDimensions","isTextElement","isUsingAdaptiveRadius","randomId","DEFAULT_FONT_FAMILY","DEFAULT_TEXT_ALIGN","DEFAULT_VERTICAL_ALIGN","PRECEDING_ELEMENT_KEY","FONT_FAMILY","ROUNDNESS","DEFAULT_SIDEBAR","getDefaultAppState","LinearElementEditor","bumpVersion","getFontString","getUpdatedTimestamp","updateActiveTool","arrayToMap","detectLineHeight","getDefaultLineHeight","measureBaseline","COLOR_PALETTE","normalizeLink","AllowedExcalidrawActiveTools","selection","text","rectangle","diamond","ellipse","line","image","arrow","freedraw","eraser","custom","frame","hand","getFontFamilyByName","fontFamilyName","Object","keys","includes","restoreElementWithProperties","element","extra","_element$versionNonce","_element$isDeleted","_element$strokeStyle","_element$roughness","_ref","_extra$x","_ref2","_extra$y","_element$seed","_element$groupIds","_element$frameId","_element$boundElement","_element$updated","_element$locked","base","type","version","versionNonce","isDeleted","id","fillStyle","strokeWidth","strokeStyle","roughness","opacity","angle","x","y","strokeColor","black","backgroundColor","transparent","width","height","seed","groupIds","frameId","roundness","strokeSharpness","LEGACY","PROPORTIONAL_RADIUS","boundElements","boundElementIds","map","updated","link","locked","customData","restoreElement","_element$text","_element$containerId","_element$name","refreshDimensions","arguments","length","undefined","fontSize","fontFamily","fontPx","_fontFamily","font","split","parseFloat","lineHeight","baseline","textAlign","verticalAlign","containerId","originalText","points","lastCommittedPoint","simulatePressure","pressures","status","fileId","scale","startArrowhead","endArrowhead","Array","isArray","getNormalizedPoints","startBinding","endBinding","name","repairContainerElement","container","elementsMap","slice","boundIds","Set","reduce","acc","binding","boundElement","get","has","add","push","repairBoundElement","find","repairFrameMembership","containingFrame","restoreElements","elements","localElements","opts","existingIds","localElementsMap","restoredElements","migratedElement","localElement","repairBindings","restoredElementsMap","coalesceAppStateValue","key","appState","defaultAppState","value","LegacyAppStateMigrations","isSidebarDocked","_appState$isSidebarDo","restoreAppState","localAppState","_localAppState$penDet","_appState$penDetected","_nextAppState$activeT","_appState$zoom","nextAppState","legacyKey","nextKey","nextValue","defaultValue","entries","suppliedValue","localValue","cursorButton","penDetected","penMode","activeTool","lastActiveTool","zoom","openSidebar","restore","data","elementsConfig","files","restoreLibraryItem","libraryItem","restoreLibraryItems","libraryItems","defaultStatus","restoredItems","item","restoredItem","created","Date","now","_item"],"sources":["D:/project/excalidraw-cn/src/data/restore.ts"],"sourcesContent":["import {\n  ExcalidrawElement,\n  ExcalidrawSelectionElement,\n  ExcalidrawTextElement,\n  FontFamilyValues,\n  StrokeRoundness,\n} from \"../element/types\";\nimport {\n  AppState,\n  BinaryFiles,\n  LibraryItem,\n  NormalizedZoomValue,\n} from \"../types\";\nimport { ImportedDataState, LegacyAppState } from \"./types\";\nimport {\n  getNonDeletedElements,\n  getNormalizedDimensions,\n  isInvisiblySmallElement,\n  refreshTextDimensions,\n} from \"../element\";\nimport { isTextElement, isUsingAdaptiveRadius } from \"../element/typeChecks\";\nimport { randomId } from \"../random\";\nimport {\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n  DEFAULT_VERTICAL_ALIGN,\n  PRECEDING_ELEMENT_KEY,\n  FONT_FAMILY,\n  ROUNDNESS,\n  DEFAULT_SIDEBAR,\n} from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { bumpVersion } from \"../element/mutateElement\";\nimport { getFontString, getUpdatedTimestamp, updateActiveTool } from \"../utils\";\nimport { arrayToMap } from \"../utils\";\nimport { MarkOptional, Mutable } from \"../utility-types\";\nimport {\n  detectLineHeight,\n  getDefaultLineHeight,\n  measureBaseline,\n} from \"../element/textElement\";\nimport { COLOR_PALETTE } from \"../colors\";\nimport { normalizeLink } from \"./url\";\n\ntype RestoredAppState = Omit<\n  AppState,\n  \"offsetTop\" | \"offsetLeft\" | \"width\" | \"height\"\n>;\n\nexport const AllowedExcalidrawActiveTools: Record<\n  AppState[\"activeTool\"][\"type\"],\n  boolean\n> = {\n  selection: true,\n  text: true,\n  rectangle: true,\n  diamond: true,\n  ellipse: true,\n  line: true,\n  image: true,\n  arrow: true,\n  freedraw: true,\n  eraser: false,\n  custom: true,\n  frame: true,\n  hand: true,\n};\n\nexport type RestoredDataState = {\n  elements: ExcalidrawElement[];\n  appState: RestoredAppState;\n  files: BinaryFiles;\n};\n\nconst getFontFamilyByName = (fontFamilyName: string): FontFamilyValues => {\n  if (Object.keys(FONT_FAMILY).includes(fontFamilyName)) {\n    return FONT_FAMILY[\n      fontFamilyName as keyof typeof FONT_FAMILY\n    ] as FontFamilyValues;\n  }\n  return DEFAULT_FONT_FAMILY;\n};\n\nconst restoreElementWithProperties = <\n  T extends Required<Omit<ExcalidrawElement, \"customData\">> & {\n    customData?: ExcalidrawElement[\"customData\"];\n    /** @deprecated */\n    boundElementIds?: readonly ExcalidrawElement[\"id\"][];\n    /** @deprecated */\n    strokeSharpness?: StrokeRoundness;\n    /** metadata that may be present in elements during collaboration */\n    [PRECEDING_ELEMENT_KEY]?: string;\n  },\n  K extends Pick<T, keyof Omit<Required<T>, keyof ExcalidrawElement>>,\n>(\n  element: T,\n  extra: Pick<\n    T,\n    // This extra Pick<T, keyof K> ensure no excess properties are passed.\n    // @ts-ignore TS complains here but type checks the call sites fine.\n    keyof K\n  > &\n    Partial<Pick<ExcalidrawElement, \"type\" | \"x\" | \"y\">>,\n): T => {\n  const base: Pick<T, keyof ExcalidrawElement> & {\n    [PRECEDING_ELEMENT_KEY]?: string;\n  } = {\n    type: extra.type || element.type,\n    // all elements must have version > 0 so getSceneVersion() will pick up\n    // newly added elements\n    version: element.version || 1,\n    versionNonce: element.versionNonce ?? 0,\n    isDeleted: element.isDeleted ?? false,\n    id: element.id || randomId(),\n    fillStyle: element.fillStyle || \"hachure\",\n    strokeWidth: element.strokeWidth || 1,\n    strokeStyle: element.strokeStyle ?? \"solid\",\n    roughness: element.roughness ?? 1,\n    opacity: element.opacity == null ? 100 : element.opacity,\n    angle: element.angle || 0,\n    x: extra.x ?? element.x ?? 0,\n    y: extra.y ?? element.y ?? 0,\n    strokeColor: element.strokeColor || COLOR_PALETTE.black,\n    backgroundColor: element.backgroundColor || COLOR_PALETTE.transparent,\n    width: element.width || 0,\n    height: element.height || 0,\n    seed: element.seed ?? 1,\n    groupIds: element.groupIds ?? [],\n    frameId: element.frameId ?? null,\n    roundness: element.roundness\n      ? element.roundness\n      : element.strokeSharpness === \"round\"\n      ? {\n          // for old elements that would now use adaptive radius algo,\n          // use legacy algo instead\n          type: isUsingAdaptiveRadius(element.type)\n            ? ROUNDNESS.LEGACY\n            : ROUNDNESS.PROPORTIONAL_RADIUS,\n        }\n      : null,\n    boundElements: element.boundElementIds\n      ? element.boundElementIds.map((id) => ({ type: \"arrow\", id }))\n      : element.boundElements ?? [],\n    updated: element.updated ?? getUpdatedTimestamp(),\n    link: element.link ? normalizeLink(element.link) : null,\n    locked: element.locked ?? false,\n  };\n\n  if (\"customData\" in element) {\n    base.customData = element.customData;\n  }\n\n  if (PRECEDING_ELEMENT_KEY in element) {\n    base[PRECEDING_ELEMENT_KEY] = element[PRECEDING_ELEMENT_KEY];\n  }\n\n  return {\n    ...base,\n    ...getNormalizedDimensions(base),\n    ...extra,\n  } as unknown as T;\n};\n\nconst restoreElement = (\n  element: Exclude<ExcalidrawElement, ExcalidrawSelectionElement>,\n  refreshDimensions = false,\n): typeof element | null => {\n  switch (element.type) {\n    case \"text\":\n      let fontSize = element.fontSize;\n      let fontFamily = element.fontFamily;\n      if (\"font\" in element) {\n        const [fontPx, _fontFamily]: [string, string] = (\n          element as any\n        ).font.split(\" \");\n        fontSize = parseFloat(fontPx);\n        fontFamily = getFontFamilyByName(_fontFamily);\n      }\n      const text = element.text ?? \"\";\n\n      // line-height might not be specified either when creating elements\n      // programmatically, or when importing old diagrams.\n      // For the latter we want to detect the original line height which\n      // will likely differ from our per-font fixed line height we now use,\n      // to maintain backward compatibility.\n      const lineHeight =\n        element.lineHeight ||\n        (element.height\n          ? // detect line-height from current element height and font-size\n            detectLineHeight(element)\n          : // no element height likely means programmatic use, so default\n            // to a fixed line height\n            getDefaultLineHeight(element.fontFamily));\n      const baseline = measureBaseline(\n        element.text,\n        getFontString(element),\n        lineHeight,\n      );\n      element = restoreElementWithProperties(element, {\n        fontSize,\n        fontFamily,\n        text,\n        textAlign: element.textAlign || DEFAULT_TEXT_ALIGN,\n        verticalAlign: element.verticalAlign || DEFAULT_VERTICAL_ALIGN,\n        containerId: element.containerId ?? null,\n        originalText: element.originalText || text,\n\n        lineHeight,\n        baseline,\n      });\n\n      if (refreshDimensions) {\n        element = { ...element, ...refreshTextDimensions(element) };\n      }\n      return element;\n    case \"freedraw\": {\n      return restoreElementWithProperties(element, {\n        points: element.points,\n        lastCommittedPoint: null,\n        simulatePressure: element.simulatePressure,\n        pressures: element.pressures,\n      });\n    }\n    case \"image\":\n      return restoreElementWithProperties(element, {\n        status: element.status || \"pending\",\n        fileId: element.fileId,\n        scale: element.scale || [1, 1],\n      });\n    case \"line\":\n    // @ts-ignore LEGACY type\n    // eslint-disable-next-line no-fallthrough\n    case \"draw\":\n    case \"arrow\": {\n      const {\n        startArrowhead = null,\n        endArrowhead = element.type === \"arrow\" ? \"arrow\" : null,\n      } = element;\n\n      let x = element.x;\n      let y = element.y;\n      let points = // migrate old arrow model to new one\n        !Array.isArray(element.points) || element.points.length < 2\n          ? [\n              [0, 0],\n              [element.width, element.height],\n            ]\n          : element.points;\n\n      if (points[0][0] !== 0 || points[0][1] !== 0) {\n        ({ points, x, y } = LinearElementEditor.getNormalizedPoints(element));\n      }\n\n      return restoreElementWithProperties(element, {\n        type:\n          (element.type as ExcalidrawElement[\"type\"] | \"draw\") === \"draw\"\n            ? \"line\"\n            : element.type,\n        startBinding: element.startBinding,\n        endBinding: element.endBinding,\n        lastCommittedPoint: null,\n        startArrowhead,\n        endArrowhead,\n        points,\n        x,\n        y,\n      });\n    }\n\n    // generic elements\n    case \"ellipse\":\n      return restoreElementWithProperties(element, {});\n    case \"rectangle\":\n      return restoreElementWithProperties(element, {});\n    case \"diamond\":\n      return restoreElementWithProperties(element, {});\n    case \"frame\":\n      return restoreElementWithProperties(element, {\n        name: element.name ?? null,\n      });\n\n    // Don't use default case so as to catch a missing an element type case.\n    // We also don't want to throw, but instead return void so we filter\n    // out these unsupported elements from the restored array.\n  }\n};\n\n/**\n * Repairs contaienr element's boundElements array by removing duplicates and\n * fixing containerId of bound elements if not present. Also removes any\n * bound elements that do not exist in the elements array.\n *\n * NOTE mutates elements.\n */\nconst repairContainerElement = (\n  container: Mutable<ExcalidrawElement>,\n  elementsMap: Map<string, Mutable<ExcalidrawElement>>,\n) => {\n  if (container.boundElements) {\n    // copy because we're not cloning on restore, and we don't want to mutate upstream\n    const boundElements = container.boundElements.slice();\n\n    // dedupe bindings & fix boundElement.containerId if not set already\n    const boundIds = new Set<ExcalidrawElement[\"id\"]>();\n    container.boundElements = boundElements.reduce(\n      (\n        acc: Mutable<NonNullable<ExcalidrawElement[\"boundElements\"]>>,\n        binding,\n      ) => {\n        const boundElement = elementsMap.get(binding.id);\n        if (boundElement && !boundIds.has(binding.id)) {\n          boundIds.add(binding.id);\n\n          if (boundElement.isDeleted) {\n            return acc;\n          }\n\n          acc.push(binding);\n\n          if (\n            isTextElement(boundElement) &&\n            // being slightly conservative here, preserving existing containerId\n            // if defined, lest boundElements is stale\n            !boundElement.containerId\n          ) {\n            (boundElement as Mutable<ExcalidrawTextElement>).containerId =\n              container.id;\n          }\n        }\n        return acc;\n      },\n      [],\n    );\n  }\n};\n\n/**\n * Repairs target bound element's container's boundElements array,\n * or removes contaienrId if container does not exist.\n *\n * NOTE mutates elements.\n */\nconst repairBoundElement = (\n  boundElement: Mutable<ExcalidrawTextElement>,\n  elementsMap: Map<string, Mutable<ExcalidrawElement>>,\n) => {\n  const container = boundElement.containerId\n    ? elementsMap.get(boundElement.containerId)\n    : null;\n\n  if (!container) {\n    boundElement.containerId = null;\n    return;\n  }\n\n  if (boundElement.isDeleted) {\n    return;\n  }\n\n  if (\n    container.boundElements &&\n    !container.boundElements.find((binding) => binding.id === boundElement.id)\n  ) {\n    // copy because we're not cloning on restore, and we don't want to mutate upstream\n    const boundElements = (\n      container.boundElements || (container.boundElements = [])\n    ).slice();\n    boundElements.push({ type: \"text\", id: boundElement.id });\n    container.boundElements = boundElements;\n  }\n};\n\n/**\n * Remove an element's frameId if its containing frame is non-existent\n *\n * NOTE mutates elements.\n */\nconst repairFrameMembership = (\n  element: Mutable<ExcalidrawElement>,\n  elementsMap: Map<string, Mutable<ExcalidrawElement>>,\n) => {\n  if (element.frameId) {\n    const containingFrame = elementsMap.get(element.frameId);\n\n    if (!containingFrame) {\n      element.frameId = null;\n    }\n  }\n};\n\nexport const restoreElements = (\n  elements: ImportedDataState[\"elements\"],\n  /** NOTE doesn't serve for reconciliation */\n  localElements: readonly ExcalidrawElement[] | null | undefined,\n  opts?: { refreshDimensions?: boolean; repairBindings?: boolean } | undefined,\n): ExcalidrawElement[] => {\n  // used to detect duplicate top-level element ids\n  const existingIds = new Set<string>();\n\n  const localElementsMap = localElements ? arrayToMap(localElements) : null;\n  const restoredElements = (elements || []).reduce((elements, element) => {\n    // filtering out selection, which is legacy, no longer kept in elements,\n    // and causing issues if retained\n    if (element.type !== \"selection\" && !isInvisiblySmallElement(element)) {\n      let migratedElement: ExcalidrawElement | null = restoreElement(\n        element,\n        opts?.refreshDimensions,\n      );\n      if (migratedElement) {\n        const localElement = localElementsMap?.get(element.id);\n        if (localElement && localElement.version > migratedElement.version) {\n          migratedElement = bumpVersion(migratedElement, localElement.version);\n        }\n        if (existingIds.has(migratedElement.id)) {\n          migratedElement = { ...migratedElement, id: randomId() };\n        }\n        existingIds.add(migratedElement.id);\n        elements.push(migratedElement);\n      }\n    }\n    return elements;\n  }, [] as ExcalidrawElement[]);\n\n  if (!opts?.repairBindings) {\n    return restoredElements;\n  }\n\n  // repair binding. Mutates elements.\n  const restoredElementsMap = arrayToMap(restoredElements);\n  for (const element of restoredElements) {\n    if (element.frameId) {\n      repairFrameMembership(element, restoredElementsMap);\n    }\n\n    if (isTextElement(element) && element.containerId) {\n      repairBoundElement(element, restoredElementsMap);\n    } else if (element.boundElements) {\n      repairContainerElement(element, restoredElementsMap);\n    }\n  }\n\n  return restoredElements;\n};\n\nconst coalesceAppStateValue = <\n  T extends keyof ReturnType<typeof getDefaultAppState>,\n>(\n  key: T,\n  appState: Exclude<ImportedDataState[\"appState\"], null | undefined>,\n  defaultAppState: ReturnType<typeof getDefaultAppState>,\n) => {\n  const value = appState[key];\n  // NOTE the value! assertion is needed in TS 4.5.5 (fixed in newer versions)\n  return value !== undefined ? value! : defaultAppState[key];\n};\n\nconst LegacyAppStateMigrations: {\n  [K in keyof LegacyAppState]: (\n    ImportedDataState: Exclude<ImportedDataState[\"appState\"], null | undefined>,\n    defaultAppState: ReturnType<typeof getDefaultAppState>,\n  ) => [LegacyAppState[K][1], AppState[LegacyAppState[K][1]]];\n} = {\n  isSidebarDocked: (appState, defaultAppState) => {\n    return [\n      \"defaultSidebarDockedPreference\",\n      appState.isSidebarDocked ??\n        coalesceAppStateValue(\n          \"defaultSidebarDockedPreference\",\n          appState,\n          defaultAppState,\n        ),\n    ];\n  },\n};\n\nexport const restoreAppState = (\n  appState: ImportedDataState[\"appState\"],\n  localAppState: Partial<AppState> | null | undefined,\n): RestoredAppState => {\n  appState = appState || {};\n  const defaultAppState = getDefaultAppState();\n  const nextAppState = {} as typeof defaultAppState;\n\n  // first, migrate all legacy AppState properties to new ones. We do it\n  // in one go before migrate the rest of the properties in case the new ones\n  // depend on checking any other key (i.e. they are coupled)\n  for (const legacyKey of Object.keys(\n    LegacyAppStateMigrations,\n  ) as (keyof typeof LegacyAppStateMigrations)[]) {\n    if (legacyKey in appState) {\n      const [nextKey, nextValue] = LegacyAppStateMigrations[legacyKey](\n        appState,\n        defaultAppState,\n      );\n      (nextAppState as any)[nextKey] = nextValue;\n    }\n  }\n\n  for (const [key, defaultValue] of Object.entries(defaultAppState) as [\n    keyof typeof defaultAppState,\n    any,\n  ][]) {\n    // if AppState contains a legacy key, prefer that one and migrate its\n    // value to the new one\n    const suppliedValue = appState[key];\n\n    const localValue = localAppState ? localAppState[key] : undefined;\n    (nextAppState as any)[key] =\n      suppliedValue !== undefined\n        ? suppliedValue\n        : localValue !== undefined\n        ? localValue\n        : defaultValue;\n  }\n\n  return {\n    ...nextAppState,\n    cursorButton: localAppState?.cursorButton || \"up\",\n    // reset on fresh restore so as to hide the UI button if penMode not active\n    penDetected:\n      localAppState?.penDetected ??\n      (appState.penMode ? appState.penDetected ?? false : false),\n    activeTool: {\n      ...updateActiveTool(\n        defaultAppState,\n        nextAppState.activeTool.type &&\n          AllowedExcalidrawActiveTools[nextAppState.activeTool.type]\n          ? nextAppState.activeTool\n          : { type: \"selection\" },\n      ),\n      lastActiveTool: null,\n      locked: nextAppState.activeTool.locked ?? false,\n    },\n    // Migrates from previous version where appState.zoom was a number\n    zoom:\n      typeof appState.zoom === \"number\"\n        ? {\n            value: appState.zoom as NormalizedZoomValue,\n          }\n        : appState.zoom?.value\n        ? appState.zoom\n        : defaultAppState.zoom,\n    openSidebar:\n      // string (legacy)\n      typeof (appState.openSidebar as any as string) === \"string\"\n        ? { name: DEFAULT_SIDEBAR.name }\n        : nextAppState.openSidebar,\n  };\n};\n\nexport const restore = (\n  data: Pick<ImportedDataState, \"appState\" | \"elements\" | \"files\"> | null,\n  /**\n   * Local AppState (`this.state` or initial state from localStorage) so that we\n   * don't overwrite local state with default values (when values not\n   * explicitly specified).\n   * Supply `null` if you can't get access to it.\n   */\n  localAppState: Partial<AppState> | null | undefined,\n  localElements: readonly ExcalidrawElement[] | null | undefined,\n  elementsConfig?: { refreshDimensions?: boolean; repairBindings?: boolean },\n): RestoredDataState => {\n  return {\n    elements: restoreElements(data?.elements, localElements, elementsConfig),\n    appState: restoreAppState(data?.appState, localAppState || null),\n    files: data?.files || {},\n  };\n};\n\nconst restoreLibraryItem = (libraryItem: LibraryItem) => {\n  const elements = restoreElements(\n    getNonDeletedElements(libraryItem.elements),\n    null,\n  );\n  return elements.length ? { ...libraryItem, elements } : null;\n};\n\nexport const restoreLibraryItems = (\n  libraryItems: ImportedDataState[\"libraryItems\"] = [],\n  defaultStatus: LibraryItem[\"status\"],\n) => {\n  const restoredItems: LibraryItem[] = [];\n  for (const item of libraryItems) {\n    // migrate older libraries\n    if (Array.isArray(item)) {\n      const restoredItem = restoreLibraryItem({\n        status: defaultStatus,\n        elements: item,\n        id: randomId(),\n        created: Date.now(),\n      });\n      if (restoredItem) {\n        restoredItems.push(restoredItem);\n      }\n    } else {\n      const _item = item as MarkOptional<\n        LibraryItem,\n        \"id\" | \"status\" | \"created\"\n      >;\n      const restoredItem = restoreLibraryItem({\n        ..._item,\n        id: _item.id || randomId(),\n        status: _item.status || defaultStatus,\n        created: _item.created || Date.now(),\n      });\n      if (restoredItem) {\n        restoredItems.push(restoredItem);\n      }\n    }\n  }\n  return restoredItems;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}