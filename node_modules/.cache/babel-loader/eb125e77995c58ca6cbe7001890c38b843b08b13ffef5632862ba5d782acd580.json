{"ast":null,"code":"import _objectWithoutProperties from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";import _createForOfIteratorHelper from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import _toConsumableArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _objectSpread from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _slicedToArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";var _excluded=[\"element\"];import{SHIFT_LOCKING_ANGLE}from\"../constants\";import{rescalePoints}from\"../points\";import{rotate,adjustXYWithRotation,centerPoint,rotatePoint}from\"../math\";import{getElementAbsoluteCoords,getCommonBounds,getResizedElementAbsoluteCoords,getCommonBoundingBox,getElementPointsCoords}from\"./bounds\";import{isArrowElement,isBoundToContainer,isFrameElement,isFreeDrawElement,isImageElement,isLinearElement,isTextElement}from\"./typeChecks\";import{mutateElement}from\"./mutateElement\";import{getFontString}from\"../utils\";import{updateBoundElements}from\"./binding\";import Scene from\"../scene/Scene\";import{getApproxMinLineWidth,getBoundTextElement,getBoundTextElementId,getContainerElement,handleBindTextResize,getBoundTextMaxWidth,getApproxMinLineHeight,measureText,getBoundTextMaxHeight}from\"./textElement\";import{LinearElementEditor}from\"./linearElementEditor\";export var normalizeAngle=function normalizeAngle(angle){if(angle<0){return angle+2*Math.PI;}if(angle>=2*Math.PI){return angle-2*Math.PI;}return angle;};// Returns true when transform (resizing/rotation) happened\nexport var transformElements=function transformElements(pointerDownState,transformHandleType,selectedElements,resizeArrowDirection,shouldRotateWithDiscreteAngle,shouldResizeFromCenter,shouldMaintainAspectRatio,pointerX,pointerY,centerX,centerY){if(selectedElements.length===1){var _selectedElements=_slicedToArray(selectedElements,1),element=_selectedElements[0];if(transformHandleType===\"rotation\"){rotateSingleElement(element,pointerX,pointerY,shouldRotateWithDiscreteAngle,pointerDownState.originalElements);updateBoundElements(element);}else if(isTextElement(element)&&(transformHandleType===\"nw\"||transformHandleType===\"ne\"||transformHandleType===\"sw\"||transformHandleType===\"se\")){resizeSingleTextElement(element,transformHandleType,shouldResizeFromCenter,pointerX,pointerY);updateBoundElements(element);}else if(transformHandleType){resizeSingleElement(pointerDownState.originalElements,shouldMaintainAspectRatio,element,transformHandleType,shouldResizeFromCenter,pointerX,pointerY);}return true;}else if(selectedElements.length>1){if(transformHandleType===\"rotation\"){rotateMultipleElements(pointerDownState,selectedElements,pointerX,pointerY,shouldRotateWithDiscreteAngle,centerX,centerY);return true;}else if(transformHandleType===\"nw\"||transformHandleType===\"ne\"||transformHandleType===\"sw\"||transformHandleType===\"se\"){resizeMultipleElements(pointerDownState,selectedElements,transformHandleType,shouldResizeFromCenter,pointerX,pointerY);return true;}}return false;};var rotateSingleElement=function rotateSingleElement(element,pointerX,pointerY,shouldRotateWithDiscreteAngle,originalElements){var _getElementAbsoluteCo=getElementAbsoluteCoords(element),_getElementAbsoluteCo2=_slicedToArray(_getElementAbsoluteCo,4),x1=_getElementAbsoluteCo2[0],y1=_getElementAbsoluteCo2[1],x2=_getElementAbsoluteCo2[2],y2=_getElementAbsoluteCo2[3];var cx=(x1+x2)/2;var cy=(y1+y2)/2;var angle;if(isFrameElement(element)){angle=0;}else{angle=5*Math.PI/2+Math.atan2(pointerY-cy,pointerX-cx);if(shouldRotateWithDiscreteAngle){angle+=SHIFT_LOCKING_ANGLE/2;angle-=angle%SHIFT_LOCKING_ANGLE;}angle=normalizeAngle(angle);}var boundTextElementId=getBoundTextElementId(element);mutateElement(element,{angle:angle});if(boundTextElementId){var _Scene$getScene;var textElement=(_Scene$getScene=Scene.getScene(element))===null||_Scene$getScene===void 0?void 0:_Scene$getScene.getElement(boundTextElementId);if(textElement&&!isArrowElement(element)){mutateElement(textElement,{angle:angle});}}};var rescalePointsInElement=function rescalePointsInElement(element,width,height,normalizePoints){return isLinearElement(element)||isFreeDrawElement(element)?{points:rescalePoints(0,width,rescalePoints(1,height,element.points,normalizePoints),normalizePoints)}:{};};var MIN_FONT_SIZE=1;var measureFontSizeFromWidth=function measureFontSizeFromWidth(element,nextWidth,nextHeight){// We only use width to scale font on resize\nvar width=element.width;var hasContainer=isBoundToContainer(element);if(hasContainer){var container=getContainerElement(element);if(container){width=getBoundTextMaxWidth(container);}}var nextFontSize=element.fontSize*(nextWidth/width);if(nextFontSize<MIN_FONT_SIZE){return null;}var metrics=measureText(element.text,getFontString({fontSize:nextFontSize,fontFamily:element.fontFamily}),element.lineHeight);return{size:nextFontSize,baseline:metrics.baseline+(nextHeight-metrics.height)};};var getSidesForTransformHandle=function getSidesForTransformHandle(transformHandleType,shouldResizeFromCenter){return{n:/^(n|ne|nw)$/.test(transformHandleType)||shouldResizeFromCenter&&/^(s|se|sw)$/.test(transformHandleType),s:/^(s|se|sw)$/.test(transformHandleType)||shouldResizeFromCenter&&/^(n|ne|nw)$/.test(transformHandleType),w:/^(w|nw|sw)$/.test(transformHandleType)||shouldResizeFromCenter&&/^(e|ne|se)$/.test(transformHandleType),e:/^(e|ne|se)$/.test(transformHandleType)||shouldResizeFromCenter&&/^(w|nw|sw)$/.test(transformHandleType)};};var resizeSingleTextElement=function resizeSingleTextElement(element,transformHandleType,shouldResizeFromCenter,pointerX,pointerY){var _getElementAbsoluteCo3=getElementAbsoluteCoords(element),_getElementAbsoluteCo4=_slicedToArray(_getElementAbsoluteCo3,4),x1=_getElementAbsoluteCo4[0],y1=_getElementAbsoluteCo4[1],x2=_getElementAbsoluteCo4[2],y2=_getElementAbsoluteCo4[3];var cx=(x1+x2)/2;var cy=(y1+y2)/2;// rotation pointer with reverse angle\nvar _rotate=rotate(pointerX,pointerY,cx,cy,-element.angle),_rotate2=_slicedToArray(_rotate,2),rotatedX=_rotate2[0],rotatedY=_rotate2[1];var scale;switch(transformHandleType){case\"se\":scale=Math.max((rotatedX-x1)/(x2-x1),(rotatedY-y1)/(y2-y1));break;case\"nw\":scale=Math.max((x2-rotatedX)/(x2-x1),(y2-rotatedY)/(y2-y1));break;case\"ne\":scale=Math.max((rotatedX-x1)/(x2-x1),(y2-rotatedY)/(y2-y1));break;case\"sw\":scale=Math.max((x2-rotatedX)/(x2-x1),(rotatedY-y1)/(y2-y1));break;}if(scale>0){var nextWidth=element.width*scale;var nextHeight=element.height*scale;var metrics=measureFontSizeFromWidth(element,nextWidth,nextHeight);if(metrics===null){return;}var _getResizedElementAbs=getResizedElementAbsoluteCoords(element,nextWidth,nextHeight,false),_getResizedElementAbs2=_slicedToArray(_getResizedElementAbs,4),nextX1=_getResizedElementAbs2[0],nextY1=_getResizedElementAbs2[1],nextX2=_getResizedElementAbs2[2],nextY2=_getResizedElementAbs2[3];var deltaX1=(x1-nextX1)/2;var deltaY1=(y1-nextY1)/2;var deltaX2=(x2-nextX2)/2;var deltaY2=(y2-nextY2)/2;var _adjustXYWithRotation=adjustXYWithRotation(getSidesForTransformHandle(transformHandleType,shouldResizeFromCenter),element.x,element.y,element.angle,deltaX1,deltaY1,deltaX2,deltaY2),_adjustXYWithRotation2=_slicedToArray(_adjustXYWithRotation,2),nextElementX=_adjustXYWithRotation2[0],nextElementY=_adjustXYWithRotation2[1];mutateElement(element,{fontSize:metrics.size,width:nextWidth,height:nextHeight,baseline:metrics.baseline,x:nextElementX,y:nextElementY});}};export var resizeSingleElement=function resizeSingleElement(originalElements,shouldMaintainAspectRatio,element,transformHandleDirection,shouldResizeFromCenter,pointerX,pointerY){var stateAtResizeStart=originalElements.get(element.id);// Gets bounds corners\nvar _getResizedElementAbs3=getResizedElementAbsoluteCoords(stateAtResizeStart,stateAtResizeStart.width,stateAtResizeStart.height,true),_getResizedElementAbs4=_slicedToArray(_getResizedElementAbs3,4),x1=_getResizedElementAbs4[0],y1=_getResizedElementAbs4[1],x2=_getResizedElementAbs4[2],y2=_getResizedElementAbs4[3];var startTopLeft=[x1,y1];var startBottomRight=[x2,y2];var startCenter=centerPoint(startTopLeft,startBottomRight);// Calculate new dimensions based on cursor position\nvar rotatedPointer=rotatePoint([pointerX,pointerY],startCenter,-stateAtResizeStart.angle);// Get bounds corners rendered on screen\nvar _getResizedElementAbs5=getResizedElementAbsoluteCoords(element,element.width,element.height,true),_getResizedElementAbs6=_slicedToArray(_getResizedElementAbs5,4),esx1=_getResizedElementAbs6[0],esy1=_getResizedElementAbs6[1],esx2=_getResizedElementAbs6[2],esy2=_getResizedElementAbs6[3];var boundsCurrentWidth=esx2-esx1;var boundsCurrentHeight=esy2-esy1;// It's important we set the initial scale value based on the width and height at resize start,\n// otherwise previous dimensions affected by modifiers will be taken into account.\nvar atStartBoundsWidth=startBottomRight[0]-startTopLeft[0];var atStartBoundsHeight=startBottomRight[1]-startTopLeft[1];var scaleX=atStartBoundsWidth/boundsCurrentWidth;var scaleY=atStartBoundsHeight/boundsCurrentHeight;var boundTextFont={};var boundTextElement=getBoundTextElement(element);if(transformHandleDirection.includes(\"e\")){scaleX=(rotatedPointer[0]-startTopLeft[0])/boundsCurrentWidth;}if(transformHandleDirection.includes(\"s\")){scaleY=(rotatedPointer[1]-startTopLeft[1])/boundsCurrentHeight;}if(transformHandleDirection.includes(\"w\")){scaleX=(startBottomRight[0]-rotatedPointer[0])/boundsCurrentWidth;}if(transformHandleDirection.includes(\"n\")){scaleY=(startBottomRight[1]-rotatedPointer[1])/boundsCurrentHeight;}// Linear elements dimensions differ from bounds dimensions\nvar eleInitialWidth=stateAtResizeStart.width;var eleInitialHeight=stateAtResizeStart.height;// We have to use dimensions of element on screen, otherwise the scaling of the\n// dimensions won't match the cursor for linear elements.\nvar eleNewWidth=element.width*scaleX;var eleNewHeight=element.height*scaleY;// adjust dimensions for resizing from center\nif(shouldResizeFromCenter){eleNewWidth=2*eleNewWidth-eleInitialWidth;eleNewHeight=2*eleNewHeight-eleInitialHeight;}// adjust dimensions to keep sides ratio\nif(shouldMaintainAspectRatio){var widthRatio=Math.abs(eleNewWidth)/eleInitialWidth;var heightRatio=Math.abs(eleNewHeight)/eleInitialHeight;if(transformHandleDirection.length===1){eleNewHeight*=widthRatio;eleNewWidth*=heightRatio;}if(transformHandleDirection.length===2){var ratio=Math.max(widthRatio,heightRatio);eleNewWidth=eleInitialWidth*ratio*Math.sign(eleNewWidth);eleNewHeight=eleInitialHeight*ratio*Math.sign(eleNewHeight);}}if(boundTextElement){var stateOfBoundTextElementAtResize=originalElements.get(boundTextElement.id);if(stateOfBoundTextElementAtResize){boundTextFont={fontSize:stateOfBoundTextElementAtResize.fontSize,baseline:stateOfBoundTextElementAtResize.baseline};}if(shouldMaintainAspectRatio){var updatedElement=_objectSpread(_objectSpread({},element),{},{width:eleNewWidth,height:eleNewHeight});var nextFont=measureFontSizeFromWidth(boundTextElement,getBoundTextMaxWidth(updatedElement),getBoundTextMaxHeight(updatedElement,boundTextElement));if(nextFont===null){return;}boundTextFont={fontSize:nextFont.size,baseline:nextFont.baseline};}else{var minWidth=getApproxMinLineWidth(getFontString(boundTextElement),boundTextElement.lineHeight);var minHeight=getApproxMinLineHeight(boundTextElement.fontSize,boundTextElement.lineHeight);eleNewWidth=Math.ceil(Math.max(eleNewWidth,minWidth));eleNewHeight=Math.ceil(Math.max(eleNewHeight,minHeight));}}var _getResizedElementAbs7=getResizedElementAbsoluteCoords(stateAtResizeStart,eleNewWidth,eleNewHeight,true),_getResizedElementAbs8=_slicedToArray(_getResizedElementAbs7,4),newBoundsX1=_getResizedElementAbs8[0],newBoundsY1=_getResizedElementAbs8[1],newBoundsX2=_getResizedElementAbs8[2],newBoundsY2=_getResizedElementAbs8[3];var newBoundsWidth=newBoundsX2-newBoundsX1;var newBoundsHeight=newBoundsY2-newBoundsY1;// Calculate new topLeft based on fixed corner during resize\nvar newTopLeft=[].concat(startTopLeft);if([\"n\",\"w\",\"nw\"].includes(transformHandleDirection)){newTopLeft=[startBottomRight[0]-Math.abs(newBoundsWidth),startBottomRight[1]-Math.abs(newBoundsHeight)];}if(transformHandleDirection===\"ne\"){var bottomLeft=[startTopLeft[0],startBottomRight[1]];newTopLeft=[bottomLeft[0],bottomLeft[1]-Math.abs(newBoundsHeight)];}if(transformHandleDirection===\"sw\"){var topRight=[startBottomRight[0],startTopLeft[1]];newTopLeft=[topRight[0]-Math.abs(newBoundsWidth),topRight[1]];}// Keeps opposite handle fixed during resize\nif(shouldMaintainAspectRatio){if([\"s\",\"n\"].includes(transformHandleDirection)){newTopLeft[0]=startCenter[0]-newBoundsWidth/2;}if([\"e\",\"w\"].includes(transformHandleDirection)){newTopLeft[1]=startCenter[1]-newBoundsHeight/2;}}// Flip horizontally\nif(eleNewWidth<0){if(transformHandleDirection.includes(\"e\")){newTopLeft[0]-=Math.abs(newBoundsWidth);}if(transformHandleDirection.includes(\"w\")){newTopLeft[0]+=Math.abs(newBoundsWidth);}}// Flip vertically\nif(eleNewHeight<0){if(transformHandleDirection.includes(\"s\")){newTopLeft[1]-=Math.abs(newBoundsHeight);}if(transformHandleDirection.includes(\"n\")){newTopLeft[1]+=Math.abs(newBoundsHeight);}}if(shouldResizeFromCenter){newTopLeft[0]=startCenter[0]-Math.abs(newBoundsWidth)/2;newTopLeft[1]=startCenter[1]-Math.abs(newBoundsHeight)/2;}// adjust topLeft to new rotation point\nvar angle=stateAtResizeStart.angle;var rotatedTopLeft=rotatePoint(newTopLeft,startCenter,angle);var newCenter=[newTopLeft[0]+Math.abs(newBoundsWidth)/2,newTopLeft[1]+Math.abs(newBoundsHeight)/2];var rotatedNewCenter=rotatePoint(newCenter,startCenter,angle);newTopLeft=rotatePoint(rotatedTopLeft,rotatedNewCenter,-angle);// Readjust points for linear elements\nvar rescaledElementPointsY;var rescaledPoints;if(isLinearElement(element)||isFreeDrawElement(element)){rescaledElementPointsY=rescalePoints(1,eleNewHeight,stateAtResizeStart.points,true);rescaledPoints=rescalePoints(0,eleNewWidth,rescaledElementPointsY,true);}// For linear elements (x,y) are the coordinates of the first drawn point not the top-left corner\n// So we need to readjust (x,y) to be where the first point should be\nvar newOrigin=_toConsumableArray(newTopLeft);newOrigin[0]+=stateAtResizeStart.x-newBoundsX1;newOrigin[1]+=stateAtResizeStart.y-newBoundsY1;var resizedElement={width:Math.abs(eleNewWidth),height:Math.abs(eleNewHeight),x:newOrigin[0],y:newOrigin[1],points:rescaledPoints};if(\"scale\"in element&&\"scale\"in stateAtResizeStart){mutateElement(element,{scale:[// defaulting because scaleX/Y can be 0/-0\n(Math.sign(newBoundsX2-stateAtResizeStart.x)||stateAtResizeStart.scale[0])*stateAtResizeStart.scale[0],(Math.sign(newBoundsY2-stateAtResizeStart.y)||stateAtResizeStart.scale[1])*stateAtResizeStart.scale[1]]});}if(resizedElement.width!==0&&resizedElement.height!==0&&Number.isFinite(resizedElement.x)&&Number.isFinite(resizedElement.y)){updateBoundElements(element,{newSize:{width:resizedElement.width,height:resizedElement.height}});mutateElement(element,resizedElement);if(boundTextElement&&boundTextFont!=null){mutateElement(boundTextElement,{fontSize:boundTextFont.fontSize,baseline:boundTextFont.baseline});}handleBindTextResize(element,transformHandleDirection);}};export var resizeMultipleElements=function resizeMultipleElements(pointerDownState,selectedElements,transformHandleType,shouldResizeFromCenter,pointerX,pointerY){var _Scene$getScene2;// map selected elements to the original elements. While it never should\n// happen that pointerDownState.originalElements won't contain the selected\n// elements during resize, this coupling isn't guaranteed, so to ensure\n// type safety we need to transform only those elements we filter.\nvar targetElements=selectedElements.reduce(function(acc,element){var origElement=pointerDownState.originalElements.get(element.id);if(origElement){acc.push({orig:origElement,latest:element});}return acc;},[]);// getCommonBoundingBox() uses getBoundTextElement() which returns null for\n// original elements from pointerDownState, so we have to find and add these\n// bound text elements manually. Additionally, the coordinates of bound text\n// elements aren't always up to date.\nvar boundTextElements=targetElements.reduce(function(acc,_ref){var _pointerDownState$ori;var orig=_ref.orig;if(!isLinearElement(orig)){return acc;}var textId=getBoundTextElementId(orig);if(!textId){return acc;}var text=(_pointerDownState$ori=pointerDownState.originalElements.get(textId))!==null&&_pointerDownState$ori!==void 0?_pointerDownState$ori:null;if(!isBoundToContainer(text)){return acc;}var xy=LinearElementEditor.getBoundTextElementPosition(orig,text);return[].concat(_toConsumableArray(acc),[_objectSpread(_objectSpread({},text),xy)]);},[]);var _getCommonBoundingBox=getCommonBoundingBox(targetElements.map(function(_ref2){var orig=_ref2.orig;return orig;}).concat(boundTextElements)),minX=_getCommonBoundingBox.minX,minY=_getCommonBoundingBox.minY,maxX=_getCommonBoundingBox.maxX,maxY=_getCommonBoundingBox.maxY,midX=_getCommonBoundingBox.midX,midY=_getCommonBoundingBox.midY;var direction=transformHandleType;var mapDirectionsToAnchors={ne:[minX,maxY],se:[minX,minY],sw:[maxX,minY],nw:[maxX,maxY]};// anchor point must be on the opposite side of the dragged selection handle\n// or be the center of the selection if shouldResizeFromCenter\nvar _ref3=shouldResizeFromCenter?[midX,midY]:mapDirectionsToAnchors[direction],_ref4=_slicedToArray(_ref3,2),anchorX=_ref4[0],anchorY=_ref4[1];var scale=Math.max(Math.abs(pointerX-anchorX)/(maxX-minX)||0,Math.abs(pointerY-anchorY)/(maxY-minY)||0)*(shouldResizeFromCenter?2:1);if(scale===0){return;}var mapDirectionsToPointerPositions={ne:[pointerX>=anchorX,pointerY<=anchorY],se:[pointerX>=anchorX,pointerY>=anchorY],sw:[pointerX<=anchorX,pointerY>=anchorY],nw:[pointerX<=anchorX,pointerY<=anchorY]};/**\n   * to flip an element:\n   * 1. determine over which axis is the element being flipped\n   *    (could be x, y, or both) indicated by `flipFactorX` & `flipFactorY`\n   * 2. shift element's position by the amount of width or height (or both) or\n   *    mirror points in the case of linear & freedraw elemenets\n   * 3. adjust element angle\n   */var _mapDirectionsToPoint=mapDirectionsToPointerPositions[direction].map(function(condition){return condition?1:-1;}),_mapDirectionsToPoint2=_slicedToArray(_mapDirectionsToPoint,2),flipFactorX=_mapDirectionsToPoint2[0],flipFactorY=_mapDirectionsToPoint2[1];var isFlippedByX=flipFactorX<0;var isFlippedByY=flipFactorY<0;var elementsAndUpdates=[];var _iterator=_createForOfIteratorHelper(targetElements),_step;try{var _loop=function _loop(){var _step$value=_step.value,orig=_step$value.orig,latest=_step$value.latest;// bounded text elements are updated along with their container elements\nif(isTextElement(orig)&&isBoundToContainer(orig)){return\"continue\";}var width=orig.width*scale;var height=orig.height*scale;var angle=normalizeAngle(orig.angle*flipFactorX*flipFactorY);var isLinearOrFreeDraw=isLinearElement(orig)||isFreeDrawElement(orig);var offsetX=orig.x-anchorX;var offsetY=orig.y-anchorY;var shiftX=isFlippedByX&&!isLinearOrFreeDraw?width:0;var shiftY=isFlippedByY&&!isLinearOrFreeDraw?height:0;var x=anchorX+flipFactorX*(offsetX*scale+shiftX);var y=anchorY+flipFactorY*(offsetY*scale+shiftY);var rescaledPoints=rescalePointsInElement(orig,width*flipFactorX,height*flipFactorY,false);var update=_objectSpread({x:x,y:y,width:width,height:height,angle:angle},rescaledPoints);if(isImageElement(orig)&&targetElements.length===1){update.scale=[orig.scale[0]*flipFactorX,orig.scale[1]*flipFactorY];}if(isLinearElement(orig)&&(isFlippedByX||isFlippedByY)){var origBounds=getElementPointsCoords(orig,orig.points);var newBounds=getElementPointsCoords(_objectSpread(_objectSpread({},orig),{},{x:x,y:y}),rescaledPoints.points);var origXY=[orig.x,orig.y];var newXY=[x,y];var linearShift=function linearShift(axis){var i=axis===\"x\"?0:1;return(newBounds[i+2]-newXY[i]-(origXY[i]-origBounds[i])*scale+(origBounds[i+2]-origXY[i])*scale-(newXY[i]-newBounds[i]))/2;};if(isFlippedByX){update.x-=linearShift(\"x\");}if(isFlippedByY){update.y-=linearShift(\"y\");}}var boundText=null;var boundTextElement=getBoundTextElement(latest);if(boundTextElement||isTextElement(orig)){var updatedElement=_objectSpread(_objectSpread({},latest),{},{width:width,height:height});var metrics=measureFontSizeFromWidth(boundTextElement!==null&&boundTextElement!==void 0?boundTextElement:orig,boundTextElement?getBoundTextMaxWidth(updatedElement):updatedElement.width,boundTextElement?getBoundTextMaxHeight(updatedElement,boundTextElement):updatedElement.height);if(!metrics){return{v:void 0};}if(isTextElement(orig)){update.fontSize=metrics.size;update.baseline=metrics.baseline;}if(boundTextElement){boundText={element:boundTextElement,fontSize:metrics.size,baseline:metrics.baseline};}}elementsAndUpdates.push({element:latest,update:update,boundText:boundText});};for(_iterator.s();!(_step=_iterator.n()).done;){var _ret=_loop();if(_ret===\"continue\")continue;if(typeof _ret===\"object\")return _ret.v;}}catch(err){_iterator.e(err);}finally{_iterator.f();}var elementsToUpdate=elementsAndUpdates.map(function(_ref5){var element=_ref5.element;return element;});for(var _i=0,_elementsAndUpdates=elementsAndUpdates;_i<_elementsAndUpdates.length;_i++){var _elementsAndUpdates$_=_elementsAndUpdates[_i],element=_elementsAndUpdates$_.element,update=_elementsAndUpdates$_.update,boundText=_elementsAndUpdates$_.boundText;var width=update.width,height=update.height,angle=update.angle;mutateElement(element,update,false);updateBoundElements(element,{simultaneouslyUpdated:elementsToUpdate,newSize:{width:width,height:height}});if(boundText){var boundTextElement=boundText.element,boundTextUpdates=_objectWithoutProperties(boundText,_excluded);mutateElement(boundTextElement,_objectSpread(_objectSpread({},boundTextUpdates),{},{angle:isLinearElement(element)?undefined:angle}),false);handleBindTextResize(element,transformHandleType);}}(_Scene$getScene2=Scene.getScene(elementsAndUpdates[0].element))===null||_Scene$getScene2===void 0?void 0:_Scene$getScene2.informMutation();};var rotateMultipleElements=function rotateMultipleElements(pointerDownState,elements,pointerX,pointerY,shouldRotateWithDiscreteAngle,centerX,centerY){var _Scene$getScene3;var centerAngle=5*Math.PI/2+Math.atan2(pointerY-centerY,pointerX-centerX);if(shouldRotateWithDiscreteAngle){centerAngle+=SHIFT_LOCKING_ANGLE/2;centerAngle-=centerAngle%SHIFT_LOCKING_ANGLE;}elements.filter(function(element){return element.type!==\"frame\";}).forEach(function(element){var _pointerDownState$ori2,_pointerDownState$ori3;var _getElementAbsoluteCo5=getElementAbsoluteCoords(element),_getElementAbsoluteCo6=_slicedToArray(_getElementAbsoluteCo5,4),x1=_getElementAbsoluteCo6[0],y1=_getElementAbsoluteCo6[1],x2=_getElementAbsoluteCo6[2],y2=_getElementAbsoluteCo6[3];var cx=(x1+x2)/2;var cy=(y1+y2)/2;var origAngle=(_pointerDownState$ori2=(_pointerDownState$ori3=pointerDownState.originalElements.get(element.id))===null||_pointerDownState$ori3===void 0?void 0:_pointerDownState$ori3.angle)!==null&&_pointerDownState$ori2!==void 0?_pointerDownState$ori2:element.angle;var _rotate3=rotate(cx,cy,centerX,centerY,centerAngle+origAngle-element.angle),_rotate4=_slicedToArray(_rotate3,2),rotatedCX=_rotate4[0],rotatedCY=_rotate4[1];mutateElement(element,{x:element.x+(rotatedCX-cx),y:element.y+(rotatedCY-cy),angle:normalizeAngle(centerAngle+origAngle)},false);updateBoundElements(element,{simultaneouslyUpdated:elements});var boundText=getBoundTextElement(element);if(boundText&&!isArrowElement(element)){mutateElement(boundText,{x:boundText.x+(rotatedCX-cx),y:boundText.y+(rotatedCY-cy),angle:normalizeAngle(centerAngle+origAngle)},false);}});(_Scene$getScene3=Scene.getScene(elements[0]))===null||_Scene$getScene3===void 0?void 0:_Scene$getScene3.informMutation();};export var getResizeOffsetXY=function getResizeOffsetXY(transformHandleType,selectedElements,x,y){var _ref6=selectedElements.length===1?getElementAbsoluteCoords(selectedElements[0]):getCommonBounds(selectedElements),_ref7=_slicedToArray(_ref6,4),x1=_ref7[0],y1=_ref7[1],x2=_ref7[2],y2=_ref7[3];var cx=(x1+x2)/2;var cy=(y1+y2)/2;var angle=selectedElements.length===1?selectedElements[0].angle:0;var _rotate5=rotate(x,y,cx,cy,-angle);var _rotate6=_slicedToArray(_rotate5,2);x=_rotate6[0];y=_rotate6[1];switch(transformHandleType){case\"n\":return rotate(x-(x1+x2)/2,y-y1,0,0,angle);case\"s\":return rotate(x-(x1+x2)/2,y-y2,0,0,angle);case\"w\":return rotate(x-x1,y-(y1+y2)/2,0,0,angle);case\"e\":return rotate(x-x2,y-(y1+y2)/2,0,0,angle);case\"nw\":return rotate(x-x1,y-y1,0,0,angle);case\"ne\":return rotate(x-x2,y-y1,0,0,angle);case\"sw\":return rotate(x-x1,y-y2,0,0,angle);case\"se\":return rotate(x-x2,y-y2,0,0,angle);default:return[0,0];}};export var getResizeArrowDirection=function getResizeArrowDirection(transformHandleType,element){var _element$points=_slicedToArray(element.points,2),_element$points$=_slicedToArray(_element$points[1],2),px=_element$points$[0],py=_element$points$[1];var isResizeEnd=transformHandleType===\"nw\"&&(px<0||py<0)||transformHandleType===\"ne\"&&px>=0||transformHandleType===\"sw\"&&px<=0||transformHandleType===\"se\"&&(px>0||py>0);return isResizeEnd?\"end\":\"origin\";};","map":{"version":3,"names":["SHIFT_LOCKING_ANGLE","rescalePoints","rotate","adjustXYWithRotation","centerPoint","rotatePoint","getElementAbsoluteCoords","getCommonBounds","getResizedElementAbsoluteCoords","getCommonBoundingBox","getElementPointsCoords","isArrowElement","isBoundToContainer","isFrameElement","isFreeDrawElement","isImageElement","isLinearElement","isTextElement","mutateElement","getFontString","updateBoundElements","Scene","getApproxMinLineWidth","getBoundTextElement","getBoundTextElementId","getContainerElement","handleBindTextResize","getBoundTextMaxWidth","getApproxMinLineHeight","measureText","getBoundTextMaxHeight","LinearElementEditor","normalizeAngle","angle","Math","PI","transformElements","pointerDownState","transformHandleType","selectedElements","resizeArrowDirection","shouldRotateWithDiscreteAngle","shouldResizeFromCenter","shouldMaintainAspectRatio","pointerX","pointerY","centerX","centerY","length","_selectedElements","_slicedToArray","element","rotateSingleElement","originalElements","resizeSingleTextElement","resizeSingleElement","rotateMultipleElements","resizeMultipleElements","_getElementAbsoluteCo","_getElementAbsoluteCo2","x1","y1","x2","y2","cx","cy","atan2","boundTextElementId","_Scene$getScene","textElement","getScene","getElement","rescalePointsInElement","width","height","normalizePoints","points","MIN_FONT_SIZE","measureFontSizeFromWidth","nextWidth","nextHeight","hasContainer","container","nextFontSize","fontSize","metrics","text","fontFamily","lineHeight","size","baseline","getSidesForTransformHandle","n","test","s","w","e","_getElementAbsoluteCo3","_getElementAbsoluteCo4","_rotate","_rotate2","rotatedX","rotatedY","scale","max","_getResizedElementAbs","_getResizedElementAbs2","nextX1","nextY1","nextX2","nextY2","deltaX1","deltaY1","deltaX2","deltaY2","_adjustXYWithRotation","x","y","_adjustXYWithRotation2","nextElementX","nextElementY","transformHandleDirection","stateAtResizeStart","get","id","_getResizedElementAbs3","_getResizedElementAbs4","startTopLeft","startBottomRight","startCenter","rotatedPointer","_getResizedElementAbs5","_getResizedElementAbs6","esx1","esy1","esx2","esy2","boundsCurrentWidth","boundsCurrentHeight","atStartBoundsWidth","atStartBoundsHeight","scaleX","scaleY","boundTextFont","boundTextElement","includes","eleInitialWidth","eleInitialHeight","eleNewWidth","eleNewHeight","widthRatio","abs","heightRatio","ratio","sign","stateOfBoundTextElementAtResize","updatedElement","_objectSpread","nextFont","minWidth","minHeight","ceil","_getResizedElementAbs7","_getResizedElementAbs8","newBoundsX1","newBoundsY1","newBoundsX2","newBoundsY2","newBoundsWidth","newBoundsHeight","newTopLeft","concat","bottomLeft","topRight","rotatedTopLeft","newCenter","rotatedNewCenter","rescaledElementPointsY","rescaledPoints","newOrigin","_toConsumableArray","resizedElement","Number","isFinite","newSize","_Scene$getScene2","targetElements","reduce","acc","origElement","push","orig","latest","boundTextElements","_ref","_pointerDownState$ori","textId","xy","getBoundTextElementPosition","_getCommonBoundingBox","map","_ref2","minX","minY","maxX","maxY","midX","midY","direction","mapDirectionsToAnchors","ne","se","sw","nw","_ref3","_ref4","anchorX","anchorY","mapDirectionsToPointerPositions","_mapDirectionsToPoint","condition","_mapDirectionsToPoint2","flipFactorX","flipFactorY","isFlippedByX","isFlippedByY","elementsAndUpdates","_iterator","_createForOfIteratorHelper","_step","_loop","_step$value","value","isLinearOrFreeDraw","offsetX","offsetY","shiftX","shiftY","update","origBounds","newBounds","origXY","newXY","linearShift","axis","i","boundText","v","done","_ret","err","f","elementsToUpdate","_ref5","_i","_elementsAndUpdates","_elementsAndUpdates$_","simultaneouslyUpdated","boundTextUpdates","_objectWithoutProperties","_excluded","undefined","informMutation","elements","_Scene$getScene3","centerAngle","filter","type","forEach","_pointerDownState$ori2","_pointerDownState$ori3","_getElementAbsoluteCo5","_getElementAbsoluteCo6","origAngle","_rotate3","_rotate4","rotatedCX","rotatedCY","getResizeOffsetXY","_ref6","_ref7","_rotate5","_rotate6","getResizeArrowDirection","_element$points","_element$points$","px","py","isResizeEnd"],"sources":["D:/project/excalidraw-cn/src/element/resizeElements.ts"],"sourcesContent":["import { SHIFT_LOCKING_ANGLE } from \"../constants\";\nimport { rescalePoints } from \"../points\";\n\nimport {\n  rotate,\n  adjustXYWithRotation,\n  centerPoint,\n  rotatePoint,\n} from \"../math\";\nimport {\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ExcalidrawElement,\n  ExcalidrawTextElementWithContainer,\n  ExcalidrawImageElement,\n} from \"./types\";\nimport type { Mutable } from \"../utility-types\";\nimport {\n  getElementAbsoluteCoords,\n  getCommonBounds,\n  getResizedElementAbsoluteCoords,\n  getCommonBoundingBox,\n  getElementPointsCoords,\n} from \"./bounds\";\nimport {\n  isArrowElement,\n  isBoundToContainer,\n  isFrameElement,\n  isFreeDrawElement,\n  isImageElement,\n  isLinearElement,\n  isTextElement,\n} from \"./typeChecks\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getFontString } from \"../utils\";\nimport { updateBoundElements } from \"./binding\";\nimport {\n  TransformHandleType,\n  MaybeTransformHandleType,\n  TransformHandleDirection,\n} from \"./transformHandles\";\nimport { Point, PointerDownState } from \"../types\";\nimport Scene from \"../scene/Scene\";\nimport {\n  getApproxMinLineWidth,\n  getBoundTextElement,\n  getBoundTextElementId,\n  getContainerElement,\n  handleBindTextResize,\n  getBoundTextMaxWidth,\n  getApproxMinLineHeight,\n  measureText,\n  getBoundTextMaxHeight,\n} from \"./textElement\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\n\nexport const normalizeAngle = (angle: number): number => {\n  if (angle < 0) {\n    return angle + 2 * Math.PI;\n  }\n  if (angle >= 2 * Math.PI) {\n    return angle - 2 * Math.PI;\n  }\n  return angle;\n};\n\n// Returns true when transform (resizing/rotation) happened\nexport const transformElements = (\n  pointerDownState: PointerDownState,\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  resizeArrowDirection: \"origin\" | \"end\",\n  shouldRotateWithDiscreteAngle: boolean,\n  shouldResizeFromCenter: boolean,\n  shouldMaintainAspectRatio: boolean,\n  pointerX: number,\n  pointerY: number,\n  centerX: number,\n  centerY: number,\n) => {\n  if (selectedElements.length === 1) {\n    const [element] = selectedElements;\n    if (transformHandleType === \"rotation\") {\n      rotateSingleElement(\n        element,\n        pointerX,\n        pointerY,\n        shouldRotateWithDiscreteAngle,\n        pointerDownState.originalElements,\n      );\n      updateBoundElements(element);\n    } else if (\n      isTextElement(element) &&\n      (transformHandleType === \"nw\" ||\n        transformHandleType === \"ne\" ||\n        transformHandleType === \"sw\" ||\n        transformHandleType === \"se\")\n    ) {\n      resizeSingleTextElement(\n        element,\n        transformHandleType,\n        shouldResizeFromCenter,\n        pointerX,\n        pointerY,\n      );\n      updateBoundElements(element);\n    } else if (transformHandleType) {\n      resizeSingleElement(\n        pointerDownState.originalElements,\n        shouldMaintainAspectRatio,\n        element,\n        transformHandleType,\n        shouldResizeFromCenter,\n        pointerX,\n        pointerY,\n      );\n    }\n\n    return true;\n  } else if (selectedElements.length > 1) {\n    if (transformHandleType === \"rotation\") {\n      rotateMultipleElements(\n        pointerDownState,\n        selectedElements,\n        pointerX,\n        pointerY,\n        shouldRotateWithDiscreteAngle,\n        centerX,\n        centerY,\n      );\n      return true;\n    } else if (\n      transformHandleType === \"nw\" ||\n      transformHandleType === \"ne\" ||\n      transformHandleType === \"sw\" ||\n      transformHandleType === \"se\"\n    ) {\n      resizeMultipleElements(\n        pointerDownState,\n        selectedElements,\n        transformHandleType,\n        shouldResizeFromCenter,\n        pointerX,\n        pointerY,\n      );\n      return true;\n    }\n  }\n  return false;\n};\n\nconst rotateSingleElement = (\n  element: NonDeletedExcalidrawElement,\n  pointerX: number,\n  pointerY: number,\n  shouldRotateWithDiscreteAngle: boolean,\n  originalElements: Map<string, NonDeleted<ExcalidrawElement>>,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  let angle: number;\n  if (isFrameElement(element)) {\n    angle = 0;\n  } else {\n    angle = (5 * Math.PI) / 2 + Math.atan2(pointerY - cy, pointerX - cx);\n    if (shouldRotateWithDiscreteAngle) {\n      angle += SHIFT_LOCKING_ANGLE / 2;\n      angle -= angle % SHIFT_LOCKING_ANGLE;\n    }\n    angle = normalizeAngle(angle);\n  }\n  const boundTextElementId = getBoundTextElementId(element);\n\n  mutateElement(element, { angle });\n  if (boundTextElementId) {\n    const textElement =\n      Scene.getScene(element)?.getElement<ExcalidrawTextElementWithContainer>(\n        boundTextElementId,\n      );\n\n    if (textElement && !isArrowElement(element)) {\n      mutateElement(textElement, { angle });\n    }\n  }\n};\n\nconst rescalePointsInElement = (\n  element: NonDeletedExcalidrawElement,\n  width: number,\n  height: number,\n  normalizePoints: boolean,\n) =>\n  isLinearElement(element) || isFreeDrawElement(element)\n    ? {\n        points: rescalePoints(\n          0,\n          width,\n          rescalePoints(1, height, element.points, normalizePoints),\n          normalizePoints,\n        ),\n      }\n    : {};\n\nconst MIN_FONT_SIZE = 1;\n\nconst measureFontSizeFromWidth = (\n  element: NonDeleted<ExcalidrawTextElement>,\n  nextWidth: number,\n  nextHeight: number,\n): { size: number; baseline: number } | null => {\n  // We only use width to scale font on resize\n  let width = element.width;\n\n  const hasContainer = isBoundToContainer(element);\n  if (hasContainer) {\n    const container = getContainerElement(element);\n    if (container) {\n      width = getBoundTextMaxWidth(container);\n    }\n  }\n  const nextFontSize = element.fontSize * (nextWidth / width);\n  if (nextFontSize < MIN_FONT_SIZE) {\n    return null;\n  }\n  const metrics = measureText(\n    element.text,\n    getFontString({ fontSize: nextFontSize, fontFamily: element.fontFamily }),\n    element.lineHeight,\n  );\n  return {\n    size: nextFontSize,\n    baseline: metrics.baseline + (nextHeight - metrics.height),\n  };\n};\n\nconst getSidesForTransformHandle = (\n  transformHandleType: TransformHandleType,\n  shouldResizeFromCenter: boolean,\n) => {\n  return {\n    n:\n      /^(n|ne|nw)$/.test(transformHandleType) ||\n      (shouldResizeFromCenter && /^(s|se|sw)$/.test(transformHandleType)),\n    s:\n      /^(s|se|sw)$/.test(transformHandleType) ||\n      (shouldResizeFromCenter && /^(n|ne|nw)$/.test(transformHandleType)),\n    w:\n      /^(w|nw|sw)$/.test(transformHandleType) ||\n      (shouldResizeFromCenter && /^(e|ne|se)$/.test(transformHandleType)),\n    e:\n      /^(e|ne|se)$/.test(transformHandleType) ||\n      (shouldResizeFromCenter && /^(w|nw|sw)$/.test(transformHandleType)),\n  };\n};\n\nconst resizeSingleTextElement = (\n  element: NonDeleted<ExcalidrawTextElement>,\n  transformHandleType: \"nw\" | \"ne\" | \"sw\" | \"se\",\n  shouldResizeFromCenter: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  // rotation pointer with reverse angle\n  const [rotatedX, rotatedY] = rotate(\n    pointerX,\n    pointerY,\n    cx,\n    cy,\n    -element.angle,\n  );\n  let scale: number;\n  switch (transformHandleType) {\n    case \"se\":\n      scale = Math.max(\n        (rotatedX - x1) / (x2 - x1),\n        (rotatedY - y1) / (y2 - y1),\n      );\n      break;\n    case \"nw\":\n      scale = Math.max(\n        (x2 - rotatedX) / (x2 - x1),\n        (y2 - rotatedY) / (y2 - y1),\n      );\n      break;\n    case \"ne\":\n      scale = Math.max(\n        (rotatedX - x1) / (x2 - x1),\n        (y2 - rotatedY) / (y2 - y1),\n      );\n      break;\n    case \"sw\":\n      scale = Math.max(\n        (x2 - rotatedX) / (x2 - x1),\n        (rotatedY - y1) / (y2 - y1),\n      );\n      break;\n  }\n  if (scale > 0) {\n    const nextWidth = element.width * scale;\n    const nextHeight = element.height * scale;\n    const metrics = measureFontSizeFromWidth(element, nextWidth, nextHeight);\n    if (metrics === null) {\n      return;\n    }\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n      false,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n    const [nextElementX, nextElementY] = adjustXYWithRotation(\n      getSidesForTransformHandle(transformHandleType, shouldResizeFromCenter),\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n    mutateElement(element, {\n      fontSize: metrics.size,\n      width: nextWidth,\n      height: nextHeight,\n      baseline: metrics.baseline,\n      x: nextElementX,\n      y: nextElementY,\n    });\n  }\n};\n\nexport const resizeSingleElement = (\n  originalElements: PointerDownState[\"originalElements\"],\n  shouldMaintainAspectRatio: boolean,\n  element: NonDeletedExcalidrawElement,\n  transformHandleDirection: TransformHandleDirection,\n  shouldResizeFromCenter: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  const stateAtResizeStart = originalElements.get(element.id)!;\n  // Gets bounds corners\n  const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(\n    stateAtResizeStart,\n    stateAtResizeStart.width,\n    stateAtResizeStart.height,\n    true,\n  );\n  const startTopLeft: Point = [x1, y1];\n  const startBottomRight: Point = [x2, y2];\n  const startCenter: Point = centerPoint(startTopLeft, startBottomRight);\n\n  // Calculate new dimensions based on cursor position\n  const rotatedPointer = rotatePoint(\n    [pointerX, pointerY],\n    startCenter,\n    -stateAtResizeStart.angle,\n  );\n\n  // Get bounds corners rendered on screen\n  const [esx1, esy1, esx2, esy2] = getResizedElementAbsoluteCoords(\n    element,\n    element.width,\n    element.height,\n    true,\n  );\n\n  const boundsCurrentWidth = esx2 - esx1;\n  const boundsCurrentHeight = esy2 - esy1;\n\n  // It's important we set the initial scale value based on the width and height at resize start,\n  // otherwise previous dimensions affected by modifiers will be taken into account.\n  const atStartBoundsWidth = startBottomRight[0] - startTopLeft[0];\n  const atStartBoundsHeight = startBottomRight[1] - startTopLeft[1];\n  let scaleX = atStartBoundsWidth / boundsCurrentWidth;\n  let scaleY = atStartBoundsHeight / boundsCurrentHeight;\n\n  let boundTextFont: { fontSize?: number; baseline?: number } = {};\n  const boundTextElement = getBoundTextElement(element);\n\n  if (transformHandleDirection.includes(\"e\")) {\n    scaleX = (rotatedPointer[0] - startTopLeft[0]) / boundsCurrentWidth;\n  }\n  if (transformHandleDirection.includes(\"s\")) {\n    scaleY = (rotatedPointer[1] - startTopLeft[1]) / boundsCurrentHeight;\n  }\n  if (transformHandleDirection.includes(\"w\")) {\n    scaleX = (startBottomRight[0] - rotatedPointer[0]) / boundsCurrentWidth;\n  }\n  if (transformHandleDirection.includes(\"n\")) {\n    scaleY = (startBottomRight[1] - rotatedPointer[1]) / boundsCurrentHeight;\n  }\n\n  // Linear elements dimensions differ from bounds dimensions\n  const eleInitialWidth = stateAtResizeStart.width;\n  const eleInitialHeight = stateAtResizeStart.height;\n  // We have to use dimensions of element on screen, otherwise the scaling of the\n  // dimensions won't match the cursor for linear elements.\n  let eleNewWidth = element.width * scaleX;\n  let eleNewHeight = element.height * scaleY;\n\n  // adjust dimensions for resizing from center\n  if (shouldResizeFromCenter) {\n    eleNewWidth = 2 * eleNewWidth - eleInitialWidth;\n    eleNewHeight = 2 * eleNewHeight - eleInitialHeight;\n  }\n\n  // adjust dimensions to keep sides ratio\n  if (shouldMaintainAspectRatio) {\n    const widthRatio = Math.abs(eleNewWidth) / eleInitialWidth;\n    const heightRatio = Math.abs(eleNewHeight) / eleInitialHeight;\n    if (transformHandleDirection.length === 1) {\n      eleNewHeight *= widthRatio;\n      eleNewWidth *= heightRatio;\n    }\n    if (transformHandleDirection.length === 2) {\n      const ratio = Math.max(widthRatio, heightRatio);\n      eleNewWidth = eleInitialWidth * ratio * Math.sign(eleNewWidth);\n      eleNewHeight = eleInitialHeight * ratio * Math.sign(eleNewHeight);\n    }\n  }\n\n  if (boundTextElement) {\n    const stateOfBoundTextElementAtResize = originalElements.get(\n      boundTextElement.id,\n    ) as typeof boundTextElement | undefined;\n    if (stateOfBoundTextElementAtResize) {\n      boundTextFont = {\n        fontSize: stateOfBoundTextElementAtResize.fontSize,\n        baseline: stateOfBoundTextElementAtResize.baseline,\n      };\n    }\n    if (shouldMaintainAspectRatio) {\n      const updatedElement = {\n        ...element,\n        width: eleNewWidth,\n        height: eleNewHeight,\n      };\n\n      const nextFont = measureFontSizeFromWidth(\n        boundTextElement,\n        getBoundTextMaxWidth(updatedElement),\n        getBoundTextMaxHeight(updatedElement, boundTextElement),\n      );\n      if (nextFont === null) {\n        return;\n      }\n      boundTextFont = {\n        fontSize: nextFont.size,\n        baseline: nextFont.baseline,\n      };\n    } else {\n      const minWidth = getApproxMinLineWidth(\n        getFontString(boundTextElement),\n        boundTextElement.lineHeight,\n      );\n      const minHeight = getApproxMinLineHeight(\n        boundTextElement.fontSize,\n        boundTextElement.lineHeight,\n      );\n      eleNewWidth = Math.ceil(Math.max(eleNewWidth, minWidth));\n      eleNewHeight = Math.ceil(Math.max(eleNewHeight, minHeight));\n    }\n  }\n\n  const [newBoundsX1, newBoundsY1, newBoundsX2, newBoundsY2] =\n    getResizedElementAbsoluteCoords(\n      stateAtResizeStart,\n      eleNewWidth,\n      eleNewHeight,\n      true,\n    );\n  const newBoundsWidth = newBoundsX2 - newBoundsX1;\n  const newBoundsHeight = newBoundsY2 - newBoundsY1;\n\n  // Calculate new topLeft based on fixed corner during resize\n  let newTopLeft = [...startTopLeft] as [number, number];\n  if ([\"n\", \"w\", \"nw\"].includes(transformHandleDirection)) {\n    newTopLeft = [\n      startBottomRight[0] - Math.abs(newBoundsWidth),\n      startBottomRight[1] - Math.abs(newBoundsHeight),\n    ];\n  }\n  if (transformHandleDirection === \"ne\") {\n    const bottomLeft = [startTopLeft[0], startBottomRight[1]];\n    newTopLeft = [bottomLeft[0], bottomLeft[1] - Math.abs(newBoundsHeight)];\n  }\n  if (transformHandleDirection === \"sw\") {\n    const topRight = [startBottomRight[0], startTopLeft[1]];\n    newTopLeft = [topRight[0] - Math.abs(newBoundsWidth), topRight[1]];\n  }\n\n  // Keeps opposite handle fixed during resize\n  if (shouldMaintainAspectRatio) {\n    if ([\"s\", \"n\"].includes(transformHandleDirection)) {\n      newTopLeft[0] = startCenter[0] - newBoundsWidth / 2;\n    }\n    if ([\"e\", \"w\"].includes(transformHandleDirection)) {\n      newTopLeft[1] = startCenter[1] - newBoundsHeight / 2;\n    }\n  }\n\n  // Flip horizontally\n  if (eleNewWidth < 0) {\n    if (transformHandleDirection.includes(\"e\")) {\n      newTopLeft[0] -= Math.abs(newBoundsWidth);\n    }\n    if (transformHandleDirection.includes(\"w\")) {\n      newTopLeft[0] += Math.abs(newBoundsWidth);\n    }\n  }\n  // Flip vertically\n  if (eleNewHeight < 0) {\n    if (transformHandleDirection.includes(\"s\")) {\n      newTopLeft[1] -= Math.abs(newBoundsHeight);\n    }\n    if (transformHandleDirection.includes(\"n\")) {\n      newTopLeft[1] += Math.abs(newBoundsHeight);\n    }\n  }\n\n  if (shouldResizeFromCenter) {\n    newTopLeft[0] = startCenter[0] - Math.abs(newBoundsWidth) / 2;\n    newTopLeft[1] = startCenter[1] - Math.abs(newBoundsHeight) / 2;\n  }\n\n  // adjust topLeft to new rotation point\n  const angle = stateAtResizeStart.angle;\n  const rotatedTopLeft = rotatePoint(newTopLeft, startCenter, angle);\n  const newCenter: Point = [\n    newTopLeft[0] + Math.abs(newBoundsWidth) / 2,\n    newTopLeft[1] + Math.abs(newBoundsHeight) / 2,\n  ];\n  const rotatedNewCenter = rotatePoint(newCenter, startCenter, angle);\n  newTopLeft = rotatePoint(rotatedTopLeft, rotatedNewCenter, -angle);\n\n  // Readjust points for linear elements\n  let rescaledElementPointsY;\n  let rescaledPoints;\n\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    rescaledElementPointsY = rescalePoints(\n      1,\n      eleNewHeight,\n      (stateAtResizeStart as ExcalidrawLinearElement).points,\n      true,\n    );\n\n    rescaledPoints = rescalePoints(\n      0,\n      eleNewWidth,\n      rescaledElementPointsY,\n      true,\n    );\n  }\n\n  // For linear elements (x,y) are the coordinates of the first drawn point not the top-left corner\n  // So we need to readjust (x,y) to be where the first point should be\n  const newOrigin = [...newTopLeft];\n  newOrigin[0] += stateAtResizeStart.x - newBoundsX1;\n  newOrigin[1] += stateAtResizeStart.y - newBoundsY1;\n  const resizedElement = {\n    width: Math.abs(eleNewWidth),\n    height: Math.abs(eleNewHeight),\n    x: newOrigin[0],\n    y: newOrigin[1],\n    points: rescaledPoints,\n  };\n\n  if (\"scale\" in element && \"scale\" in stateAtResizeStart) {\n    mutateElement(element, {\n      scale: [\n        // defaulting because scaleX/Y can be 0/-0\n        (Math.sign(newBoundsX2 - stateAtResizeStart.x) ||\n          stateAtResizeStart.scale[0]) * stateAtResizeStart.scale[0],\n        (Math.sign(newBoundsY2 - stateAtResizeStart.y) ||\n          stateAtResizeStart.scale[1]) * stateAtResizeStart.scale[1],\n      ],\n    });\n  }\n\n  if (\n    resizedElement.width !== 0 &&\n    resizedElement.height !== 0 &&\n    Number.isFinite(resizedElement.x) &&\n    Number.isFinite(resizedElement.y)\n  ) {\n    updateBoundElements(element, {\n      newSize: { width: resizedElement.width, height: resizedElement.height },\n    });\n\n    mutateElement(element, resizedElement);\n    if (boundTextElement && boundTextFont != null) {\n      mutateElement(boundTextElement, {\n        fontSize: boundTextFont.fontSize,\n        baseline: boundTextFont.baseline,\n      });\n    }\n    handleBindTextResize(element, transformHandleDirection);\n  }\n};\n\nexport const resizeMultipleElements = (\n  pointerDownState: PointerDownState,\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  transformHandleType: \"nw\" | \"ne\" | \"sw\" | \"se\",\n  shouldResizeFromCenter: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  // map selected elements to the original elements. While it never should\n  // happen that pointerDownState.originalElements won't contain the selected\n  // elements during resize, this coupling isn't guaranteed, so to ensure\n  // type safety we need to transform only those elements we filter.\n  const targetElements = selectedElements.reduce(\n    (\n      acc: {\n        /** element at resize start */\n        orig: NonDeletedExcalidrawElement;\n        /** latest element */\n        latest: NonDeletedExcalidrawElement;\n      }[],\n      element,\n    ) => {\n      const origElement = pointerDownState.originalElements.get(element.id);\n      if (origElement) {\n        acc.push({ orig: origElement, latest: element });\n      }\n      return acc;\n    },\n    [],\n  );\n\n  // getCommonBoundingBox() uses getBoundTextElement() which returns null for\n  // original elements from pointerDownState, so we have to find and add these\n  // bound text elements manually. Additionally, the coordinates of bound text\n  // elements aren't always up to date.\n  const boundTextElements = targetElements.reduce((acc, { orig }) => {\n    if (!isLinearElement(orig)) {\n      return acc;\n    }\n    const textId = getBoundTextElementId(orig);\n    if (!textId) {\n      return acc;\n    }\n    const text = pointerDownState.originalElements.get(textId) ?? null;\n    if (!isBoundToContainer(text)) {\n      return acc;\n    }\n    const xy = LinearElementEditor.getBoundTextElementPosition(orig, text);\n    return [...acc, { ...text, ...xy }];\n  }, [] as ExcalidrawTextElementWithContainer[]);\n\n  const { minX, minY, maxX, maxY, midX, midY } = getCommonBoundingBox(\n    targetElements.map(({ orig }) => orig).concat(boundTextElements),\n  );\n  const direction = transformHandleType;\n\n  const mapDirectionsToAnchors: Record<typeof direction, Point> = {\n    ne: [minX, maxY],\n    se: [minX, minY],\n    sw: [maxX, minY],\n    nw: [maxX, maxY],\n  };\n\n  // anchor point must be on the opposite side of the dragged selection handle\n  // or be the center of the selection if shouldResizeFromCenter\n  const [anchorX, anchorY]: Point = shouldResizeFromCenter\n    ? [midX, midY]\n    : mapDirectionsToAnchors[direction];\n\n  const scale =\n    Math.max(\n      Math.abs(pointerX - anchorX) / (maxX - minX) || 0,\n      Math.abs(pointerY - anchorY) / (maxY - minY) || 0,\n    ) * (shouldResizeFromCenter ? 2 : 1);\n\n  if (scale === 0) {\n    return;\n  }\n\n  const mapDirectionsToPointerPositions: Record<\n    typeof direction,\n    [x: boolean, y: boolean]\n  > = {\n    ne: [pointerX >= anchorX, pointerY <= anchorY],\n    se: [pointerX >= anchorX, pointerY >= anchorY],\n    sw: [pointerX <= anchorX, pointerY >= anchorY],\n    nw: [pointerX <= anchorX, pointerY <= anchorY],\n  };\n\n  /**\n   * to flip an element:\n   * 1. determine over which axis is the element being flipped\n   *    (could be x, y, or both) indicated by `flipFactorX` & `flipFactorY`\n   * 2. shift element's position by the amount of width or height (or both) or\n   *    mirror points in the case of linear & freedraw elemenets\n   * 3. adjust element angle\n   */\n  const [flipFactorX, flipFactorY] = mapDirectionsToPointerPositions[\n    direction\n  ].map((condition) => (condition ? 1 : -1));\n  const isFlippedByX = flipFactorX < 0;\n  const isFlippedByY = flipFactorY < 0;\n\n  const elementsAndUpdates: {\n    element: NonDeletedExcalidrawElement;\n    update: Mutable<\n      Pick<ExcalidrawElement, \"x\" | \"y\" | \"width\" | \"height\" | \"angle\">\n    > & {\n      points?: ExcalidrawLinearElement[\"points\"];\n      fontSize?: ExcalidrawTextElement[\"fontSize\"];\n      baseline?: ExcalidrawTextElement[\"baseline\"];\n      scale?: ExcalidrawImageElement[\"scale\"];\n    };\n    boundText: {\n      element: ExcalidrawTextElementWithContainer;\n      fontSize: ExcalidrawTextElement[\"fontSize\"];\n      baseline: ExcalidrawTextElement[\"baseline\"];\n    } | null;\n  }[] = [];\n\n  for (const { orig, latest } of targetElements) {\n    // bounded text elements are updated along with their container elements\n    if (isTextElement(orig) && isBoundToContainer(orig)) {\n      continue;\n    }\n\n    const width = orig.width * scale;\n    const height = orig.height * scale;\n    const angle = normalizeAngle(orig.angle * flipFactorX * flipFactorY);\n\n    const isLinearOrFreeDraw = isLinearElement(orig) || isFreeDrawElement(orig);\n    const offsetX = orig.x - anchorX;\n    const offsetY = orig.y - anchorY;\n    const shiftX = isFlippedByX && !isLinearOrFreeDraw ? width : 0;\n    const shiftY = isFlippedByY && !isLinearOrFreeDraw ? height : 0;\n    const x = anchorX + flipFactorX * (offsetX * scale + shiftX);\n    const y = anchorY + flipFactorY * (offsetY * scale + shiftY);\n\n    const rescaledPoints = rescalePointsInElement(\n      orig,\n      width * flipFactorX,\n      height * flipFactorY,\n      false,\n    );\n\n    const update: typeof elementsAndUpdates[0][\"update\"] = {\n      x,\n      y,\n      width,\n      height,\n      angle,\n      ...rescaledPoints,\n    };\n\n    if (isImageElement(orig) && targetElements.length === 1) {\n      update.scale = [orig.scale[0] * flipFactorX, orig.scale[1] * flipFactorY];\n    }\n\n    if (isLinearElement(orig) && (isFlippedByX || isFlippedByY)) {\n      const origBounds = getElementPointsCoords(orig, orig.points);\n      const newBounds = getElementPointsCoords(\n        { ...orig, x, y },\n        rescaledPoints.points!,\n      );\n      const origXY = [orig.x, orig.y];\n      const newXY = [x, y];\n\n      const linearShift = (axis: \"x\" | \"y\") => {\n        const i = axis === \"x\" ? 0 : 1;\n        return (\n          (newBounds[i + 2] -\n            newXY[i] -\n            (origXY[i] - origBounds[i]) * scale +\n            (origBounds[i + 2] - origXY[i]) * scale -\n            (newXY[i] - newBounds[i])) /\n          2\n        );\n      };\n\n      if (isFlippedByX) {\n        update.x -= linearShift(\"x\");\n      }\n\n      if (isFlippedByY) {\n        update.y -= linearShift(\"y\");\n      }\n    }\n\n    let boundText: typeof elementsAndUpdates[0][\"boundText\"] = null;\n\n    const boundTextElement = getBoundTextElement(latest);\n\n    if (boundTextElement || isTextElement(orig)) {\n      const updatedElement = {\n        ...latest,\n        width,\n        height,\n      };\n      const metrics = measureFontSizeFromWidth(\n        boundTextElement ?? (orig as ExcalidrawTextElement),\n        boundTextElement\n          ? getBoundTextMaxWidth(updatedElement)\n          : updatedElement.width,\n        boundTextElement\n          ? getBoundTextMaxHeight(updatedElement, boundTextElement)\n          : updatedElement.height,\n      );\n\n      if (!metrics) {\n        return;\n      }\n\n      if (isTextElement(orig)) {\n        update.fontSize = metrics.size;\n        update.baseline = metrics.baseline;\n      }\n\n      if (boundTextElement) {\n        boundText = {\n          element: boundTextElement,\n          fontSize: metrics.size,\n          baseline: metrics.baseline,\n        };\n      }\n    }\n\n    elementsAndUpdates.push({ element: latest, update, boundText });\n  }\n\n  const elementsToUpdate = elementsAndUpdates.map(({ element }) => element);\n\n  for (const { element, update, boundText } of elementsAndUpdates) {\n    const { width, height, angle } = update;\n\n    mutateElement(element, update, false);\n\n    updateBoundElements(element, {\n      simultaneouslyUpdated: elementsToUpdate,\n      newSize: { width, height },\n    });\n\n    if (boundText) {\n      const { element: boundTextElement, ...boundTextUpdates } = boundText;\n      mutateElement(\n        boundTextElement,\n        {\n          ...boundTextUpdates,\n          angle: isLinearElement(element) ? undefined : angle,\n        },\n        false,\n      );\n      handleBindTextResize(element, transformHandleType);\n    }\n  }\n\n  Scene.getScene(elementsAndUpdates[0].element)?.informMutation();\n};\n\nconst rotateMultipleElements = (\n  pointerDownState: PointerDownState,\n  elements: readonly NonDeletedExcalidrawElement[],\n  pointerX: number,\n  pointerY: number,\n  shouldRotateWithDiscreteAngle: boolean,\n  centerX: number,\n  centerY: number,\n) => {\n  let centerAngle =\n    (5 * Math.PI) / 2 + Math.atan2(pointerY - centerY, pointerX - centerX);\n  if (shouldRotateWithDiscreteAngle) {\n    centerAngle += SHIFT_LOCKING_ANGLE / 2;\n    centerAngle -= centerAngle % SHIFT_LOCKING_ANGLE;\n  }\n\n  elements\n    .filter((element) => element.type !== \"frame\")\n    .forEach((element) => {\n      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n      const cx = (x1 + x2) / 2;\n      const cy = (y1 + y2) / 2;\n      const origAngle =\n        pointerDownState.originalElements.get(element.id)?.angle ??\n        element.angle;\n      const [rotatedCX, rotatedCY] = rotate(\n        cx,\n        cy,\n        centerX,\n        centerY,\n        centerAngle + origAngle - element.angle,\n      );\n      mutateElement(\n        element,\n        {\n          x: element.x + (rotatedCX - cx),\n          y: element.y + (rotatedCY - cy),\n          angle: normalizeAngle(centerAngle + origAngle),\n        },\n        false,\n      );\n      updateBoundElements(element, { simultaneouslyUpdated: elements });\n\n      const boundText = getBoundTextElement(element);\n      if (boundText && !isArrowElement(element)) {\n        mutateElement(\n          boundText,\n          {\n            x: boundText.x + (rotatedCX - cx),\n            y: boundText.y + (rotatedCY - cy),\n            angle: normalizeAngle(centerAngle + origAngle),\n          },\n          false,\n        );\n      }\n    });\n\n  Scene.getScene(elements[0])?.informMutation();\n};\n\nexport const getResizeOffsetXY = (\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: NonDeletedExcalidrawElement[],\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1, x2, y2] =\n    selectedElements.length === 1\n      ? getElementAbsoluteCoords(selectedElements[0])\n      : getCommonBounds(selectedElements);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  const angle = selectedElements.length === 1 ? selectedElements[0].angle : 0;\n  [x, y] = rotate(x, y, cx, cy, -angle);\n  switch (transformHandleType) {\n    case \"n\":\n      return rotate(x - (x1 + x2) / 2, y - y1, 0, 0, angle);\n    case \"s\":\n      return rotate(x - (x1 + x2) / 2, y - y2, 0, 0, angle);\n    case \"w\":\n      return rotate(x - x1, y - (y1 + y2) / 2, 0, 0, angle);\n    case \"e\":\n      return rotate(x - x2, y - (y1 + y2) / 2, 0, 0, angle);\n    case \"nw\":\n      return rotate(x - x1, y - y1, 0, 0, angle);\n    case \"ne\":\n      return rotate(x - x2, y - y1, 0, 0, angle);\n    case \"sw\":\n      return rotate(x - x1, y - y2, 0, 0, angle);\n    case \"se\":\n      return rotate(x - x2, y - y2, 0, 0, angle);\n    default:\n      return [0, 0];\n  }\n};\n\nexport const getResizeArrowDirection = (\n  transformHandleType: MaybeTransformHandleType,\n  element: NonDeleted<ExcalidrawLinearElement>,\n): \"origin\" | \"end\" => {\n  const [, [px, py]] = element.points;\n  const isResizeEnd =\n    (transformHandleType === \"nw\" && (px < 0 || py < 0)) ||\n    (transformHandleType === \"ne\" && px >= 0) ||\n    (transformHandleType === \"sw\" && px <= 0) ||\n    (transformHandleType === \"se\" && (px > 0 || py > 0));\n  return isResizeEnd ? \"end\" : \"origin\";\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}