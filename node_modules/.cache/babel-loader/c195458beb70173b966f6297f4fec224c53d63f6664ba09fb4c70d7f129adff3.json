{"ast":null,"code":"import { getSceneVersion } from \"../../element\";\nimport { restoreElements } from \"../../data/restore\";\nimport { FILE_CACHE_MAX_AGE_SEC } from \"../app_constants\";\nimport { decompressData } from \"../../data/encode\";\nimport { encryptData, decryptData } from \"../../data/encryption\";\nimport { MIME_TYPES } from \"../../constants\";\nimport { reconcileElements } from \"../collab/reconciliation\";\nimport { getSyncableElements } from \".\";\n// private\n// -----------------------------------------------------------------------------\nlet FIREBASE_CONFIG;\ntry {\n  FIREBASE_CONFIG = JSON.parse(process.env.REACT_APP_FIREBASE_CONFIG);\n} catch (error) {\n  console.warn(`Error JSON parsing firebase config. Supplied value: ${process.env.REACT_APP_FIREBASE_CONFIG}`);\n  FIREBASE_CONFIG = {};\n}\nlet firebasePromise = null;\nlet firestorePromise = null;\nlet firebaseStoragePromise = null;\nlet isFirebaseInitialized = false;\nconst _loadFirebase = async () => {\n  const firebase = (await import( /* webpackChunkName: \"firebase\" */\"firebase/app\")).default;\n  if (!isFirebaseInitialized) {\n    try {\n      firebase.initializeApp(FIREBASE_CONFIG);\n    } catch (error) {\n      // trying initialize again throws. Usually this is harmless, and happens\n      // mainly in dev (HMR)\n      if (error.code === \"app/duplicate-app\") {\n        console.warn(error.name, error.code);\n      } else {\n        throw error;\n      }\n    }\n    isFirebaseInitialized = true;\n  }\n  return firebase;\n};\nconst _getFirebase = async () => {\n  if (!firebasePromise) {\n    firebasePromise = _loadFirebase();\n  }\n  return firebasePromise;\n};\n\n// -----------------------------------------------------------------------------\n\nconst loadFirestore = async () => {\n  const firebase = await _getFirebase();\n  if (!firestorePromise) {\n    firestorePromise = import( /* webpackChunkName: \"firestore\" */\"firebase/firestore\");\n  }\n  if (firestorePromise !== true) {\n    await firestorePromise;\n    firestorePromise = true;\n  }\n  return firebase;\n};\nexport const loadFirebaseStorage = async () => {\n  const firebase = await _getFirebase();\n  if (!firebaseStoragePromise) {\n    firebaseStoragePromise = import( /* webpackChunkName: \"storage\" */\"firebase/storage\");\n  }\n  if (firebaseStoragePromise !== true) {\n    await firebaseStoragePromise;\n    firebaseStoragePromise = true;\n  }\n  return firebase;\n};\nconst encryptElements = async (key, elements) => {\n  const json = JSON.stringify(elements);\n  const encoded = new TextEncoder().encode(json);\n  const {\n    encryptedBuffer,\n    iv\n  } = await encryptData(key, encoded);\n  return {\n    ciphertext: encryptedBuffer,\n    iv\n  };\n};\nconst decryptElements = async (data, roomKey) => {\n  const ciphertext = data.ciphertext.toUint8Array();\n  const iv = data.iv.toUint8Array();\n  const decrypted = await decryptData(iv, ciphertext, roomKey);\n  const decodedData = new TextDecoder(\"utf-8\").decode(new Uint8Array(decrypted));\n  return JSON.parse(decodedData);\n};\nclass FirebaseSceneVersionCache {}\nFirebaseSceneVersionCache.cache = new WeakMap();\nFirebaseSceneVersionCache.get = socket => {\n  return FirebaseSceneVersionCache.cache.get(socket);\n};\nFirebaseSceneVersionCache.set = (socket, elements) => {\n  FirebaseSceneVersionCache.cache.set(socket, getSceneVersion(elements));\n};\nexport const isSavedToFirebase = (portal, elements) => {\n  if (portal.socket && portal.roomId && portal.roomKey) {\n    const sceneVersion = getSceneVersion(elements);\n    return FirebaseSceneVersionCache.get(portal.socket) === sceneVersion;\n  }\n  // if no room exists, consider the room saved so that we don't unnecessarily\n  // prevent unload (there's nothing we could do at that point anyway)\n  return true;\n};\nexport const saveFilesToFirebase = async _ref => {\n  let {\n    prefix,\n    files\n  } = _ref;\n  const firebase = await loadFirebaseStorage();\n  const erroredFiles = new Map();\n  const savedFiles = new Map();\n  await Promise.all(files.map(async _ref2 => {\n    let {\n      id,\n      buffer\n    } = _ref2;\n    try {\n      await firebase.storage().ref(`${prefix}/${id}`).put(new Blob([buffer], {\n        type: MIME_TYPES.binary\n      }), {\n        cacheControl: `public, max-age=${FILE_CACHE_MAX_AGE_SEC}`\n      });\n      savedFiles.set(id, true);\n    } catch (error) {\n      erroredFiles.set(id, true);\n    }\n  }));\n  return {\n    savedFiles,\n    erroredFiles\n  };\n};\nconst createFirebaseSceneDocument = async (firebase, elements, roomKey) => {\n  const sceneVersion = getSceneVersion(elements);\n  const {\n    ciphertext,\n    iv\n  } = await encryptElements(roomKey, elements);\n  return {\n    sceneVersion,\n    ciphertext: firebase.firestore.Blob.fromUint8Array(new Uint8Array(ciphertext)),\n    iv: firebase.firestore.Blob.fromUint8Array(iv)\n  };\n};\nexport const saveToFirebase = async (portal, elements, appState) => {\n  const {\n    roomId,\n    roomKey,\n    socket\n  } = portal;\n  if (\n  // bail if no room exists as there's nothing we can do at this point\n  !roomId || !roomKey || !socket || isSavedToFirebase(portal, elements)) {\n    return false;\n  }\n  const firebase = await loadFirestore();\n  const firestore = firebase.firestore();\n  const docRef = firestore.collection(\"scenes\").doc(roomId);\n  const savedData = await firestore.runTransaction(async transaction => {\n    const snapshot = await transaction.get(docRef);\n    if (!snapshot.exists) {\n      const sceneDocument = await createFirebaseSceneDocument(firebase, elements, roomKey);\n      transaction.set(docRef, sceneDocument);\n      return {\n        elements,\n        reconciledElements: null\n      };\n    }\n    const prevDocData = snapshot.data();\n    const prevElements = getSyncableElements(await decryptElements(prevDocData, roomKey));\n    const reconciledElements = getSyncableElements(reconcileElements(elements, prevElements, appState));\n    const sceneDocument = await createFirebaseSceneDocument(firebase, reconciledElements, roomKey);\n    transaction.update(docRef, sceneDocument);\n    return {\n      elements,\n      reconciledElements\n    };\n  });\n  FirebaseSceneVersionCache.set(socket, savedData.elements);\n  return {\n    reconciledElements: savedData.reconciledElements\n  };\n};\nexport const loadFromFirebase = async (roomId, roomKey, socket) => {\n  const firebase = await loadFirestore();\n  const db = firebase.firestore();\n  const docRef = db.collection(\"scenes\").doc(roomId);\n  const doc = await docRef.get();\n  if (!doc.exists) {\n    return null;\n  }\n  const storedScene = doc.data();\n  const elements = getSyncableElements(await decryptElements(storedScene, roomKey));\n  if (socket) {\n    FirebaseSceneVersionCache.set(socket, elements);\n  }\n  return restoreElements(elements, null);\n};\nexport const loadFilesFromFirebase = async (prefix, decryptionKey, filesIds) => {\n  const loadedFiles = [];\n  const erroredFiles = new Map();\n  await Promise.all([...new Set(filesIds)].map(async id => {\n    try {\n      const url = `https://firebasestorage.googleapis.com/v0/b/${FIREBASE_CONFIG.storageBucket}/o/${encodeURIComponent(prefix.replace(/^\\//, \"\"))}%2F${id}`;\n      const response = await fetch(`${url}?alt=media`);\n      if (response.status < 400) {\n        const arrayBuffer = await response.arrayBuffer();\n        const {\n          data,\n          metadata\n        } = await decompressData(new Uint8Array(arrayBuffer), {\n          decryptionKey\n        });\n        const dataURL = new TextDecoder().decode(data);\n        loadedFiles.push({\n          mimeType: metadata.mimeType || MIME_TYPES.binary,\n          id,\n          dataURL,\n          created: (metadata === null || metadata === void 0 ? void 0 : metadata.created) || Date.now(),\n          lastRetrieved: (metadata === null || metadata === void 0 ? void 0 : metadata.created) || Date.now()\n        });\n      } else {\n        erroredFiles.set(id, true);\n      }\n    } catch (error) {\n      erroredFiles.set(id, true);\n      console.error(error);\n    }\n  }));\n  return {\n    loadedFiles,\n    erroredFiles\n  };\n};","map":{"version":3,"names":["getSceneVersion","restoreElements","FILE_CACHE_MAX_AGE_SEC","decompressData","encryptData","decryptData","MIME_TYPES","reconcileElements","getSyncableElements","FIREBASE_CONFIG","JSON","parse","process","env","REACT_APP_FIREBASE_CONFIG","error","console","warn","firebasePromise","firestorePromise","firebaseStoragePromise","isFirebaseInitialized","_loadFirebase","firebase","default","initializeApp","code","name","_getFirebase","loadFirestore","loadFirebaseStorage","encryptElements","key","elements","json","stringify","encoded","TextEncoder","encode","encryptedBuffer","iv","ciphertext","decryptElements","data","roomKey","toUint8Array","decrypted","decodedData","TextDecoder","decode","Uint8Array","FirebaseSceneVersionCache","cache","WeakMap","get","socket","set","isSavedToFirebase","portal","roomId","sceneVersion","saveFilesToFirebase","_ref","prefix","files","erroredFiles","Map","savedFiles","Promise","all","map","_ref2","id","buffer","storage","ref","put","Blob","type","binary","cacheControl","createFirebaseSceneDocument","firestore","fromUint8Array","saveToFirebase","appState","docRef","collection","doc","savedData","runTransaction","transaction","snapshot","exists","sceneDocument","reconciledElements","prevDocData","prevElements","update","loadFromFirebase","db","storedScene","loadFilesFromFirebase","decryptionKey","filesIds","loadedFiles","Set","url","storageBucket","encodeURIComponent","replace","response","fetch","status","arrayBuffer","metadata","dataURL","push","mimeType","created","Date","now","lastRetrieved"],"sources":["D:/project/excalidraw-cn/src/excalidraw-app/data/firebase.ts"],"sourcesContent":["import { ExcalidrawElement, FileId } from \"../../element/types\";\nimport { getSceneVersion } from \"../../element\";\nimport Portal from \"../collab/Portal\";\nimport { restoreElements } from \"../../data/restore\";\nimport {\n  AppState,\n  BinaryFileData,\n  BinaryFileMetadata,\n  DataURL,\n} from \"../../types\";\nimport { FILE_CACHE_MAX_AGE_SEC } from \"../app_constants\";\nimport { decompressData } from \"../../data/encode\";\nimport { encryptData, decryptData } from \"../../data/encryption\";\nimport { MIME_TYPES } from \"../../constants\";\nimport { reconcileElements } from \"../collab/reconciliation\";\nimport { getSyncableElements, SyncableExcalidrawElement } from \".\";\nimport { ResolutionType } from \"../../utility-types\";\n\n// private\n// -----------------------------------------------------------------------------\n\nlet FIREBASE_CONFIG: Record<string, any>;\ntry {\n  FIREBASE_CONFIG = JSON.parse(process.env.REACT_APP_FIREBASE_CONFIG);\n} catch (error: any) {\n  console.warn(\n    `Error JSON parsing firebase config. Supplied value: ${process.env.REACT_APP_FIREBASE_CONFIG}`,\n  );\n  FIREBASE_CONFIG = {};\n}\n\nlet firebasePromise: Promise<typeof import(\"firebase/app\").default> | null =\n  null;\nlet firestorePromise: Promise<any> | null | true = null;\nlet firebaseStoragePromise: Promise<any> | null | true = null;\n\nlet isFirebaseInitialized = false;\n\nconst _loadFirebase = async () => {\n  const firebase = (\n    await import(/* webpackChunkName: \"firebase\" */ \"firebase/app\")\n  ).default;\n\n  if (!isFirebaseInitialized) {\n    try {\n      firebase.initializeApp(FIREBASE_CONFIG);\n    } catch (error: any) {\n      // trying initialize again throws. Usually this is harmless, and happens\n      // mainly in dev (HMR)\n      if (error.code === \"app/duplicate-app\") {\n        console.warn(error.name, error.code);\n      } else {\n        throw error;\n      }\n    }\n    isFirebaseInitialized = true;\n  }\n\n  return firebase;\n};\n\nconst _getFirebase = async (): Promise<\n  typeof import(\"firebase/app\").default\n> => {\n  if (!firebasePromise) {\n    firebasePromise = _loadFirebase();\n  }\n  return firebasePromise;\n};\n\n// -----------------------------------------------------------------------------\n\nconst loadFirestore = async () => {\n  const firebase = await _getFirebase();\n  if (!firestorePromise) {\n    firestorePromise = import(\n      /* webpackChunkName: \"firestore\" */ \"firebase/firestore\"\n    );\n  }\n  if (firestorePromise !== true) {\n    await firestorePromise;\n    firestorePromise = true;\n  }\n  return firebase;\n};\n\nexport const loadFirebaseStorage = async () => {\n  const firebase = await _getFirebase();\n  if (!firebaseStoragePromise) {\n    firebaseStoragePromise = import(\n      /* webpackChunkName: \"storage\" */ \"firebase/storage\"\n    );\n  }\n  if (firebaseStoragePromise !== true) {\n    await firebaseStoragePromise;\n    firebaseStoragePromise = true;\n  }\n  return firebase;\n};\n\ninterface FirebaseStoredScene {\n  sceneVersion: number;\n  iv: firebase.default.firestore.Blob;\n  ciphertext: firebase.default.firestore.Blob;\n}\n\nconst encryptElements = async (\n  key: string,\n  elements: readonly ExcalidrawElement[],\n): Promise<{ ciphertext: ArrayBuffer; iv: Uint8Array }> => {\n  const json = JSON.stringify(elements);\n  const encoded = new TextEncoder().encode(json);\n  const { encryptedBuffer, iv } = await encryptData(key, encoded);\n\n  return { ciphertext: encryptedBuffer, iv };\n};\n\nconst decryptElements = async (\n  data: FirebaseStoredScene,\n  roomKey: string,\n): Promise<readonly ExcalidrawElement[]> => {\n  const ciphertext = data.ciphertext.toUint8Array();\n  const iv = data.iv.toUint8Array();\n\n  const decrypted = await decryptData(iv, ciphertext, roomKey);\n  const decodedData = new TextDecoder(\"utf-8\").decode(\n    new Uint8Array(decrypted),\n  );\n  return JSON.parse(decodedData);\n};\n\nclass FirebaseSceneVersionCache {\n  private static cache = new WeakMap<SocketIOClient.Socket, number>();\n  static get = (socket: SocketIOClient.Socket) => {\n    return FirebaseSceneVersionCache.cache.get(socket);\n  };\n  static set = (\n    socket: SocketIOClient.Socket,\n    elements: readonly SyncableExcalidrawElement[],\n  ) => {\n    FirebaseSceneVersionCache.cache.set(socket, getSceneVersion(elements));\n  };\n}\n\nexport const isSavedToFirebase = (\n  portal: Portal,\n  elements: readonly ExcalidrawElement[],\n): boolean => {\n  if (portal.socket && portal.roomId && portal.roomKey) {\n    const sceneVersion = getSceneVersion(elements);\n\n    return FirebaseSceneVersionCache.get(portal.socket) === sceneVersion;\n  }\n  // if no room exists, consider the room saved so that we don't unnecessarily\n  // prevent unload (there's nothing we could do at that point anyway)\n  return true;\n};\n\nexport const saveFilesToFirebase = async ({\n  prefix,\n  files,\n}: {\n  prefix: string;\n  files: { id: FileId; buffer: Uint8Array }[];\n}) => {\n  const firebase = await loadFirebaseStorage();\n\n  const erroredFiles = new Map<FileId, true>();\n  const savedFiles = new Map<FileId, true>();\n\n  await Promise.all(\n    files.map(async ({ id, buffer }) => {\n      try {\n        await firebase\n          .storage()\n          .ref(`${prefix}/${id}`)\n          .put(\n            new Blob([buffer], {\n              type: MIME_TYPES.binary,\n            }),\n            {\n              cacheControl: `public, max-age=${FILE_CACHE_MAX_AGE_SEC}`,\n            },\n          );\n        savedFiles.set(id, true);\n      } catch (error: any) {\n        erroredFiles.set(id, true);\n      }\n    }),\n  );\n\n  return { savedFiles, erroredFiles };\n};\n\nconst createFirebaseSceneDocument = async (\n  firebase: ResolutionType<typeof loadFirestore>,\n  elements: readonly SyncableExcalidrawElement[],\n  roomKey: string,\n) => {\n  const sceneVersion = getSceneVersion(elements);\n  const { ciphertext, iv } = await encryptElements(roomKey, elements);\n  return {\n    sceneVersion,\n    ciphertext: firebase.firestore.Blob.fromUint8Array(\n      new Uint8Array(ciphertext),\n    ),\n    iv: firebase.firestore.Blob.fromUint8Array(iv),\n  } as FirebaseStoredScene;\n};\n\nexport const saveToFirebase = async (\n  portal: Portal,\n  elements: readonly SyncableExcalidrawElement[],\n  appState: AppState,\n) => {\n  const { roomId, roomKey, socket } = portal;\n  if (\n    // bail if no room exists as there's nothing we can do at this point\n    !roomId ||\n    !roomKey ||\n    !socket ||\n    isSavedToFirebase(portal, elements)\n  ) {\n    return false;\n  }\n\n  const firebase = await loadFirestore();\n  const firestore = firebase.firestore();\n\n  const docRef = firestore.collection(\"scenes\").doc(roomId);\n\n  const savedData = await firestore.runTransaction(async (transaction) => {\n    const snapshot = await transaction.get(docRef);\n\n    if (!snapshot.exists) {\n      const sceneDocument = await createFirebaseSceneDocument(\n        firebase,\n        elements,\n        roomKey,\n      );\n\n      transaction.set(docRef, sceneDocument);\n\n      return {\n        elements,\n        reconciledElements: null,\n      };\n    }\n\n    const prevDocData = snapshot.data() as FirebaseStoredScene;\n    const prevElements = getSyncableElements(\n      await decryptElements(prevDocData, roomKey),\n    );\n\n    const reconciledElements = getSyncableElements(\n      reconcileElements(elements, prevElements, appState),\n    );\n\n    const sceneDocument = await createFirebaseSceneDocument(\n      firebase,\n      reconciledElements,\n      roomKey,\n    );\n\n    transaction.update(docRef, sceneDocument);\n    return {\n      elements,\n      reconciledElements,\n    };\n  });\n\n  FirebaseSceneVersionCache.set(socket, savedData.elements);\n\n  return { reconciledElements: savedData.reconciledElements };\n};\n\nexport const loadFromFirebase = async (\n  roomId: string,\n  roomKey: string,\n  socket: SocketIOClient.Socket | null,\n): Promise<readonly ExcalidrawElement[] | null> => {\n  const firebase = await loadFirestore();\n  const db = firebase.firestore();\n\n  const docRef = db.collection(\"scenes\").doc(roomId);\n  const doc = await docRef.get();\n  if (!doc.exists) {\n    return null;\n  }\n  const storedScene = doc.data() as FirebaseStoredScene;\n  const elements = getSyncableElements(\n    await decryptElements(storedScene, roomKey),\n  );\n\n  if (socket) {\n    FirebaseSceneVersionCache.set(socket, elements);\n  }\n\n  return restoreElements(elements, null);\n};\n\nexport const loadFilesFromFirebase = async (\n  prefix: string,\n  decryptionKey: string,\n  filesIds: readonly FileId[],\n) => {\n  const loadedFiles: BinaryFileData[] = [];\n  const erroredFiles = new Map<FileId, true>();\n\n  await Promise.all(\n    [...new Set(filesIds)].map(async (id) => {\n      try {\n        const url = `https://firebasestorage.googleapis.com/v0/b/${\n          FIREBASE_CONFIG.storageBucket\n        }/o/${encodeURIComponent(prefix.replace(/^\\//, \"\"))}%2F${id}`;\n        const response = await fetch(`${url}?alt=media`);\n        if (response.status < 400) {\n          const arrayBuffer = await response.arrayBuffer();\n\n          const { data, metadata } = await decompressData<BinaryFileMetadata>(\n            new Uint8Array(arrayBuffer),\n            {\n              decryptionKey,\n            },\n          );\n\n          const dataURL = new TextDecoder().decode(data) as DataURL;\n\n          loadedFiles.push({\n            mimeType: metadata.mimeType || MIME_TYPES.binary,\n            id,\n            dataURL,\n            created: metadata?.created || Date.now(),\n            lastRetrieved: metadata?.created || Date.now(),\n          });\n        } else {\n          erroredFiles.set(id, true);\n        }\n      } catch (error: any) {\n        erroredFiles.set(id, true);\n        console.error(error);\n      }\n    }),\n  );\n\n  return { loadedFiles, erroredFiles };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}