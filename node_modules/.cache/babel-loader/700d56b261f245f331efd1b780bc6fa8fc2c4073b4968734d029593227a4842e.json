{"ast":null,"code":"import { compressData, decompressData } from \"../../data/encode\";\nimport { decryptData, generateEncryptionKey, IV_LENGTH_BYTES } from \"../../data/encryption\";\nimport { serializeAsJSON } from \"../../data/json\";\nimport { restore } from \"../../data/restore\";\nimport { isInvisiblySmallElement } from \"../../element/sizeHelpers\";\nimport { isInitializedImageElement } from \"../../element/typeChecks\";\nimport { t } from \"../../i18n\";\nimport { bytesToHexString } from \"../../utils\";\nimport { DELETED_ELEMENT_TIMEOUT, FILE_UPLOAD_MAX_BYTES, ROOM_ID_BYTES } from \"../app_constants\";\nimport { encodeFilesForUpload } from \"./FileManager\";\nimport { saveFilesToFirebase } from \"./firebase\";\nexport const isSyncableElement = element => {\n  if (element.isDeleted) {\n    if (element.updated > Date.now() - DELETED_ELEMENT_TIMEOUT) {\n      return true;\n    }\n    return false;\n  }\n  return !isInvisiblySmallElement(element);\n};\nexport const getSyncableElements = elements => elements.filter(element => isSyncableElement(element));\nconst BACKEND_V2_GET = process.env.REACT_APP_BACKEND_V2_GET_URL;\nconst BACKEND_V2_POST = process.env.REACT_APP_BACKEND_V2_POST_URL;\nconst generateRoomId = async () => {\n  const buffer = new Uint8Array(ROOM_ID_BYTES);\n  window.crypto.getRandomValues(buffer);\n  return bytesToHexString(buffer);\n};\n\n/**\n * Right now the reason why we resolve connection params (url, polling...)\n * from upstream is to allow changing the params immediately when needed without\n * having to wait for clients to update the SW.\n *\n * If REACT_APP_WS_SERVER_URL env is set, we use that instead (useful for forks)\n */\nexport const getCollabServer = async () => {\n  if (process.env.REACT_APP_WS_SERVER_URL) {\n    return {\n      url: process.env.REACT_APP_WS_SERVER_URL,\n      polling: true\n    };\n  }\n  try {\n    const resp = await fetch(`${process.env.REACT_APP_PORTAL_URL}/collab-server`);\n    return await resp.json();\n  } catch (error) {\n    console.error(error);\n    throw new Error(t(\"errors.cannotResolveCollabServer\"));\n  }\n};\nconst RE_COLLAB_LINK = /^#room=([a-zA-Z0-9_-]+),([a-zA-Z0-9_-]+)$/;\nexport const isCollaborationLink = link => {\n  const hash = new URL(link).hash;\n  return RE_COLLAB_LINK.test(hash);\n};\nexport const getCollaborationLinkData = link => {\n  const hash = new URL(link).hash;\n  const match = hash.match(RE_COLLAB_LINK);\n  if (match && match[2].length !== 22) {\n    window.alert(t(\"alerts.invalidEncryptionKey\"));\n    return null;\n  }\n  return match ? {\n    roomId: match[1],\n    roomKey: match[2]\n  } : null;\n};\nexport const generateCollaborationLinkData = async () => {\n  const roomId = await generateRoomId();\n  const roomKey = await generateEncryptionKey();\n  if (!roomKey) {\n    throw new Error(\"Couldn't generate room key\");\n  }\n  return {\n    roomId,\n    roomKey\n  };\n};\nexport const getCollaborationLink = data => {\n  return `${window.location.origin}${window.location.pathname}#room=${data.roomId},${data.roomKey}`;\n};\n\n/**\n * Decodes shareLink data using the legacy buffer format.\n * @deprecated\n */\nconst legacy_decodeFromBackend = async _ref => {\n  let {\n    buffer,\n    decryptionKey\n  } = _ref;\n  let decrypted;\n  try {\n    // Buffer should contain both the IV (fixed length) and encrypted data\n    const iv = buffer.slice(0, IV_LENGTH_BYTES);\n    const encrypted = buffer.slice(IV_LENGTH_BYTES, buffer.byteLength);\n    decrypted = await decryptData(new Uint8Array(iv), encrypted, decryptionKey);\n  } catch (error) {\n    // Fixed IV (old format, backward compatibility)\n    const fixedIv = new Uint8Array(IV_LENGTH_BYTES);\n    decrypted = await decryptData(fixedIv, buffer, decryptionKey);\n  }\n\n  // We need to convert the decrypted array buffer to a string\n  const string = new window.TextDecoder(\"utf-8\").decode(new Uint8Array(decrypted));\n  const data = JSON.parse(string);\n  return {\n    elements: data.elements || null,\n    appState: data.appState || null\n  };\n};\nconst importFromBackend = async (id, decryptionKey) => {\n  try {\n    const response = await fetch(`${BACKEND_V2_GET}${id}`);\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return {};\n    }\n    const buffer = await response.arrayBuffer();\n    try {\n      const {\n        data: decodedBuffer\n      } = await decompressData(new Uint8Array(buffer), {\n        decryptionKey\n      });\n      const data = JSON.parse(new TextDecoder().decode(decodedBuffer));\n      return {\n        elements: data.elements || null,\n        appState: data.appState || null\n      };\n    } catch (error) {\n      console.warn(\"error when decoding shareLink data using the new format:\", error);\n      return legacy_decodeFromBackend({\n        buffer,\n        decryptionKey\n      });\n    }\n  } catch (error) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n    return {};\n  }\n};\nexport const loadScene = async (id, privateKey, localDataState) => {\n  let data;\n  if (id != null && privateKey != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = restore(await importFromBackend(id, privateKey), localDataState === null || localDataState === void 0 ? void 0 : localDataState.appState, localDataState === null || localDataState === void 0 ? void 0 : localDataState.elements, {\n      repairBindings: true,\n      refreshDimensions: false\n    });\n  } else {\n    data = restore(localDataState || null, null, null, {\n      repairBindings: true\n    });\n  }\n  return {\n    elements: data.elements,\n    appState: data.appState,\n    // note: this will always be empty because we're not storing files\n    // in the scene database/localStorage, and instead fetch them async\n    // from a different database\n    files: data.files,\n    commitToHistory: false\n  };\n};\nexport const exportToBackend = async (elements, appState, files) => {\n  const encryptionKey = await generateEncryptionKey(\"string\");\n  const payload = await compressData(new TextEncoder().encode(serializeAsJSON(elements, appState, files, \"database\")), {\n    encryptionKey\n  });\n  try {\n    const filesMap = new Map();\n    for (const element of elements) {\n      if (isInitializedImageElement(element) && files[element.fileId]) {\n        filesMap.set(element.fileId, files[element.fileId]);\n      }\n    }\n    const filesToUpload = await encodeFilesForUpload({\n      files: filesMap,\n      encryptionKey,\n      maxBytes: FILE_UPLOAD_MAX_BYTES\n    });\n    const response = await fetch(BACKEND_V2_POST, {\n      method: \"POST\",\n      body: payload.buffer\n    });\n    const json = await response.json();\n    if (json.id) {\n      const url = new URL(window.location.href);\n      // We need to store the key (and less importantly the id) as hash instead\n      // of queryParam in order to never send it to the server\n      url.hash = `json=${json.id},${encryptionKey}`;\n      const urlString = url.toString();\n      await saveFilesToFirebase({\n        prefix: `/files/shareLinks/${json.id}`,\n        files: filesToUpload\n      });\n      return {\n        url: urlString,\n        errorMessage: null\n      };\n    } else if (json.error_class === \"RequestTooLargeError\") {\n      return {\n        url: null,\n        errorMessage: t(\"alerts.couldNotCreateShareableLinkTooBig\")\n      };\n    }\n    return {\n      url: null,\n      errorMessage: t(\"alerts.couldNotCreateShareableLink\")\n    };\n  } catch (error) {\n    console.error(error);\n    return {\n      url: null,\n      errorMessage: t(\"alerts.couldNotCreateShareableLink\")\n    };\n  }\n};","map":{"version":3,"names":["compressData","decompressData","decryptData","generateEncryptionKey","IV_LENGTH_BYTES","serializeAsJSON","restore","isInvisiblySmallElement","isInitializedImageElement","t","bytesToHexString","DELETED_ELEMENT_TIMEOUT","FILE_UPLOAD_MAX_BYTES","ROOM_ID_BYTES","encodeFilesForUpload","saveFilesToFirebase","isSyncableElement","element","isDeleted","updated","Date","now","getSyncableElements","elements","filter","BACKEND_V2_GET","process","env","REACT_APP_BACKEND_V2_GET_URL","BACKEND_V2_POST","REACT_APP_BACKEND_V2_POST_URL","generateRoomId","buffer","Uint8Array","window","crypto","getRandomValues","getCollabServer","REACT_APP_WS_SERVER_URL","url","polling","resp","fetch","REACT_APP_PORTAL_URL","json","error","console","Error","RE_COLLAB_LINK","isCollaborationLink","link","hash","URL","test","getCollaborationLinkData","match","length","alert","roomId","roomKey","generateCollaborationLinkData","getCollaborationLink","data","location","origin","pathname","legacy_decodeFromBackend","_ref","decryptionKey","decrypted","iv","slice","encrypted","byteLength","fixedIv","string","TextDecoder","decode","JSON","parse","appState","importFromBackend","id","response","ok","arrayBuffer","decodedBuffer","warn","loadScene","privateKey","localDataState","repairBindings","refreshDimensions","files","commitToHistory","exportToBackend","encryptionKey","payload","TextEncoder","encode","filesMap","Map","fileId","set","filesToUpload","maxBytes","method","body","href","urlString","toString","prefix","errorMessage","error_class"],"sources":["D:/project/excalidraw-cn/src/excalidraw-app/data/index.ts"],"sourcesContent":["import { compressData, decompressData } from \"../../data/encode\";\nimport {\n  decryptData,\n  generateEncryptionKey,\n  IV_LENGTH_BYTES,\n} from \"../../data/encryption\";\nimport { serializeAsJSON } from \"../../data/json\";\nimport { restore } from \"../../data/restore\";\nimport { ImportedDataState } from \"../../data/types\";\nimport { isInvisiblySmallElement } from \"../../element/sizeHelpers\";\nimport { isInitializedImageElement } from \"../../element/typeChecks\";\nimport { ExcalidrawElement, FileId } from \"../../element/types\";\nimport { t } from \"../../i18n\";\nimport {\n  AppState,\n  BinaryFileData,\n  BinaryFiles,\n  UserIdleState,\n} from \"../../types\";\nimport { bytesToHexString } from \"../../utils\";\nimport {\n  DELETED_ELEMENT_TIMEOUT,\n  FILE_UPLOAD_MAX_BYTES,\n  ROOM_ID_BYTES,\n} from \"../app_constants\";\nimport { encodeFilesForUpload } from \"./FileManager\";\nimport { saveFilesToFirebase } from \"./firebase\";\n\nexport type SyncableExcalidrawElement = ExcalidrawElement & {\n  _brand: \"SyncableExcalidrawElement\";\n};\n\nexport const isSyncableElement = (\n  element: ExcalidrawElement,\n): element is SyncableExcalidrawElement => {\n  if (element.isDeleted) {\n    if (element.updated > Date.now() - DELETED_ELEMENT_TIMEOUT) {\n      return true;\n    }\n    return false;\n  }\n  return !isInvisiblySmallElement(element);\n};\n\nexport const getSyncableElements = (elements: readonly ExcalidrawElement[]) =>\n  elements.filter((element) =>\n    isSyncableElement(element),\n  ) as SyncableExcalidrawElement[];\n\nconst BACKEND_V2_GET = process.env.REACT_APP_BACKEND_V2_GET_URL;\nconst BACKEND_V2_POST = process.env.REACT_APP_BACKEND_V2_POST_URL;\n\nconst generateRoomId = async () => {\n  const buffer = new Uint8Array(ROOM_ID_BYTES);\n  window.crypto.getRandomValues(buffer);\n  return bytesToHexString(buffer);\n};\n\n/**\n * Right now the reason why we resolve connection params (url, polling...)\n * from upstream is to allow changing the params immediately when needed without\n * having to wait for clients to update the SW.\n *\n * If REACT_APP_WS_SERVER_URL env is set, we use that instead (useful for forks)\n */\nexport const getCollabServer = async (): Promise<{\n  url: string;\n  polling: boolean;\n}> => {\n  if (process.env.REACT_APP_WS_SERVER_URL) {\n    return {\n      url: process.env.REACT_APP_WS_SERVER_URL,\n      polling: true,\n    };\n  }\n\n  try {\n    const resp = await fetch(\n      `${process.env.REACT_APP_PORTAL_URL}/collab-server`,\n    );\n    return await resp.json();\n  } catch (error) {\n    console.error(error);\n    throw new Error(t(\"errors.cannotResolveCollabServer\"));\n  }\n};\n\nexport type EncryptedData = {\n  data: ArrayBuffer;\n  iv: Uint8Array;\n};\n\nexport type SocketUpdateDataSource = {\n  SCENE_INIT: {\n    type: \"SCENE_INIT\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  SCENE_UPDATE: {\n    type: \"SCENE_UPDATE\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  MOUSE_LOCATION: {\n    type: \"MOUSE_LOCATION\";\n    payload: {\n      socketId: string;\n      pointer: { x: number; y: number };\n      button: \"down\" | \"up\";\n      selectedElementIds: AppState[\"selectedElementIds\"];\n      username: string;\n    };\n  };\n  IDLE_STATUS: {\n    type: \"IDLE_STATUS\";\n    payload: {\n      socketId: string;\n      userState: UserIdleState;\n      username: string;\n    };\n  };\n};\n\nexport type SocketUpdateDataIncoming =\n  | SocketUpdateDataSource[keyof SocketUpdateDataSource]\n  | {\n      type: \"INVALID_RESPONSE\";\n    };\n\nexport type SocketUpdateData =\n  SocketUpdateDataSource[keyof SocketUpdateDataSource] & {\n    _brand: \"socketUpdateData\";\n  };\n\nconst RE_COLLAB_LINK = /^#room=([a-zA-Z0-9_-]+),([a-zA-Z0-9_-]+)$/;\n\nexport const isCollaborationLink = (link: string) => {\n  const hash = new URL(link).hash;\n  return RE_COLLAB_LINK.test(hash);\n};\n\nexport const getCollaborationLinkData = (link: string) => {\n  const hash = new URL(link).hash;\n  const match = hash.match(RE_COLLAB_LINK);\n  if (match && match[2].length !== 22) {\n    window.alert(t(\"alerts.invalidEncryptionKey\"));\n    return null;\n  }\n  return match ? { roomId: match[1], roomKey: match[2] } : null;\n};\n\nexport const generateCollaborationLinkData = async () => {\n  const roomId = await generateRoomId();\n  const roomKey = await generateEncryptionKey();\n\n  if (!roomKey) {\n    throw new Error(\"Couldn't generate room key\");\n  }\n\n  return { roomId, roomKey };\n};\n\nexport const getCollaborationLink = (data: {\n  roomId: string;\n  roomKey: string;\n}) => {\n  return `${window.location.origin}${window.location.pathname}#room=${data.roomId},${data.roomKey}`;\n};\n\n/**\n * Decodes shareLink data using the legacy buffer format.\n * @deprecated\n */\nconst legacy_decodeFromBackend = async ({\n  buffer,\n  decryptionKey,\n}: {\n  buffer: ArrayBuffer;\n  decryptionKey: string;\n}) => {\n  let decrypted: ArrayBuffer;\n\n  try {\n    // Buffer should contain both the IV (fixed length) and encrypted data\n    const iv = buffer.slice(0, IV_LENGTH_BYTES);\n    const encrypted = buffer.slice(IV_LENGTH_BYTES, buffer.byteLength);\n    decrypted = await decryptData(new Uint8Array(iv), encrypted, decryptionKey);\n  } catch (error: any) {\n    // Fixed IV (old format, backward compatibility)\n    const fixedIv = new Uint8Array(IV_LENGTH_BYTES);\n    decrypted = await decryptData(fixedIv, buffer, decryptionKey);\n  }\n\n  // We need to convert the decrypted array buffer to a string\n  const string = new window.TextDecoder(\"utf-8\").decode(\n    new Uint8Array(decrypted),\n  );\n  const data: ImportedDataState = JSON.parse(string);\n\n  return {\n    elements: data.elements || null,\n    appState: data.appState || null,\n  };\n};\n\nconst importFromBackend = async (\n  id: string,\n  decryptionKey: string,\n): Promise<ImportedDataState> => {\n  try {\n    const response = await fetch(`${BACKEND_V2_GET}${id}`);\n\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return {};\n    }\n    const buffer = await response.arrayBuffer();\n\n    try {\n      const { data: decodedBuffer } = await decompressData(\n        new Uint8Array(buffer),\n        {\n          decryptionKey,\n        },\n      );\n      const data: ImportedDataState = JSON.parse(\n        new TextDecoder().decode(decodedBuffer),\n      );\n\n      return {\n        elements: data.elements || null,\n        appState: data.appState || null,\n      };\n    } catch (error: any) {\n      console.warn(\n        \"error when decoding shareLink data using the new format:\",\n        error,\n      );\n      return legacy_decodeFromBackend({ buffer, decryptionKey });\n    }\n  } catch (error: any) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n    return {};\n  }\n};\n\nexport const loadScene = async (\n  id: string | null,\n  privateKey: string | null,\n  // Supply local state even if importing from backend to ensure we restore\n  // localStorage user settings which we do not persist on server.\n  // Non-optional so we don't forget to pass it even if `undefined`.\n  localDataState: ImportedDataState | undefined | null,\n) => {\n  let data;\n  if (id != null && privateKey != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = restore(\n      await importFromBackend(id, privateKey),\n      localDataState?.appState,\n      localDataState?.elements,\n      { repairBindings: true, refreshDimensions: false },\n    );\n  } else {\n    data = restore(localDataState || null, null, null, {\n      repairBindings: true,\n    });\n  }\n\n  return {\n    elements: data.elements,\n    appState: data.appState,\n    // note: this will always be empty because we're not storing files\n    // in the scene database/localStorage, and instead fetch them async\n    // from a different database\n    files: data.files,\n    commitToHistory: false,\n  };\n};\n\ntype ExportToBackendResult =\n  | { url: null; errorMessage: string }\n  | { url: string; errorMessage: null };\n\nexport const exportToBackend = async (\n  elements: readonly ExcalidrawElement[],\n  appState: Partial<AppState>,\n  files: BinaryFiles,\n): Promise<ExportToBackendResult> => {\n  const encryptionKey = await generateEncryptionKey(\"string\");\n\n  const payload = await compressData(\n    new TextEncoder().encode(\n      serializeAsJSON(elements, appState, files, \"database\"),\n    ),\n    { encryptionKey },\n  );\n\n  try {\n    const filesMap = new Map<FileId, BinaryFileData>();\n    for (const element of elements) {\n      if (isInitializedImageElement(element) && files[element.fileId]) {\n        filesMap.set(element.fileId, files[element.fileId]);\n      }\n    }\n\n    const filesToUpload = await encodeFilesForUpload({\n      files: filesMap,\n      encryptionKey,\n      maxBytes: FILE_UPLOAD_MAX_BYTES,\n    });\n\n    const response = await fetch(BACKEND_V2_POST, {\n      method: \"POST\",\n      body: payload.buffer,\n    });\n    const json = await response.json();\n    if (json.id) {\n      const url = new URL(window.location.href);\n      // We need to store the key (and less importantly the id) as hash instead\n      // of queryParam in order to never send it to the server\n      url.hash = `json=${json.id},${encryptionKey}`;\n      const urlString = url.toString();\n\n      await saveFilesToFirebase({\n        prefix: `/files/shareLinks/${json.id}`,\n        files: filesToUpload,\n      });\n\n      return { url: urlString, errorMessage: null };\n    } else if (json.error_class === \"RequestTooLargeError\") {\n      return {\n        url: null,\n        errorMessage: t(\"alerts.couldNotCreateShareableLinkTooBig\"),\n      };\n    }\n\n    return { url: null, errorMessage: t(\"alerts.couldNotCreateShareableLink\") };\n  } catch (error: any) {\n    console.error(error);\n\n    return { url: null, errorMessage: t(\"alerts.couldNotCreateShareableLink\") };\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}