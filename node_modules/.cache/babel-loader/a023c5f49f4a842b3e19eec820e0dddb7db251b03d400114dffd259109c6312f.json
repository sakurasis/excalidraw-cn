{"ast":null,"code":"import { pointsOnBezierCurves, simplify } from 'points-on-curve';\nimport { parsePath, absolutize, normalize } from 'path-data-parser';\nexport function pointsOnPath(path, tolerance, distance) {\n  const segments = parsePath(path);\n  const normalized = normalize(absolutize(segments));\n  const sets = [];\n  let currentPoints = [];\n  let start = [0, 0];\n  let pendingCurve = [];\n  const appendPendingCurve = () => {\n    if (pendingCurve.length >= 4) {\n      currentPoints.push(...pointsOnBezierCurves(pendingCurve, tolerance));\n    }\n    pendingCurve = [];\n  };\n  const appendPendingPoints = () => {\n    appendPendingCurve();\n    if (currentPoints.length) {\n      sets.push(currentPoints);\n      currentPoints = [];\n    }\n  };\n  for (const {\n    key,\n    data\n  } of normalized) {\n    switch (key) {\n      case 'M':\n        appendPendingPoints();\n        start = [data[0], data[1]];\n        currentPoints.push(start);\n        break;\n      case 'L':\n        appendPendingCurve();\n        currentPoints.push([data[0], data[1]]);\n        break;\n      case 'C':\n        if (!pendingCurve.length) {\n          const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;\n          pendingCurve.push([lastPoint[0], lastPoint[1]]);\n        }\n        pendingCurve.push([data[0], data[1]]);\n        pendingCurve.push([data[2], data[3]]);\n        pendingCurve.push([data[4], data[5]]);\n        break;\n      case 'Z':\n        appendPendingCurve();\n        currentPoints.push([start[0], start[1]]);\n        break;\n    }\n  }\n  appendPendingPoints();\n  if (!distance) {\n    return sets;\n  }\n  const out = [];\n  for (const set of sets) {\n    const simplifiedSet = simplify(set, distance);\n    if (simplifiedSet.length) {\n      out.push(simplifiedSet);\n    }\n  }\n  return out;\n}","map":{"version":3,"names":["pointsOnBezierCurves","simplify","parsePath","absolutize","normalize","pointsOnPath","path","tolerance","distance","segments","normalized","sets","currentPoints","start","pendingCurve","appendPendingCurve","length","push","appendPendingPoints","key","data","lastPoint","out","set","simplifiedSet"],"sources":["D:/project/excalidraw-cn/node_modules/points-on-path/lib/index.js"],"sourcesContent":["import { pointsOnBezierCurves, simplify } from 'points-on-curve';\nimport { parsePath, absolutize, normalize } from 'path-data-parser';\nexport function pointsOnPath(path, tolerance, distance) {\n    const segments = parsePath(path);\n    const normalized = normalize(absolutize(segments));\n    const sets = [];\n    let currentPoints = [];\n    let start = [0, 0];\n    let pendingCurve = [];\n    const appendPendingCurve = () => {\n        if (pendingCurve.length >= 4) {\n            currentPoints.push(...pointsOnBezierCurves(pendingCurve, tolerance));\n        }\n        pendingCurve = [];\n    };\n    const appendPendingPoints = () => {\n        appendPendingCurve();\n        if (currentPoints.length) {\n            sets.push(currentPoints);\n            currentPoints = [];\n        }\n    };\n    for (const { key, data } of normalized) {\n        switch (key) {\n            case 'M':\n                appendPendingPoints();\n                start = [data[0], data[1]];\n                currentPoints.push(start);\n                break;\n            case 'L':\n                appendPendingCurve();\n                currentPoints.push([data[0], data[1]]);\n                break;\n            case 'C':\n                if (!pendingCurve.length) {\n                    const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;\n                    pendingCurve.push([lastPoint[0], lastPoint[1]]);\n                }\n                pendingCurve.push([data[0], data[1]]);\n                pendingCurve.push([data[2], data[3]]);\n                pendingCurve.push([data[4], data[5]]);\n                break;\n            case 'Z':\n                appendPendingCurve();\n                currentPoints.push([start[0], start[1]]);\n                break;\n        }\n    }\n    appendPendingPoints();\n    if (!distance) {\n        return sets;\n    }\n    const out = [];\n    for (const set of sets) {\n        const simplifiedSet = simplify(set, distance);\n        if (simplifiedSet.length) {\n            out.push(simplifiedSet);\n        }\n    }\n    return out;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}