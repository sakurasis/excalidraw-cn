{"ast":null,"code":"import { BOUND_TEXT_PADDING, ROUNDNESS, VERTICAL_ALIGN, TEXT_ALIGN } from \"../constants\";\nimport { isTextElement, newElement } from \"../element\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { computeBoundTextPosition, computeContainerDimensionForBoundText, getBoundTextElement, measureText, redrawTextBoundingBox } from \"../element/textElement\";\nimport { getOriginalContainerHeightFromCache, resetOriginalContainerCache, updateOriginalContainerCache } from \"../element/textWysiwyg\";\nimport { hasBoundTextElement, isTextBindableContainer, isUsingAdaptiveRadius } from \"../element/typeChecks\";\nimport { getFontString } from \"../utils\";\nimport { register } from \"./register\";\nexport const actionUnbindText = register({\n  name: \"unbindText\",\n  contextItemLabel: \"labels.unbindText\",\n  trackEvent: {\n    category: \"element\"\n  },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    return selectedElements.some(element => hasBoundTextElement(element));\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    selectedElements.forEach(element => {\n      const boundTextElement = getBoundTextElement(element);\n      if (boundTextElement) {\n        var _element$boundElement;\n        const {\n          width,\n          height,\n          baseline\n        } = measureText(boundTextElement.originalText, getFontString(boundTextElement), boundTextElement.lineHeight);\n        const originalContainerHeight = getOriginalContainerHeightFromCache(element.id);\n        resetOriginalContainerCache(element.id);\n        const {\n          x,\n          y\n        } = computeBoundTextPosition(element, boundTextElement);\n        mutateElement(boundTextElement, {\n          containerId: null,\n          width,\n          height,\n          baseline,\n          text: boundTextElement.originalText,\n          x,\n          y\n        });\n        mutateElement(element, {\n          boundElements: (_element$boundElement = element.boundElements) === null || _element$boundElement === void 0 ? void 0 : _element$boundElement.filter(ele => ele.id !== boundTextElement.id),\n          height: originalContainerHeight ? originalContainerHeight : element.height\n        });\n      }\n    });\n    return {\n      elements,\n      appState,\n      commitToHistory: true\n    };\n  }\n});\nexport const actionBindText = register({\n  name: \"bindText\",\n  contextItemLabel: \"labels.bindText\",\n  trackEvent: {\n    category: \"element\"\n  },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    if (selectedElements.length === 2) {\n      const textElement = isTextElement(selectedElements[0]) || isTextElement(selectedElements[1]);\n      let bindingContainer;\n      if (isTextBindableContainer(selectedElements[0])) {\n        bindingContainer = selectedElements[0];\n      } else if (isTextBindableContainer(selectedElements[1])) {\n        bindingContainer = selectedElements[1];\n      }\n      if (textElement && bindingContainer && getBoundTextElement(bindingContainer) === null) {\n        return true;\n      }\n    }\n    return false;\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    let textElement;\n    let container;\n    if (isTextElement(selectedElements[0]) && isTextBindableContainer(selectedElements[1])) {\n      textElement = selectedElements[0];\n      container = selectedElements[1];\n    } else {\n      textElement = selectedElements[1];\n      container = selectedElements[0];\n    }\n    mutateElement(textElement, {\n      containerId: container.id,\n      verticalAlign: VERTICAL_ALIGN.MIDDLE,\n      textAlign: TEXT_ALIGN.CENTER\n    });\n    mutateElement(container, {\n      boundElements: (container.boundElements || []).concat({\n        type: \"text\",\n        id: textElement.id\n      })\n    });\n    const originalContainerHeight = container.height;\n    redrawTextBoundingBox(textElement, container);\n    // overwritting the cache with original container height so\n    // it can be restored when unbind\n    updateOriginalContainerCache(container.id, originalContainerHeight);\n    return {\n      elements: pushTextAboveContainer(elements, container, textElement),\n      appState: {\n        ...appState,\n        selectedElementIds: {\n          [container.id]: true\n        }\n      },\n      commitToHistory: true\n    };\n  }\n});\nconst pushTextAboveContainer = (elements, container, textElement) => {\n  const updatedElements = elements.slice();\n  const textElementIndex = updatedElements.findIndex(ele => ele.id === textElement.id);\n  updatedElements.splice(textElementIndex, 1);\n  const containerIndex = updatedElements.findIndex(ele => ele.id === container.id);\n  updatedElements.splice(containerIndex + 1, 0, textElement);\n  return updatedElements;\n};\nconst pushContainerBelowText = (elements, container, textElement) => {\n  const updatedElements = elements.slice();\n  const containerIndex = updatedElements.findIndex(ele => ele.id === container.id);\n  updatedElements.splice(containerIndex, 1);\n  const textElementIndex = updatedElements.findIndex(ele => ele.id === textElement.id);\n  updatedElements.splice(textElementIndex, 0, container);\n  return updatedElements;\n};\nexport const actionWrapTextInContainer = register({\n  name: \"wrapTextInContainer\",\n  contextItemLabel: \"labels.createContainerFromText\",\n  trackEvent: {\n    category: \"element\"\n  },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    const areTextElements = selectedElements.every(el => isTextElement(el));\n    return selectedElements.length > 0 && areTextElements;\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    let updatedElements = elements.slice();\n    const containerIds = {};\n    for (const textElement of selectedElements) {\n      if (isTextElement(textElement)) {\n        var _textElement$boundEle;\n        const container = newElement({\n          type: \"rectangle\",\n          backgroundColor: appState.currentItemBackgroundColor,\n          boundElements: [...(textElement.boundElements || []), {\n            id: textElement.id,\n            type: \"text\"\n          }],\n          angle: textElement.angle,\n          fillStyle: appState.currentItemFillStyle,\n          strokeColor: appState.currentItemStrokeColor,\n          roughness: appState.currentItemRoughness,\n          strokeWidth: appState.currentItemStrokeWidth,\n          strokeStyle: appState.currentItemStrokeStyle,\n          roundness: appState.currentItemRoundness === \"round\" ? {\n            type: isUsingAdaptiveRadius(\"rectangle\") ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS\n          } : null,\n          opacity: 100,\n          locked: false,\n          x: textElement.x - BOUND_TEXT_PADDING,\n          y: textElement.y - BOUND_TEXT_PADDING,\n          width: computeContainerDimensionForBoundText(textElement.width, \"rectangle\"),\n          height: computeContainerDimensionForBoundText(textElement.height, \"rectangle\"),\n          groupIds: textElement.groupIds,\n          frameId: textElement.frameId\n        });\n\n        // update bindings\n        if ((_textElement$boundEle = textElement.boundElements) !== null && _textElement$boundEle !== void 0 && _textElement$boundEle.length) {\n          const linearElementIds = textElement.boundElements.filter(ele => ele.type === \"arrow\").map(el => el.id);\n          const linearElements = updatedElements.filter(ele => linearElementIds.includes(ele.id));\n          linearElements.forEach(ele => {\n            var _startBinding, _endBinding;\n            let startBinding = ele.startBinding;\n            let endBinding = ele.endBinding;\n            if (((_startBinding = startBinding) === null || _startBinding === void 0 ? void 0 : _startBinding.elementId) === textElement.id) {\n              startBinding = {\n                ...startBinding,\n                elementId: container.id\n              };\n            }\n            if (((_endBinding = endBinding) === null || _endBinding === void 0 ? void 0 : _endBinding.elementId) === textElement.id) {\n              endBinding = {\n                ...endBinding,\n                elementId: container.id\n              };\n            }\n            if (startBinding || endBinding) {\n              mutateElement(ele, {\n                startBinding,\n                endBinding\n              }, false);\n            }\n          });\n        }\n        mutateElement(textElement, {\n          containerId: container.id,\n          verticalAlign: VERTICAL_ALIGN.MIDDLE,\n          boundElements: null,\n          textAlign: TEXT_ALIGN.CENTER\n        }, false);\n        redrawTextBoundingBox(textElement, container);\n        updatedElements = pushContainerBelowText([...updatedElements, container], container, textElement);\n        containerIds[container.id] = true;\n      }\n    }\n    return {\n      elements: updatedElements,\n      appState: {\n        ...appState,\n        selectedElementIds: containerIds\n      },\n      commitToHistory: true\n    };\n  }\n});","map":{"version":3,"names":["BOUND_TEXT_PADDING","ROUNDNESS","VERTICAL_ALIGN","TEXT_ALIGN","isTextElement","newElement","mutateElement","computeBoundTextPosition","computeContainerDimensionForBoundText","getBoundTextElement","measureText","redrawTextBoundingBox","getOriginalContainerHeightFromCache","resetOriginalContainerCache","updateOriginalContainerCache","hasBoundTextElement","isTextBindableContainer","isUsingAdaptiveRadius","getFontString","register","actionUnbindText","name","contextItemLabel","trackEvent","category","predicate","elements","appState","_","app","selectedElements","scene","getSelectedElements","some","element","perform","forEach","boundTextElement","_element$boundElement","width","height","baseline","originalText","lineHeight","originalContainerHeight","id","x","y","containerId","text","boundElements","filter","ele","commitToHistory","actionBindText","length","textElement","bindingContainer","container","verticalAlign","MIDDLE","textAlign","CENTER","concat","type","pushTextAboveContainer","selectedElementIds","updatedElements","slice","textElementIndex","findIndex","splice","containerIndex","pushContainerBelowText","actionWrapTextInContainer","areTextElements","every","el","containerIds","_textElement$boundEle","backgroundColor","currentItemBackgroundColor","angle","fillStyle","currentItemFillStyle","strokeColor","currentItemStrokeColor","roughness","currentItemRoughness","strokeWidth","currentItemStrokeWidth","strokeStyle","currentItemStrokeStyle","roundness","currentItemRoundness","ADAPTIVE_RADIUS","PROPORTIONAL_RADIUS","opacity","locked","groupIds","frameId","linearElementIds","map","linearElements","includes","_startBinding","_endBinding","startBinding","endBinding","elementId"],"sources":["D:/project/excalidraw-cn/src/actions/actionBoundText.tsx"],"sourcesContent":["import {\n  BOUND_TEXT_PADDING,\n  ROUNDNESS,\n  VERTICAL_ALIGN,\n  TEXT_ALIGN,\n} from \"../constants\";\nimport { isTextElement, newElement } from \"../element\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport {\n  computeBoundTextPosition,\n  computeContainerDimensionForBoundText,\n  getBoundTextElement,\n  measureText,\n  redrawTextBoundingBox,\n} from \"../element/textElement\";\nimport {\n  getOriginalContainerHeightFromCache,\n  resetOriginalContainerCache,\n  updateOriginalContainerCache,\n} from \"../element/textWysiwyg\";\nimport {\n  hasBoundTextElement,\n  isTextBindableContainer,\n  isUsingAdaptiveRadius,\n} from \"../element/typeChecks\";\nimport {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextContainer,\n  ExcalidrawTextElement,\n} from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { Mutable } from \"../utility-types\";\nimport { getFontString } from \"../utils\";\nimport { register } from \"./register\";\n\nexport const actionUnbindText = register({\n  name: \"unbindText\",\n  contextItemLabel: \"labels.unbindText\",\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n\n    return selectedElements.some((element) => hasBoundTextElement(element));\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    selectedElements.forEach((element) => {\n      const boundTextElement = getBoundTextElement(element);\n      if (boundTextElement) {\n        const { width, height, baseline } = measureText(\n          boundTextElement.originalText,\n          getFontString(boundTextElement),\n          boundTextElement.lineHeight,\n        );\n        const originalContainerHeight = getOriginalContainerHeightFromCache(\n          element.id,\n        );\n        resetOriginalContainerCache(element.id);\n        const { x, y } = computeBoundTextPosition(element, boundTextElement);\n        mutateElement(boundTextElement as ExcalidrawTextElement, {\n          containerId: null,\n          width,\n          height,\n          baseline,\n          text: boundTextElement.originalText,\n          x,\n          y,\n        });\n        mutateElement(element, {\n          boundElements: element.boundElements?.filter(\n            (ele) => ele.id !== boundTextElement.id,\n          ),\n          height: originalContainerHeight\n            ? originalContainerHeight\n            : element.height,\n        });\n      }\n    });\n    return {\n      elements,\n      appState,\n      commitToHistory: true,\n    };\n  },\n});\n\nexport const actionBindText = register({\n  name: \"bindText\",\n  contextItemLabel: \"labels.bindText\",\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n\n    if (selectedElements.length === 2) {\n      const textElement =\n        isTextElement(selectedElements[0]) ||\n        isTextElement(selectedElements[1]);\n\n      let bindingContainer;\n      if (isTextBindableContainer(selectedElements[0])) {\n        bindingContainer = selectedElements[0];\n      } else if (isTextBindableContainer(selectedElements[1])) {\n        bindingContainer = selectedElements[1];\n      }\n      if (\n        textElement &&\n        bindingContainer &&\n        getBoundTextElement(bindingContainer) === null\n      ) {\n        return true;\n      }\n    }\n    return false;\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n\n    let textElement: ExcalidrawTextElement;\n    let container: ExcalidrawTextContainer;\n\n    if (\n      isTextElement(selectedElements[0]) &&\n      isTextBindableContainer(selectedElements[1])\n    ) {\n      textElement = selectedElements[0];\n      container = selectedElements[1];\n    } else {\n      textElement = selectedElements[1] as ExcalidrawTextElement;\n      container = selectedElements[0] as ExcalidrawTextContainer;\n    }\n    mutateElement(textElement, {\n      containerId: container.id,\n      verticalAlign: VERTICAL_ALIGN.MIDDLE,\n      textAlign: TEXT_ALIGN.CENTER,\n    });\n    mutateElement(container, {\n      boundElements: (container.boundElements || []).concat({\n        type: \"text\",\n        id: textElement.id,\n      }),\n    });\n    const originalContainerHeight = container.height;\n    redrawTextBoundingBox(textElement, container);\n    // overwritting the cache with original container height so\n    // it can be restored when unbind\n    updateOriginalContainerCache(container.id, originalContainerHeight);\n\n    return {\n      elements: pushTextAboveContainer(elements, container, textElement),\n      appState: { ...appState, selectedElementIds: { [container.id]: true } },\n      commitToHistory: true,\n    };\n  },\n});\n\nconst pushTextAboveContainer = (\n  elements: readonly ExcalidrawElement[],\n  container: ExcalidrawElement,\n  textElement: ExcalidrawTextElement,\n) => {\n  const updatedElements = elements.slice();\n  const textElementIndex = updatedElements.findIndex(\n    (ele) => ele.id === textElement.id,\n  );\n  updatedElements.splice(textElementIndex, 1);\n\n  const containerIndex = updatedElements.findIndex(\n    (ele) => ele.id === container.id,\n  );\n  updatedElements.splice(containerIndex + 1, 0, textElement);\n  return updatedElements;\n};\n\nconst pushContainerBelowText = (\n  elements: readonly ExcalidrawElement[],\n  container: ExcalidrawElement,\n  textElement: ExcalidrawTextElement,\n) => {\n  const updatedElements = elements.slice();\n  const containerIndex = updatedElements.findIndex(\n    (ele) => ele.id === container.id,\n  );\n  updatedElements.splice(containerIndex, 1);\n\n  const textElementIndex = updatedElements.findIndex(\n    (ele) => ele.id === textElement.id,\n  );\n  updatedElements.splice(textElementIndex, 0, container);\n  return updatedElements;\n};\n\nexport const actionWrapTextInContainer = register({\n  name: \"wrapTextInContainer\",\n  contextItemLabel: \"labels.createContainerFromText\",\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    const areTextElements = selectedElements.every((el) => isTextElement(el));\n    return selectedElements.length > 0 && areTextElements;\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    let updatedElements: readonly ExcalidrawElement[] = elements.slice();\n    const containerIds: Mutable<AppState[\"selectedElementIds\"]> = {};\n\n    for (const textElement of selectedElements) {\n      if (isTextElement(textElement)) {\n        const container = newElement({\n          type: \"rectangle\",\n          backgroundColor: appState.currentItemBackgroundColor,\n          boundElements: [\n            ...(textElement.boundElements || []),\n            { id: textElement.id, type: \"text\" },\n          ],\n          angle: textElement.angle,\n          fillStyle: appState.currentItemFillStyle,\n          strokeColor: appState.currentItemStrokeColor,\n          roughness: appState.currentItemRoughness,\n          strokeWidth: appState.currentItemStrokeWidth,\n          strokeStyle: appState.currentItemStrokeStyle,\n          roundness:\n            appState.currentItemRoundness === \"round\"\n              ? {\n                  type: isUsingAdaptiveRadius(\"rectangle\")\n                    ? ROUNDNESS.ADAPTIVE_RADIUS\n                    : ROUNDNESS.PROPORTIONAL_RADIUS,\n                }\n              : null,\n          opacity: 100,\n          locked: false,\n          x: textElement.x - BOUND_TEXT_PADDING,\n          y: textElement.y - BOUND_TEXT_PADDING,\n          width: computeContainerDimensionForBoundText(\n            textElement.width,\n            \"rectangle\",\n          ),\n          height: computeContainerDimensionForBoundText(\n            textElement.height,\n            \"rectangle\",\n          ),\n          groupIds: textElement.groupIds,\n          frameId: textElement.frameId,\n        });\n\n        // update bindings\n        if (textElement.boundElements?.length) {\n          const linearElementIds = textElement.boundElements\n            .filter((ele) => ele.type === \"arrow\")\n            .map((el) => el.id);\n          const linearElements = updatedElements.filter((ele) =>\n            linearElementIds.includes(ele.id),\n          ) as ExcalidrawLinearElement[];\n          linearElements.forEach((ele) => {\n            let startBinding = ele.startBinding;\n            let endBinding = ele.endBinding;\n\n            if (startBinding?.elementId === textElement.id) {\n              startBinding = {\n                ...startBinding,\n                elementId: container.id,\n              };\n            }\n\n            if (endBinding?.elementId === textElement.id) {\n              endBinding = { ...endBinding, elementId: container.id };\n            }\n\n            if (startBinding || endBinding) {\n              mutateElement(ele, { startBinding, endBinding }, false);\n            }\n          });\n        }\n\n        mutateElement(\n          textElement,\n          {\n            containerId: container.id,\n            verticalAlign: VERTICAL_ALIGN.MIDDLE,\n            boundElements: null,\n            textAlign: TEXT_ALIGN.CENTER,\n          },\n          false,\n        );\n        redrawTextBoundingBox(textElement, container);\n\n        updatedElements = pushContainerBelowText(\n          [...updatedElements, container],\n          container,\n          textElement,\n        );\n        containerIds[container.id] = true;\n      }\n    }\n\n    return {\n      elements: updatedElements,\n      appState: {\n        ...appState,\n        selectedElementIds: containerIds,\n      },\n      commitToHistory: true,\n    };\n  },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}