{"ast":null,"code":"import { isTextElement, isLinearElement, isFreeDrawElement, isInitializedImageElement, isArrowElement, hasBoundTextElement } from \"../element/typeChecks\";\nimport { getDiamondPoints, getElementAbsoluteCoords, getArrowheadPoints } from \"../element/bounds\";\nimport { distance, getFontString, getFontFamilyString, isRTL } from \"../utils\";\nimport { getCornerRadius, isPathALoop, isRightAngle } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { getDefaultAppState } from \"../appState\";\nimport { BOUND_TEXT_PADDING, FRAME_STYLE, MAX_DECIMALS_FOR_SVG_EXPORT, MIME_TYPES, SVG_NS } from \"../constants\";\nimport { getStroke } from \"perfect-freehand\";\nimport { getBoundTextElement, getContainerCoords, getContainerElement, getLineHeightInPx, getBoundTextMaxHeight, getBoundTextMaxWidth } from \"../element/textElement\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { getContainingFrame } from \"../frame\";\nimport { normalizeLink } from \"../data/url\";\n\n// using a stronger invert (100% vs our regular 93%) and saturate\n// as a temp hack to make images in dark theme look closer to original\n// color scheme (it's still not quite there and the colors look slightly\n// desatured, alas...)\nconst IMAGE_INVERT_FILTER = \"invert(100%) hue-rotate(180deg) saturate(1.25)\";\nconst defaultAppState = getDefaultAppState();\nconst isPendingImageElement = (element, renderConfig) => isInitializedImageElement(element) && !renderConfig.imageCache.has(element.fileId);\nconst shouldResetImageFilter = (element, renderConfig) => {\n  var _renderConfig$imageCa;\n  return renderConfig.theme === \"dark\" && isInitializedImageElement(element) && !isPendingImageElement(element, renderConfig) && ((_renderConfig$imageCa = renderConfig.imageCache.get(element.fileId)) === null || _renderConfig$imageCa === void 0 ? void 0 : _renderConfig$imageCa.mimeType) !== MIME_TYPES.svg;\n};\nconst getDashArrayDashed = strokeWidth => [8, 8 + strokeWidth];\nconst getDashArrayDotted = strokeWidth => [1.5, 6 + strokeWidth];\nconst getCanvasPadding = element => element.type === \"freedraw\" ? element.strokeWidth * 12 : 20;\nconst cappedElementCanvasSize = (element, zoom) => {\n  // these limits are ballpark, they depend on specific browsers and device.\n  // We've chosen lower limits to be safe. We might want to change these limits\n  // based on browser/device type, if we get reports of low quality rendering\n  // on zoom.\n  //\n  // ~ safari mobile canvas area limit\n  const AREA_LIMIT = 16777216;\n  // ~ safari width/height limit based on developer.mozilla.org.\n  const WIDTH_HEIGHT_LIMIT = 32767;\n  const padding = getCanvasPadding(element);\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const elementWidth = isLinearElement(element) || isFreeDrawElement(element) ? distance(x1, x2) : element.width;\n  const elementHeight = isLinearElement(element) || isFreeDrawElement(element) ? distance(y1, y2) : element.height;\n  let width = elementWidth * window.devicePixelRatio + padding * 2;\n  let height = elementHeight * window.devicePixelRatio + padding * 2;\n  let scale = zoom.value;\n\n  // rescale to ensure width and height is within limits\n  if (width * scale > WIDTH_HEIGHT_LIMIT || height * scale > WIDTH_HEIGHT_LIMIT) {\n    scale = Math.min(WIDTH_HEIGHT_LIMIT / width, WIDTH_HEIGHT_LIMIT / height);\n  }\n\n  // rescale to ensure canvas area is within limits\n  if (width * height * scale * scale > AREA_LIMIT) {\n    scale = Math.sqrt(AREA_LIMIT / (width * height));\n  }\n  width = Math.floor(width * scale);\n  height = Math.floor(height * scale);\n  return {\n    width,\n    height,\n    scale\n  };\n};\nconst generateElementCanvas = (element, zoom, renderConfig) => {\n  var _getBoundTextElement, _getContainingFrame;\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  const padding = getCanvasPadding(element);\n  const {\n    width,\n    height,\n    scale\n  } = cappedElementCanvasSize(element, zoom);\n  canvas.width = width;\n  canvas.height = height;\n  let canvasOffsetX = 0;\n  let canvasOffsetY = 0;\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    const [x1, y1] = getElementAbsoluteCoords(element);\n    canvasOffsetX = element.x > x1 ? distance(element.x, x1) * window.devicePixelRatio * scale : 0;\n    canvasOffsetY = element.y > y1 ? distance(element.y, y1) * window.devicePixelRatio * scale : 0;\n    context.translate(canvasOffsetX, canvasOffsetY);\n  }\n  context.save();\n  context.translate(padding * scale, padding * scale);\n  context.scale(window.devicePixelRatio * scale, window.devicePixelRatio * scale);\n  const rc = rough.canvas(canvas);\n\n  // in dark theme, revert the image color filter\n  if (shouldResetImageFilter(element, renderConfig)) {\n    context.filter = IMAGE_INVERT_FILTER;\n  }\n  drawElementOnCanvas(element, rc, context, renderConfig);\n  context.restore();\n  return {\n    element,\n    canvas,\n    theme: renderConfig.theme,\n    scale,\n    zoomValue: zoom.value,\n    canvasOffsetX,\n    canvasOffsetY,\n    boundTextElementVersion: ((_getBoundTextElement = getBoundTextElement(element)) === null || _getBoundTextElement === void 0 ? void 0 : _getBoundTextElement.version) || null,\n    containingFrameOpacity: ((_getContainingFrame = getContainingFrame(element)) === null || _getContainingFrame === void 0 ? void 0 : _getContainingFrame.opacity) || 100\n  };\n};\nexport const DEFAULT_LINK_SIZE = 14;\nconst IMAGE_PLACEHOLDER_IMG = document.createElement(\"img\");\nIMAGE_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(`<svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"image\" class=\"svg-inline--fa fa-image fa-w-16\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path fill=\"#888\" d=\"M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z\"></path></svg>`)}`;\nconst IMAGE_ERROR_PLACEHOLDER_IMG = document.createElement(\"img\");\nIMAGE_ERROR_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(`<svg viewBox=\"0 0 668 668\" xmlns=\"http://www.w3.org/2000/svg\" xml:space=\"preserve\" style=\"fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2\"><path d=\"M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48ZM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56ZM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48Z\" style=\"fill:#888;fill-rule:nonzero\" transform=\"matrix(.81709 0 0 .81709 124.825 145.825)\"/><path d=\"M256 8C119.034 8 8 119.033 8 256c0 136.967 111.034 248 248 248s248-111.034 248-248S392.967 8 256 8Zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676ZM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676Z\" style=\"fill:#888;fill-rule:nonzero\" transform=\"matrix(.30366 0 0 .30366 506.822 60.065)\"/></svg>`)}`;\nconst drawImagePlaceholder = (element, context, zoomValue) => {\n  context.fillStyle = \"#E7E7E7\";\n  context.fillRect(0, 0, element.width, element.height);\n  const imageMinWidthOrHeight = Math.min(element.width, element.height);\n  const size = Math.min(imageMinWidthOrHeight, Math.min(imageMinWidthOrHeight * 0.4, 100));\n  context.drawImage(element.status === \"error\" ? IMAGE_ERROR_PLACEHOLDER_IMG : IMAGE_PLACEHOLDER_IMG, element.width / 2 - size / 2, element.height / 2 - size / 2, size, size);\n};\nconst drawElementOnCanvas = (element, rc, context, renderConfig) => {\n  var _getContainingFrame$o, _getContainingFrame2;\n  context.globalAlpha = ((_getContainingFrame$o = (_getContainingFrame2 = getContainingFrame(element)) === null || _getContainingFrame2 === void 0 ? void 0 : _getContainingFrame2.opacity) !== null && _getContainingFrame$o !== void 0 ? _getContainingFrame$o : 100) * element.opacity / 10000;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n      {\n        context.lineJoin = \"round\";\n        context.lineCap = \"round\";\n        rc.draw(getShapeForElement(element));\n        break;\n      }\n    case \"arrow\":\n    case \"line\":\n      {\n        context.lineJoin = \"round\";\n        context.lineCap = \"round\";\n        getShapeForElement(element).forEach(shape => {\n          rc.draw(shape);\n        });\n        break;\n      }\n    case \"freedraw\":\n      {\n        // Draw directly to canvas\n        context.save();\n        context.fillStyle = element.strokeColor;\n        const path = getFreeDrawPath2D(element);\n        const fillShape = getShapeForElement(element);\n        if (fillShape) {\n          rc.draw(fillShape);\n        }\n        context.fillStyle = element.strokeColor;\n        context.fill(path);\n        context.restore();\n        break;\n      }\n    case \"image\":\n      {\n        var _renderConfig$imageCa2;\n        const img = isInitializedImageElement(element) ? (_renderConfig$imageCa2 = renderConfig.imageCache.get(element.fileId)) === null || _renderConfig$imageCa2 === void 0 ? void 0 : _renderConfig$imageCa2.image : undefined;\n        if (img != null && !(img instanceof Promise)) {\n          context.drawImage(img, 0 /* hardcoded for the selection box*/, 0, element.width, element.height);\n        } else {\n          drawImagePlaceholder(element, context, renderConfig.zoom.value);\n        }\n        break;\n      }\n    default:\n      {\n        if (isTextElement(element)) {\n          const rtl = isRTL(element.text);\n          const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;\n          if (shouldTemporarilyAttach) {\n            // to correctly render RTL text mixed with LTR, we have to append it\n            // to the DOM\n            document.body.appendChild(context.canvas);\n          }\n          context.canvas.setAttribute(\"dir\", rtl ? \"rtl\" : \"ltr\");\n          context.save();\n          context.font = getFontString(element);\n          context.fillStyle = element.strokeColor;\n          context.textAlign = element.textAlign;\n\n          // Canvas does not support multiline text by default\n          const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n          const horizontalOffset = element.textAlign === \"center\" ? element.width / 2 : element.textAlign === \"right\" ? element.width : 0;\n          const lineHeightPx = getLineHeightInPx(element.fontSize, element.lineHeight);\n          const verticalOffset = element.height - element.baseline;\n          for (let index = 0; index < lines.length; index++) {\n            context.fillText(lines[index], horizontalOffset, (index + 1) * lineHeightPx - verticalOffset);\n          }\n          context.restore();\n          if (shouldTemporarilyAttach) {\n            context.canvas.remove();\n          }\n        } else {\n          throw new Error(`Unimplemented type ${element.type}`);\n        }\n      }\n  }\n  context.globalAlpha = 1;\n};\nconst elementWithCanvasCache = new WeakMap();\nconst shapeCache = new WeakMap();\nexport const getShapeForElement = element => shapeCache.get(element);\nexport const setShapeForElement = (element, shape) => shapeCache.set(element, shape);\nexport const invalidateShapeForElement = element => shapeCache.delete(element);\nexport const generateRoughOptions = function (element) {\n  let continuousPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const options = {\n    seed: element.seed,\n    strokeLineDash: element.strokeStyle === \"dashed\" ? getDashArrayDashed(element.strokeWidth) : element.strokeStyle === \"dotted\" ? getDashArrayDotted(element.strokeWidth) : undefined,\n    // for non-solid strokes, disable multiStroke because it tends to make\n    // dashes/dots overlay each other\n    disableMultiStroke: element.strokeStyle !== \"solid\",\n    // for non-solid strokes, increase the width a bit to make it visually\n    // similar to solid strokes, because we're also disabling multiStroke\n    strokeWidth: element.strokeStyle !== \"solid\" ? element.strokeWidth + 0.5 : element.strokeWidth,\n    // when increasing strokeWidth, we must explicitly set fillWeight and\n    // hachureGap because if not specified, roughjs uses strokeWidth to\n    // calculate them (and we don't want the fills to be modified)\n    fillWeight: element.strokeWidth / 2,\n    hachureGap: element.strokeWidth * 4,\n    roughness: element.roughness,\n    stroke: element.strokeColor,\n    preserveVertices: continuousPath\n  };\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n      {\n        options.fillStyle = element.fillStyle;\n        options.fill = element.backgroundColor === \"transparent\" ? undefined : element.backgroundColor;\n        if (element.type === \"ellipse\") {\n          options.curveFitting = 1;\n        }\n        return options;\n      }\n    case \"line\":\n    case \"freedraw\":\n      {\n        if (isPathALoop(element.points)) {\n          options.fillStyle = element.fillStyle;\n          options.fill = element.backgroundColor === \"transparent\" ? undefined : element.backgroundColor;\n        }\n        return options;\n      }\n    case \"arrow\":\n      return options;\n    default:\n      {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n  }\n};\n\n/**\n * Generates the element's shape and puts it into the cache.\n * @param element\n * @param generator\n */\nconst generateElementShape = (element, generator) => {\n  let shape = shapeCache.get(element);\n\n  // `null` indicates no rc shape applicable for this element type\n  // (= do not generate anything)\n  if (shape === undefined) {\n    elementWithCanvasCache.delete(element);\n    switch (element.type) {\n      case \"rectangle\":\n        {\n          if (element.roundness) {\n            const w = element.width;\n            const h = element.height;\n            const r = getCornerRadius(Math.min(w, h), element);\n            shape = generator.path(`M ${r} 0 L ${w - r} 0 Q ${w} 0, ${w} ${r} L ${w} ${h - r} Q ${w} ${h}, ${w - r} ${h} L ${r} ${h} Q 0 ${h}, 0 ${h - r} L 0 ${r} Q 0 0, ${r} 0`, generateRoughOptions(element, true));\n          } else {\n            shape = generator.rectangle(0, 0, element.width, element.height, generateRoughOptions(element));\n          }\n          setShapeForElement(element, shape);\n          break;\n        }\n      case \"diamond\":\n        {\n          const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] = getDiamondPoints(element);\n          if (element.roundness) {\n            const verticalRadius = getCornerRadius(Math.abs(topX - leftX), element);\n            const horizontalRadius = getCornerRadius(Math.abs(rightY - topY), element);\n            shape = generator.path(`M ${topX + verticalRadius} ${topY + horizontalRadius} L ${rightX - verticalRadius} ${rightY - horizontalRadius}\n            C ${rightX} ${rightY}, ${rightX} ${rightY}, ${rightX - verticalRadius} ${rightY + horizontalRadius}\n            L ${bottomX + verticalRadius} ${bottomY - horizontalRadius}\n            C ${bottomX} ${bottomY}, ${bottomX} ${bottomY}, ${bottomX - verticalRadius} ${bottomY - horizontalRadius}\n            L ${leftX + verticalRadius} ${leftY + horizontalRadius}\n            C ${leftX} ${leftY}, ${leftX} ${leftY}, ${leftX + verticalRadius} ${leftY - horizontalRadius}\n            L ${topX - verticalRadius} ${topY + horizontalRadius}\n            C ${topX} ${topY}, ${topX} ${topY}, ${topX + verticalRadius} ${topY + horizontalRadius}`, generateRoughOptions(element, true));\n          } else {\n            shape = generator.polygon([[topX, topY], [rightX, rightY], [bottomX, bottomY], [leftX, leftY]], generateRoughOptions(element));\n          }\n          setShapeForElement(element, shape);\n          break;\n        }\n      case \"ellipse\":\n        shape = generator.ellipse(element.width / 2, element.height / 2, element.width, element.height, generateRoughOptions(element));\n        setShapeForElement(element, shape);\n        break;\n      case \"line\":\n      case \"arrow\":\n        {\n          const options = generateRoughOptions(element);\n\n          // points array can be empty in the beginning, so it is important to add\n          // initial position to it\n          const points = element.points.length ? element.points : [[0, 0]];\n\n          // curve is always the first element\n          // this simplifies finding the curve for an element\n          if (!element.roundness) {\n            if (options.fill) {\n              shape = [generator.polygon(points, options)];\n            } else {\n              shape = [generator.linearPath(points, options)];\n            }\n          } else {\n            shape = [generator.curve(points, options)];\n          }\n\n          // add lines only in arrow\n          if (element.type === \"arrow\") {\n            const {\n              startArrowhead = null,\n              endArrowhead = \"arrow\"\n            } = element;\n            const getArrowheadShapes = (element, shape, position, arrowhead) => {\n              const arrowheadPoints = getArrowheadPoints(element, shape, position, arrowhead);\n              if (arrowheadPoints === null) {\n                return [];\n              }\n\n              // Other arrowheads here...\n              if (arrowhead === \"dot\") {\n                const [x, y, r] = arrowheadPoints;\n                return [generator.circle(x, y, r, {\n                  ...options,\n                  fill: element.strokeColor,\n                  fillStyle: \"solid\",\n                  stroke: \"none\"\n                })];\n              }\n              if (arrowhead === \"triangle\") {\n                const [x, y, x2, y2, x3, y3] = arrowheadPoints;\n\n                // always use solid stroke for triangle arrowhead\n                delete options.strokeLineDash;\n                return [generator.polygon([[x, y], [x2, y2], [x3, y3], [x, y]], {\n                  ...options,\n                  fill: element.strokeColor,\n                  fillStyle: \"solid\"\n                })];\n              }\n\n              // Arrow arrowheads\n              const [x2, y2, x3, y3, x4, y4] = arrowheadPoints;\n              if (element.strokeStyle === \"dotted\") {\n                // for dotted arrows caps, reduce gap to make it more legible\n                const dash = getDashArrayDotted(element.strokeWidth - 1);\n                options.strokeLineDash = [dash[0], dash[1] - 1];\n              } else {\n                // for solid/dashed, keep solid arrow cap\n                delete options.strokeLineDash;\n              }\n              return [generator.line(x3, y3, x2, y2, options), generator.line(x4, y4, x2, y2, options)];\n            };\n            if (startArrowhead !== null) {\n              const shapes = getArrowheadShapes(element, shape, \"start\", startArrowhead);\n              shape.push(...shapes);\n            }\n            if (endArrowhead !== null) {\n              if (endArrowhead === undefined) {\n                // Hey, we have an old arrow here!\n              }\n              const shapes = getArrowheadShapes(element, shape, \"end\", endArrowhead);\n              shape.push(...shapes);\n            }\n          }\n          setShapeForElement(element, shape);\n          break;\n        }\n      case \"freedraw\":\n        {\n          generateFreeDrawShape(element);\n          if (isPathALoop(element.points)) {\n            // generate rough polygon to fill freedraw shape\n            shape = generator.polygon(element.points, {\n              ...generateRoughOptions(element),\n              stroke: \"none\"\n            });\n          } else {\n            shape = null;\n          }\n          setShapeForElement(element, shape);\n          break;\n        }\n      case \"text\":\n      case \"image\":\n        {\n          // just to ensure we don't regenerate element.canvas on rerenders\n          setShapeForElement(element, null);\n          break;\n        }\n    }\n  }\n};\nconst generateElementWithCanvas = (element, renderConfig) => {\n  var _getBoundTextElement2, _getContainingFrame3;\n  const zoom = renderConfig ? renderConfig.zoom : defaultAppState.zoom;\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom = prevElementWithCanvas && prevElementWithCanvas.zoomValue !== zoom.value && !(renderConfig !== null && renderConfig !== void 0 && renderConfig.shouldCacheIgnoreZoom);\n  const boundTextElementVersion = ((_getBoundTextElement2 = getBoundTextElement(element)) === null || _getBoundTextElement2 === void 0 ? void 0 : _getBoundTextElement2.version) || null;\n  const containingFrameOpacity = ((_getContainingFrame3 = getContainingFrame(element)) === null || _getContainingFrame3 === void 0 ? void 0 : _getContainingFrame3.opacity) || 100;\n  if (!prevElementWithCanvas || shouldRegenerateBecauseZoom || prevElementWithCanvas.theme !== renderConfig.theme || prevElementWithCanvas.boundTextElementVersion !== boundTextElementVersion || prevElementWithCanvas.containingFrameOpacity !== containingFrameOpacity) {\n    const elementWithCanvas = generateElementCanvas(element, zoom, renderConfig);\n    elementWithCanvasCache.set(element, elementWithCanvas);\n    return elementWithCanvas;\n  }\n  return prevElementWithCanvas;\n};\nconst drawElementFromCanvas = (elementWithCanvas, rc, context, renderConfig) => {\n  const element = elementWithCanvas.element;\n  const padding = getCanvasPadding(element);\n  const zoom = elementWithCanvas.scale;\n  let [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n  // Free draw elements will otherwise \"shuffle\" as the min x and y change\n  if (isFreeDrawElement(element)) {\n    x1 = Math.floor(x1);\n    x2 = Math.ceil(x2);\n    y1 = Math.floor(y1);\n    y2 = Math.ceil(y2);\n  }\n  const cx = ((x1 + x2) / 2 + renderConfig.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + renderConfig.scrollY) * window.devicePixelRatio;\n  context.save();\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n  const boundTextElement = getBoundTextElement(element);\n  if (isArrowElement(element) && boundTextElement) {\n    const tempCanvas = document.createElement(\"canvas\");\n    const tempCanvasContext = tempCanvas.getContext(\"2d\");\n\n    // Take max dimensions of arrow canvas so that when canvas is rotated\n    // the arrow doesn't get clipped\n    const maxDim = Math.max(distance(x1, x2), distance(y1, y2));\n    tempCanvas.width = maxDim * window.devicePixelRatio * zoom + padding * elementWithCanvas.scale * 10;\n    tempCanvas.height = maxDim * window.devicePixelRatio * zoom + padding * elementWithCanvas.scale * 10;\n    const offsetX = (tempCanvas.width - elementWithCanvas.canvas.width) / 2;\n    const offsetY = (tempCanvas.height - elementWithCanvas.canvas.height) / 2;\n    tempCanvasContext.translate(tempCanvas.width / 2, tempCanvas.height / 2);\n    tempCanvasContext.rotate(element.angle);\n    tempCanvasContext.drawImage(elementWithCanvas.canvas, -elementWithCanvas.canvas.width / 2, -elementWithCanvas.canvas.height / 2, elementWithCanvas.canvas.width, elementWithCanvas.canvas.height);\n    const [,,,, boundTextCx, boundTextCy] = getElementAbsoluteCoords(boundTextElement);\n    tempCanvasContext.rotate(-element.angle);\n\n    // Shift the canvas to the center of the bound text element\n    const shiftX = tempCanvas.width / 2 - (boundTextCx - x1) * window.devicePixelRatio * zoom - offsetX - padding * zoom;\n    const shiftY = tempCanvas.height / 2 - (boundTextCy - y1) * window.devicePixelRatio * zoom - offsetY - padding * zoom;\n    tempCanvasContext.translate(-shiftX, -shiftY);\n\n    // Clear the bound text area\n    tempCanvasContext.clearRect(-(boundTextElement.width / 2 + BOUND_TEXT_PADDING) * window.devicePixelRatio * zoom, -(boundTextElement.height / 2 + BOUND_TEXT_PADDING) * window.devicePixelRatio * zoom, (boundTextElement.width + BOUND_TEXT_PADDING * 2) * window.devicePixelRatio * zoom, (boundTextElement.height + BOUND_TEXT_PADDING * 2) * window.devicePixelRatio * zoom);\n    context.translate(cx, cy);\n    context.drawImage(tempCanvas, -(x2 - x1) / 2 * window.devicePixelRatio - offsetX / zoom - padding, -(y2 - y1) / 2 * window.devicePixelRatio - offsetY / zoom - padding, tempCanvas.width / zoom, tempCanvas.height / zoom);\n  } else {\n    // we translate context to element center so that rotation and scale\n    // originates from the element center\n    context.translate(cx, cy);\n    context.rotate(element.angle);\n    if (\"scale\" in elementWithCanvas.element && !isPendingImageElement(element, renderConfig)) {\n      context.scale(elementWithCanvas.element.scale[0], elementWithCanvas.element.scale[1]);\n    }\n\n    // revert afterwards we don't have account for it during drawing\n    context.translate(-cx, -cy);\n    context.drawImage(elementWithCanvas.canvas, (x1 + renderConfig.scrollX) * window.devicePixelRatio - padding * elementWithCanvas.scale / elementWithCanvas.scale, (y1 + renderConfig.scrollY) * window.devicePixelRatio - padding * elementWithCanvas.scale / elementWithCanvas.scale, elementWithCanvas.canvas.width / elementWithCanvas.scale, elementWithCanvas.canvas.height / elementWithCanvas.scale);\n    if (process.env.REACT_APP_DEBUG_ENABLE_TEXT_CONTAINER_BOUNDING_BOX === \"true\" && hasBoundTextElement(element)) {\n      const textElement = getBoundTextElement(element);\n      const coords = getContainerCoords(element);\n      context.strokeStyle = \"#c92a2a\";\n      context.lineWidth = 3;\n      context.strokeRect((coords.x + renderConfig.scrollX) * window.devicePixelRatio, (coords.y + renderConfig.scrollY) * window.devicePixelRatio, getBoundTextMaxWidth(element) * window.devicePixelRatio, getBoundTextMaxHeight(element, textElement) * window.devicePixelRatio);\n    }\n  }\n  context.restore();\n\n  // Clear the nested element we appended to the DOM\n};\n\nexport const renderElement = (element, rc, context, renderConfig, appState) => {\n  const generator = rc.generator;\n  switch (element.type) {\n    case \"selection\":\n      {\n        // do not render selection when exporting\n        if (!renderConfig.isExporting) {\n          context.save();\n          context.translate(element.x + renderConfig.scrollX, element.y + renderConfig.scrollY);\n          context.fillStyle = \"rgba(0, 0, 200, 0.04)\";\n\n          // render from 0.5px offset  to get 1px wide line\n          // https://stackoverflow.com/questions/7530593/html5-canvas-and-line-width/7531540#7531540\n          // TODO can be be improved by offseting to the negative when user selects\n          // from right to left\n          const offset = 0.5 / renderConfig.zoom.value;\n          context.fillRect(offset, offset, element.width, element.height);\n          context.lineWidth = 1 / renderConfig.zoom.value;\n          context.strokeStyle = \" rgb(105, 101, 219)\";\n          context.strokeRect(offset, offset, element.width, element.height);\n          context.restore();\n        }\n        break;\n      }\n    case \"frame\":\n      {\n        if (!renderConfig.isExporting && appState.frameRendering.enabled && appState.frameRendering.outline) {\n          context.save();\n          context.translate(element.x + renderConfig.scrollX, element.y + renderConfig.scrollY);\n          context.fillStyle = \"rgba(0, 0, 200, 0.04)\";\n          context.lineWidth = 2 / renderConfig.zoom.value;\n          context.strokeStyle = FRAME_STYLE.strokeColor;\n          if (FRAME_STYLE.radius && context.roundRect) {\n            context.beginPath();\n            context.roundRect(0, 0, element.width, element.height, FRAME_STYLE.radius / renderConfig.zoom.value);\n            context.stroke();\n            context.closePath();\n          } else {\n            context.strokeRect(0, 0, element.width, element.height);\n          }\n          context.restore();\n        }\n        break;\n      }\n    case \"freedraw\":\n      {\n        generateElementShape(element, generator);\n        if (renderConfig.isExporting) {\n          const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n          const cx = (x1 + x2) / 2 + renderConfig.scrollX;\n          const cy = (y1 + y2) / 2 + renderConfig.scrollY;\n          const shiftX = (x2 - x1) / 2 - (element.x - x1);\n          const shiftY = (y2 - y1) / 2 - (element.y - y1);\n          context.save();\n          context.translate(cx, cy);\n          context.rotate(element.angle);\n          context.translate(-shiftX, -shiftY);\n          drawElementOnCanvas(element, rc, context, renderConfig);\n          context.restore();\n        } else {\n          const elementWithCanvas = generateElementWithCanvas(element, renderConfig);\n          drawElementFromCanvas(elementWithCanvas, rc, context, renderConfig);\n        }\n        break;\n      }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"arrow\":\n    case \"image\":\n    case \"text\":\n      {\n        generateElementShape(element, generator);\n        if (renderConfig.isExporting) {\n          const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n          const cx = (x1 + x2) / 2 + renderConfig.scrollX;\n          const cy = (y1 + y2) / 2 + renderConfig.scrollY;\n          let shiftX = (x2 - x1) / 2 - (element.x - x1);\n          let shiftY = (y2 - y1) / 2 - (element.y - y1);\n          if (isTextElement(element)) {\n            const container = getContainerElement(element);\n            if (isArrowElement(container)) {\n              const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(container, element);\n              shiftX = (x2 - x1) / 2 - (boundTextCoords.x - x1);\n              shiftY = (y2 - y1) / 2 - (boundTextCoords.y - y1);\n            }\n          }\n          context.save();\n          context.translate(cx, cy);\n          if (shouldResetImageFilter(element, renderConfig)) {\n            context.filter = \"none\";\n          }\n          const boundTextElement = getBoundTextElement(element);\n          if (isArrowElement(element) && boundTextElement) {\n            const tempCanvas = document.createElement(\"canvas\");\n            const tempCanvasContext = tempCanvas.getContext(\"2d\");\n\n            // Take max dimensions of arrow canvas so that when canvas is rotated\n            // the arrow doesn't get clipped\n            const maxDim = Math.max(distance(x1, x2), distance(y1, y2));\n            const padding = getCanvasPadding(element);\n            tempCanvas.width = maxDim * appState.exportScale + padding * 10 * appState.exportScale;\n            tempCanvas.height = maxDim * appState.exportScale + padding * 10 * appState.exportScale;\n            tempCanvasContext.translate(tempCanvas.width / 2, tempCanvas.height / 2);\n            tempCanvasContext.scale(appState.exportScale, appState.exportScale);\n\n            // Shift the canvas to left most point of the arrow\n            shiftX = element.width / 2 - (element.x - x1);\n            shiftY = element.height / 2 - (element.y - y1);\n            tempCanvasContext.rotate(element.angle);\n            const tempRc = rough.canvas(tempCanvas);\n            tempCanvasContext.translate(-shiftX, -shiftY);\n            drawElementOnCanvas(element, tempRc, tempCanvasContext, renderConfig);\n            tempCanvasContext.translate(shiftX, shiftY);\n            tempCanvasContext.rotate(-element.angle);\n\n            // Shift the canvas to center of bound text\n            const [,,,, boundTextCx, boundTextCy] = getElementAbsoluteCoords(boundTextElement);\n            const boundTextShiftX = (x1 + x2) / 2 - boundTextCx;\n            const boundTextShiftY = (y1 + y2) / 2 - boundTextCy;\n            tempCanvasContext.translate(-boundTextShiftX, -boundTextShiftY);\n\n            // Clear the bound text area\n            tempCanvasContext.clearRect(-boundTextElement.width / 2, -boundTextElement.height / 2, boundTextElement.width, boundTextElement.height);\n            context.scale(1 / appState.exportScale, 1 / appState.exportScale);\n            context.drawImage(tempCanvas, -tempCanvas.width / 2, -tempCanvas.height / 2, tempCanvas.width, tempCanvas.height);\n          } else {\n            context.rotate(element.angle);\n            if (element.type === \"image\") {\n              // note: scale must be applied *after* rotating\n              context.scale(element.scale[0], element.scale[1]);\n            }\n            context.translate(-shiftX, -shiftY);\n            drawElementOnCanvas(element, rc, context, renderConfig);\n          }\n          context.restore();\n          // not exporting → optimized rendering (cache & render from element\n          // canvases)\n        } else {\n          const elementWithCanvas = generateElementWithCanvas(element, renderConfig);\n          const currentImageSmoothingStatus = context.imageSmoothingEnabled;\n          if (\n          // do not disable smoothing during zoom as blurry shapes look better\n          // on low resolution (while still zooming in) than sharp ones\n          !(renderConfig !== null && renderConfig !== void 0 && renderConfig.shouldCacheIgnoreZoom) && (\n          // angle is 0 -> always disable smoothing\n          !element.angle ||\n          // or check if angle is a right angle in which case we can still\n          // disable smoothing without adversely affecting the result\n          isRightAngle(element.angle))) {\n            // Disabling smoothing makes output much sharper, especially for\n            // text. Unless for non-right angles, where the aliasing is really\n            // terrible on Chromium.\n            //\n            // Note that `context.imageSmoothingQuality=\"high\"` has almost\n            // zero effect.\n            //\n            context.imageSmoothingEnabled = false;\n          }\n          drawElementFromCanvas(elementWithCanvas, rc, context, renderConfig);\n\n          // reset\n          context.imageSmoothingEnabled = currentImageSmoothingStatus;\n        }\n        break;\n      }\n    default:\n      {\n        // @ts-ignore\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n  }\n};\nconst roughSVGDrawWithPrecision = (rsvg, drawable, precision) => {\n  if (typeof precision === \"undefined\") {\n    return rsvg.draw(drawable);\n  }\n  const pshape = {\n    sets: drawable.sets,\n    shape: drawable.shape,\n    options: {\n      ...drawable.options,\n      fixedDecimalPlaceDigits: precision\n    }\n  };\n  return rsvg.draw(pshape);\n};\nconst maybeWrapNodesInFrameClipPath = (element, root, nodes, exportedFrameId) => {\n  const frame = getContainingFrame(element);\n  if (frame && frame.id === exportedFrameId) {\n    const g = root.ownerDocument.createElementNS(SVG_NS, \"g\");\n    g.setAttributeNS(SVG_NS, \"clip-path\", `url(#${frame.id})`);\n    nodes.forEach(node => g.appendChild(node));\n    return g;\n  }\n  return null;\n};\nexport const renderElementToSvg = (element, rsvg, svgRoot, files, offsetX, offsetY, exportWithDarkMode, exportingFrameId) => {\n  var _getContainingFrame$o2, _getContainingFrame4;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  let cx = (x2 - x1) / 2 - (element.x - x1);\n  let cy = (y2 - y1) / 2 - (element.y - y1);\n  if (isTextElement(element)) {\n    const container = getContainerElement(element);\n    if (isArrowElement(container)) {\n      const [x1, y1, x2, y2] = getElementAbsoluteCoords(container);\n      const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(container, element);\n      cx = (x2 - x1) / 2 - (boundTextCoords.x - x1);\n      cy = (y2 - y1) / 2 - (boundTextCoords.y - y1);\n      offsetX = offsetX + boundTextCoords.x - element.x;\n      offsetY = offsetY + boundTextCoords.y - element.y;\n    }\n  }\n  const degree = 180 * element.angle / Math.PI;\n  const generator = rsvg.generator;\n\n  // element to append node to, most of the time svgRoot\n  let root = svgRoot;\n\n  // if the element has a link, create an anchor tag and make that the new root\n  if (element.link) {\n    const anchorTag = svgRoot.ownerDocument.createElementNS(SVG_NS, \"a\");\n    anchorTag.setAttribute(\"href\", normalizeLink(element.link));\n    root.appendChild(anchorTag);\n    root = anchorTag;\n  }\n  const opacity = ((_getContainingFrame$o2 = (_getContainingFrame4 = getContainingFrame(element)) === null || _getContainingFrame4 === void 0 ? void 0 : _getContainingFrame4.opacity) !== null && _getContainingFrame$o2 !== void 0 ? _getContainingFrame$o2 : 100) * element.opacity / 10000;\n  switch (element.type) {\n    case \"selection\":\n      {\n        // Since this is used only during editing experience, which is canvas based,\n        // this should not happen\n        throw new Error(\"Selection rendering is not supported for SVG\");\n      }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n      {\n        generateElementShape(element, generator);\n        const node = roughSVGDrawWithPrecision(rsvg, getShapeForElement(element), MAX_DECIMALS_FOR_SVG_EXPORT);\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\"stroke-linecap\", \"round\");\n        node.setAttribute(\"transform\", `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`);\n        const g = maybeWrapNodesInFrameClipPath(element, root, [node], exportingFrameId);\n        g ? root.appendChild(g) : root.appendChild(node);\n        break;\n      }\n    case \"line\":\n    case \"arrow\":\n      {\n        const boundText = getBoundTextElement(element);\n        const maskPath = svgRoot.ownerDocument.createElementNS(SVG_NS, \"mask\");\n        if (boundText) {\n          maskPath.setAttribute(\"id\", `mask-${element.id}`);\n          const maskRectVisible = svgRoot.ownerDocument.createElementNS(SVG_NS, \"rect\");\n          offsetX = offsetX || 0;\n          offsetY = offsetY || 0;\n          maskRectVisible.setAttribute(\"x\", \"0\");\n          maskRectVisible.setAttribute(\"y\", \"0\");\n          maskRectVisible.setAttribute(\"fill\", \"#fff\");\n          maskRectVisible.setAttribute(\"width\", `${element.width + 100 + offsetX}`);\n          maskRectVisible.setAttribute(\"height\", `${element.height + 100 + offsetY}`);\n          maskPath.appendChild(maskRectVisible);\n          const maskRectInvisible = svgRoot.ownerDocument.createElementNS(SVG_NS, \"rect\");\n          const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(element, boundText);\n          const maskX = offsetX + boundTextCoords.x - element.x;\n          const maskY = offsetY + boundTextCoords.y - element.y;\n          maskRectInvisible.setAttribute(\"x\", maskX.toString());\n          maskRectInvisible.setAttribute(\"y\", maskY.toString());\n          maskRectInvisible.setAttribute(\"fill\", \"#000\");\n          maskRectInvisible.setAttribute(\"width\", `${boundText.width}`);\n          maskRectInvisible.setAttribute(\"height\", `${boundText.height}`);\n          maskRectInvisible.setAttribute(\"opacity\", \"1\");\n          maskPath.appendChild(maskRectInvisible);\n        }\n        generateElementShape(element, generator);\n        const group = svgRoot.ownerDocument.createElementNS(SVG_NS, \"g\");\n        if (boundText) {\n          group.setAttribute(\"mask\", `url(#mask-${element.id})`);\n        }\n        group.setAttribute(\"stroke-linecap\", \"round\");\n        getShapeForElement(element).forEach(shape => {\n          const node = roughSVGDrawWithPrecision(rsvg, shape, MAX_DECIMALS_FOR_SVG_EXPORT);\n          if (opacity !== 1) {\n            node.setAttribute(\"stroke-opacity\", `${opacity}`);\n            node.setAttribute(\"fill-opacity\", `${opacity}`);\n          }\n          node.setAttribute(\"transform\", `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`);\n          if (element.type === \"line\" && isPathALoop(element.points) && element.backgroundColor !== \"transparent\") {\n            node.setAttribute(\"fill-rule\", \"evenodd\");\n          }\n          group.appendChild(node);\n        });\n        const g = maybeWrapNodesInFrameClipPath(element, root, [group, maskPath], exportingFrameId);\n        if (g) {\n          root.appendChild(g);\n        } else {\n          root.appendChild(group);\n          root.append(maskPath);\n        }\n        break;\n      }\n    case \"freedraw\":\n      {\n        generateElementShape(element, generator);\n        generateFreeDrawShape(element);\n        const shape = getShapeForElement(element);\n        const node = shape ? roughSVGDrawWithPrecision(rsvg, shape, MAX_DECIMALS_FOR_SVG_EXPORT) : svgRoot.ownerDocument.createElementNS(SVG_NS, \"g\");\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\"transform\", `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`);\n        node.setAttribute(\"stroke\", \"none\");\n        const path = svgRoot.ownerDocument.createElementNS(SVG_NS, \"path\");\n        path.setAttribute(\"fill\", element.strokeColor);\n        path.setAttribute(\"d\", getFreeDrawSvgPath(element));\n        node.appendChild(path);\n        const g = maybeWrapNodesInFrameClipPath(element, root, [node], exportingFrameId);\n        g ? root.appendChild(g) : root.appendChild(node);\n        break;\n      }\n    case \"image\":\n      {\n        const width = Math.round(element.width);\n        const height = Math.round(element.height);\n        const fileData = isInitializedImageElement(element) && files[element.fileId];\n        if (fileData) {\n          const symbolId = `image-${fileData.id}`;\n          let symbol = svgRoot.querySelector(`#${symbolId}`);\n          if (!symbol) {\n            symbol = svgRoot.ownerDocument.createElementNS(SVG_NS, \"symbol\");\n            symbol.id = symbolId;\n            const image = svgRoot.ownerDocument.createElementNS(SVG_NS, \"image\");\n            image.setAttribute(\"width\", \"100%\");\n            image.setAttribute(\"height\", \"100%\");\n            image.setAttribute(\"href\", fileData.dataURL);\n            symbol.appendChild(image);\n            root.prepend(symbol);\n          }\n          const use = svgRoot.ownerDocument.createElementNS(SVG_NS, \"use\");\n          use.setAttribute(\"href\", `#${symbolId}`);\n\n          // in dark theme, revert the image color filter\n          if (exportWithDarkMode && fileData.mimeType !== MIME_TYPES.svg) {\n            use.setAttribute(\"filter\", IMAGE_INVERT_FILTER);\n          }\n          use.setAttribute(\"width\", `${width}`);\n          use.setAttribute(\"height\", `${height}`);\n          use.setAttribute(\"opacity\", `${opacity}`);\n\n          // We first apply `scale` transforms (horizontal/vertical mirroring)\n          // on the <use> element, then apply translation and rotation\n          // on the <g> element which wraps the <use>.\n          // Doing this separately is a quick hack to to work around compositing\n          // the transformations correctly (the transform-origin was not being\n          // applied correctly).\n          if (element.scale[0] !== 1 || element.scale[1] !== 1) {\n            const translateX = element.scale[0] !== 1 ? -width : 0;\n            const translateY = element.scale[1] !== 1 ? -height : 0;\n            use.setAttribute(\"transform\", `scale(${element.scale[0]}, ${element.scale[1]}) translate(${translateX} ${translateY})`);\n          }\n          const g = svgRoot.ownerDocument.createElementNS(SVG_NS, \"g\");\n          g.appendChild(use);\n          g.setAttribute(\"transform\", `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`);\n          const clipG = maybeWrapNodesInFrameClipPath(element, root, [g], exportingFrameId);\n          clipG ? root.appendChild(clipG) : root.appendChild(g);\n        }\n        break;\n      }\n    // frames are not rendered and only acts as a container\n    case \"frame\":\n      {\n        break;\n      }\n    default:\n      {\n        if (isTextElement(element)) {\n          const node = svgRoot.ownerDocument.createElementNS(SVG_NS, \"g\");\n          if (opacity !== 1) {\n            node.setAttribute(\"stroke-opacity\", `${opacity}`);\n            node.setAttribute(\"fill-opacity\", `${opacity}`);\n          }\n          node.setAttribute(\"transform\", `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`);\n          const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n          const lineHeightPx = getLineHeightInPx(element.fontSize, element.lineHeight);\n          const horizontalOffset = element.textAlign === \"center\" ? element.width / 2 : element.textAlign === \"right\" ? element.width : 0;\n          const direction = isRTL(element.text) ? \"rtl\" : \"ltr\";\n          const textAnchor = element.textAlign === \"center\" ? \"middle\" : element.textAlign === \"right\" || direction === \"rtl\" ? \"end\" : \"start\";\n          for (let i = 0; i < lines.length; i++) {\n            const text = svgRoot.ownerDocument.createElementNS(SVG_NS, \"text\");\n            text.textContent = lines[i];\n            text.setAttribute(\"x\", `${horizontalOffset}`);\n            text.setAttribute(\"y\", `${i * lineHeightPx}`);\n            text.setAttribute(\"font-family\", getFontFamilyString(element));\n            text.setAttribute(\"font-size\", `${element.fontSize}px`);\n            text.setAttribute(\"fill\", element.strokeColor);\n            text.setAttribute(\"text-anchor\", textAnchor);\n            text.setAttribute(\"style\", \"white-space: pre;\");\n            text.setAttribute(\"direction\", direction);\n            text.setAttribute(\"dominant-baseline\", \"text-before-edge\");\n            node.appendChild(text);\n          }\n          const g = maybeWrapNodesInFrameClipPath(element, root, [node], exportingFrameId);\n          g ? root.appendChild(g) : root.appendChild(node);\n        } else {\n          // @ts-ignore\n          throw new Error(`Unimplemented type ${element.type}`);\n        }\n      }\n  }\n};\nexport const pathsCache = new WeakMap([]);\nexport function generateFreeDrawShape(element) {\n  const svgPathData = getFreeDrawSvgPath(element);\n  const path = new Path2D(svgPathData);\n  pathsCache.set(element, path);\n  return path;\n}\nexport function getFreeDrawPath2D(element) {\n  return pathsCache.get(element);\n}\nexport function getFreeDrawSvgPath(element) {\n  // If input points are empty (should they ever be?) return a dot\n  const inputPoints = element.simulatePressure ? element.points : element.points.length ? element.points.map((_ref, i) => {\n    let [x, y] = _ref;\n    return [x, y, element.pressures[i]];\n  }) : [[0, 0, 0.5]];\n\n  // Consider changing the options for simulated pressure vs real pressure\n  const options = {\n    simulatePressure: element.simulatePressure,\n    size: element.strokeWidth * 4.25,\n    thinning: 0.6,\n    smoothing: 0.5,\n    streamline: 0.5,\n    easing: t => Math.sin(t * Math.PI / 2),\n    // https://easings.net/#easeOutSine\n    last: !!element.lastCommittedPoint // LastCommittedPoint is added on pointerup\n  };\n\n  return getSvgPathFromStroke(getStroke(inputPoints, options));\n}\nfunction med(A, B) {\n  return [(A[0] + B[0]) / 2, (A[1] + B[1]) / 2];\n}\n\n// Trim SVG path data so number are each two decimal points. This\n// improves SVG exports, and prevents rendering errors on points\n// with long decimals.\nconst TO_FIXED_PRECISION = /(\\s?[A-Z]?,?-?[0-9]*\\.[0-9]{0,2})(([0-9]|e|-)*)/g;\nfunction getSvgPathFromStroke(points) {\n  if (!points.length) {\n    return \"\";\n  }\n  const max = points.length - 1;\n  return points.reduce((acc, point, i, arr) => {\n    if (i === max) {\n      acc.push(point, med(point, arr[0]), \"L\", arr[0], \"Z\");\n    } else {\n      acc.push(point, med(point, arr[i + 1]));\n    }\n    return acc;\n  }, [\"M\", points[0], \"Q\"]).join(\" \").replace(TO_FIXED_PRECISION, \"$1\");\n}","map":{"version":3,"names":["isTextElement","isLinearElement","isFreeDrawElement","isInitializedImageElement","isArrowElement","hasBoundTextElement","getDiamondPoints","getElementAbsoluteCoords","getArrowheadPoints","distance","getFontString","getFontFamilyString","isRTL","getCornerRadius","isPathALoop","isRightAngle","rough","getDefaultAppState","BOUND_TEXT_PADDING","FRAME_STYLE","MAX_DECIMALS_FOR_SVG_EXPORT","MIME_TYPES","SVG_NS","getStroke","getBoundTextElement","getContainerCoords","getContainerElement","getLineHeightInPx","getBoundTextMaxHeight","getBoundTextMaxWidth","LinearElementEditor","getContainingFrame","normalizeLink","IMAGE_INVERT_FILTER","defaultAppState","isPendingImageElement","element","renderConfig","imageCache","has","fileId","shouldResetImageFilter","_renderConfig$imageCa","theme","get","mimeType","svg","getDashArrayDashed","strokeWidth","getDashArrayDotted","getCanvasPadding","type","cappedElementCanvasSize","zoom","AREA_LIMIT","WIDTH_HEIGHT_LIMIT","padding","x1","y1","x2","y2","elementWidth","width","elementHeight","height","window","devicePixelRatio","scale","value","Math","min","sqrt","floor","generateElementCanvas","_getBoundTextElement","_getContainingFrame","canvas","document","createElement","context","getContext","canvasOffsetX","canvasOffsetY","x","y","translate","save","rc","filter","drawElementOnCanvas","restore","zoomValue","boundTextElementVersion","version","containingFrameOpacity","opacity","DEFAULT_LINK_SIZE","IMAGE_PLACEHOLDER_IMG","src","encodeURIComponent","IMAGE_ERROR_PLACEHOLDER_IMG","drawImagePlaceholder","fillStyle","fillRect","imageMinWidthOrHeight","size","drawImage","status","_getContainingFrame$o","_getContainingFrame2","globalAlpha","lineJoin","lineCap","draw","getShapeForElement","forEach","shape","strokeColor","path","getFreeDrawPath2D","fillShape","fill","_renderConfig$imageCa2","img","image","undefined","Promise","rtl","text","shouldTemporarilyAttach","isConnected","body","appendChild","setAttribute","font","textAlign","lines","replace","split","horizontalOffset","lineHeightPx","fontSize","lineHeight","verticalOffset","baseline","index","length","fillText","remove","Error","elementWithCanvasCache","WeakMap","shapeCache","setShapeForElement","set","invalidateShapeForElement","delete","generateRoughOptions","continuousPath","arguments","options","seed","strokeLineDash","strokeStyle","disableMultiStroke","fillWeight","hachureGap","roughness","stroke","preserveVertices","backgroundColor","curveFitting","points","generateElementShape","generator","roundness","w","h","r","rectangle","topX","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","verticalRadius","abs","horizontalRadius","polygon","ellipse","linearPath","curve","startArrowhead","endArrowhead","getArrowheadShapes","position","arrowhead","arrowheadPoints","circle","x3","y3","x4","y4","dash","line","shapes","push","generateFreeDrawShape","generateElementWithCanvas","_getBoundTextElement2","_getContainingFrame3","prevElementWithCanvas","shouldRegenerateBecauseZoom","shouldCacheIgnoreZoom","elementWithCanvas","drawElementFromCanvas","ceil","cx","scrollX","cy","scrollY","boundTextElement","tempCanvas","tempCanvasContext","maxDim","max","offsetX","offsetY","rotate","angle","boundTextCx","boundTextCy","shiftX","shiftY","clearRect","process","env","REACT_APP_DEBUG_ENABLE_TEXT_CONTAINER_BOUNDING_BOX","textElement","coords","lineWidth","strokeRect","renderElement","appState","isExporting","offset","frameRendering","enabled","outline","radius","roundRect","beginPath","closePath","container","boundTextCoords","getBoundTextElementPosition","exportScale","tempRc","boundTextShiftX","boundTextShiftY","currentImageSmoothingStatus","imageSmoothingEnabled","roughSVGDrawWithPrecision","rsvg","drawable","precision","pshape","sets","fixedDecimalPlaceDigits","maybeWrapNodesInFrameClipPath","root","nodes","exportedFrameId","frame","id","g","ownerDocument","createElementNS","setAttributeNS","node","renderElementToSvg","svgRoot","files","exportWithDarkMode","exportingFrameId","_getContainingFrame$o2","_getContainingFrame4","degree","PI","link","anchorTag","boundText","maskPath","maskRectVisible","maskRectInvisible","maskX","maskY","toString","group","append","getFreeDrawSvgPath","round","fileData","symbolId","symbol","querySelector","dataURL","prepend","use","translateX","translateY","clipG","direction","textAnchor","i","textContent","pathsCache","svgPathData","Path2D","inputPoints","simulatePressure","map","_ref","pressures","thinning","smoothing","streamline","easing","t","sin","last","lastCommittedPoint","getSvgPathFromStroke","med","A","B","TO_FIXED_PRECISION","reduce","acc","point","arr","join"],"sources":["D:/project/excalidraw-cn/src/renderer/renderElement.ts"],"sourcesContent":["import {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  Arrowhead,\n  NonDeletedExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawImageElement,\n  ExcalidrawTextElementWithContainer,\n} from \"../element/types\";\nimport {\n  isTextElement,\n  isLinearElement,\n  isFreeDrawElement,\n  isInitializedImageElement,\n  isArrowElement,\n  hasBoundTextElement,\n} from \"../element/typeChecks\";\nimport {\n  getDiamondPoints,\n  getElementAbsoluteCoords,\n  getArrowheadPoints,\n} from \"../element/bounds\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { Drawable, Options } from \"roughjs/bin/core\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport { RoughGenerator } from \"roughjs/bin/generator\";\n\nimport { RenderConfig } from \"../scene/types\";\nimport { distance, getFontString, getFontFamilyString, isRTL } from \"../utils\";\nimport { getCornerRadius, isPathALoop, isRightAngle } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { AppState, BinaryFiles, Zoom } from \"../types\";\nimport { getDefaultAppState } from \"../appState\";\nimport {\n  BOUND_TEXT_PADDING,\n  FRAME_STYLE,\n  MAX_DECIMALS_FOR_SVG_EXPORT,\n  MIME_TYPES,\n  SVG_NS,\n} from \"../constants\";\nimport { getStroke, StrokeOptions } from \"perfect-freehand\";\nimport {\n  getBoundTextElement,\n  getContainerCoords,\n  getContainerElement,\n  getLineHeightInPx,\n  getBoundTextMaxHeight,\n  getBoundTextMaxWidth,\n} from \"../element/textElement\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { getContainingFrame } from \"../frame\";\nimport { normalizeLink } from \"../data/url\";\n\n// using a stronger invert (100% vs our regular 93%) and saturate\n// as a temp hack to make images in dark theme look closer to original\n// color scheme (it's still not quite there and the colors look slightly\n// desatured, alas...)\nconst IMAGE_INVERT_FILTER = \"invert(100%) hue-rotate(180deg) saturate(1.25)\";\n\nconst defaultAppState = getDefaultAppState();\n\nconst isPendingImageElement = (\n  element: ExcalidrawElement,\n  renderConfig: RenderConfig,\n) =>\n  isInitializedImageElement(element) &&\n  !renderConfig.imageCache.has(element.fileId);\n\nconst shouldResetImageFilter = (\n  element: ExcalidrawElement,\n  renderConfig: RenderConfig,\n) => {\n  return (\n    renderConfig.theme === \"dark\" &&\n    isInitializedImageElement(element) &&\n    !isPendingImageElement(element, renderConfig) &&\n    renderConfig.imageCache.get(element.fileId)?.mimeType !== MIME_TYPES.svg\n  );\n};\n\nconst getDashArrayDashed = (strokeWidth: number) => [8, 8 + strokeWidth];\n\nconst getDashArrayDotted = (strokeWidth: number) => [1.5, 6 + strokeWidth];\n\nconst getCanvasPadding = (element: ExcalidrawElement) =>\n  element.type === \"freedraw\" ? element.strokeWidth * 12 : 20;\n\nexport interface ExcalidrawElementWithCanvas {\n  element: ExcalidrawElement | ExcalidrawTextElement;\n  canvas: HTMLCanvasElement;\n  theme: RenderConfig[\"theme\"];\n  scale: number;\n  zoomValue: RenderConfig[\"zoom\"][\"value\"];\n  canvasOffsetX: number;\n  canvasOffsetY: number;\n  boundTextElementVersion: number | null;\n  containingFrameOpacity: number;\n}\n\nconst cappedElementCanvasSize = (\n  element: NonDeletedExcalidrawElement,\n  zoom: Zoom,\n): {\n  width: number;\n  height: number;\n  scale: number;\n} => {\n  // these limits are ballpark, they depend on specific browsers and device.\n  // We've chosen lower limits to be safe. We might want to change these limits\n  // based on browser/device type, if we get reports of low quality rendering\n  // on zoom.\n  //\n  // ~ safari mobile canvas area limit\n  const AREA_LIMIT = 16777216;\n  // ~ safari width/height limit based on developer.mozilla.org.\n  const WIDTH_HEIGHT_LIMIT = 32767;\n\n  const padding = getCanvasPadding(element);\n\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const elementWidth =\n    isLinearElement(element) || isFreeDrawElement(element)\n      ? distance(x1, x2)\n      : element.width;\n  const elementHeight =\n    isLinearElement(element) || isFreeDrawElement(element)\n      ? distance(y1, y2)\n      : element.height;\n\n  let width = elementWidth * window.devicePixelRatio + padding * 2;\n  let height = elementHeight * window.devicePixelRatio + padding * 2;\n\n  let scale: number = zoom.value;\n\n  // rescale to ensure width and height is within limits\n  if (\n    width * scale > WIDTH_HEIGHT_LIMIT ||\n    height * scale > WIDTH_HEIGHT_LIMIT\n  ) {\n    scale = Math.min(WIDTH_HEIGHT_LIMIT / width, WIDTH_HEIGHT_LIMIT / height);\n  }\n\n  // rescale to ensure canvas area is within limits\n  if (width * height * scale * scale > AREA_LIMIT) {\n    scale = Math.sqrt(AREA_LIMIT / (width * height));\n  }\n\n  width = Math.floor(width * scale);\n  height = Math.floor(height * scale);\n\n  return { width, height, scale };\n};\n\nconst generateElementCanvas = (\n  element: NonDeletedExcalidrawElement,\n  zoom: Zoom,\n  renderConfig: RenderConfig,\n): ExcalidrawElementWithCanvas => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\")!;\n  const padding = getCanvasPadding(element);\n\n  const { width, height, scale } = cappedElementCanvasSize(element, zoom);\n\n  canvas.width = width;\n  canvas.height = height;\n\n  let canvasOffsetX = 0;\n  let canvasOffsetY = 0;\n\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    const [x1, y1] = getElementAbsoluteCoords(element);\n\n    canvasOffsetX =\n      element.x > x1\n        ? distance(element.x, x1) * window.devicePixelRatio * scale\n        : 0;\n\n    canvasOffsetY =\n      element.y > y1\n        ? distance(element.y, y1) * window.devicePixelRatio * scale\n        : 0;\n\n    context.translate(canvasOffsetX, canvasOffsetY);\n  }\n\n  context.save();\n  context.translate(padding * scale, padding * scale);\n  context.scale(\n    window.devicePixelRatio * scale,\n    window.devicePixelRatio * scale,\n  );\n\n  const rc = rough.canvas(canvas);\n\n  // in dark theme, revert the image color filter\n  if (shouldResetImageFilter(element, renderConfig)) {\n    context.filter = IMAGE_INVERT_FILTER;\n  }\n\n  drawElementOnCanvas(element, rc, context, renderConfig);\n  context.restore();\n\n  return {\n    element,\n    canvas,\n    theme: renderConfig.theme,\n    scale,\n    zoomValue: zoom.value,\n    canvasOffsetX,\n    canvasOffsetY,\n    boundTextElementVersion: getBoundTextElement(element)?.version || null,\n    containingFrameOpacity: getContainingFrame(element)?.opacity || 100,\n  };\n};\n\nexport const DEFAULT_LINK_SIZE = 14;\n\nconst IMAGE_PLACEHOLDER_IMG = document.createElement(\"img\");\nIMAGE_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(\n  `<svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"image\" class=\"svg-inline--fa fa-image fa-w-16\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path fill=\"#888\" d=\"M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z\"></path></svg>`,\n)}`;\n\nconst IMAGE_ERROR_PLACEHOLDER_IMG = document.createElement(\"img\");\nIMAGE_ERROR_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(\n  `<svg viewBox=\"0 0 668 668\" xmlns=\"http://www.w3.org/2000/svg\" xml:space=\"preserve\" style=\"fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2\"><path d=\"M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48ZM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56ZM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48Z\" style=\"fill:#888;fill-rule:nonzero\" transform=\"matrix(.81709 0 0 .81709 124.825 145.825)\"/><path d=\"M256 8C119.034 8 8 119.033 8 256c0 136.967 111.034 248 248 248s248-111.034 248-248S392.967 8 256 8Zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676ZM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676Z\" style=\"fill:#888;fill-rule:nonzero\" transform=\"matrix(.30366 0 0 .30366 506.822 60.065)\"/></svg>`,\n)}`;\n\nconst drawImagePlaceholder = (\n  element: ExcalidrawImageElement,\n  context: CanvasRenderingContext2D,\n  zoomValue: AppState[\"zoom\"][\"value\"],\n) => {\n  context.fillStyle = \"#E7E7E7\";\n  context.fillRect(0, 0, element.width, element.height);\n\n  const imageMinWidthOrHeight = Math.min(element.width, element.height);\n\n  const size = Math.min(\n    imageMinWidthOrHeight,\n    Math.min(imageMinWidthOrHeight * 0.4, 100),\n  );\n\n  context.drawImage(\n    element.status === \"error\"\n      ? IMAGE_ERROR_PLACEHOLDER_IMG\n      : IMAGE_PLACEHOLDER_IMG,\n    element.width / 2 - size / 2,\n    element.height / 2 - size / 2,\n    size,\n    size,\n  );\n};\nconst drawElementOnCanvas = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderConfig: RenderConfig,\n) => {\n  context.globalAlpha =\n    ((getContainingFrame(element)?.opacity ?? 100) * element.opacity) / 10000;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      context.lineJoin = \"round\";\n      context.lineCap = \"round\";\n      rc.draw(getShapeForElement(element)!);\n      break;\n    }\n    case \"arrow\":\n    case \"line\": {\n      context.lineJoin = \"round\";\n      context.lineCap = \"round\";\n\n      getShapeForElement(element)!.forEach((shape) => {\n        rc.draw(shape);\n      });\n      break;\n    }\n    case \"freedraw\": {\n      // Draw directly to canvas\n      context.save();\n      context.fillStyle = element.strokeColor;\n\n      const path = getFreeDrawPath2D(element) as Path2D;\n      const fillShape = getShapeForElement(element);\n\n      if (fillShape) {\n        rc.draw(fillShape);\n      }\n\n      context.fillStyle = element.strokeColor;\n      context.fill(path);\n\n      context.restore();\n      break;\n    }\n    case \"image\": {\n      const img = isInitializedImageElement(element)\n        ? renderConfig.imageCache.get(element.fileId)?.image\n        : undefined;\n      if (img != null && !(img instanceof Promise)) {\n        context.drawImage(\n          img,\n          0 /* hardcoded for the selection box*/,\n          0,\n          element.width,\n          element.height,\n        );\n      } else {\n        drawImagePlaceholder(element, context, renderConfig.zoom.value);\n      }\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const rtl = isRTL(element.text);\n        const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;\n        if (shouldTemporarilyAttach) {\n          // to correctly render RTL text mixed with LTR, we have to append it\n          // to the DOM\n          document.body.appendChild(context.canvas);\n        }\n        context.canvas.setAttribute(\"dir\", rtl ? \"rtl\" : \"ltr\");\n        context.save();\n        context.font = getFontString(element);\n        context.fillStyle = element.strokeColor;\n        context.textAlign = element.textAlign as CanvasTextAlign;\n\n        // Canvas does not support multiline text by default\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        const lineHeightPx = getLineHeightInPx(\n          element.fontSize,\n          element.lineHeight,\n        );\n        const verticalOffset = element.height - element.baseline;\n        for (let index = 0; index < lines.length; index++) {\n          context.fillText(\n            lines[index],\n            horizontalOffset,\n            (index + 1) * lineHeightPx - verticalOffset,\n          );\n        }\n        context.restore();\n        if (shouldTemporarilyAttach) {\n          context.canvas.remove();\n        }\n      } else {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n  context.globalAlpha = 1;\n};\n\nconst elementWithCanvasCache = new WeakMap<\n  ExcalidrawElement,\n  ExcalidrawElementWithCanvas\n>();\n\nconst shapeCache = new WeakMap<ExcalidrawElement, ElementShape>();\n\ntype ElementShape = Drawable | Drawable[] | null;\n\ntype ElementShapes = {\n  freedraw: Drawable | null;\n  arrow: Drawable[];\n  line: Drawable[];\n  text: null;\n  image: null;\n};\n\nexport const getShapeForElement = <T extends ExcalidrawElement>(element: T) =>\n  shapeCache.get(element) as T[\"type\"] extends keyof ElementShapes\n    ? ElementShapes[T[\"type\"]] | undefined\n    : Drawable | null | undefined;\n\nexport const setShapeForElement = <T extends ExcalidrawElement>(\n  element: T,\n  shape: T[\"type\"] extends keyof ElementShapes\n    ? ElementShapes[T[\"type\"]]\n    : Drawable,\n) => shapeCache.set(element, shape);\n\nexport const invalidateShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.delete(element);\n\nexport const generateRoughOptions = (\n  element: ExcalidrawElement,\n  continuousPath = false,\n): Options => {\n  const options: Options = {\n    seed: element.seed,\n    strokeLineDash:\n      element.strokeStyle === \"dashed\"\n        ? getDashArrayDashed(element.strokeWidth)\n        : element.strokeStyle === \"dotted\"\n        ? getDashArrayDotted(element.strokeWidth)\n        : undefined,\n    // for non-solid strokes, disable multiStroke because it tends to make\n    // dashes/dots overlay each other\n    disableMultiStroke: element.strokeStyle !== \"solid\",\n    // for non-solid strokes, increase the width a bit to make it visually\n    // similar to solid strokes, because we're also disabling multiStroke\n    strokeWidth:\n      element.strokeStyle !== \"solid\"\n        ? element.strokeWidth + 0.5\n        : element.strokeWidth,\n    // when increasing strokeWidth, we must explicitly set fillWeight and\n    // hachureGap because if not specified, roughjs uses strokeWidth to\n    // calculate them (and we don't want the fills to be modified)\n    fillWeight: element.strokeWidth / 2,\n    hachureGap: element.strokeWidth * 4,\n    roughness: element.roughness,\n    stroke: element.strokeColor,\n    preserveVertices: continuousPath,\n  };\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      options.fillStyle = element.fillStyle;\n      options.fill =\n        element.backgroundColor === \"transparent\"\n          ? undefined\n          : element.backgroundColor;\n      if (element.type === \"ellipse\") {\n        options.curveFitting = 1;\n      }\n      return options;\n    }\n    case \"line\":\n    case \"freedraw\": {\n      if (isPathALoop(element.points)) {\n        options.fillStyle = element.fillStyle;\n        options.fill =\n          element.backgroundColor === \"transparent\"\n            ? undefined\n            : element.backgroundColor;\n      }\n      return options;\n    }\n    case \"arrow\":\n      return options;\n    default: {\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\n/**\n * Generates the element's shape and puts it into the cache.\n * @param element\n * @param generator\n */\nconst generateElementShape = (\n  element: NonDeletedExcalidrawElement,\n  generator: RoughGenerator,\n) => {\n  let shape = shapeCache.get(element);\n\n  // `null` indicates no rc shape applicable for this element type\n  // (= do not generate anything)\n  if (shape === undefined) {\n    elementWithCanvasCache.delete(element);\n\n    switch (element.type) {\n      case \"rectangle\": {\n        if (element.roundness) {\n          const w = element.width;\n          const h = element.height;\n          const r = getCornerRadius(Math.min(w, h), element);\n          shape = generator.path(\n            `M ${r} 0 L ${w - r} 0 Q ${w} 0, ${w} ${r} L ${w} ${\n              h - r\n            } Q ${w} ${h}, ${w - r} ${h} L ${r} ${h} Q 0 ${h}, 0 ${\n              h - r\n            } L 0 ${r} Q 0 0, ${r} 0`,\n            generateRoughOptions(element, true),\n          );\n        } else {\n          shape = generator.rectangle(\n            0,\n            0,\n            element.width,\n            element.height,\n            generateRoughOptions(element),\n          );\n        }\n        setShapeForElement(element, shape);\n\n        break;\n      }\n      case \"diamond\": {\n        const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] =\n          getDiamondPoints(element);\n        if (element.roundness) {\n          const verticalRadius = getCornerRadius(\n            Math.abs(topX - leftX),\n            element,\n          );\n\n          const horizontalRadius = getCornerRadius(\n            Math.abs(rightY - topY),\n            element,\n          );\n\n          shape = generator.path(\n            `M ${topX + verticalRadius} ${topY + horizontalRadius} L ${\n              rightX - verticalRadius\n            } ${rightY - horizontalRadius}\n            C ${rightX} ${rightY}, ${rightX} ${rightY}, ${\n              rightX - verticalRadius\n            } ${rightY + horizontalRadius}\n            L ${bottomX + verticalRadius} ${bottomY - horizontalRadius}\n            C ${bottomX} ${bottomY}, ${bottomX} ${bottomY}, ${\n              bottomX - verticalRadius\n            } ${bottomY - horizontalRadius}\n            L ${leftX + verticalRadius} ${leftY + horizontalRadius}\n            C ${leftX} ${leftY}, ${leftX} ${leftY}, ${leftX + verticalRadius} ${\n              leftY - horizontalRadius\n            }\n            L ${topX - verticalRadius} ${topY + horizontalRadius}\n            C ${topX} ${topY}, ${topX} ${topY}, ${topX + verticalRadius} ${\n              topY + horizontalRadius\n            }`,\n            generateRoughOptions(element, true),\n          );\n        } else {\n          shape = generator.polygon(\n            [\n              [topX, topY],\n              [rightX, rightY],\n              [bottomX, bottomY],\n              [leftX, leftY],\n            ],\n            generateRoughOptions(element),\n          );\n        }\n        setShapeForElement(element, shape);\n\n        break;\n      }\n      case \"ellipse\":\n        shape = generator.ellipse(\n          element.width / 2,\n          element.height / 2,\n          element.width,\n          element.height,\n          generateRoughOptions(element),\n        );\n        setShapeForElement(element, shape);\n\n        break;\n      case \"line\":\n      case \"arrow\": {\n        const options = generateRoughOptions(element);\n\n        // points array can be empty in the beginning, so it is important to add\n        // initial position to it\n        const points = element.points.length ? element.points : [[0, 0]];\n\n        // curve is always the first element\n        // this simplifies finding the curve for an element\n        if (!element.roundness) {\n          if (options.fill) {\n            shape = [generator.polygon(points as [number, number][], options)];\n          } else {\n            shape = [\n              generator.linearPath(points as [number, number][], options),\n            ];\n          }\n        } else {\n          shape = [generator.curve(points as [number, number][], options)];\n        }\n\n        // add lines only in arrow\n        if (element.type === \"arrow\") {\n          const { startArrowhead = null, endArrowhead = \"arrow\" } = element;\n\n          const getArrowheadShapes = (\n            element: ExcalidrawLinearElement,\n            shape: Drawable[],\n            position: \"start\" | \"end\",\n            arrowhead: Arrowhead,\n          ) => {\n            const arrowheadPoints = getArrowheadPoints(\n              element,\n              shape,\n              position,\n              arrowhead,\n            );\n\n            if (arrowheadPoints === null) {\n              return [];\n            }\n\n            // Other arrowheads here...\n            if (arrowhead === \"dot\") {\n              const [x, y, r] = arrowheadPoints;\n\n              return [\n                generator.circle(x, y, r, {\n                  ...options,\n                  fill: element.strokeColor,\n                  fillStyle: \"solid\",\n                  stroke: \"none\",\n                }),\n              ];\n            }\n\n            if (arrowhead === \"triangle\") {\n              const [x, y, x2, y2, x3, y3] = arrowheadPoints;\n\n              // always use solid stroke for triangle arrowhead\n              delete options.strokeLineDash;\n\n              return [\n                generator.polygon(\n                  [\n                    [x, y],\n                    [x2, y2],\n                    [x3, y3],\n                    [x, y],\n                  ],\n                  {\n                    ...options,\n                    fill: element.strokeColor,\n                    fillStyle: \"solid\",\n                  },\n                ),\n              ];\n            }\n\n            // Arrow arrowheads\n            const [x2, y2, x3, y3, x4, y4] = arrowheadPoints;\n\n            if (element.strokeStyle === \"dotted\") {\n              // for dotted arrows caps, reduce gap to make it more legible\n              const dash = getDashArrayDotted(element.strokeWidth - 1);\n              options.strokeLineDash = [dash[0], dash[1] - 1];\n            } else {\n              // for solid/dashed, keep solid arrow cap\n              delete options.strokeLineDash;\n            }\n            return [\n              generator.line(x3, y3, x2, y2, options),\n              generator.line(x4, y4, x2, y2, options),\n            ];\n          };\n\n          if (startArrowhead !== null) {\n            const shapes = getArrowheadShapes(\n              element,\n              shape,\n              \"start\",\n              startArrowhead,\n            );\n            shape.push(...shapes);\n          }\n\n          if (endArrowhead !== null) {\n            if (endArrowhead === undefined) {\n              // Hey, we have an old arrow here!\n            }\n\n            const shapes = getArrowheadShapes(\n              element,\n              shape,\n              \"end\",\n              endArrowhead,\n            );\n            shape.push(...shapes);\n          }\n        }\n\n        setShapeForElement(element, shape);\n\n        break;\n      }\n      case \"freedraw\": {\n        generateFreeDrawShape(element);\n\n        if (isPathALoop(element.points)) {\n          // generate rough polygon to fill freedraw shape\n          shape = generator.polygon(element.points as [number, number][], {\n            ...generateRoughOptions(element),\n            stroke: \"none\",\n          });\n        } else {\n          shape = null;\n        }\n        setShapeForElement(element, shape);\n        break;\n      }\n      case \"text\":\n      case \"image\": {\n        // just to ensure we don't regenerate element.canvas on rerenders\n        setShapeForElement(element, null);\n        break;\n      }\n    }\n  }\n};\n\nconst generateElementWithCanvas = (\n  element: NonDeletedExcalidrawElement,\n  renderConfig: RenderConfig,\n) => {\n  const zoom: Zoom = renderConfig ? renderConfig.zoom : defaultAppState.zoom;\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom =\n    prevElementWithCanvas &&\n    prevElementWithCanvas.zoomValue !== zoom.value &&\n    !renderConfig?.shouldCacheIgnoreZoom;\n  const boundTextElementVersion = getBoundTextElement(element)?.version || null;\n  const containingFrameOpacity = getContainingFrame(element)?.opacity || 100;\n\n  if (\n    !prevElementWithCanvas ||\n    shouldRegenerateBecauseZoom ||\n    prevElementWithCanvas.theme !== renderConfig.theme ||\n    prevElementWithCanvas.boundTextElementVersion !== boundTextElementVersion ||\n    prevElementWithCanvas.containingFrameOpacity !== containingFrameOpacity\n  ) {\n    const elementWithCanvas = generateElementCanvas(\n      element,\n      zoom,\n      renderConfig,\n    );\n\n    elementWithCanvasCache.set(element, elementWithCanvas);\n\n    return elementWithCanvas;\n  }\n  return prevElementWithCanvas;\n};\n\nconst drawElementFromCanvas = (\n  elementWithCanvas: ExcalidrawElementWithCanvas,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderConfig: RenderConfig,\n) => {\n  const element = elementWithCanvas.element;\n  const padding = getCanvasPadding(element);\n  const zoom = elementWithCanvas.scale;\n  let [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n  // Free draw elements will otherwise \"shuffle\" as the min x and y change\n  if (isFreeDrawElement(element)) {\n    x1 = Math.floor(x1);\n    x2 = Math.ceil(x2);\n    y1 = Math.floor(y1);\n    y2 = Math.ceil(y2);\n  }\n\n  const cx = ((x1 + x2) / 2 + renderConfig.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + renderConfig.scrollY) * window.devicePixelRatio;\n\n  context.save();\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n  const boundTextElement = getBoundTextElement(element);\n\n  if (isArrowElement(element) && boundTextElement) {\n    const tempCanvas = document.createElement(\"canvas\");\n    const tempCanvasContext = tempCanvas.getContext(\"2d\")!;\n\n    // Take max dimensions of arrow canvas so that when canvas is rotated\n    // the arrow doesn't get clipped\n    const maxDim = Math.max(distance(x1, x2), distance(y1, y2));\n    tempCanvas.width =\n      maxDim * window.devicePixelRatio * zoom +\n      padding * elementWithCanvas.scale * 10;\n    tempCanvas.height =\n      maxDim * window.devicePixelRatio * zoom +\n      padding * elementWithCanvas.scale * 10;\n    const offsetX = (tempCanvas.width - elementWithCanvas.canvas!.width) / 2;\n    const offsetY = (tempCanvas.height - elementWithCanvas.canvas!.height) / 2;\n\n    tempCanvasContext.translate(tempCanvas.width / 2, tempCanvas.height / 2);\n    tempCanvasContext.rotate(element.angle);\n\n    tempCanvasContext.drawImage(\n      elementWithCanvas.canvas!,\n      -elementWithCanvas.canvas.width / 2,\n      -elementWithCanvas.canvas.height / 2,\n      elementWithCanvas.canvas.width,\n      elementWithCanvas.canvas.height,\n    );\n\n    const [, , , , boundTextCx, boundTextCy] =\n      getElementAbsoluteCoords(boundTextElement);\n\n    tempCanvasContext.rotate(-element.angle);\n\n    // Shift the canvas to the center of the bound text element\n    const shiftX =\n      tempCanvas.width / 2 -\n      (boundTextCx - x1) * window.devicePixelRatio * zoom -\n      offsetX -\n      padding * zoom;\n\n    const shiftY =\n      tempCanvas.height / 2 -\n      (boundTextCy - y1) * window.devicePixelRatio * zoom -\n      offsetY -\n      padding * zoom;\n    tempCanvasContext.translate(-shiftX, -shiftY);\n\n    // Clear the bound text area\n    tempCanvasContext.clearRect(\n      -(boundTextElement.width / 2 + BOUND_TEXT_PADDING) *\n        window.devicePixelRatio *\n        zoom,\n      -(boundTextElement.height / 2 + BOUND_TEXT_PADDING) *\n        window.devicePixelRatio *\n        zoom,\n      (boundTextElement.width + BOUND_TEXT_PADDING * 2) *\n        window.devicePixelRatio *\n        zoom,\n      (boundTextElement.height + BOUND_TEXT_PADDING * 2) *\n        window.devicePixelRatio *\n        zoom,\n    );\n\n    context.translate(cx, cy);\n    context.drawImage(\n      tempCanvas,\n      (-(x2 - x1) / 2) * window.devicePixelRatio - offsetX / zoom - padding,\n      (-(y2 - y1) / 2) * window.devicePixelRatio - offsetY / zoom - padding,\n      tempCanvas.width / zoom,\n      tempCanvas.height / zoom,\n    );\n  } else {\n    // we translate context to element center so that rotation and scale\n    // originates from the element center\n    context.translate(cx, cy);\n\n    context.rotate(element.angle);\n\n    if (\n      \"scale\" in elementWithCanvas.element &&\n      !isPendingImageElement(element, renderConfig)\n    ) {\n      context.scale(\n        elementWithCanvas.element.scale[0],\n        elementWithCanvas.element.scale[1],\n      );\n    }\n\n    // revert afterwards we don't have account for it during drawing\n    context.translate(-cx, -cy);\n\n    context.drawImage(\n      elementWithCanvas.canvas!,\n      (x1 + renderConfig.scrollX) * window.devicePixelRatio -\n        (padding * elementWithCanvas.scale) / elementWithCanvas.scale,\n      (y1 + renderConfig.scrollY) * window.devicePixelRatio -\n        (padding * elementWithCanvas.scale) / elementWithCanvas.scale,\n      elementWithCanvas.canvas!.width / elementWithCanvas.scale,\n      elementWithCanvas.canvas!.height / elementWithCanvas.scale,\n    );\n\n    if (\n      process.env.REACT_APP_DEBUG_ENABLE_TEXT_CONTAINER_BOUNDING_BOX ===\n        \"true\" &&\n      hasBoundTextElement(element)\n    ) {\n      const textElement = getBoundTextElement(\n        element,\n      ) as ExcalidrawTextElementWithContainer;\n      const coords = getContainerCoords(element);\n      context.strokeStyle = \"#c92a2a\";\n      context.lineWidth = 3;\n      context.strokeRect(\n        (coords.x + renderConfig.scrollX) * window.devicePixelRatio,\n        (coords.y + renderConfig.scrollY) * window.devicePixelRatio,\n        getBoundTextMaxWidth(element) * window.devicePixelRatio,\n        getBoundTextMaxHeight(element, textElement) * window.devicePixelRatio,\n      );\n    }\n  }\n  context.restore();\n\n  // Clear the nested element we appended to the DOM\n};\n\nexport const renderElement = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderConfig: RenderConfig,\n  appState: AppState,\n) => {\n  const generator = rc.generator;\n  switch (element.type) {\n    case \"selection\": {\n      // do not render selection when exporting\n      if (!renderConfig.isExporting) {\n        context.save();\n        context.translate(\n          element.x + renderConfig.scrollX,\n          element.y + renderConfig.scrollY,\n        );\n        context.fillStyle = \"rgba(0, 0, 200, 0.04)\";\n\n        // render from 0.5px offset  to get 1px wide line\n        // https://stackoverflow.com/questions/7530593/html5-canvas-and-line-width/7531540#7531540\n        // TODO can be be improved by offseting to the negative when user selects\n        // from right to left\n        const offset = 0.5 / renderConfig.zoom.value;\n\n        context.fillRect(offset, offset, element.width, element.height);\n        context.lineWidth = 1 / renderConfig.zoom.value;\n        context.strokeStyle = \" rgb(105, 101, 219)\";\n        context.strokeRect(offset, offset, element.width, element.height);\n\n        context.restore();\n      }\n      break;\n    }\n    case \"frame\": {\n      if (\n        !renderConfig.isExporting &&\n        appState.frameRendering.enabled &&\n        appState.frameRendering.outline\n      ) {\n        context.save();\n        context.translate(\n          element.x + renderConfig.scrollX,\n          element.y + renderConfig.scrollY,\n        );\n        context.fillStyle = \"rgba(0, 0, 200, 0.04)\";\n\n        context.lineWidth = 2 / renderConfig.zoom.value;\n        context.strokeStyle = FRAME_STYLE.strokeColor;\n\n        if (FRAME_STYLE.radius && context.roundRect) {\n          context.beginPath();\n          context.roundRect(\n            0,\n            0,\n            element.width,\n            element.height,\n            FRAME_STYLE.radius / renderConfig.zoom.value,\n          );\n          context.stroke();\n          context.closePath();\n        } else {\n          context.strokeRect(0, 0, element.width, element.height);\n        }\n\n        context.restore();\n      }\n      break;\n    }\n    case \"freedraw\": {\n      generateElementShape(element, generator);\n\n      if (renderConfig.isExporting) {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n        const cx = (x1 + x2) / 2 + renderConfig.scrollX;\n        const cy = (y1 + y2) / 2 + renderConfig.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.save();\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(element, rc, context, renderConfig);\n        context.restore();\n      } else {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          renderConfig,\n        );\n        drawElementFromCanvas(elementWithCanvas, rc, context, renderConfig);\n      }\n\n      break;\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"arrow\":\n    case \"image\":\n    case \"text\": {\n      generateElementShape(element, generator);\n      if (renderConfig.isExporting) {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n        const cx = (x1 + x2) / 2 + renderConfig.scrollX;\n        const cy = (y1 + y2) / 2 + renderConfig.scrollY;\n        let shiftX = (x2 - x1) / 2 - (element.x - x1);\n        let shiftY = (y2 - y1) / 2 - (element.y - y1);\n        if (isTextElement(element)) {\n          const container = getContainerElement(element);\n          if (isArrowElement(container)) {\n            const boundTextCoords =\n              LinearElementEditor.getBoundTextElementPosition(\n                container,\n                element as ExcalidrawTextElementWithContainer,\n              );\n            shiftX = (x2 - x1) / 2 - (boundTextCoords.x - x1);\n            shiftY = (y2 - y1) / 2 - (boundTextCoords.y - y1);\n          }\n        }\n        context.save();\n        context.translate(cx, cy);\n\n        if (shouldResetImageFilter(element, renderConfig)) {\n          context.filter = \"none\";\n        }\n        const boundTextElement = getBoundTextElement(element);\n\n        if (isArrowElement(element) && boundTextElement) {\n          const tempCanvas = document.createElement(\"canvas\");\n\n          const tempCanvasContext = tempCanvas.getContext(\"2d\")!;\n\n          // Take max dimensions of arrow canvas so that when canvas is rotated\n          // the arrow doesn't get clipped\n          const maxDim = Math.max(distance(x1, x2), distance(y1, y2));\n          const padding = getCanvasPadding(element);\n          tempCanvas.width =\n            maxDim * appState.exportScale + padding * 10 * appState.exportScale;\n          tempCanvas.height =\n            maxDim * appState.exportScale + padding * 10 * appState.exportScale;\n\n          tempCanvasContext.translate(\n            tempCanvas.width / 2,\n            tempCanvas.height / 2,\n          );\n          tempCanvasContext.scale(appState.exportScale, appState.exportScale);\n\n          // Shift the canvas to left most point of the arrow\n          shiftX = element.width / 2 - (element.x - x1);\n          shiftY = element.height / 2 - (element.y - y1);\n\n          tempCanvasContext.rotate(element.angle);\n          const tempRc = rough.canvas(tempCanvas);\n\n          tempCanvasContext.translate(-shiftX, -shiftY);\n\n          drawElementOnCanvas(element, tempRc, tempCanvasContext, renderConfig);\n\n          tempCanvasContext.translate(shiftX, shiftY);\n\n          tempCanvasContext.rotate(-element.angle);\n\n          // Shift the canvas to center of bound text\n          const [, , , , boundTextCx, boundTextCy] =\n            getElementAbsoluteCoords(boundTextElement);\n          const boundTextShiftX = (x1 + x2) / 2 - boundTextCx;\n          const boundTextShiftY = (y1 + y2) / 2 - boundTextCy;\n          tempCanvasContext.translate(-boundTextShiftX, -boundTextShiftY);\n\n          // Clear the bound text area\n          tempCanvasContext.clearRect(\n            -boundTextElement.width / 2,\n            -boundTextElement.height / 2,\n            boundTextElement.width,\n            boundTextElement.height,\n          );\n          context.scale(1 / appState.exportScale, 1 / appState.exportScale);\n          context.drawImage(\n            tempCanvas,\n            -tempCanvas.width / 2,\n            -tempCanvas.height / 2,\n            tempCanvas.width,\n            tempCanvas.height,\n          );\n        } else {\n          context.rotate(element.angle);\n\n          if (element.type === \"image\") {\n            // note: scale must be applied *after* rotating\n            context.scale(element.scale[0], element.scale[1]);\n          }\n\n          context.translate(-shiftX, -shiftY);\n          drawElementOnCanvas(element, rc, context, renderConfig);\n        }\n\n        context.restore();\n        // not exporting → optimized rendering (cache & render from element\n        // canvases)\n      } else {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          renderConfig,\n        );\n\n        const currentImageSmoothingStatus = context.imageSmoothingEnabled;\n\n        if (\n          // do not disable smoothing during zoom as blurry shapes look better\n          // on low resolution (while still zooming in) than sharp ones\n          !renderConfig?.shouldCacheIgnoreZoom &&\n          // angle is 0 -> always disable smoothing\n          (!element.angle ||\n            // or check if angle is a right angle in which case we can still\n            // disable smoothing without adversely affecting the result\n            isRightAngle(element.angle))\n        ) {\n          // Disabling smoothing makes output much sharper, especially for\n          // text. Unless for non-right angles, where the aliasing is really\n          // terrible on Chromium.\n          //\n          // Note that `context.imageSmoothingQuality=\"high\"` has almost\n          // zero effect.\n          //\n          context.imageSmoothingEnabled = false;\n        }\n\n        drawElementFromCanvas(elementWithCanvas, rc, context, renderConfig);\n\n        // reset\n        context.imageSmoothingEnabled = currentImageSmoothingStatus;\n      }\n      break;\n    }\n    default: {\n      // @ts-ignore\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nconst roughSVGDrawWithPrecision = (\n  rsvg: RoughSVG,\n  drawable: Drawable,\n  precision?: number,\n) => {\n  if (typeof precision === \"undefined\") {\n    return rsvg.draw(drawable);\n  }\n  const pshape: Drawable = {\n    sets: drawable.sets,\n    shape: drawable.shape,\n    options: { ...drawable.options, fixedDecimalPlaceDigits: precision },\n  };\n  return rsvg.draw(pshape);\n};\n\nconst maybeWrapNodesInFrameClipPath = (\n  element: NonDeletedExcalidrawElement,\n  root: SVGElement,\n  nodes: SVGElement[],\n  exportedFrameId?: string | null,\n) => {\n  const frame = getContainingFrame(element);\n  if (frame && frame.id === exportedFrameId) {\n    const g = root.ownerDocument!.createElementNS(SVG_NS, \"g\");\n    g.setAttributeNS(SVG_NS, \"clip-path\", `url(#${frame.id})`);\n    nodes.forEach((node) => g.appendChild(node));\n    return g;\n  }\n\n  return null;\n};\n\nexport const renderElementToSvg = (\n  element: NonDeletedExcalidrawElement,\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  files: BinaryFiles,\n  offsetX: number,\n  offsetY: number,\n  exportWithDarkMode?: boolean,\n  exportingFrameId?: string | null,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  let cx = (x2 - x1) / 2 - (element.x - x1);\n  let cy = (y2 - y1) / 2 - (element.y - y1);\n  if (isTextElement(element)) {\n    const container = getContainerElement(element);\n    if (isArrowElement(container)) {\n      const [x1, y1, x2, y2] = getElementAbsoluteCoords(container);\n\n      const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(\n        container,\n        element as ExcalidrawTextElementWithContainer,\n      );\n      cx = (x2 - x1) / 2 - (boundTextCoords.x - x1);\n      cy = (y2 - y1) / 2 - (boundTextCoords.y - y1);\n      offsetX = offsetX + boundTextCoords.x - element.x;\n      offsetY = offsetY + boundTextCoords.y - element.y;\n    }\n  }\n  const degree = (180 * element.angle) / Math.PI;\n  const generator = rsvg.generator;\n\n  // element to append node to, most of the time svgRoot\n  let root = svgRoot;\n\n  // if the element has a link, create an anchor tag and make that the new root\n  if (element.link) {\n    const anchorTag = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"a\");\n    anchorTag.setAttribute(\"href\", normalizeLink(element.link));\n    root.appendChild(anchorTag);\n    root = anchorTag;\n  }\n\n  const opacity =\n    ((getContainingFrame(element)?.opacity ?? 100) * element.opacity) / 10000;\n\n  switch (element.type) {\n    case \"selection\": {\n      // Since this is used only during editing experience, which is canvas based,\n      // this should not happen\n      throw new Error(\"Selection rendering is not supported for SVG\");\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      generateElementShape(element, generator);\n      const node = roughSVGDrawWithPrecision(\n        rsvg,\n        getShapeForElement(element)!,\n        MAX_DECIMALS_FOR_SVG_EXPORT,\n      );\n      if (opacity !== 1) {\n        node.setAttribute(\"stroke-opacity\", `${opacity}`);\n        node.setAttribute(\"fill-opacity\", `${opacity}`);\n      }\n      node.setAttribute(\"stroke-linecap\", \"round\");\n      node.setAttribute(\n        \"transform\",\n        `translate(${offsetX || 0} ${\n          offsetY || 0\n        }) rotate(${degree} ${cx} ${cy})`,\n      );\n\n      const g = maybeWrapNodesInFrameClipPath(\n        element,\n        root,\n        [node],\n        exportingFrameId,\n      );\n\n      g ? root.appendChild(g) : root.appendChild(node);\n      break;\n    }\n    case \"line\":\n    case \"arrow\": {\n      const boundText = getBoundTextElement(element);\n      const maskPath = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"mask\");\n      if (boundText) {\n        maskPath.setAttribute(\"id\", `mask-${element.id}`);\n        const maskRectVisible = svgRoot.ownerDocument!.createElementNS(\n          SVG_NS,\n          \"rect\",\n        );\n        offsetX = offsetX || 0;\n        offsetY = offsetY || 0;\n        maskRectVisible.setAttribute(\"x\", \"0\");\n        maskRectVisible.setAttribute(\"y\", \"0\");\n        maskRectVisible.setAttribute(\"fill\", \"#fff\");\n        maskRectVisible.setAttribute(\n          \"width\",\n          `${element.width + 100 + offsetX}`,\n        );\n        maskRectVisible.setAttribute(\n          \"height\",\n          `${element.height + 100 + offsetY}`,\n        );\n\n        maskPath.appendChild(maskRectVisible);\n        const maskRectInvisible = svgRoot.ownerDocument!.createElementNS(\n          SVG_NS,\n          \"rect\",\n        );\n        const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(\n          element,\n          boundText,\n        );\n\n        const maskX = offsetX + boundTextCoords.x - element.x;\n        const maskY = offsetY + boundTextCoords.y - element.y;\n\n        maskRectInvisible.setAttribute(\"x\", maskX.toString());\n        maskRectInvisible.setAttribute(\"y\", maskY.toString());\n        maskRectInvisible.setAttribute(\"fill\", \"#000\");\n        maskRectInvisible.setAttribute(\"width\", `${boundText.width}`);\n        maskRectInvisible.setAttribute(\"height\", `${boundText.height}`);\n        maskRectInvisible.setAttribute(\"opacity\", \"1\");\n        maskPath.appendChild(maskRectInvisible);\n      }\n      generateElementShape(element, generator);\n      const group = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n      if (boundText) {\n        group.setAttribute(\"mask\", `url(#mask-${element.id})`);\n      }\n      group.setAttribute(\"stroke-linecap\", \"round\");\n\n      getShapeForElement(element)!.forEach((shape) => {\n        const node = roughSVGDrawWithPrecision(\n          rsvg,\n          shape,\n          MAX_DECIMALS_FOR_SVG_EXPORT,\n        );\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        if (\n          element.type === \"line\" &&\n          isPathALoop(element.points) &&\n          element.backgroundColor !== \"transparent\"\n        ) {\n          node.setAttribute(\"fill-rule\", \"evenodd\");\n        }\n        group.appendChild(node);\n      });\n\n      const g = maybeWrapNodesInFrameClipPath(\n        element,\n        root,\n        [group, maskPath],\n        exportingFrameId,\n      );\n      if (g) {\n        root.appendChild(g);\n      } else {\n        root.appendChild(group);\n        root.append(maskPath);\n      }\n      break;\n    }\n    case \"freedraw\": {\n      generateElementShape(element, generator);\n      generateFreeDrawShape(element);\n      const shape = getShapeForElement(element);\n      const node = shape\n        ? roughSVGDrawWithPrecision(rsvg, shape, MAX_DECIMALS_FOR_SVG_EXPORT)\n        : svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n      if (opacity !== 1) {\n        node.setAttribute(\"stroke-opacity\", `${opacity}`);\n        node.setAttribute(\"fill-opacity\", `${opacity}`);\n      }\n      node.setAttribute(\n        \"transform\",\n        `translate(${offsetX || 0} ${\n          offsetY || 0\n        }) rotate(${degree} ${cx} ${cy})`,\n      );\n      node.setAttribute(\"stroke\", \"none\");\n      const path = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"path\");\n      path.setAttribute(\"fill\", element.strokeColor);\n      path.setAttribute(\"d\", getFreeDrawSvgPath(element));\n      node.appendChild(path);\n\n      const g = maybeWrapNodesInFrameClipPath(\n        element,\n        root,\n        [node],\n        exportingFrameId,\n      );\n\n      g ? root.appendChild(g) : root.appendChild(node);\n      break;\n    }\n    case \"image\": {\n      const width = Math.round(element.width);\n      const height = Math.round(element.height);\n      const fileData =\n        isInitializedImageElement(element) && files[element.fileId];\n      if (fileData) {\n        const symbolId = `image-${fileData.id}`;\n        let symbol = svgRoot.querySelector(`#${symbolId}`);\n        if (!symbol) {\n          symbol = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"symbol\");\n          symbol.id = symbolId;\n\n          const image = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"image\");\n\n          image.setAttribute(\"width\", \"100%\");\n          image.setAttribute(\"height\", \"100%\");\n          image.setAttribute(\"href\", fileData.dataURL);\n\n          symbol.appendChild(image);\n\n          root.prepend(symbol);\n        }\n\n        const use = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"use\");\n        use.setAttribute(\"href\", `#${symbolId}`);\n\n        // in dark theme, revert the image color filter\n        if (exportWithDarkMode && fileData.mimeType !== MIME_TYPES.svg) {\n          use.setAttribute(\"filter\", IMAGE_INVERT_FILTER);\n        }\n\n        use.setAttribute(\"width\", `${width}`);\n        use.setAttribute(\"height\", `${height}`);\n        use.setAttribute(\"opacity\", `${opacity}`);\n\n        // We first apply `scale` transforms (horizontal/vertical mirroring)\n        // on the <use> element, then apply translation and rotation\n        // on the <g> element which wraps the <use>.\n        // Doing this separately is a quick hack to to work around compositing\n        // the transformations correctly (the transform-origin was not being\n        // applied correctly).\n        if (element.scale[0] !== 1 || element.scale[1] !== 1) {\n          const translateX = element.scale[0] !== 1 ? -width : 0;\n          const translateY = element.scale[1] !== 1 ? -height : 0;\n          use.setAttribute(\n            \"transform\",\n            `scale(${element.scale[0]}, ${element.scale[1]}) translate(${translateX} ${translateY})`,\n          );\n        }\n\n        const g = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n        g.appendChild(use);\n        g.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n\n        const clipG = maybeWrapNodesInFrameClipPath(\n          element,\n          root,\n          [g],\n          exportingFrameId,\n        );\n        clipG ? root.appendChild(clipG) : root.appendChild(g);\n      }\n      break;\n    }\n    // frames are not rendered and only acts as a container\n    case \"frame\": {\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const node = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeightPx = getLineHeightInPx(\n          element.fontSize,\n          element.lineHeight,\n        );\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        const direction = isRTL(element.text) ? \"rtl\" : \"ltr\";\n        const textAnchor =\n          element.textAlign === \"center\"\n            ? \"middle\"\n            : element.textAlign === \"right\" || direction === \"rtl\"\n            ? \"end\"\n            : \"start\";\n        for (let i = 0; i < lines.length; i++) {\n          const text = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"text\");\n          text.textContent = lines[i];\n          text.setAttribute(\"x\", `${horizontalOffset}`);\n          text.setAttribute(\"y\", `${i * lineHeightPx}`);\n          text.setAttribute(\"font-family\", getFontFamilyString(element));\n          text.setAttribute(\"font-size\", `${element.fontSize}px`);\n          text.setAttribute(\"fill\", element.strokeColor);\n          text.setAttribute(\"text-anchor\", textAnchor);\n          text.setAttribute(\"style\", \"white-space: pre;\");\n          text.setAttribute(\"direction\", direction);\n          text.setAttribute(\"dominant-baseline\", \"text-before-edge\");\n          node.appendChild(text);\n        }\n\n        const g = maybeWrapNodesInFrameClipPath(\n          element,\n          root,\n          [node],\n          exportingFrameId,\n        );\n\n        g ? root.appendChild(g) : root.appendChild(node);\n      } else {\n        // @ts-ignore\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n};\n\nexport const pathsCache = new WeakMap<ExcalidrawFreeDrawElement, Path2D>([]);\n\nexport function generateFreeDrawShape(element: ExcalidrawFreeDrawElement) {\n  const svgPathData = getFreeDrawSvgPath(element);\n  const path = new Path2D(svgPathData);\n  pathsCache.set(element, path);\n  return path;\n}\n\nexport function getFreeDrawPath2D(element: ExcalidrawFreeDrawElement) {\n  return pathsCache.get(element);\n}\n\nexport function getFreeDrawSvgPath(element: ExcalidrawFreeDrawElement) {\n  // If input points are empty (should they ever be?) return a dot\n  const inputPoints = element.simulatePressure\n    ? element.points\n    : element.points.length\n    ? element.points.map(([x, y], i) => [x, y, element.pressures[i]])\n    : [[0, 0, 0.5]];\n\n  // Consider changing the options for simulated pressure vs real pressure\n  const options: StrokeOptions = {\n    simulatePressure: element.simulatePressure,\n    size: element.strokeWidth * 4.25,\n    thinning: 0.6,\n    smoothing: 0.5,\n    streamline: 0.5,\n    easing: (t) => Math.sin((t * Math.PI) / 2), // https://easings.net/#easeOutSine\n    last: !!element.lastCommittedPoint, // LastCommittedPoint is added on pointerup\n  };\n\n  return getSvgPathFromStroke(getStroke(inputPoints as number[][], options));\n}\n\nfunction med(A: number[], B: number[]) {\n  return [(A[0] + B[0]) / 2, (A[1] + B[1]) / 2];\n}\n\n// Trim SVG path data so number are each two decimal points. This\n// improves SVG exports, and prevents rendering errors on points\n// with long decimals.\nconst TO_FIXED_PRECISION = /(\\s?[A-Z]?,?-?[0-9]*\\.[0-9]{0,2})(([0-9]|e|-)*)/g;\n\nfunction getSvgPathFromStroke(points: number[][]): string {\n  if (!points.length) {\n    return \"\";\n  }\n\n  const max = points.length - 1;\n\n  return points\n    .reduce(\n      (acc, point, i, arr) => {\n        if (i === max) {\n          acc.push(point, med(point, arr[0]), \"L\", arr[0], \"Z\");\n        } else {\n          acc.push(point, med(point, arr[i + 1]));\n        }\n        return acc;\n      },\n      [\"M\", points[0], \"Q\"],\n    )\n    .join(\" \")\n    .replace(TO_FIXED_PRECISION, \"$1\");\n}\n"],"mappings":"AAUA,SACEA,aAAa,EACbC,eAAe,EACfC,iBAAiB,EACjBC,yBAAyB,EACzBC,cAAc,EACdC,mBAAmB,QACd,uBAAuB;AAC9B,SACEC,gBAAgB,EAChBC,wBAAwB,EACxBC,kBAAkB,QACb,mBAAmB;AAO1B,SAASC,QAAQ,EAAEC,aAAa,EAAEC,mBAAmB,EAAEC,KAAK,QAAQ,UAAU;AAC9E,SAASC,eAAe,EAAEC,WAAW,EAAEC,YAAY,QAAQ,SAAS;AACpE,OAAOC,KAAK,MAAM,mBAAmB;AAErC,SAASC,kBAAkB,QAAQ,aAAa;AAChD,SACEC,kBAAkB,EAClBC,WAAW,EACXC,2BAA2B,EAC3BC,UAAU,EACVC,MAAM,QACD,cAAc;AACrB,SAASC,SAAS,QAAuB,kBAAkB;AAC3D,SACEC,mBAAmB,EACnBC,kBAAkB,EAClBC,mBAAmB,EACnBC,iBAAiB,EACjBC,qBAAqB,EACrBC,oBAAoB,QACf,wBAAwB;AAC/B,SAASC,mBAAmB,QAAQ,gCAAgC;AACpE,SAASC,kBAAkB,QAAQ,UAAU;AAC7C,SAASC,aAAa,QAAQ,aAAa;;AAE3C;AACA;AACA;AACA;AACA,MAAMC,mBAAmB,GAAG,gDAAgD;AAE5E,MAAMC,eAAe,GAAGjB,kBAAkB,EAAE;AAE5C,MAAMkB,qBAAqB,GAAGA,CAC5BC,OAA0B,EAC1BC,YAA0B,KAE1BlC,yBAAyB,CAACiC,OAAO,CAAC,IAClC,CAACC,YAAY,CAACC,UAAU,CAACC,GAAG,CAACH,OAAO,CAACI,MAAM,CAAC;AAE9C,MAAMC,sBAAsB,GAAGA,CAC7BL,OAA0B,EAC1BC,YAA0B,KACvB;EAAA,IAAAK,qBAAA;EACH,OACEL,YAAY,CAACM,KAAK,KAAK,MAAM,IAC7BxC,yBAAyB,CAACiC,OAAO,CAAC,IAClC,CAACD,qBAAqB,CAACC,OAAO,EAAEC,YAAY,CAAC,IAC7C,EAAAK,qBAAA,GAAAL,YAAY,CAACC,UAAU,CAACM,GAAG,CAACR,OAAO,CAACI,MAAM,CAAC,cAAAE,qBAAA,uBAA3CA,qBAAA,CAA6CG,QAAQ,MAAKxB,UAAU,CAACyB,GAAG;AAE5E,CAAC;AAED,MAAMC,kBAAkB,GAAIC,WAAmB,IAAK,CAAC,CAAC,EAAE,CAAC,GAAGA,WAAW,CAAC;AAExE,MAAMC,kBAAkB,GAAID,WAAmB,IAAK,CAAC,GAAG,EAAE,CAAC,GAAGA,WAAW,CAAC;AAE1E,MAAME,gBAAgB,GAAId,OAA0B,IAClDA,OAAO,CAACe,IAAI,KAAK,UAAU,GAAGf,OAAO,CAACY,WAAW,GAAG,EAAE,GAAG,EAAE;AAc7D,MAAMI,uBAAuB,GAAGA,CAC9BhB,OAAoC,EACpCiB,IAAU,KAKP;EACH;EACA;EACA;EACA;EACA;EACA;EACA,MAAMC,UAAU,GAAG,QAAQ;EAC3B;EACA,MAAMC,kBAAkB,GAAG,KAAK;EAEhC,MAAMC,OAAO,GAAGN,gBAAgB,CAACd,OAAO,CAAC;EAEzC,MAAM,CAACqB,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,GAAGrD,wBAAwB,CAAC6B,OAAO,CAAC;EAC1D,MAAMyB,YAAY,GAChB5D,eAAe,CAACmC,OAAO,CAAC,IAAIlC,iBAAiB,CAACkC,OAAO,CAAC,GAClD3B,QAAQ,CAACgD,EAAE,EAAEE,EAAE,CAAC,GAChBvB,OAAO,CAAC0B,KAAK;EACnB,MAAMC,aAAa,GACjB9D,eAAe,CAACmC,OAAO,CAAC,IAAIlC,iBAAiB,CAACkC,OAAO,CAAC,GAClD3B,QAAQ,CAACiD,EAAE,EAAEE,EAAE,CAAC,GAChBxB,OAAO,CAAC4B,MAAM;EAEpB,IAAIF,KAAK,GAAGD,YAAY,GAAGI,MAAM,CAACC,gBAAgB,GAAGV,OAAO,GAAG,CAAC;EAChE,IAAIQ,MAAM,GAAGD,aAAa,GAAGE,MAAM,CAACC,gBAAgB,GAAGV,OAAO,GAAG,CAAC;EAElE,IAAIW,KAAa,GAAGd,IAAI,CAACe,KAAK;;EAE9B;EACA,IACEN,KAAK,GAAGK,KAAK,GAAGZ,kBAAkB,IAClCS,MAAM,GAAGG,KAAK,GAAGZ,kBAAkB,EACnC;IACAY,KAAK,GAAGE,IAAI,CAACC,GAAG,CAACf,kBAAkB,GAAGO,KAAK,EAAEP,kBAAkB,GAAGS,MAAM,CAAC;EAC3E;;EAEA;EACA,IAAIF,KAAK,GAAGE,MAAM,GAAGG,KAAK,GAAGA,KAAK,GAAGb,UAAU,EAAE;IAC/Ca,KAAK,GAAGE,IAAI,CAACE,IAAI,CAACjB,UAAU,IAAIQ,KAAK,GAAGE,MAAM,CAAC,CAAC;EAClD;EAEAF,KAAK,GAAGO,IAAI,CAACG,KAAK,CAACV,KAAK,GAAGK,KAAK,CAAC;EACjCH,MAAM,GAAGK,IAAI,CAACG,KAAK,CAACR,MAAM,GAAGG,KAAK,CAAC;EAEnC,OAAO;IAAEL,KAAK;IAAEE,MAAM;IAAEG;EAAM,CAAC;AACjC,CAAC;AAED,MAAMM,qBAAqB,GAAGA,CAC5BrC,OAAoC,EACpCiB,IAAU,EACVhB,YAA0B,KACM;EAAA,IAAAqC,oBAAA,EAAAC,mBAAA;EAChC,MAAMC,MAAM,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;EAC/C,MAAMC,OAAO,GAAGH,MAAM,CAACI,UAAU,CAAC,IAAI,CAAE;EACxC,MAAMxB,OAAO,GAAGN,gBAAgB,CAACd,OAAO,CAAC;EAEzC,MAAM;IAAE0B,KAAK;IAAEE,MAAM;IAAEG;EAAM,CAAC,GAAGf,uBAAuB,CAAChB,OAAO,EAAEiB,IAAI,CAAC;EAEvEuB,MAAM,CAACd,KAAK,GAAGA,KAAK;EACpBc,MAAM,CAACZ,MAAM,GAAGA,MAAM;EAEtB,IAAIiB,aAAa,GAAG,CAAC;EACrB,IAAIC,aAAa,GAAG,CAAC;EAErB,IAAIjF,eAAe,CAACmC,OAAO,CAAC,IAAIlC,iBAAiB,CAACkC,OAAO,CAAC,EAAE;IAC1D,MAAM,CAACqB,EAAE,EAAEC,EAAE,CAAC,GAAGnD,wBAAwB,CAAC6B,OAAO,CAAC;IAElD6C,aAAa,GACX7C,OAAO,CAAC+C,CAAC,GAAG1B,EAAE,GACVhD,QAAQ,CAAC2B,OAAO,CAAC+C,CAAC,EAAE1B,EAAE,CAAC,GAAGQ,MAAM,CAACC,gBAAgB,GAAGC,KAAK,GACzD,CAAC;IAEPe,aAAa,GACX9C,OAAO,CAACgD,CAAC,GAAG1B,EAAE,GACVjD,QAAQ,CAAC2B,OAAO,CAACgD,CAAC,EAAE1B,EAAE,CAAC,GAAGO,MAAM,CAACC,gBAAgB,GAAGC,KAAK,GACzD,CAAC;IAEPY,OAAO,CAACM,SAAS,CAACJ,aAAa,EAAEC,aAAa,CAAC;EACjD;EAEAH,OAAO,CAACO,IAAI,EAAE;EACdP,OAAO,CAACM,SAAS,CAAC7B,OAAO,GAAGW,KAAK,EAAEX,OAAO,GAAGW,KAAK,CAAC;EACnDY,OAAO,CAACZ,KAAK,CACXF,MAAM,CAACC,gBAAgB,GAAGC,KAAK,EAC/BF,MAAM,CAACC,gBAAgB,GAAGC,KAAK,CAChC;EAED,MAAMoB,EAAE,GAAGvE,KAAK,CAAC4D,MAAM,CAACA,MAAM,CAAC;;EAE/B;EACA,IAAInC,sBAAsB,CAACL,OAAO,EAAEC,YAAY,CAAC,EAAE;IACjD0C,OAAO,CAACS,MAAM,GAAGvD,mBAAmB;EACtC;EAEAwD,mBAAmB,CAACrD,OAAO,EAAEmD,EAAE,EAAER,OAAO,EAAE1C,YAAY,CAAC;EACvD0C,OAAO,CAACW,OAAO,EAAE;EAEjB,OAAO;IACLtD,OAAO;IACPwC,MAAM;IACNjC,KAAK,EAAEN,YAAY,CAACM,KAAK;IACzBwB,KAAK;IACLwB,SAAS,EAAEtC,IAAI,CAACe,KAAK;IACrBa,aAAa;IACbC,aAAa;IACbU,uBAAuB,EAAE,EAAAlB,oBAAA,GAAAlD,mBAAmB,CAACY,OAAO,CAAC,cAAAsC,oBAAA,uBAA5BA,oBAAA,CAA8BmB,OAAO,KAAI,IAAI;IACtEC,sBAAsB,EAAE,EAAAnB,mBAAA,GAAA5C,kBAAkB,CAACK,OAAO,CAAC,cAAAuC,mBAAA,uBAA3BA,mBAAA,CAA6BoB,OAAO,KAAI;EAClE,CAAC;AACH,CAAC;AAED,OAAO,MAAMC,iBAAiB,GAAG,EAAE;AAEnC,MAAMC,qBAAqB,GAAGpB,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;AAC3DmB,qBAAqB,CAACC,GAAG,GAAI,QAAO7E,UAAU,CAACyB,GAAI,IAAGqD,kBAAkB,CACrE,8iBAA6iB,CAC9iB,EAAC;AAEH,MAAMC,2BAA2B,GAAGvB,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;AACjEsB,2BAA2B,CAACF,GAAG,GAAI,QAAO7E,UAAU,CAACyB,GAAI,IAAGqD,kBAAkB,CAC3E,uhCAAshC,CACvhC,EAAC;AAEH,MAAME,oBAAoB,GAAGA,CAC3BjE,OAA+B,EAC/B2C,OAAiC,EACjCY,SAAoC,KACjC;EACHZ,OAAO,CAACuB,SAAS,GAAG,SAAS;EAC7BvB,OAAO,CAACwB,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEnE,OAAO,CAAC0B,KAAK,EAAE1B,OAAO,CAAC4B,MAAM,CAAC;EAErD,MAAMwC,qBAAqB,GAAGnC,IAAI,CAACC,GAAG,CAAClC,OAAO,CAAC0B,KAAK,EAAE1B,OAAO,CAAC4B,MAAM,CAAC;EAErE,MAAMyC,IAAI,GAAGpC,IAAI,CAACC,GAAG,CACnBkC,qBAAqB,EACrBnC,IAAI,CAACC,GAAG,CAACkC,qBAAqB,GAAG,GAAG,EAAE,GAAG,CAAC,CAC3C;EAEDzB,OAAO,CAAC2B,SAAS,CACftE,OAAO,CAACuE,MAAM,KAAK,OAAO,GACtBP,2BAA2B,GAC3BH,qBAAqB,EACzB7D,OAAO,CAAC0B,KAAK,GAAG,CAAC,GAAG2C,IAAI,GAAG,CAAC,EAC5BrE,OAAO,CAAC4B,MAAM,GAAG,CAAC,GAAGyC,IAAI,GAAG,CAAC,EAC7BA,IAAI,EACJA,IAAI,CACL;AACH,CAAC;AACD,MAAMhB,mBAAmB,GAAGA,CAC1BrD,OAAoC,EACpCmD,EAAe,EACfR,OAAiC,EACjC1C,YAA0B,KACvB;EAAA,IAAAuE,qBAAA,EAAAC,oBAAA;EACH9B,OAAO,CAAC+B,WAAW,GAChB,EAAAF,qBAAA,IAAAC,oBAAA,GAAC9E,kBAAkB,CAACK,OAAO,CAAC,cAAAyE,oBAAA,uBAA3BA,oBAAA,CAA6Bd,OAAO,cAAAa,qBAAA,cAAAA,qBAAA,GAAI,GAAG,IAAIxE,OAAO,CAAC2D,OAAO,GAAI,KAAK;EAC3E,QAAQ3D,OAAO,CAACe,IAAI;IAClB,KAAK,WAAW;IAChB,KAAK,SAAS;IACd,KAAK,SAAS;MAAE;QACd4B,OAAO,CAACgC,QAAQ,GAAG,OAAO;QAC1BhC,OAAO,CAACiC,OAAO,GAAG,OAAO;QACzBzB,EAAE,CAAC0B,IAAI,CAACC,kBAAkB,CAAC9E,OAAO,CAAC,CAAE;QACrC;MACF;IACA,KAAK,OAAO;IACZ,KAAK,MAAM;MAAE;QACX2C,OAAO,CAACgC,QAAQ,GAAG,OAAO;QAC1BhC,OAAO,CAACiC,OAAO,GAAG,OAAO;QAEzBE,kBAAkB,CAAC9E,OAAO,CAAC,CAAE+E,OAAO,CAAEC,KAAK,IAAK;UAC9C7B,EAAE,CAAC0B,IAAI,CAACG,KAAK,CAAC;QAChB,CAAC,CAAC;QACF;MACF;IACA,KAAK,UAAU;MAAE;QACf;QACArC,OAAO,CAACO,IAAI,EAAE;QACdP,OAAO,CAACuB,SAAS,GAAGlE,OAAO,CAACiF,WAAW;QAEvC,MAAMC,IAAI,GAAGC,iBAAiB,CAACnF,OAAO,CAAW;QACjD,MAAMoF,SAAS,GAAGN,kBAAkB,CAAC9E,OAAO,CAAC;QAE7C,IAAIoF,SAAS,EAAE;UACbjC,EAAE,CAAC0B,IAAI,CAACO,SAAS,CAAC;QACpB;QAEAzC,OAAO,CAACuB,SAAS,GAAGlE,OAAO,CAACiF,WAAW;QACvCtC,OAAO,CAAC0C,IAAI,CAACH,IAAI,CAAC;QAElBvC,OAAO,CAACW,OAAO,EAAE;QACjB;MACF;IACA,KAAK,OAAO;MAAE;QAAA,IAAAgC,sBAAA;QACZ,MAAMC,GAAG,GAAGxH,yBAAyB,CAACiC,OAAO,CAAC,IAAAsF,sBAAA,GAC1CrF,YAAY,CAACC,UAAU,CAACM,GAAG,CAACR,OAAO,CAACI,MAAM,CAAC,cAAAkF,sBAAA,uBAA3CA,sBAAA,CAA6CE,KAAK,GAClDC,SAAS;QACb,IAAIF,GAAG,IAAI,IAAI,IAAI,EAAEA,GAAG,YAAYG,OAAO,CAAC,EAAE;UAC5C/C,OAAO,CAAC2B,SAAS,CACfiB,GAAG,EACH,CAAC,CAAC,sCACF,CAAC,EACDvF,OAAO,CAAC0B,KAAK,EACb1B,OAAO,CAAC4B,MAAM,CACf;QACH,CAAC,MAAM;UACLqC,oBAAoB,CAACjE,OAAO,EAAE2C,OAAO,EAAE1C,YAAY,CAACgB,IAAI,CAACe,KAAK,CAAC;QACjE;QACA;MACF;IACA;MAAS;QACP,IAAIpE,aAAa,CAACoC,OAAO,CAAC,EAAE;UAC1B,MAAM2F,GAAG,GAAGnH,KAAK,CAACwB,OAAO,CAAC4F,IAAI,CAAC;UAC/B,MAAMC,uBAAuB,GAAGF,GAAG,IAAI,CAAChD,OAAO,CAACH,MAAM,CAACsD,WAAW;UAClE,IAAID,uBAAuB,EAAE;YAC3B;YACA;YACApD,QAAQ,CAACsD,IAAI,CAACC,WAAW,CAACrD,OAAO,CAACH,MAAM,CAAC;UAC3C;UACAG,OAAO,CAACH,MAAM,CAACyD,YAAY,CAAC,KAAK,EAAEN,GAAG,GAAG,KAAK,GAAG,KAAK,CAAC;UACvDhD,OAAO,CAACO,IAAI,EAAE;UACdP,OAAO,CAACuD,IAAI,GAAG5H,aAAa,CAAC0B,OAAO,CAAC;UACrC2C,OAAO,CAACuB,SAAS,GAAGlE,OAAO,CAACiF,WAAW;UACvCtC,OAAO,CAACwD,SAAS,GAAGnG,OAAO,CAACmG,SAA4B;;UAExD;UACA,MAAMC,KAAK,GAAGpG,OAAO,CAAC4F,IAAI,CAACS,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,CAACC,KAAK,CAAC,IAAI,CAAC;UAE9D,MAAMC,gBAAgB,GACpBvG,OAAO,CAACmG,SAAS,KAAK,QAAQ,GAC1BnG,OAAO,CAAC0B,KAAK,GAAG,CAAC,GACjB1B,OAAO,CAACmG,SAAS,KAAK,OAAO,GAC7BnG,OAAO,CAAC0B,KAAK,GACb,CAAC;UACP,MAAM8E,YAAY,GAAGjH,iBAAiB,CACpCS,OAAO,CAACyG,QAAQ,EAChBzG,OAAO,CAAC0G,UAAU,CACnB;UACD,MAAMC,cAAc,GAAG3G,OAAO,CAAC4B,MAAM,GAAG5B,OAAO,CAAC4G,QAAQ;UACxD,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGT,KAAK,CAACU,MAAM,EAAED,KAAK,EAAE,EAAE;YACjDlE,OAAO,CAACoE,QAAQ,CACdX,KAAK,CAACS,KAAK,CAAC,EACZN,gBAAgB,EAChB,CAACM,KAAK,GAAG,CAAC,IAAIL,YAAY,GAAGG,cAAc,CAC5C;UACH;UACAhE,OAAO,CAACW,OAAO,EAAE;UACjB,IAAIuC,uBAAuB,EAAE;YAC3BlD,OAAO,CAACH,MAAM,CAACwE,MAAM,EAAE;UACzB;QACF,CAAC,MAAM;UACL,MAAM,IAAIC,KAAK,CAAE,sBAAqBjH,OAAO,CAACe,IAAK,EAAC,CAAC;QACvD;MACF;EAAC;EAEH4B,OAAO,CAAC+B,WAAW,GAAG,CAAC;AACzB,CAAC;AAED,MAAMwC,sBAAsB,GAAG,IAAIC,OAAO,EAGvC;AAEH,MAAMC,UAAU,GAAG,IAAID,OAAO,EAAmC;AAYjE,OAAO,MAAMrC,kBAAkB,GAAiC9E,OAAU,IACxEoH,UAAU,CAAC5G,GAAG,CAACR,OAAO,CAES;AAEjC,OAAO,MAAMqH,kBAAkB,GAAGA,CAChCrH,OAAU,EACVgF,KAEY,KACToC,UAAU,CAACE,GAAG,CAACtH,OAAO,EAAEgF,KAAK,CAAC;AAEnC,OAAO,MAAMuC,yBAAyB,GAAIvH,OAA0B,IAClEoH,UAAU,CAACI,MAAM,CAACxH,OAAO,CAAC;AAE5B,OAAO,MAAMyH,oBAAoB,GAAG,SAAAA,CAClCzH,OAA0B,EAEd;EAAA,IADZ0H,cAAc,GAAAC,SAAA,CAAAb,MAAA,QAAAa,SAAA,QAAAlC,SAAA,GAAAkC,SAAA,MAAG,KAAK;EAEtB,MAAMC,OAAgB,GAAG;IACvBC,IAAI,EAAE7H,OAAO,CAAC6H,IAAI;IAClBC,cAAc,EACZ9H,OAAO,CAAC+H,WAAW,KAAK,QAAQ,GAC5BpH,kBAAkB,CAACX,OAAO,CAACY,WAAW,CAAC,GACvCZ,OAAO,CAAC+H,WAAW,KAAK,QAAQ,GAChClH,kBAAkB,CAACb,OAAO,CAACY,WAAW,CAAC,GACvC6E,SAAS;IACf;IACA;IACAuC,kBAAkB,EAAEhI,OAAO,CAAC+H,WAAW,KAAK,OAAO;IACnD;IACA;IACAnH,WAAW,EACTZ,OAAO,CAAC+H,WAAW,KAAK,OAAO,GAC3B/H,OAAO,CAACY,WAAW,GAAG,GAAG,GACzBZ,OAAO,CAACY,WAAW;IACzB;IACA;IACA;IACAqH,UAAU,EAAEjI,OAAO,CAACY,WAAW,GAAG,CAAC;IACnCsH,UAAU,EAAElI,OAAO,CAACY,WAAW,GAAG,CAAC;IACnCuH,SAAS,EAAEnI,OAAO,CAACmI,SAAS;IAC5BC,MAAM,EAAEpI,OAAO,CAACiF,WAAW;IAC3BoD,gBAAgB,EAAEX;EACpB,CAAC;EAED,QAAQ1H,OAAO,CAACe,IAAI;IAClB,KAAK,WAAW;IAChB,KAAK,SAAS;IACd,KAAK,SAAS;MAAE;QACd6G,OAAO,CAAC1D,SAAS,GAAGlE,OAAO,CAACkE,SAAS;QACrC0D,OAAO,CAACvC,IAAI,GACVrF,OAAO,CAACsI,eAAe,KAAK,aAAa,GACrC7C,SAAS,GACTzF,OAAO,CAACsI,eAAe;QAC7B,IAAItI,OAAO,CAACe,IAAI,KAAK,SAAS,EAAE;UAC9B6G,OAAO,CAACW,YAAY,GAAG,CAAC;QAC1B;QACA,OAAOX,OAAO;MAChB;IACA,KAAK,MAAM;IACX,KAAK,UAAU;MAAE;QACf,IAAIlJ,WAAW,CAACsB,OAAO,CAACwI,MAAM,CAAC,EAAE;UAC/BZ,OAAO,CAAC1D,SAAS,GAAGlE,OAAO,CAACkE,SAAS;UACrC0D,OAAO,CAACvC,IAAI,GACVrF,OAAO,CAACsI,eAAe,KAAK,aAAa,GACrC7C,SAAS,GACTzF,OAAO,CAACsI,eAAe;QAC/B;QACA,OAAOV,OAAO;MAChB;IACA,KAAK,OAAO;MACV,OAAOA,OAAO;IAChB;MAAS;QACP,MAAM,IAAIX,KAAK,CAAE,sBAAqBjH,OAAO,CAACe,IAAK,EAAC,CAAC;MACvD;EAAC;AAEL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAM0H,oBAAoB,GAAGA,CAC3BzI,OAAoC,EACpC0I,SAAyB,KACtB;EACH,IAAI1D,KAAK,GAAGoC,UAAU,CAAC5G,GAAG,CAACR,OAAO,CAAC;;EAEnC;EACA;EACA,IAAIgF,KAAK,KAAKS,SAAS,EAAE;IACvByB,sBAAsB,CAACM,MAAM,CAACxH,OAAO,CAAC;IAEtC,QAAQA,OAAO,CAACe,IAAI;MAClB,KAAK,WAAW;QAAE;UAChB,IAAIf,OAAO,CAAC2I,SAAS,EAAE;YACrB,MAAMC,CAAC,GAAG5I,OAAO,CAAC0B,KAAK;YACvB,MAAMmH,CAAC,GAAG7I,OAAO,CAAC4B,MAAM;YACxB,MAAMkH,CAAC,GAAGrK,eAAe,CAACwD,IAAI,CAACC,GAAG,CAAC0G,CAAC,EAAEC,CAAC,CAAC,EAAE7I,OAAO,CAAC;YAClDgF,KAAK,GAAG0D,SAAS,CAACxD,IAAI,CACnB,KAAI4D,CAAE,QAAOF,CAAC,GAAGE,CAAE,QAAOF,CAAE,OAAMA,CAAE,IAAGE,CAAE,MAAKF,CAAE,IAC/CC,CAAC,GAAGC,CACL,MAAKF,CAAE,IAAGC,CAAE,KAAID,CAAC,GAAGE,CAAE,IAAGD,CAAE,MAAKC,CAAE,IAAGD,CAAE,QAAOA,CAAE,OAC/CA,CAAC,GAAGC,CACL,QAAOA,CAAE,WAAUA,CAAE,IAAG,EACzBrB,oBAAoB,CAACzH,OAAO,EAAE,IAAI,CAAC,CACpC;UACH,CAAC,MAAM;YACLgF,KAAK,GAAG0D,SAAS,CAACK,SAAS,CACzB,CAAC,EACD,CAAC,EACD/I,OAAO,CAAC0B,KAAK,EACb1B,OAAO,CAAC4B,MAAM,EACd6F,oBAAoB,CAACzH,OAAO,CAAC,CAC9B;UACH;UACAqH,kBAAkB,CAACrH,OAAO,EAAEgF,KAAK,CAAC;UAElC;QACF;MACA,KAAK,SAAS;QAAE;UACd,MAAM,CAACgE,IAAI,EAAEC,IAAI,EAAEC,MAAM,EAAEC,MAAM,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,CAAC,GAChErL,gBAAgB,CAAC8B,OAAO,CAAC;UAC3B,IAAIA,OAAO,CAAC2I,SAAS,EAAE;YACrB,MAAMa,cAAc,GAAG/K,eAAe,CACpCwD,IAAI,CAACwH,GAAG,CAACT,IAAI,GAAGM,KAAK,CAAC,EACtBtJ,OAAO,CACR;YAED,MAAM0J,gBAAgB,GAAGjL,eAAe,CACtCwD,IAAI,CAACwH,GAAG,CAACN,MAAM,GAAGF,IAAI,CAAC,EACvBjJ,OAAO,CACR;YAEDgF,KAAK,GAAG0D,SAAS,CAACxD,IAAI,CACnB,KAAI8D,IAAI,GAAGQ,cAAe,IAAGP,IAAI,GAAGS,gBAAiB,MACpDR,MAAM,GAAGM,cACV,IAAGL,MAAM,GAAGO,gBAAiB;AAC1C,gBAAgBR,MAAO,IAAGC,MAAO,KAAID,MAAO,IAAGC,MAAO,KACxCD,MAAM,GAAGM,cACV,IAAGL,MAAM,GAAGO,gBAAiB;AAC1C,gBAAgBN,OAAO,GAAGI,cAAe,IAAGH,OAAO,GAAGK,gBAAiB;AACvE,gBAAgBN,OAAQ,IAAGC,OAAQ,KAAID,OAAQ,IAAGC,OAAQ,KAC5CD,OAAO,GAAGI,cACX,IAAGH,OAAO,GAAGK,gBAAiB;AAC3C,gBAAgBJ,KAAK,GAAGE,cAAe,IAAGD,KAAK,GAAGG,gBAAiB;AACnE,gBAAgBJ,KAAM,IAAGC,KAAM,KAAID,KAAM,IAAGC,KAAM,KAAID,KAAK,GAAGE,cAAe,IAC/DD,KAAK,GAAGG,gBACT;AACb,gBAAgBV,IAAI,GAAGQ,cAAe,IAAGP,IAAI,GAAGS,gBAAiB;AACjE,gBAAgBV,IAAK,IAAGC,IAAK,KAAID,IAAK,IAAGC,IAAK,KAAID,IAAI,GAAGQ,cAAe,IAC1DP,IAAI,GAAGS,gBACR,EAAC,EACFjC,oBAAoB,CAACzH,OAAO,EAAE,IAAI,CAAC,CACpC;UACH,CAAC,MAAM;YACLgF,KAAK,GAAG0D,SAAS,CAACiB,OAAO,CACvB,CACE,CAACX,IAAI,EAAEC,IAAI,CAAC,EACZ,CAACC,MAAM,EAAEC,MAAM,CAAC,EAChB,CAACC,OAAO,EAAEC,OAAO,CAAC,EAClB,CAACC,KAAK,EAAEC,KAAK,CAAC,CACf,EACD9B,oBAAoB,CAACzH,OAAO,CAAC,CAC9B;UACH;UACAqH,kBAAkB,CAACrH,OAAO,EAAEgF,KAAK,CAAC;UAElC;QACF;MACA,KAAK,SAAS;QACZA,KAAK,GAAG0D,SAAS,CAACkB,OAAO,CACvB5J,OAAO,CAAC0B,KAAK,GAAG,CAAC,EACjB1B,OAAO,CAAC4B,MAAM,GAAG,CAAC,EAClB5B,OAAO,CAAC0B,KAAK,EACb1B,OAAO,CAAC4B,MAAM,EACd6F,oBAAoB,CAACzH,OAAO,CAAC,CAC9B;QACDqH,kBAAkB,CAACrH,OAAO,EAAEgF,KAAK,CAAC;QAElC;MACF,KAAK,MAAM;MACX,KAAK,OAAO;QAAE;UACZ,MAAM4C,OAAO,GAAGH,oBAAoB,CAACzH,OAAO,CAAC;;UAE7C;UACA;UACA,MAAMwI,MAAM,GAAGxI,OAAO,CAACwI,MAAM,CAAC1B,MAAM,GAAG9G,OAAO,CAACwI,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;;UAEhE;UACA;UACA,IAAI,CAACxI,OAAO,CAAC2I,SAAS,EAAE;YACtB,IAAIf,OAAO,CAACvC,IAAI,EAAE;cAChBL,KAAK,GAAG,CAAC0D,SAAS,CAACiB,OAAO,CAACnB,MAAM,EAAwBZ,OAAO,CAAC,CAAC;YACpE,CAAC,MAAM;cACL5C,KAAK,GAAG,CACN0D,SAAS,CAACmB,UAAU,CAACrB,MAAM,EAAwBZ,OAAO,CAAC,CAC5D;YACH;UACF,CAAC,MAAM;YACL5C,KAAK,GAAG,CAAC0D,SAAS,CAACoB,KAAK,CAACtB,MAAM,EAAwBZ,OAAO,CAAC,CAAC;UAClE;;UAEA;UACA,IAAI5H,OAAO,CAACe,IAAI,KAAK,OAAO,EAAE;YAC5B,MAAM;cAAEgJ,cAAc,GAAG,IAAI;cAAEC,YAAY,GAAG;YAAQ,CAAC,GAAGhK,OAAO;YAEjE,MAAMiK,kBAAkB,GAAGA,CACzBjK,OAAgC,EAChCgF,KAAiB,EACjBkF,QAAyB,EACzBC,SAAoB,KACjB;cACH,MAAMC,eAAe,GAAGhM,kBAAkB,CACxC4B,OAAO,EACPgF,KAAK,EACLkF,QAAQ,EACRC,SAAS,CACV;cAED,IAAIC,eAAe,KAAK,IAAI,EAAE;gBAC5B,OAAO,EAAE;cACX;;cAEA;cACA,IAAID,SAAS,KAAK,KAAK,EAAE;gBACvB,MAAM,CAACpH,CAAC,EAAEC,CAAC,EAAE8F,CAAC,CAAC,GAAGsB,eAAe;gBAEjC,OAAO,CACL1B,SAAS,CAAC2B,MAAM,CAACtH,CAAC,EAAEC,CAAC,EAAE8F,CAAC,EAAE;kBACxB,GAAGlB,OAAO;kBACVvC,IAAI,EAAErF,OAAO,CAACiF,WAAW;kBACzBf,SAAS,EAAE,OAAO;kBAClBkE,MAAM,EAAE;gBACV,CAAC,CAAC,CACH;cACH;cAEA,IAAI+B,SAAS,KAAK,UAAU,EAAE;gBAC5B,MAAM,CAACpH,CAAC,EAAEC,CAAC,EAAEzB,EAAE,EAAEC,EAAE,EAAE8I,EAAE,EAAEC,EAAE,CAAC,GAAGH,eAAe;;gBAE9C;gBACA,OAAOxC,OAAO,CAACE,cAAc;gBAE7B,OAAO,CACLY,SAAS,CAACiB,OAAO,CACf,CACE,CAAC5G,CAAC,EAAEC,CAAC,CAAC,EACN,CAACzB,EAAE,EAAEC,EAAE,CAAC,EACR,CAAC8I,EAAE,EAAEC,EAAE,CAAC,EACR,CAACxH,CAAC,EAAEC,CAAC,CAAC,CACP,EACD;kBACE,GAAG4E,OAAO;kBACVvC,IAAI,EAAErF,OAAO,CAACiF,WAAW;kBACzBf,SAAS,EAAE;gBACb,CAAC,CACF,CACF;cACH;;cAEA;cACA,MAAM,CAAC3C,EAAE,EAAEC,EAAE,EAAE8I,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,GAAGL,eAAe;cAEhD,IAAIpK,OAAO,CAAC+H,WAAW,KAAK,QAAQ,EAAE;gBACpC;gBACA,MAAM2C,IAAI,GAAG7J,kBAAkB,CAACb,OAAO,CAACY,WAAW,GAAG,CAAC,CAAC;gBACxDgH,OAAO,CAACE,cAAc,GAAG,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;cACjD,CAAC,MAAM;gBACL;gBACA,OAAO9C,OAAO,CAACE,cAAc;cAC/B;cACA,OAAO,CACLY,SAAS,CAACiC,IAAI,CAACL,EAAE,EAAEC,EAAE,EAAEhJ,EAAE,EAAEC,EAAE,EAAEoG,OAAO,CAAC,EACvCc,SAAS,CAACiC,IAAI,CAACH,EAAE,EAAEC,EAAE,EAAElJ,EAAE,EAAEC,EAAE,EAAEoG,OAAO,CAAC,CACxC;YACH,CAAC;YAED,IAAImC,cAAc,KAAK,IAAI,EAAE;cAC3B,MAAMa,MAAM,GAAGX,kBAAkB,CAC/BjK,OAAO,EACPgF,KAAK,EACL,OAAO,EACP+E,cAAc,CACf;cACD/E,KAAK,CAAC6F,IAAI,CAAC,GAAGD,MAAM,CAAC;YACvB;YAEA,IAAIZ,YAAY,KAAK,IAAI,EAAE;cACzB,IAAIA,YAAY,KAAKvE,SAAS,EAAE;gBAC9B;cAAA;cAGF,MAAMmF,MAAM,GAAGX,kBAAkB,CAC/BjK,OAAO,EACPgF,KAAK,EACL,KAAK,EACLgF,YAAY,CACb;cACDhF,KAAK,CAAC6F,IAAI,CAAC,GAAGD,MAAM,CAAC;YACvB;UACF;UAEAvD,kBAAkB,CAACrH,OAAO,EAAEgF,KAAK,CAAC;UAElC;QACF;MACA,KAAK,UAAU;QAAE;UACf8F,qBAAqB,CAAC9K,OAAO,CAAC;UAE9B,IAAItB,WAAW,CAACsB,OAAO,CAACwI,MAAM,CAAC,EAAE;YAC/B;YACAxD,KAAK,GAAG0D,SAAS,CAACiB,OAAO,CAAC3J,OAAO,CAACwI,MAAM,EAAwB;cAC9D,GAAGf,oBAAoB,CAACzH,OAAO,CAAC;cAChCoI,MAAM,EAAE;YACV,CAAC,CAAC;UACJ,CAAC,MAAM;YACLpD,KAAK,GAAG,IAAI;UACd;UACAqC,kBAAkB,CAACrH,OAAO,EAAEgF,KAAK,CAAC;UAClC;QACF;MACA,KAAK,MAAM;MACX,KAAK,OAAO;QAAE;UACZ;UACAqC,kBAAkB,CAACrH,OAAO,EAAE,IAAI,CAAC;UACjC;QACF;IAAC;EAEL;AACF,CAAC;AAED,MAAM+K,yBAAyB,GAAGA,CAChC/K,OAAoC,EACpCC,YAA0B,KACvB;EAAA,IAAA+K,qBAAA,EAAAC,oBAAA;EACH,MAAMhK,IAAU,GAAGhB,YAAY,GAAGA,YAAY,CAACgB,IAAI,GAAGnB,eAAe,CAACmB,IAAI;EAC1E,MAAMiK,qBAAqB,GAAGhE,sBAAsB,CAAC1G,GAAG,CAACR,OAAO,CAAC;EACjE,MAAMmL,2BAA2B,GAC/BD,qBAAqB,IACrBA,qBAAqB,CAAC3H,SAAS,KAAKtC,IAAI,CAACe,KAAK,IAC9C,EAAC/B,YAAY,aAAZA,YAAY,eAAZA,YAAY,CAAEmL,qBAAqB;EACtC,MAAM5H,uBAAuB,GAAG,EAAAwH,qBAAA,GAAA5L,mBAAmB,CAACY,OAAO,CAAC,cAAAgL,qBAAA,uBAA5BA,qBAAA,CAA8BvH,OAAO,KAAI,IAAI;EAC7E,MAAMC,sBAAsB,GAAG,EAAAuH,oBAAA,GAAAtL,kBAAkB,CAACK,OAAO,CAAC,cAAAiL,oBAAA,uBAA3BA,oBAAA,CAA6BtH,OAAO,KAAI,GAAG;EAE1E,IACE,CAACuH,qBAAqB,IACtBC,2BAA2B,IAC3BD,qBAAqB,CAAC3K,KAAK,KAAKN,YAAY,CAACM,KAAK,IAClD2K,qBAAqB,CAAC1H,uBAAuB,KAAKA,uBAAuB,IACzE0H,qBAAqB,CAACxH,sBAAsB,KAAKA,sBAAsB,EACvE;IACA,MAAM2H,iBAAiB,GAAGhJ,qBAAqB,CAC7CrC,OAAO,EACPiB,IAAI,EACJhB,YAAY,CACb;IAEDiH,sBAAsB,CAACI,GAAG,CAACtH,OAAO,EAAEqL,iBAAiB,CAAC;IAEtD,OAAOA,iBAAiB;EAC1B;EACA,OAAOH,qBAAqB;AAC9B,CAAC;AAED,MAAMI,qBAAqB,GAAGA,CAC5BD,iBAA8C,EAC9ClI,EAAe,EACfR,OAAiC,EACjC1C,YAA0B,KACvB;EACH,MAAMD,OAAO,GAAGqL,iBAAiB,CAACrL,OAAO;EACzC,MAAMoB,OAAO,GAAGN,gBAAgB,CAACd,OAAO,CAAC;EACzC,MAAMiB,IAAI,GAAGoK,iBAAiB,CAACtJ,KAAK;EACpC,IAAI,CAACV,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,GAAGrD,wBAAwB,CAAC6B,OAAO,CAAC;;EAExD;EACA,IAAIlC,iBAAiB,CAACkC,OAAO,CAAC,EAAE;IAC9BqB,EAAE,GAAGY,IAAI,CAACG,KAAK,CAACf,EAAE,CAAC;IACnBE,EAAE,GAAGU,IAAI,CAACsJ,IAAI,CAAChK,EAAE,CAAC;IAClBD,EAAE,GAAGW,IAAI,CAACG,KAAK,CAACd,EAAE,CAAC;IACnBE,EAAE,GAAGS,IAAI,CAACsJ,IAAI,CAAC/J,EAAE,CAAC;EACpB;EAEA,MAAMgK,EAAE,GAAG,CAAC,CAACnK,EAAE,GAAGE,EAAE,IAAI,CAAC,GAAGtB,YAAY,CAACwL,OAAO,IAAI5J,MAAM,CAACC,gBAAgB;EAC3E,MAAM4J,EAAE,GAAG,CAAC,CAACpK,EAAE,GAAGE,EAAE,IAAI,CAAC,GAAGvB,YAAY,CAAC0L,OAAO,IAAI9J,MAAM,CAACC,gBAAgB;EAE3Ea,OAAO,CAACO,IAAI,EAAE;EACdP,OAAO,CAACZ,KAAK,CAAC,CAAC,GAAGF,MAAM,CAACC,gBAAgB,EAAE,CAAC,GAAGD,MAAM,CAACC,gBAAgB,CAAC;EACvE,MAAM8J,gBAAgB,GAAGxM,mBAAmB,CAACY,OAAO,CAAC;EAErD,IAAIhC,cAAc,CAACgC,OAAO,CAAC,IAAI4L,gBAAgB,EAAE;IAC/C,MAAMC,UAAU,GAAGpJ,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;IACnD,MAAMoJ,iBAAiB,GAAGD,UAAU,CAACjJ,UAAU,CAAC,IAAI,CAAE;;IAEtD;IACA;IACA,MAAMmJ,MAAM,GAAG9J,IAAI,CAAC+J,GAAG,CAAC3N,QAAQ,CAACgD,EAAE,EAAEE,EAAE,CAAC,EAAElD,QAAQ,CAACiD,EAAE,EAAEE,EAAE,CAAC,CAAC;IAC3DqK,UAAU,CAACnK,KAAK,GACdqK,MAAM,GAAGlK,MAAM,CAACC,gBAAgB,GAAGb,IAAI,GACvCG,OAAO,GAAGiK,iBAAiB,CAACtJ,KAAK,GAAG,EAAE;IACxC8J,UAAU,CAACjK,MAAM,GACfmK,MAAM,GAAGlK,MAAM,CAACC,gBAAgB,GAAGb,IAAI,GACvCG,OAAO,GAAGiK,iBAAiB,CAACtJ,KAAK,GAAG,EAAE;IACxC,MAAMkK,OAAO,GAAG,CAACJ,UAAU,CAACnK,KAAK,GAAG2J,iBAAiB,CAAC7I,MAAM,CAAEd,KAAK,IAAI,CAAC;IACxE,MAAMwK,OAAO,GAAG,CAACL,UAAU,CAACjK,MAAM,GAAGyJ,iBAAiB,CAAC7I,MAAM,CAAEZ,MAAM,IAAI,CAAC;IAE1EkK,iBAAiB,CAAC7I,SAAS,CAAC4I,UAAU,CAACnK,KAAK,GAAG,CAAC,EAAEmK,UAAU,CAACjK,MAAM,GAAG,CAAC,CAAC;IACxEkK,iBAAiB,CAACK,MAAM,CAACnM,OAAO,CAACoM,KAAK,CAAC;IAEvCN,iBAAiB,CAACxH,SAAS,CACzB+G,iBAAiB,CAAC7I,MAAM,EACxB,CAAC6I,iBAAiB,CAAC7I,MAAM,CAACd,KAAK,GAAG,CAAC,EACnC,CAAC2J,iBAAiB,CAAC7I,MAAM,CAACZ,MAAM,GAAG,CAAC,EACpCyJ,iBAAiB,CAAC7I,MAAM,CAACd,KAAK,EAC9B2J,iBAAiB,CAAC7I,MAAM,CAACZ,MAAM,CAChC;IAED,MAAM,MAASyK,WAAW,EAAEC,WAAW,CAAC,GACtCnO,wBAAwB,CAACyN,gBAAgB,CAAC;IAE5CE,iBAAiB,CAACK,MAAM,CAAC,CAACnM,OAAO,CAACoM,KAAK,CAAC;;IAExC;IACA,MAAMG,MAAM,GACVV,UAAU,CAACnK,KAAK,GAAG,CAAC,GACpB,CAAC2K,WAAW,GAAGhL,EAAE,IAAIQ,MAAM,CAACC,gBAAgB,GAAGb,IAAI,GACnDgL,OAAO,GACP7K,OAAO,GAAGH,IAAI;IAEhB,MAAMuL,MAAM,GACVX,UAAU,CAACjK,MAAM,GAAG,CAAC,GACrB,CAAC0K,WAAW,GAAGhL,EAAE,IAAIO,MAAM,CAACC,gBAAgB,GAAGb,IAAI,GACnDiL,OAAO,GACP9K,OAAO,GAAGH,IAAI;IAChB6K,iBAAiB,CAAC7I,SAAS,CAAC,CAACsJ,MAAM,EAAE,CAACC,MAAM,CAAC;;IAE7C;IACAV,iBAAiB,CAACW,SAAS,CACzB,EAAEb,gBAAgB,CAAClK,KAAK,GAAG,CAAC,GAAG5C,kBAAkB,CAAC,GAChD+C,MAAM,CAACC,gBAAgB,GACvBb,IAAI,EACN,EAAE2K,gBAAgB,CAAChK,MAAM,GAAG,CAAC,GAAG9C,kBAAkB,CAAC,GACjD+C,MAAM,CAACC,gBAAgB,GACvBb,IAAI,EACN,CAAC2K,gBAAgB,CAAClK,KAAK,GAAG5C,kBAAkB,GAAG,CAAC,IAC9C+C,MAAM,CAACC,gBAAgB,GACvBb,IAAI,EACN,CAAC2K,gBAAgB,CAAChK,MAAM,GAAG9C,kBAAkB,GAAG,CAAC,IAC/C+C,MAAM,CAACC,gBAAgB,GACvBb,IAAI,CACP;IAED0B,OAAO,CAACM,SAAS,CAACuI,EAAE,EAAEE,EAAE,CAAC;IACzB/I,OAAO,CAAC2B,SAAS,CACfuH,UAAU,EACT,EAAEtK,EAAE,GAAGF,EAAE,CAAC,GAAG,CAAC,GAAIQ,MAAM,CAACC,gBAAgB,GAAGmK,OAAO,GAAGhL,IAAI,GAAGG,OAAO,EACpE,EAAEI,EAAE,GAAGF,EAAE,CAAC,GAAG,CAAC,GAAIO,MAAM,CAACC,gBAAgB,GAAGoK,OAAO,GAAGjL,IAAI,GAAGG,OAAO,EACrEyK,UAAU,CAACnK,KAAK,GAAGT,IAAI,EACvB4K,UAAU,CAACjK,MAAM,GAAGX,IAAI,CACzB;EACH,CAAC,MAAM;IACL;IACA;IACA0B,OAAO,CAACM,SAAS,CAACuI,EAAE,EAAEE,EAAE,CAAC;IAEzB/I,OAAO,CAACwJ,MAAM,CAACnM,OAAO,CAACoM,KAAK,CAAC;IAE7B,IACE,OAAO,IAAIf,iBAAiB,CAACrL,OAAO,IACpC,CAACD,qBAAqB,CAACC,OAAO,EAAEC,YAAY,CAAC,EAC7C;MACA0C,OAAO,CAACZ,KAAK,CACXsJ,iBAAiB,CAACrL,OAAO,CAAC+B,KAAK,CAAC,CAAC,CAAC,EAClCsJ,iBAAiB,CAACrL,OAAO,CAAC+B,KAAK,CAAC,CAAC,CAAC,CACnC;IACH;;IAEA;IACAY,OAAO,CAACM,SAAS,CAAC,CAACuI,EAAE,EAAE,CAACE,EAAE,CAAC;IAE3B/I,OAAO,CAAC2B,SAAS,CACf+G,iBAAiB,CAAC7I,MAAM,EACxB,CAACnB,EAAE,GAAGpB,YAAY,CAACwL,OAAO,IAAI5J,MAAM,CAACC,gBAAgB,GAClDV,OAAO,GAAGiK,iBAAiB,CAACtJ,KAAK,GAAIsJ,iBAAiB,CAACtJ,KAAK,EAC/D,CAACT,EAAE,GAAGrB,YAAY,CAAC0L,OAAO,IAAI9J,MAAM,CAACC,gBAAgB,GAClDV,OAAO,GAAGiK,iBAAiB,CAACtJ,KAAK,GAAIsJ,iBAAiB,CAACtJ,KAAK,EAC/DsJ,iBAAiB,CAAC7I,MAAM,CAAEd,KAAK,GAAG2J,iBAAiB,CAACtJ,KAAK,EACzDsJ,iBAAiB,CAAC7I,MAAM,CAAEZ,MAAM,GAAGyJ,iBAAiB,CAACtJ,KAAK,CAC3D;IAED,IACE2K,OAAO,CAACC,GAAG,CAACC,kDAAkD,KAC5D,MAAM,IACR3O,mBAAmB,CAAC+B,OAAO,CAAC,EAC5B;MACA,MAAM6M,WAAW,GAAGzN,mBAAmB,CACrCY,OAAO,CAC8B;MACvC,MAAM8M,MAAM,GAAGzN,kBAAkB,CAACW,OAAO,CAAC;MAC1C2C,OAAO,CAACoF,WAAW,GAAG,SAAS;MAC/BpF,OAAO,CAACoK,SAAS,GAAG,CAAC;MACrBpK,OAAO,CAACqK,UAAU,CAChB,CAACF,MAAM,CAAC/J,CAAC,GAAG9C,YAAY,CAACwL,OAAO,IAAI5J,MAAM,CAACC,gBAAgB,EAC3D,CAACgL,MAAM,CAAC9J,CAAC,GAAG/C,YAAY,CAAC0L,OAAO,IAAI9J,MAAM,CAACC,gBAAgB,EAC3DrC,oBAAoB,CAACO,OAAO,CAAC,GAAG6B,MAAM,CAACC,gBAAgB,EACvDtC,qBAAqB,CAACQ,OAAO,EAAE6M,WAAW,CAAC,GAAGhL,MAAM,CAACC,gBAAgB,CACtE;IACH;EACF;EACAa,OAAO,CAACW,OAAO,EAAE;;EAEjB;AACF,CAAC;;AAED,OAAO,MAAM2J,aAAa,GAAGA,CAC3BjN,OAAoC,EACpCmD,EAAe,EACfR,OAAiC,EACjC1C,YAA0B,EAC1BiN,QAAkB,KACf;EACH,MAAMxE,SAAS,GAAGvF,EAAE,CAACuF,SAAS;EAC9B,QAAQ1I,OAAO,CAACe,IAAI;IAClB,KAAK,WAAW;MAAE;QAChB;QACA,IAAI,CAACd,YAAY,CAACkN,WAAW,EAAE;UAC7BxK,OAAO,CAACO,IAAI,EAAE;UACdP,OAAO,CAACM,SAAS,CACfjD,OAAO,CAAC+C,CAAC,GAAG9C,YAAY,CAACwL,OAAO,EAChCzL,OAAO,CAACgD,CAAC,GAAG/C,YAAY,CAAC0L,OAAO,CACjC;UACDhJ,OAAO,CAACuB,SAAS,GAAG,uBAAuB;;UAE3C;UACA;UACA;UACA;UACA,MAAMkJ,MAAM,GAAG,GAAG,GAAGnN,YAAY,CAACgB,IAAI,CAACe,KAAK;UAE5CW,OAAO,CAACwB,QAAQ,CAACiJ,MAAM,EAAEA,MAAM,EAAEpN,OAAO,CAAC0B,KAAK,EAAE1B,OAAO,CAAC4B,MAAM,CAAC;UAC/De,OAAO,CAACoK,SAAS,GAAG,CAAC,GAAG9M,YAAY,CAACgB,IAAI,CAACe,KAAK;UAC/CW,OAAO,CAACoF,WAAW,GAAG,qBAAqB;UAC3CpF,OAAO,CAACqK,UAAU,CAACI,MAAM,EAAEA,MAAM,EAAEpN,OAAO,CAAC0B,KAAK,EAAE1B,OAAO,CAAC4B,MAAM,CAAC;UAEjEe,OAAO,CAACW,OAAO,EAAE;QACnB;QACA;MACF;IACA,KAAK,OAAO;MAAE;QACZ,IACE,CAACrD,YAAY,CAACkN,WAAW,IACzBD,QAAQ,CAACG,cAAc,CAACC,OAAO,IAC/BJ,QAAQ,CAACG,cAAc,CAACE,OAAO,EAC/B;UACA5K,OAAO,CAACO,IAAI,EAAE;UACdP,OAAO,CAACM,SAAS,CACfjD,OAAO,CAAC+C,CAAC,GAAG9C,YAAY,CAACwL,OAAO,EAChCzL,OAAO,CAACgD,CAAC,GAAG/C,YAAY,CAAC0L,OAAO,CACjC;UACDhJ,OAAO,CAACuB,SAAS,GAAG,uBAAuB;UAE3CvB,OAAO,CAACoK,SAAS,GAAG,CAAC,GAAG9M,YAAY,CAACgB,IAAI,CAACe,KAAK;UAC/CW,OAAO,CAACoF,WAAW,GAAGhJ,WAAW,CAACkG,WAAW;UAE7C,IAAIlG,WAAW,CAACyO,MAAM,IAAI7K,OAAO,CAAC8K,SAAS,EAAE;YAC3C9K,OAAO,CAAC+K,SAAS,EAAE;YACnB/K,OAAO,CAAC8K,SAAS,CACf,CAAC,EACD,CAAC,EACDzN,OAAO,CAAC0B,KAAK,EACb1B,OAAO,CAAC4B,MAAM,EACd7C,WAAW,CAACyO,MAAM,GAAGvN,YAAY,CAACgB,IAAI,CAACe,KAAK,CAC7C;YACDW,OAAO,CAACyF,MAAM,EAAE;YAChBzF,OAAO,CAACgL,SAAS,EAAE;UACrB,CAAC,MAAM;YACLhL,OAAO,CAACqK,UAAU,CAAC,CAAC,EAAE,CAAC,EAAEhN,OAAO,CAAC0B,KAAK,EAAE1B,OAAO,CAAC4B,MAAM,CAAC;UACzD;UAEAe,OAAO,CAACW,OAAO,EAAE;QACnB;QACA;MACF;IACA,KAAK,UAAU;MAAE;QACfmF,oBAAoB,CAACzI,OAAO,EAAE0I,SAAS,CAAC;QAExC,IAAIzI,YAAY,CAACkN,WAAW,EAAE;UAC5B,MAAM,CAAC9L,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,GAAGrD,wBAAwB,CAAC6B,OAAO,CAAC;UAC1D,MAAMwL,EAAE,GAAG,CAACnK,EAAE,GAAGE,EAAE,IAAI,CAAC,GAAGtB,YAAY,CAACwL,OAAO;UAC/C,MAAMC,EAAE,GAAG,CAACpK,EAAE,GAAGE,EAAE,IAAI,CAAC,GAAGvB,YAAY,CAAC0L,OAAO;UAC/C,MAAMY,MAAM,GAAG,CAAChL,EAAE,GAAGF,EAAE,IAAI,CAAC,IAAIrB,OAAO,CAAC+C,CAAC,GAAG1B,EAAE,CAAC;UAC/C,MAAMmL,MAAM,GAAG,CAAChL,EAAE,GAAGF,EAAE,IAAI,CAAC,IAAItB,OAAO,CAACgD,CAAC,GAAG1B,EAAE,CAAC;UAC/CqB,OAAO,CAACO,IAAI,EAAE;UACdP,OAAO,CAACM,SAAS,CAACuI,EAAE,EAAEE,EAAE,CAAC;UACzB/I,OAAO,CAACwJ,MAAM,CAACnM,OAAO,CAACoM,KAAK,CAAC;UAC7BzJ,OAAO,CAACM,SAAS,CAAC,CAACsJ,MAAM,EAAE,CAACC,MAAM,CAAC;UACnCnJ,mBAAmB,CAACrD,OAAO,EAAEmD,EAAE,EAAER,OAAO,EAAE1C,YAAY,CAAC;UACvD0C,OAAO,CAACW,OAAO,EAAE;QACnB,CAAC,MAAM;UACL,MAAM+H,iBAAiB,GAAGN,yBAAyB,CACjD/K,OAAO,EACPC,YAAY,CACb;UACDqL,qBAAqB,CAACD,iBAAiB,EAAElI,EAAE,EAAER,OAAO,EAAE1C,YAAY,CAAC;QACrE;QAEA;MACF;IACA,KAAK,WAAW;IAChB,KAAK,SAAS;IACd,KAAK,SAAS;IACd,KAAK,MAAM;IACX,KAAK,OAAO;IACZ,KAAK,OAAO;IACZ,KAAK,MAAM;MAAE;QACXwI,oBAAoB,CAACzI,OAAO,EAAE0I,SAAS,CAAC;QACxC,IAAIzI,YAAY,CAACkN,WAAW,EAAE;UAC5B,MAAM,CAAC9L,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,GAAGrD,wBAAwB,CAAC6B,OAAO,CAAC;UAC1D,MAAMwL,EAAE,GAAG,CAACnK,EAAE,GAAGE,EAAE,IAAI,CAAC,GAAGtB,YAAY,CAACwL,OAAO;UAC/C,MAAMC,EAAE,GAAG,CAACpK,EAAE,GAAGE,EAAE,IAAI,CAAC,GAAGvB,YAAY,CAAC0L,OAAO;UAC/C,IAAIY,MAAM,GAAG,CAAChL,EAAE,GAAGF,EAAE,IAAI,CAAC,IAAIrB,OAAO,CAAC+C,CAAC,GAAG1B,EAAE,CAAC;UAC7C,IAAImL,MAAM,GAAG,CAAChL,EAAE,GAAGF,EAAE,IAAI,CAAC,IAAItB,OAAO,CAACgD,CAAC,GAAG1B,EAAE,CAAC;UAC7C,IAAI1D,aAAa,CAACoC,OAAO,CAAC,EAAE;YAC1B,MAAM4N,SAAS,GAAGtO,mBAAmB,CAACU,OAAO,CAAC;YAC9C,IAAIhC,cAAc,CAAC4P,SAAS,CAAC,EAAE;cAC7B,MAAMC,eAAe,GACnBnO,mBAAmB,CAACoO,2BAA2B,CAC7CF,SAAS,EACT5N,OAAO,CACR;cACHuM,MAAM,GAAG,CAAChL,EAAE,GAAGF,EAAE,IAAI,CAAC,IAAIwM,eAAe,CAAC9K,CAAC,GAAG1B,EAAE,CAAC;cACjDmL,MAAM,GAAG,CAAChL,EAAE,GAAGF,EAAE,IAAI,CAAC,IAAIuM,eAAe,CAAC7K,CAAC,GAAG1B,EAAE,CAAC;YACnD;UACF;UACAqB,OAAO,CAACO,IAAI,EAAE;UACdP,OAAO,CAACM,SAAS,CAACuI,EAAE,EAAEE,EAAE,CAAC;UAEzB,IAAIrL,sBAAsB,CAACL,OAAO,EAAEC,YAAY,CAAC,EAAE;YACjD0C,OAAO,CAACS,MAAM,GAAG,MAAM;UACzB;UACA,MAAMwI,gBAAgB,GAAGxM,mBAAmB,CAACY,OAAO,CAAC;UAErD,IAAIhC,cAAc,CAACgC,OAAO,CAAC,IAAI4L,gBAAgB,EAAE;YAC/C,MAAMC,UAAU,GAAGpJ,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;YAEnD,MAAMoJ,iBAAiB,GAAGD,UAAU,CAACjJ,UAAU,CAAC,IAAI,CAAE;;YAEtD;YACA;YACA,MAAMmJ,MAAM,GAAG9J,IAAI,CAAC+J,GAAG,CAAC3N,QAAQ,CAACgD,EAAE,EAAEE,EAAE,CAAC,EAAElD,QAAQ,CAACiD,EAAE,EAAEE,EAAE,CAAC,CAAC;YAC3D,MAAMJ,OAAO,GAAGN,gBAAgB,CAACd,OAAO,CAAC;YACzC6L,UAAU,CAACnK,KAAK,GACdqK,MAAM,GAAGmB,QAAQ,CAACa,WAAW,GAAG3M,OAAO,GAAG,EAAE,GAAG8L,QAAQ,CAACa,WAAW;YACrElC,UAAU,CAACjK,MAAM,GACfmK,MAAM,GAAGmB,QAAQ,CAACa,WAAW,GAAG3M,OAAO,GAAG,EAAE,GAAG8L,QAAQ,CAACa,WAAW;YAErEjC,iBAAiB,CAAC7I,SAAS,CACzB4I,UAAU,CAACnK,KAAK,GAAG,CAAC,EACpBmK,UAAU,CAACjK,MAAM,GAAG,CAAC,CACtB;YACDkK,iBAAiB,CAAC/J,KAAK,CAACmL,QAAQ,CAACa,WAAW,EAAEb,QAAQ,CAACa,WAAW,CAAC;;YAEnE;YACAxB,MAAM,GAAGvM,OAAO,CAAC0B,KAAK,GAAG,CAAC,IAAI1B,OAAO,CAAC+C,CAAC,GAAG1B,EAAE,CAAC;YAC7CmL,MAAM,GAAGxM,OAAO,CAAC4B,MAAM,GAAG,CAAC,IAAI5B,OAAO,CAACgD,CAAC,GAAG1B,EAAE,CAAC;YAE9CwK,iBAAiB,CAACK,MAAM,CAACnM,OAAO,CAACoM,KAAK,CAAC;YACvC,MAAM4B,MAAM,GAAGpP,KAAK,CAAC4D,MAAM,CAACqJ,UAAU,CAAC;YAEvCC,iBAAiB,CAAC7I,SAAS,CAAC,CAACsJ,MAAM,EAAE,CAACC,MAAM,CAAC;YAE7CnJ,mBAAmB,CAACrD,OAAO,EAAEgO,MAAM,EAAElC,iBAAiB,EAAE7L,YAAY,CAAC;YAErE6L,iBAAiB,CAAC7I,SAAS,CAACsJ,MAAM,EAAEC,MAAM,CAAC;YAE3CV,iBAAiB,CAACK,MAAM,CAAC,CAACnM,OAAO,CAACoM,KAAK,CAAC;;YAExC;YACA,MAAM,MAASC,WAAW,EAAEC,WAAW,CAAC,GACtCnO,wBAAwB,CAACyN,gBAAgB,CAAC;YAC5C,MAAMqC,eAAe,GAAG,CAAC5M,EAAE,GAAGE,EAAE,IAAI,CAAC,GAAG8K,WAAW;YACnD,MAAM6B,eAAe,GAAG,CAAC5M,EAAE,GAAGE,EAAE,IAAI,CAAC,GAAG8K,WAAW;YACnDR,iBAAiB,CAAC7I,SAAS,CAAC,CAACgL,eAAe,EAAE,CAACC,eAAe,CAAC;;YAE/D;YACApC,iBAAiB,CAACW,SAAS,CACzB,CAACb,gBAAgB,CAAClK,KAAK,GAAG,CAAC,EAC3B,CAACkK,gBAAgB,CAAChK,MAAM,GAAG,CAAC,EAC5BgK,gBAAgB,CAAClK,KAAK,EACtBkK,gBAAgB,CAAChK,MAAM,CACxB;YACDe,OAAO,CAACZ,KAAK,CAAC,CAAC,GAAGmL,QAAQ,CAACa,WAAW,EAAE,CAAC,GAAGb,QAAQ,CAACa,WAAW,CAAC;YACjEpL,OAAO,CAAC2B,SAAS,CACfuH,UAAU,EACV,CAACA,UAAU,CAACnK,KAAK,GAAG,CAAC,EACrB,CAACmK,UAAU,CAACjK,MAAM,GAAG,CAAC,EACtBiK,UAAU,CAACnK,KAAK,EAChBmK,UAAU,CAACjK,MAAM,CAClB;UACH,CAAC,MAAM;YACLe,OAAO,CAACwJ,MAAM,CAACnM,OAAO,CAACoM,KAAK,CAAC;YAE7B,IAAIpM,OAAO,CAACe,IAAI,KAAK,OAAO,EAAE;cAC5B;cACA4B,OAAO,CAACZ,KAAK,CAAC/B,OAAO,CAAC+B,KAAK,CAAC,CAAC,CAAC,EAAE/B,OAAO,CAAC+B,KAAK,CAAC,CAAC,CAAC,CAAC;YACnD;YAEAY,OAAO,CAACM,SAAS,CAAC,CAACsJ,MAAM,EAAE,CAACC,MAAM,CAAC;YACnCnJ,mBAAmB,CAACrD,OAAO,EAAEmD,EAAE,EAAER,OAAO,EAAE1C,YAAY,CAAC;UACzD;UAEA0C,OAAO,CAACW,OAAO,EAAE;UACjB;UACA;QACF,CAAC,MAAM;UACL,MAAM+H,iBAAiB,GAAGN,yBAAyB,CACjD/K,OAAO,EACPC,YAAY,CACb;UAED,MAAMkO,2BAA2B,GAAGxL,OAAO,CAACyL,qBAAqB;UAEjE;UACE;UACA;UACA,EAACnO,YAAY,aAAZA,YAAY,eAAZA,YAAY,CAAEmL,qBAAqB;UACpC;UACC,CAACpL,OAAO,CAACoM,KAAK;UACb;UACA;UACAzN,YAAY,CAACqB,OAAO,CAACoM,KAAK,CAAC,CAAC,EAC9B;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACAzJ,OAAO,CAACyL,qBAAqB,GAAG,KAAK;UACvC;UAEA9C,qBAAqB,CAACD,iBAAiB,EAAElI,EAAE,EAAER,OAAO,EAAE1C,YAAY,CAAC;;UAEnE;UACA0C,OAAO,CAACyL,qBAAqB,GAAGD,2BAA2B;QAC7D;QACA;MACF;IACA;MAAS;QACP;QACA,MAAM,IAAIlH,KAAK,CAAE,sBAAqBjH,OAAO,CAACe,IAAK,EAAC,CAAC;MACvD;EAAC;AAEL,CAAC;AAED,MAAMsN,yBAAyB,GAAGA,CAChCC,IAAc,EACdC,QAAkB,EAClBC,SAAkB,KACf;EACH,IAAI,OAAOA,SAAS,KAAK,WAAW,EAAE;IACpC,OAAOF,IAAI,CAACzJ,IAAI,CAAC0J,QAAQ,CAAC;EAC5B;EACA,MAAME,MAAgB,GAAG;IACvBC,IAAI,EAAEH,QAAQ,CAACG,IAAI;IACnB1J,KAAK,EAAEuJ,QAAQ,CAACvJ,KAAK;IACrB4C,OAAO,EAAE;MAAE,GAAG2G,QAAQ,CAAC3G,OAAO;MAAE+G,uBAAuB,EAAEH;IAAU;EACrE,CAAC;EACD,OAAOF,IAAI,CAACzJ,IAAI,CAAC4J,MAAM,CAAC;AAC1B,CAAC;AAED,MAAMG,6BAA6B,GAAGA,CACpC5O,OAAoC,EACpC6O,IAAgB,EAChBC,KAAmB,EACnBC,eAA+B,KAC5B;EACH,MAAMC,KAAK,GAAGrP,kBAAkB,CAACK,OAAO,CAAC;EACzC,IAAIgP,KAAK,IAAIA,KAAK,CAACC,EAAE,KAAKF,eAAe,EAAE;IACzC,MAAMG,CAAC,GAAGL,IAAI,CAACM,aAAa,CAAEC,eAAe,CAAClQ,MAAM,EAAE,GAAG,CAAC;IAC1DgQ,CAAC,CAACG,cAAc,CAACnQ,MAAM,EAAE,WAAW,EAAG,QAAO8P,KAAK,CAACC,EAAG,GAAE,CAAC;IAC1DH,KAAK,CAAC/J,OAAO,CAAEuK,IAAI,IAAKJ,CAAC,CAAClJ,WAAW,CAACsJ,IAAI,CAAC,CAAC;IAC5C,OAAOJ,CAAC;EACV;EAEA,OAAO,IAAI;AACb,CAAC;AAED,OAAO,MAAMK,kBAAkB,GAAGA,CAChCvP,OAAoC,EACpCsO,IAAc,EACdkB,OAAmB,EACnBC,KAAkB,EAClBxD,OAAe,EACfC,OAAe,EACfwD,kBAA4B,EAC5BC,gBAAgC,KAC7B;EAAA,IAAAC,sBAAA,EAAAC,oBAAA;EACH,MAAM,CAACxO,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,GAAGrD,wBAAwB,CAAC6B,OAAO,CAAC;EAC1D,IAAIwL,EAAE,GAAG,CAACjK,EAAE,GAAGF,EAAE,IAAI,CAAC,IAAIrB,OAAO,CAAC+C,CAAC,GAAG1B,EAAE,CAAC;EACzC,IAAIqK,EAAE,GAAG,CAAClK,EAAE,GAAGF,EAAE,IAAI,CAAC,IAAItB,OAAO,CAACgD,CAAC,GAAG1B,EAAE,CAAC;EACzC,IAAI1D,aAAa,CAACoC,OAAO,CAAC,EAAE;IAC1B,MAAM4N,SAAS,GAAGtO,mBAAmB,CAACU,OAAO,CAAC;IAC9C,IAAIhC,cAAc,CAAC4P,SAAS,CAAC,EAAE;MAC7B,MAAM,CAACvM,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,GAAGrD,wBAAwB,CAACyP,SAAS,CAAC;MAE5D,MAAMC,eAAe,GAAGnO,mBAAmB,CAACoO,2BAA2B,CACrEF,SAAS,EACT5N,OAAO,CACR;MACDwL,EAAE,GAAG,CAACjK,EAAE,GAAGF,EAAE,IAAI,CAAC,IAAIwM,eAAe,CAAC9K,CAAC,GAAG1B,EAAE,CAAC;MAC7CqK,EAAE,GAAG,CAAClK,EAAE,GAAGF,EAAE,IAAI,CAAC,IAAIuM,eAAe,CAAC7K,CAAC,GAAG1B,EAAE,CAAC;MAC7C2K,OAAO,GAAGA,OAAO,GAAG4B,eAAe,CAAC9K,CAAC,GAAG/C,OAAO,CAAC+C,CAAC;MACjDmJ,OAAO,GAAGA,OAAO,GAAG2B,eAAe,CAAC7K,CAAC,GAAGhD,OAAO,CAACgD,CAAC;IACnD;EACF;EACA,MAAM8M,MAAM,GAAI,GAAG,GAAG9P,OAAO,CAACoM,KAAK,GAAInK,IAAI,CAAC8N,EAAE;EAC9C,MAAMrH,SAAS,GAAG4F,IAAI,CAAC5F,SAAS;;EAEhC;EACA,IAAImG,IAAI,GAAGW,OAAO;;EAElB;EACA,IAAIxP,OAAO,CAACgQ,IAAI,EAAE;IAChB,MAAMC,SAAS,GAAGT,OAAO,CAACL,aAAa,CAAEC,eAAe,CAAClQ,MAAM,EAAE,GAAG,CAAC;IACrE+Q,SAAS,CAAChK,YAAY,CAAC,MAAM,EAAErG,aAAa,CAACI,OAAO,CAACgQ,IAAI,CAAC,CAAC;IAC3DnB,IAAI,CAAC7I,WAAW,CAACiK,SAAS,CAAC;IAC3BpB,IAAI,GAAGoB,SAAS;EAClB;EAEA,MAAMtM,OAAO,GACV,EAAAiM,sBAAA,IAAAC,oBAAA,GAAClQ,kBAAkB,CAACK,OAAO,CAAC,cAAA6P,oBAAA,uBAA3BA,oBAAA,CAA6BlM,OAAO,cAAAiM,sBAAA,cAAAA,sBAAA,GAAI,GAAG,IAAI5P,OAAO,CAAC2D,OAAO,GAAI,KAAK;EAE3E,QAAQ3D,OAAO,CAACe,IAAI;IAClB,KAAK,WAAW;MAAE;QAChB;QACA;QACA,MAAM,IAAIkG,KAAK,CAAC,8CAA8C,CAAC;MACjE;IACA,KAAK,WAAW;IAChB,KAAK,SAAS;IACd,KAAK,SAAS;MAAE;QACdwB,oBAAoB,CAACzI,OAAO,EAAE0I,SAAS,CAAC;QACxC,MAAM4G,IAAI,GAAGjB,yBAAyB,CACpCC,IAAI,EACJxJ,kBAAkB,CAAC9E,OAAO,CAAC,EAC3BhB,2BAA2B,CAC5B;QACD,IAAI2E,OAAO,KAAK,CAAC,EAAE;UACjB2L,IAAI,CAACrJ,YAAY,CAAC,gBAAgB,EAAG,GAAEtC,OAAQ,EAAC,CAAC;UACjD2L,IAAI,CAACrJ,YAAY,CAAC,cAAc,EAAG,GAAEtC,OAAQ,EAAC,CAAC;QACjD;QACA2L,IAAI,CAACrJ,YAAY,CAAC,gBAAgB,EAAE,OAAO,CAAC;QAC5CqJ,IAAI,CAACrJ,YAAY,CACf,WAAW,EACV,aAAYgG,OAAO,IAAI,CAAE,IACxBC,OAAO,IAAI,CACZ,YAAW4D,MAAO,IAAGtE,EAAG,IAAGE,EAAG,GAAE,CAClC;QAED,MAAMwD,CAAC,GAAGN,6BAA6B,CACrC5O,OAAO,EACP6O,IAAI,EACJ,CAACS,IAAI,CAAC,EACNK,gBAAgB,CACjB;QAEDT,CAAC,GAAGL,IAAI,CAAC7I,WAAW,CAACkJ,CAAC,CAAC,GAAGL,IAAI,CAAC7I,WAAW,CAACsJ,IAAI,CAAC;QAChD;MACF;IACA,KAAK,MAAM;IACX,KAAK,OAAO;MAAE;QACZ,MAAMY,SAAS,GAAG9Q,mBAAmB,CAACY,OAAO,CAAC;QAC9C,MAAMmQ,QAAQ,GAAGX,OAAO,CAACL,aAAa,CAAEC,eAAe,CAAClQ,MAAM,EAAE,MAAM,CAAC;QACvE,IAAIgR,SAAS,EAAE;UACbC,QAAQ,CAAClK,YAAY,CAAC,IAAI,EAAG,QAAOjG,OAAO,CAACiP,EAAG,EAAC,CAAC;UACjD,MAAMmB,eAAe,GAAGZ,OAAO,CAACL,aAAa,CAAEC,eAAe,CAC5DlQ,MAAM,EACN,MAAM,CACP;UACD+M,OAAO,GAAGA,OAAO,IAAI,CAAC;UACtBC,OAAO,GAAGA,OAAO,IAAI,CAAC;UACtBkE,eAAe,CAACnK,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;UACtCmK,eAAe,CAACnK,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;UACtCmK,eAAe,CAACnK,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC;UAC5CmK,eAAe,CAACnK,YAAY,CAC1B,OAAO,EACN,GAAEjG,OAAO,CAAC0B,KAAK,GAAG,GAAG,GAAGuK,OAAQ,EAAC,CACnC;UACDmE,eAAe,CAACnK,YAAY,CAC1B,QAAQ,EACP,GAAEjG,OAAO,CAAC4B,MAAM,GAAG,GAAG,GAAGsK,OAAQ,EAAC,CACpC;UAEDiE,QAAQ,CAACnK,WAAW,CAACoK,eAAe,CAAC;UACrC,MAAMC,iBAAiB,GAAGb,OAAO,CAACL,aAAa,CAAEC,eAAe,CAC9DlQ,MAAM,EACN,MAAM,CACP;UACD,MAAM2O,eAAe,GAAGnO,mBAAmB,CAACoO,2BAA2B,CACrE9N,OAAO,EACPkQ,SAAS,CACV;UAED,MAAMI,KAAK,GAAGrE,OAAO,GAAG4B,eAAe,CAAC9K,CAAC,GAAG/C,OAAO,CAAC+C,CAAC;UACrD,MAAMwN,KAAK,GAAGrE,OAAO,GAAG2B,eAAe,CAAC7K,CAAC,GAAGhD,OAAO,CAACgD,CAAC;UAErDqN,iBAAiB,CAACpK,YAAY,CAAC,GAAG,EAAEqK,KAAK,CAACE,QAAQ,EAAE,CAAC;UACrDH,iBAAiB,CAACpK,YAAY,CAAC,GAAG,EAAEsK,KAAK,CAACC,QAAQ,EAAE,CAAC;UACrDH,iBAAiB,CAACpK,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC;UAC9CoK,iBAAiB,CAACpK,YAAY,CAAC,OAAO,EAAG,GAAEiK,SAAS,CAACxO,KAAM,EAAC,CAAC;UAC7D2O,iBAAiB,CAACpK,YAAY,CAAC,QAAQ,EAAG,GAAEiK,SAAS,CAACtO,MAAO,EAAC,CAAC;UAC/DyO,iBAAiB,CAACpK,YAAY,CAAC,SAAS,EAAE,GAAG,CAAC;UAC9CkK,QAAQ,CAACnK,WAAW,CAACqK,iBAAiB,CAAC;QACzC;QACA5H,oBAAoB,CAACzI,OAAO,EAAE0I,SAAS,CAAC;QACxC,MAAM+H,KAAK,GAAGjB,OAAO,CAACL,aAAa,CAAEC,eAAe,CAAClQ,MAAM,EAAE,GAAG,CAAC;QACjE,IAAIgR,SAAS,EAAE;UACbO,KAAK,CAACxK,YAAY,CAAC,MAAM,EAAG,aAAYjG,OAAO,CAACiP,EAAG,GAAE,CAAC;QACxD;QACAwB,KAAK,CAACxK,YAAY,CAAC,gBAAgB,EAAE,OAAO,CAAC;QAE7CnB,kBAAkB,CAAC9E,OAAO,CAAC,CAAE+E,OAAO,CAAEC,KAAK,IAAK;UAC9C,MAAMsK,IAAI,GAAGjB,yBAAyB,CACpCC,IAAI,EACJtJ,KAAK,EACLhG,2BAA2B,CAC5B;UACD,IAAI2E,OAAO,KAAK,CAAC,EAAE;YACjB2L,IAAI,CAACrJ,YAAY,CAAC,gBAAgB,EAAG,GAAEtC,OAAQ,EAAC,CAAC;YACjD2L,IAAI,CAACrJ,YAAY,CAAC,cAAc,EAAG,GAAEtC,OAAQ,EAAC,CAAC;UACjD;UACA2L,IAAI,CAACrJ,YAAY,CACf,WAAW,EACV,aAAYgG,OAAO,IAAI,CAAE,IACxBC,OAAO,IAAI,CACZ,YAAW4D,MAAO,IAAGtE,EAAG,IAAGE,EAAG,GAAE,CAClC;UACD,IACE1L,OAAO,CAACe,IAAI,KAAK,MAAM,IACvBrC,WAAW,CAACsB,OAAO,CAACwI,MAAM,CAAC,IAC3BxI,OAAO,CAACsI,eAAe,KAAK,aAAa,EACzC;YACAgH,IAAI,CAACrJ,YAAY,CAAC,WAAW,EAAE,SAAS,CAAC;UAC3C;UACAwK,KAAK,CAACzK,WAAW,CAACsJ,IAAI,CAAC;QACzB,CAAC,CAAC;QAEF,MAAMJ,CAAC,GAAGN,6BAA6B,CACrC5O,OAAO,EACP6O,IAAI,EACJ,CAAC4B,KAAK,EAAEN,QAAQ,CAAC,EACjBR,gBAAgB,CACjB;QACD,IAAIT,CAAC,EAAE;UACLL,IAAI,CAAC7I,WAAW,CAACkJ,CAAC,CAAC;QACrB,CAAC,MAAM;UACLL,IAAI,CAAC7I,WAAW,CAACyK,KAAK,CAAC;UACvB5B,IAAI,CAAC6B,MAAM,CAACP,QAAQ,CAAC;QACvB;QACA;MACF;IACA,KAAK,UAAU;MAAE;QACf1H,oBAAoB,CAACzI,OAAO,EAAE0I,SAAS,CAAC;QACxCoC,qBAAqB,CAAC9K,OAAO,CAAC;QAC9B,MAAMgF,KAAK,GAAGF,kBAAkB,CAAC9E,OAAO,CAAC;QACzC,MAAMsP,IAAI,GAAGtK,KAAK,GACdqJ,yBAAyB,CAACC,IAAI,EAAEtJ,KAAK,EAAEhG,2BAA2B,CAAC,GACnEwQ,OAAO,CAACL,aAAa,CAAEC,eAAe,CAAClQ,MAAM,EAAE,GAAG,CAAC;QACvD,IAAIyE,OAAO,KAAK,CAAC,EAAE;UACjB2L,IAAI,CAACrJ,YAAY,CAAC,gBAAgB,EAAG,GAAEtC,OAAQ,EAAC,CAAC;UACjD2L,IAAI,CAACrJ,YAAY,CAAC,cAAc,EAAG,GAAEtC,OAAQ,EAAC,CAAC;QACjD;QACA2L,IAAI,CAACrJ,YAAY,CACf,WAAW,EACV,aAAYgG,OAAO,IAAI,CAAE,IACxBC,OAAO,IAAI,CACZ,YAAW4D,MAAO,IAAGtE,EAAG,IAAGE,EAAG,GAAE,CAClC;QACD4D,IAAI,CAACrJ,YAAY,CAAC,QAAQ,EAAE,MAAM,CAAC;QACnC,MAAMf,IAAI,GAAGsK,OAAO,CAACL,aAAa,CAAEC,eAAe,CAAClQ,MAAM,EAAE,MAAM,CAAC;QACnEgG,IAAI,CAACe,YAAY,CAAC,MAAM,EAAEjG,OAAO,CAACiF,WAAW,CAAC;QAC9CC,IAAI,CAACe,YAAY,CAAC,GAAG,EAAE0K,kBAAkB,CAAC3Q,OAAO,CAAC,CAAC;QACnDsP,IAAI,CAACtJ,WAAW,CAACd,IAAI,CAAC;QAEtB,MAAMgK,CAAC,GAAGN,6BAA6B,CACrC5O,OAAO,EACP6O,IAAI,EACJ,CAACS,IAAI,CAAC,EACNK,gBAAgB,CACjB;QAEDT,CAAC,GAAGL,IAAI,CAAC7I,WAAW,CAACkJ,CAAC,CAAC,GAAGL,IAAI,CAAC7I,WAAW,CAACsJ,IAAI,CAAC;QAChD;MACF;IACA,KAAK,OAAO;MAAE;QACZ,MAAM5N,KAAK,GAAGO,IAAI,CAAC2O,KAAK,CAAC5Q,OAAO,CAAC0B,KAAK,CAAC;QACvC,MAAME,MAAM,GAAGK,IAAI,CAAC2O,KAAK,CAAC5Q,OAAO,CAAC4B,MAAM,CAAC;QACzC,MAAMiP,QAAQ,GACZ9S,yBAAyB,CAACiC,OAAO,CAAC,IAAIyP,KAAK,CAACzP,OAAO,CAACI,MAAM,CAAC;QAC7D,IAAIyQ,QAAQ,EAAE;UACZ,MAAMC,QAAQ,GAAI,SAAQD,QAAQ,CAAC5B,EAAG,EAAC;UACvC,IAAI8B,MAAM,GAAGvB,OAAO,CAACwB,aAAa,CAAE,IAAGF,QAAS,EAAC,CAAC;UAClD,IAAI,CAACC,MAAM,EAAE;YACXA,MAAM,GAAGvB,OAAO,CAACL,aAAa,CAAEC,eAAe,CAAClQ,MAAM,EAAE,QAAQ,CAAC;YACjE6R,MAAM,CAAC9B,EAAE,GAAG6B,QAAQ;YAEpB,MAAMtL,KAAK,GAAGgK,OAAO,CAACL,aAAa,CAAEC,eAAe,CAAClQ,MAAM,EAAE,OAAO,CAAC;YAErEsG,KAAK,CAACS,YAAY,CAAC,OAAO,EAAE,MAAM,CAAC;YACnCT,KAAK,CAACS,YAAY,CAAC,QAAQ,EAAE,MAAM,CAAC;YACpCT,KAAK,CAACS,YAAY,CAAC,MAAM,EAAE4K,QAAQ,CAACI,OAAO,CAAC;YAE5CF,MAAM,CAAC/K,WAAW,CAACR,KAAK,CAAC;YAEzBqJ,IAAI,CAACqC,OAAO,CAACH,MAAM,CAAC;UACtB;UAEA,MAAMI,GAAG,GAAG3B,OAAO,CAACL,aAAa,CAAEC,eAAe,CAAClQ,MAAM,EAAE,KAAK,CAAC;UACjEiS,GAAG,CAAClL,YAAY,CAAC,MAAM,EAAG,IAAG6K,QAAS,EAAC,CAAC;;UAExC;UACA,IAAIpB,kBAAkB,IAAImB,QAAQ,CAACpQ,QAAQ,KAAKxB,UAAU,CAACyB,GAAG,EAAE;YAC9DyQ,GAAG,CAAClL,YAAY,CAAC,QAAQ,EAAEpG,mBAAmB,CAAC;UACjD;UAEAsR,GAAG,CAAClL,YAAY,CAAC,OAAO,EAAG,GAAEvE,KAAM,EAAC,CAAC;UACrCyP,GAAG,CAAClL,YAAY,CAAC,QAAQ,EAAG,GAAErE,MAAO,EAAC,CAAC;UACvCuP,GAAG,CAAClL,YAAY,CAAC,SAAS,EAAG,GAAEtC,OAAQ,EAAC,CAAC;;UAEzC;UACA;UACA;UACA;UACA;UACA;UACA,IAAI3D,OAAO,CAAC+B,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI/B,OAAO,CAAC+B,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;YACpD,MAAMqP,UAAU,GAAGpR,OAAO,CAAC+B,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAACL,KAAK,GAAG,CAAC;YACtD,MAAM2P,UAAU,GAAGrR,OAAO,CAAC+B,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAACH,MAAM,GAAG,CAAC;YACvDuP,GAAG,CAAClL,YAAY,CACd,WAAW,EACV,SAAQjG,OAAO,CAAC+B,KAAK,CAAC,CAAC,CAAE,KAAI/B,OAAO,CAAC+B,KAAK,CAAC,CAAC,CAAE,eAAcqP,UAAW,IAAGC,UAAW,GAAE,CACzF;UACH;UAEA,MAAMnC,CAAC,GAAGM,OAAO,CAACL,aAAa,CAAEC,eAAe,CAAClQ,MAAM,EAAE,GAAG,CAAC;UAC7DgQ,CAAC,CAAClJ,WAAW,CAACmL,GAAG,CAAC;UAClBjC,CAAC,CAACjJ,YAAY,CACZ,WAAW,EACV,aAAYgG,OAAO,IAAI,CAAE,IACxBC,OAAO,IAAI,CACZ,YAAW4D,MAAO,IAAGtE,EAAG,IAAGE,EAAG,GAAE,CAClC;UAED,MAAM4F,KAAK,GAAG1C,6BAA6B,CACzC5O,OAAO,EACP6O,IAAI,EACJ,CAACK,CAAC,CAAC,EACHS,gBAAgB,CACjB;UACD2B,KAAK,GAAGzC,IAAI,CAAC7I,WAAW,CAACsL,KAAK,CAAC,GAAGzC,IAAI,CAAC7I,WAAW,CAACkJ,CAAC,CAAC;QACvD;QACA;MACF;IACA;IACA,KAAK,OAAO;MAAE;QACZ;MACF;IACA;MAAS;QACP,IAAItR,aAAa,CAACoC,OAAO,CAAC,EAAE;UAC1B,MAAMsP,IAAI,GAAGE,OAAO,CAACL,aAAa,CAAEC,eAAe,CAAClQ,MAAM,EAAE,GAAG,CAAC;UAChE,IAAIyE,OAAO,KAAK,CAAC,EAAE;YACjB2L,IAAI,CAACrJ,YAAY,CAAC,gBAAgB,EAAG,GAAEtC,OAAQ,EAAC,CAAC;YACjD2L,IAAI,CAACrJ,YAAY,CAAC,cAAc,EAAG,GAAEtC,OAAQ,EAAC,CAAC;UACjD;UAEA2L,IAAI,CAACrJ,YAAY,CACf,WAAW,EACV,aAAYgG,OAAO,IAAI,CAAE,IACxBC,OAAO,IAAI,CACZ,YAAW4D,MAAO,IAAGtE,EAAG,IAAGE,EAAG,GAAE,CAClC;UACD,MAAMtF,KAAK,GAAGpG,OAAO,CAAC4F,IAAI,CAACS,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,CAACC,KAAK,CAAC,IAAI,CAAC;UAC9D,MAAME,YAAY,GAAGjH,iBAAiB,CACpCS,OAAO,CAACyG,QAAQ,EAChBzG,OAAO,CAAC0G,UAAU,CACnB;UACD,MAAMH,gBAAgB,GACpBvG,OAAO,CAACmG,SAAS,KAAK,QAAQ,GAC1BnG,OAAO,CAAC0B,KAAK,GAAG,CAAC,GACjB1B,OAAO,CAACmG,SAAS,KAAK,OAAO,GAC7BnG,OAAO,CAAC0B,KAAK,GACb,CAAC;UACP,MAAM6P,SAAS,GAAG/S,KAAK,CAACwB,OAAO,CAAC4F,IAAI,CAAC,GAAG,KAAK,GAAG,KAAK;UACrD,MAAM4L,UAAU,GACdxR,OAAO,CAACmG,SAAS,KAAK,QAAQ,GAC1B,QAAQ,GACRnG,OAAO,CAACmG,SAAS,KAAK,OAAO,IAAIoL,SAAS,KAAK,KAAK,GACpD,KAAK,GACL,OAAO;UACb,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrL,KAAK,CAACU,MAAM,EAAE2K,CAAC,EAAE,EAAE;YACrC,MAAM7L,IAAI,GAAG4J,OAAO,CAACL,aAAa,CAAEC,eAAe,CAAClQ,MAAM,EAAE,MAAM,CAAC;YACnE0G,IAAI,CAAC8L,WAAW,GAAGtL,KAAK,CAACqL,CAAC,CAAC;YAC3B7L,IAAI,CAACK,YAAY,CAAC,GAAG,EAAG,GAAEM,gBAAiB,EAAC,CAAC;YAC7CX,IAAI,CAACK,YAAY,CAAC,GAAG,EAAG,GAAEwL,CAAC,GAAGjL,YAAa,EAAC,CAAC;YAC7CZ,IAAI,CAACK,YAAY,CAAC,aAAa,EAAE1H,mBAAmB,CAACyB,OAAO,CAAC,CAAC;YAC9D4F,IAAI,CAACK,YAAY,CAAC,WAAW,EAAG,GAAEjG,OAAO,CAACyG,QAAS,IAAG,CAAC;YACvDb,IAAI,CAACK,YAAY,CAAC,MAAM,EAAEjG,OAAO,CAACiF,WAAW,CAAC;YAC9CW,IAAI,CAACK,YAAY,CAAC,aAAa,EAAEuL,UAAU,CAAC;YAC5C5L,IAAI,CAACK,YAAY,CAAC,OAAO,EAAE,mBAAmB,CAAC;YAC/CL,IAAI,CAACK,YAAY,CAAC,WAAW,EAAEsL,SAAS,CAAC;YACzC3L,IAAI,CAACK,YAAY,CAAC,mBAAmB,EAAE,kBAAkB,CAAC;YAC1DqJ,IAAI,CAACtJ,WAAW,CAACJ,IAAI,CAAC;UACxB;UAEA,MAAMsJ,CAAC,GAAGN,6BAA6B,CACrC5O,OAAO,EACP6O,IAAI,EACJ,CAACS,IAAI,CAAC,EACNK,gBAAgB,CACjB;UAEDT,CAAC,GAAGL,IAAI,CAAC7I,WAAW,CAACkJ,CAAC,CAAC,GAAGL,IAAI,CAAC7I,WAAW,CAACsJ,IAAI,CAAC;QAClD,CAAC,MAAM;UACL;UACA,MAAM,IAAIrI,KAAK,CAAE,sBAAqBjH,OAAO,CAACe,IAAK,EAAC,CAAC;QACvD;MACF;EAAC;AAEL,CAAC;AAED,OAAO,MAAM4Q,UAAU,GAAG,IAAIxK,OAAO,CAAoC,EAAE,CAAC;AAE5E,OAAO,SAAS2D,qBAAqBA,CAAC9K,OAAkC,EAAE;EACxE,MAAM4R,WAAW,GAAGjB,kBAAkB,CAAC3Q,OAAO,CAAC;EAC/C,MAAMkF,IAAI,GAAG,IAAI2M,MAAM,CAACD,WAAW,CAAC;EACpCD,UAAU,CAACrK,GAAG,CAACtH,OAAO,EAAEkF,IAAI,CAAC;EAC7B,OAAOA,IAAI;AACb;AAEA,OAAO,SAASC,iBAAiBA,CAACnF,OAAkC,EAAE;EACpE,OAAO2R,UAAU,CAACnR,GAAG,CAACR,OAAO,CAAC;AAChC;AAEA,OAAO,SAAS2Q,kBAAkBA,CAAC3Q,OAAkC,EAAE;EACrE;EACA,MAAM8R,WAAW,GAAG9R,OAAO,CAAC+R,gBAAgB,GACxC/R,OAAO,CAACwI,MAAM,GACdxI,OAAO,CAACwI,MAAM,CAAC1B,MAAM,GACrB9G,OAAO,CAACwI,MAAM,CAACwJ,GAAG,CAAC,CAAAC,IAAA,EAASR,CAAC;IAAA,IAAT,CAAC1O,CAAC,EAAEC,CAAC,CAAC,GAAAiP,IAAA;IAAA,OAAQ,CAAClP,CAAC,EAAEC,CAAC,EAAEhD,OAAO,CAACkS,SAAS,CAACT,CAAC,CAAC,CAAC;EAAA,EAAC,GAC/D,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;;EAEjB;EACA,MAAM7J,OAAsB,GAAG;IAC7BmK,gBAAgB,EAAE/R,OAAO,CAAC+R,gBAAgB;IAC1C1N,IAAI,EAAErE,OAAO,CAACY,WAAW,GAAG,IAAI;IAChCuR,QAAQ,EAAE,GAAG;IACbC,SAAS,EAAE,GAAG;IACdC,UAAU,EAAE,GAAG;IACfC,MAAM,EAAGC,CAAC,IAAKtQ,IAAI,CAACuQ,GAAG,CAAED,CAAC,GAAGtQ,IAAI,CAAC8N,EAAE,GAAI,CAAC,CAAC;IAAE;IAC5C0C,IAAI,EAAE,CAAC,CAACzS,OAAO,CAAC0S,kBAAkB,CAAE;EACtC,CAAC;;EAED,OAAOC,oBAAoB,CAACxT,SAAS,CAAC2S,WAAW,EAAgBlK,OAAO,CAAC,CAAC;AAC5E;AAEA,SAASgL,GAAGA,CAACC,CAAW,EAAEC,CAAW,EAAE;EACrC,OAAO,CAAC,CAACD,CAAC,CAAC,CAAC,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAACD,CAAC,CAAC,CAAC,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;AAC/C;;AAEA;AACA;AACA;AACA,MAAMC,kBAAkB,GAAG,kDAAkD;AAE7E,SAASJ,oBAAoBA,CAACnK,MAAkB,EAAU;EACxD,IAAI,CAACA,MAAM,CAAC1B,MAAM,EAAE;IAClB,OAAO,EAAE;EACX;EAEA,MAAMkF,GAAG,GAAGxD,MAAM,CAAC1B,MAAM,GAAG,CAAC;EAE7B,OAAO0B,MAAM,CACVwK,MAAM,CACL,CAACC,GAAG,EAAEC,KAAK,EAAEzB,CAAC,EAAE0B,GAAG,KAAK;IACtB,IAAI1B,CAAC,KAAKzF,GAAG,EAAE;MACbiH,GAAG,CAACpI,IAAI,CAACqI,KAAK,EAAEN,GAAG,CAACM,KAAK,EAAEC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC;IACvD,CAAC,MAAM;MACLF,GAAG,CAACpI,IAAI,CAACqI,KAAK,EAAEN,GAAG,CAACM,KAAK,EAAEC,GAAG,CAAC1B,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACzC;IACA,OAAOwB,GAAG;EACZ,CAAC,EACD,CAAC,GAAG,EAAEzK,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CACtB,CACA4K,IAAI,CAAC,GAAG,CAAC,CACT/M,OAAO,CAAC0M,kBAAkB,EAAE,IAAI,CAAC;AACtC"},"metadata":{},"sourceType":"module","externalDependencies":[]}