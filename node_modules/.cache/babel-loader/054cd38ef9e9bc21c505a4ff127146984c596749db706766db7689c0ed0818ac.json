{"ast":null,"code":"var _jsxFileName = \"D:\\\\project\\\\excalidraw-cn\\\\src\\\\components\\\\Sidebar\\\\Sidebar.tsx\";\nimport React, { useEffect, useLayoutEffect, useRef, useState, forwardRef, useImperativeHandle, useCallback } from \"react\";\nimport { Island } from \".././Island\";\nimport { atom, useSetAtom } from \"jotai\";\nimport { jotaiScope } from \"../../jotai\";\nimport { SidebarPropsContext } from \"./common\";\nimport { SidebarHeader } from \"./SidebarHeader\";\nimport clsx from \"clsx\";\nimport { useDevice, useExcalidrawSetAppState } from \"../App\";\nimport { updateObject } from \"../../utils\";\nimport { KEYS } from \"../../keys\";\nimport { EVENT } from \"../../constants\";\nimport { SidebarTrigger } from \"./SidebarTrigger\";\nimport { SidebarTabTriggers } from \"./SidebarTabTriggers\";\nimport { SidebarTabTrigger } from \"./SidebarTabTrigger\";\nimport { SidebarTabs } from \"./SidebarTabs\";\nimport { SidebarTab } from \"./SidebarTab\";\nimport { useUIAppState } from \"../../context/ui-appState\";\nimport { useOutsideClick } from \"../../hooks/useOutsideClick\";\nimport \"./Sidebar.scss\";\n\n/**\n * Flags whether the currently rendered Sidebar is docked or not, for use\n * in upstream components that need to act on this (e.g. LayerUI to shift the\n * UI). We use an atom because of potential host app sidebars (for the default\n * sidebar we could just read from appState.defaultSidebarDockedPreference).\n *\n * Since we can only render one Sidebar at a time, we can use a simple flag.\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { createElement as _createElement } from \"react\";\nexport const isSidebarDockedAtom = atom(false);\nexport const SidebarInner = /*#__PURE__*/forwardRef((_ref, ref) => {\n  let {\n    name,\n    children,\n    onDock,\n    docked,\n    className,\n    ...rest\n  } = _ref;\n  if (process.env.NODE_ENV === \"development\" && onDock && docked == null) {\n    console.warn(\"Sidebar: `docked` must be set when `onDock` is supplied for the sidebar to be user-dockable. To hide this message, either pass `docked` or remove `onDock`\");\n  }\n  const setAppState = useExcalidrawSetAppState();\n  const setIsSidebarDockedAtom = useSetAtom(isSidebarDockedAtom, jotaiScope);\n  useLayoutEffect(() => {\n    setIsSidebarDockedAtom(!!docked);\n    return () => {\n      setIsSidebarDockedAtom(false);\n    };\n  }, [setIsSidebarDockedAtom, docked]);\n  const headerPropsRef = useRef({});\n  headerPropsRef.current.onCloseRequest = () => {\n    setAppState({\n      openSidebar: null\n    });\n  };\n  headerPropsRef.current.onDock = isDocked => onDock === null || onDock === void 0 ? void 0 : onDock(isDocked);\n  // renew the ref object if the following props change since we want to\n  // rerender. We can't pass down as component props manually because\n  // the <Sidebar.Header/> can be rendered upstream.\n  headerPropsRef.current = updateObject(headerPropsRef.current, {\n    docked,\n    // explicit prop to rerender on update\n    shouldRenderDockButton: !!onDock && docked != null\n  });\n  const islandRef = useRef(null);\n  useImperativeHandle(ref, () => {\n    return islandRef.current;\n  });\n  const device = useDevice();\n  const closeLibrary = useCallback(() => {\n    const isDialogOpen = !!document.querySelector(\".Dialog\");\n\n    // Prevent closing if any dialog is open\n    if (isDialogOpen) {\n      return;\n    }\n    setAppState({\n      openSidebar: null\n    });\n  }, [setAppState]);\n  useOutsideClick(islandRef, useCallback(event => {\n    // If click on the library icon, do nothing so that LibraryButton\n    // can toggle library menu\n    if (event.target.closest(\".sidebar-trigger\")) {\n      return;\n    }\n    if (!docked || !device.canDeviceFitSidebar) {\n      closeLibrary();\n    }\n  }, [closeLibrary, docked, device.canDeviceFitSidebar]));\n  useEffect(() => {\n    const handleKeyDown = event => {\n      if (event.key === KEYS.ESCAPE && (!docked || !device.canDeviceFitSidebar)) {\n        closeLibrary();\n      }\n    };\n    document.addEventListener(EVENT.KEYDOWN, handleKeyDown);\n    return () => {\n      document.removeEventListener(EVENT.KEYDOWN, handleKeyDown);\n    };\n  }, [closeLibrary, docked, device.canDeviceFitSidebar]);\n  return /*#__PURE__*/_jsxDEV(Island, {\n    ...rest,\n    className: clsx(\"sidebar\", {\n      \"sidebar--docked\": docked\n    }, className),\n    ref: islandRef,\n    children: /*#__PURE__*/_jsxDEV(SidebarPropsContext.Provider, {\n      value: headerPropsRef.current,\n      children: children\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 145,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 140,\n    columnNumber: 7\n  }, this);\n});\nSidebarInner.displayName = \"SidebarInner\";\nexport const Sidebar = Object.assign( /*#__PURE__*/forwardRef((props, ref) => {\n  var _appState$openSidebar3;\n  const appState = useUIAppState();\n  const {\n    onStateChange\n  } = props;\n  const refPrevOpenSidebar = useRef(appState.openSidebar);\n  useEffect(() => {\n    var _refPrevOpenSidebar$c, _appState$openSidebar, _refPrevOpenSidebar$c2, _refPrevOpenSidebar$c3;\n    if (\n    // closing sidebar\n    (!appState.openSidebar && (refPrevOpenSidebar === null || refPrevOpenSidebar === void 0 ? void 0 : (_refPrevOpenSidebar$c = refPrevOpenSidebar.current) === null || _refPrevOpenSidebar$c === void 0 ? void 0 : _refPrevOpenSidebar$c.name) === props.name ||\n    // opening current sidebar\n    ((_appState$openSidebar = appState.openSidebar) === null || _appState$openSidebar === void 0 ? void 0 : _appState$openSidebar.name) === props.name && (refPrevOpenSidebar === null || refPrevOpenSidebar === void 0 ? void 0 : (_refPrevOpenSidebar$c2 = refPrevOpenSidebar.current) === null || _refPrevOpenSidebar$c2 === void 0 ? void 0 : _refPrevOpenSidebar$c2.name) !== props.name ||\n    // switching tabs or switching to a different sidebar\n    ((_refPrevOpenSidebar$c3 = refPrevOpenSidebar.current) === null || _refPrevOpenSidebar$c3 === void 0 ? void 0 : _refPrevOpenSidebar$c3.name) === props.name) && appState.openSidebar !== refPrevOpenSidebar.current) {\n      var _appState$openSidebar2;\n      onStateChange === null || onStateChange === void 0 ? void 0 : onStateChange(((_appState$openSidebar2 = appState.openSidebar) === null || _appState$openSidebar2 === void 0 ? void 0 : _appState$openSidebar2.name) !== props.name ? null : appState.openSidebar);\n    }\n    refPrevOpenSidebar.current = appState.openSidebar;\n  }, [appState.openSidebar, onStateChange, props.name]);\n  const [mounted, setMounted] = useState(false);\n  useLayoutEffect(() => {\n    setMounted(true);\n    return () => setMounted(false);\n  }, []);\n\n  // We want to render in the next tick (hence `mounted` flag) so that it's\n  // guaranteed to happen after unmount of the previous sidebar (in case the\n  // previous sidebar is mounted after the next one). This is necessary to\n  // prevent flicker of subcomponents that support fallbacks\n  // (e.g. SidebarHeader). This is because we're using flags to determine\n  // whether prefer the fallback component or not (otherwise both will render\n  // initially), and the flag won't be reset in time if the unmount order\n  // it not correct.\n  //\n  // Alternative, and more general solution would be to namespace the fallback\n  // HoC so that state is not shared between subcomponents when the wrapping\n  // component is of the same type (e.g. Sidebar -> SidebarHeader).\n  const shouldRender = mounted && ((_appState$openSidebar3 = appState.openSidebar) === null || _appState$openSidebar3 === void 0 ? void 0 : _appState$openSidebar3.name) === props.name;\n  if (!shouldRender) {\n    return null;\n  }\n  return /*#__PURE__*/_createElement(SidebarInner, {\n    ...props,\n    ref: ref,\n    key: props.name,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 206,\n      columnNumber: 12\n    }\n  });\n}), {\n  Header: SidebarHeader,\n  TabTriggers: SidebarTabTriggers,\n  TabTrigger: SidebarTabTrigger,\n  Tabs: SidebarTabs,\n  Tab: SidebarTab,\n  Trigger: SidebarTrigger\n});\nSidebar.displayName = \"Sidebar\";","map":{"version":3,"names":["React","useEffect","useLayoutEffect","useRef","useState","forwardRef","useImperativeHandle","useCallback","Island","atom","useSetAtom","jotaiScope","SidebarPropsContext","SidebarHeader","clsx","useDevice","useExcalidrawSetAppState","updateObject","KEYS","EVENT","SidebarTrigger","SidebarTabTriggers","SidebarTabTrigger","SidebarTabs","SidebarTab","useUIAppState","useOutsideClick","jsxDEV","_jsxDEV","createElement","_createElement","isSidebarDockedAtom","SidebarInner","_ref","ref","name","children","onDock","docked","className","rest","process","env","NODE_ENV","console","warn","setAppState","setIsSidebarDockedAtom","headerPropsRef","current","onCloseRequest","openSidebar","isDocked","shouldRenderDockButton","islandRef","device","closeLibrary","isDialogOpen","document","querySelector","event","target","closest","canDeviceFitSidebar","handleKeyDown","key","ESCAPE","addEventListener","KEYDOWN","removeEventListener","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","displayName","Sidebar","Object","assign","props","_appState$openSidebar3","appState","onStateChange","refPrevOpenSidebar","_refPrevOpenSidebar$c","_appState$openSidebar","_refPrevOpenSidebar$c2","_refPrevOpenSidebar$c3","_appState$openSidebar2","mounted","setMounted","shouldRender","__self","__source","Header","TabTriggers","TabTrigger","Tabs","Tab","Trigger"],"sources":["D:/project/excalidraw-cn/src/components/Sidebar/Sidebar.tsx"],"sourcesContent":["import React, {\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState,\n  forwardRef,\n  useImperativeHandle,\n  useCallback,\n} from \"react\";\nimport { Island } from \".././Island\";\nimport { atom, useSetAtom } from \"jotai\";\nimport { jotaiScope } from \"../../jotai\";\nimport {\n  SidebarPropsContext,\n  SidebarProps,\n  SidebarPropsContextValue,\n} from \"./common\";\nimport { SidebarHeader } from \"./SidebarHeader\";\nimport clsx from \"clsx\";\nimport { useDevice, useExcalidrawSetAppState } from \"../App\";\nimport { updateObject } from \"../../utils\";\nimport { KEYS } from \"../../keys\";\nimport { EVENT } from \"../../constants\";\nimport { SidebarTrigger } from \"./SidebarTrigger\";\nimport { SidebarTabTriggers } from \"./SidebarTabTriggers\";\nimport { SidebarTabTrigger } from \"./SidebarTabTrigger\";\nimport { SidebarTabs } from \"./SidebarTabs\";\nimport { SidebarTab } from \"./SidebarTab\";\nimport { useUIAppState } from \"../../context/ui-appState\";\nimport { useOutsideClick } from \"../../hooks/useOutsideClick\";\n\nimport \"./Sidebar.scss\";\n\n/**\n * Flags whether the currently rendered Sidebar is docked or not, for use\n * in upstream components that need to act on this (e.g. LayerUI to shift the\n * UI). We use an atom because of potential host app sidebars (for the default\n * sidebar we could just read from appState.defaultSidebarDockedPreference).\n *\n * Since we can only render one Sidebar at a time, we can use a simple flag.\n */\nexport const isSidebarDockedAtom = atom(false);\n\nexport const SidebarInner = forwardRef(\n  (\n    {\n      name,\n      children,\n      onDock,\n      docked,\n      className,\n      ...rest\n    }: SidebarProps & Omit<React.RefAttributes<HTMLDivElement>, \"onSelect\">,\n    ref: React.ForwardedRef<HTMLDivElement>,\n  ) => {\n    if (process.env.NODE_ENV === \"development\" && onDock && docked == null) {\n      console.warn(\n        \"Sidebar: `docked` must be set when `onDock` is supplied for the sidebar to be user-dockable. To hide this message, either pass `docked` or remove `onDock`\",\n      );\n    }\n\n    const setAppState = useExcalidrawSetAppState();\n\n    const setIsSidebarDockedAtom = useSetAtom(isSidebarDockedAtom, jotaiScope);\n\n    useLayoutEffect(() => {\n      setIsSidebarDockedAtom(!!docked);\n      return () => {\n        setIsSidebarDockedAtom(false);\n      };\n    }, [setIsSidebarDockedAtom, docked]);\n\n    const headerPropsRef = useRef<SidebarPropsContextValue>(\n      {} as SidebarPropsContextValue,\n    );\n    headerPropsRef.current.onCloseRequest = () => {\n      setAppState({ openSidebar: null });\n    };\n    headerPropsRef.current.onDock = (isDocked) => onDock?.(isDocked);\n    // renew the ref object if the following props change since we want to\n    // rerender. We can't pass down as component props manually because\n    // the <Sidebar.Header/> can be rendered upstream.\n    headerPropsRef.current = updateObject(headerPropsRef.current, {\n      docked,\n      // explicit prop to rerender on update\n      shouldRenderDockButton: !!onDock && docked != null,\n    });\n\n    const islandRef = useRef<HTMLDivElement>(null);\n\n    useImperativeHandle(ref, () => {\n      return islandRef.current!;\n    });\n\n    const device = useDevice();\n\n    const closeLibrary = useCallback(() => {\n      const isDialogOpen = !!document.querySelector(\".Dialog\");\n\n      // Prevent closing if any dialog is open\n      if (isDialogOpen) {\n        return;\n      }\n      setAppState({ openSidebar: null });\n    }, [setAppState]);\n\n    useOutsideClick(\n      islandRef,\n      useCallback(\n        (event) => {\n          // If click on the library icon, do nothing so that LibraryButton\n          // can toggle library menu\n          if ((event.target as Element).closest(\".sidebar-trigger\")) {\n            return;\n          }\n          if (!docked || !device.canDeviceFitSidebar) {\n            closeLibrary();\n          }\n        },\n        [closeLibrary, docked, device.canDeviceFitSidebar],\n      ),\n    );\n\n    useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        if (\n          event.key === KEYS.ESCAPE &&\n          (!docked || !device.canDeviceFitSidebar)\n        ) {\n          closeLibrary();\n        }\n      };\n      document.addEventListener(EVENT.KEYDOWN, handleKeyDown);\n      return () => {\n        document.removeEventListener(EVENT.KEYDOWN, handleKeyDown);\n      };\n    }, [closeLibrary, docked, device.canDeviceFitSidebar]);\n\n    return (\n      <Island\n        {...rest}\n        className={clsx(\"sidebar\", { \"sidebar--docked\": docked }, className)}\n        ref={islandRef}\n      >\n        <SidebarPropsContext.Provider value={headerPropsRef.current}>\n          {children}\n        </SidebarPropsContext.Provider>\n      </Island>\n    );\n  },\n);\nSidebarInner.displayName = \"SidebarInner\";\n\nexport const Sidebar = Object.assign(\n  forwardRef((props: SidebarProps, ref: React.ForwardedRef<HTMLDivElement>) => {\n    const appState = useUIAppState();\n\n    const { onStateChange } = props;\n\n    const refPrevOpenSidebar = useRef(appState.openSidebar);\n    useEffect(() => {\n      if (\n        // closing sidebar\n        ((!appState.openSidebar &&\n          refPrevOpenSidebar?.current?.name === props.name) ||\n          // opening current sidebar\n          (appState.openSidebar?.name === props.name &&\n            refPrevOpenSidebar?.current?.name !== props.name) ||\n          // switching tabs or switching to a different sidebar\n          refPrevOpenSidebar.current?.name === props.name) &&\n        appState.openSidebar !== refPrevOpenSidebar.current\n      ) {\n        onStateChange?.(\n          appState.openSidebar?.name !== props.name\n            ? null\n            : appState.openSidebar,\n        );\n      }\n      refPrevOpenSidebar.current = appState.openSidebar;\n    }, [appState.openSidebar, onStateChange, props.name]);\n\n    const [mounted, setMounted] = useState(false);\n    useLayoutEffect(() => {\n      setMounted(true);\n      return () => setMounted(false);\n    }, []);\n\n    // We want to render in the next tick (hence `mounted` flag) so that it's\n    // guaranteed to happen after unmount of the previous sidebar (in case the\n    // previous sidebar is mounted after the next one). This is necessary to\n    // prevent flicker of subcomponents that support fallbacks\n    // (e.g. SidebarHeader). This is because we're using flags to determine\n    // whether prefer the fallback component or not (otherwise both will render\n    // initially), and the flag won't be reset in time if the unmount order\n    // it not correct.\n    //\n    // Alternative, and more general solution would be to namespace the fallback\n    // HoC so that state is not shared between subcomponents when the wrapping\n    // component is of the same type (e.g. Sidebar -> SidebarHeader).\n    const shouldRender = mounted && appState.openSidebar?.name === props.name;\n\n    if (!shouldRender) {\n      return null;\n    }\n\n    return <SidebarInner {...props} ref={ref} key={props.name} />;\n  }),\n  {\n    Header: SidebarHeader,\n    TabTriggers: SidebarTabTriggers,\n    TabTrigger: SidebarTabTrigger,\n    Tabs: SidebarTabs,\n    Tab: SidebarTab,\n    Trigger: SidebarTrigger,\n  },\n);\nSidebar.displayName = \"Sidebar\";\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}