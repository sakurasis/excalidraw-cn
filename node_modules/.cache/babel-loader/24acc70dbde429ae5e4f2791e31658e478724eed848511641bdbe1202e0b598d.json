{"ast":null,"code":"import { isTextElement, refreshTextDimensions } from \"../element\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { isBoundToContainer } from \"../element/typeChecks\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport { getFontString } from \"../utils\";\nexport class Fonts {\n  constructor(_ref) {\n    let {\n      scene,\n      onSceneUpdated\n    } = _ref;\n    this.scene = void 0;\n    this.onSceneUpdated = void 0;\n    /**\n     * if we load a (new) font, it's likely that text elements using it have\n     * already been rendered using a fallback font. Thus, we want invalidate\n     * their shapes and rerender. See #637.\n     *\n     * Invalidates text elements and rerenders scene, provided that at least one\n     * of the supplied fontFaces has not already been processed.\n     */\n    this.onFontsLoaded = fontFaces => {\n      if (\n      // bail if all fonts with have been processed. We're checking just a\n      // subset of the font properties (though it should be enough), so it\n      // can technically bail on a false positive.\n      fontFaces.every(fontFace => {\n        const sig = `${fontFace.family}-${fontFace.style}-${fontFace.weight}`;\n        if (Fonts.loadedFontFaces.has(sig)) {\n          return true;\n        }\n        Fonts.loadedFontFaces.add(sig);\n        return false;\n      })) {\n        return false;\n      }\n      let didUpdate = false;\n      this.scene.mapElements(element => {\n        if (isTextElement(element) && !isBoundToContainer(element)) {\n          invalidateShapeForElement(element);\n          didUpdate = true;\n          return newElementWith(element, {\n            ...refreshTextDimensions(element)\n          });\n        }\n        return element;\n      });\n      if (didUpdate) {\n        this.onSceneUpdated();\n      }\n    };\n    this.loadFontsForElements = async elements => {\n      const fontFaces = await Promise.all([...new Set(elements.filter(element => isTextElement(element)).map(element => element.fontFamily))].map(fontFamily => {\n        var _document$fonts, _document$fonts$check;\n        const fontString = getFontString({\n          fontFamily,\n          fontSize: 16\n        });\n        if (!((_document$fonts = document.fonts) !== null && _document$fonts !== void 0 && (_document$fonts$check = _document$fonts.check) !== null && _document$fonts$check !== void 0 && _document$fonts$check.call(_document$fonts, fontString))) {\n          var _document$fonts2, _document$fonts2$load;\n          return (_document$fonts2 = document.fonts) === null || _document$fonts2 === void 0 ? void 0 : (_document$fonts2$load = _document$fonts2.load) === null || _document$fonts2$load === void 0 ? void 0 : _document$fonts2$load.call(_document$fonts2, fontString);\n        }\n        return undefined;\n      }));\n      this.onFontsLoaded(fontFaces.flat().filter(Boolean));\n    };\n    this.scene = scene;\n    this.onSceneUpdated = onSceneUpdated;\n  }\n\n  // it's ok to track fonts across multiple instances only once, so let's use\n  // a static member to reduce memory footprint\n}\nFonts.loadedFontFaces = new Set();","map":{"version":3,"names":["isTextElement","refreshTextDimensions","newElementWith","isBoundToContainer","invalidateShapeForElement","getFontString","Fonts","constructor","_ref","scene","onSceneUpdated","onFontsLoaded","fontFaces","every","fontFace","sig","family","style","weight","loadedFontFaces","has","add","didUpdate","mapElements","element","loadFontsForElements","elements","Promise","all","Set","filter","map","fontFamily","_document$fonts","_document$fonts$check","fontString","fontSize","document","fonts","check","call","_document$fonts2","_document$fonts2$load","load","undefined","flat","Boolean"],"sources":["D:/project/excalidraw-cn/src/scene/Fonts.ts"],"sourcesContent":["import { isTextElement, refreshTextDimensions } from \"../element\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { isBoundToContainer } from \"../element/typeChecks\";\nimport { ExcalidrawElement, ExcalidrawTextElement } from \"../element/types\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport { getFontString } from \"../utils\";\nimport type Scene from \"./Scene\";\n\nexport class Fonts {\n  private scene: Scene;\n  private onSceneUpdated: () => void;\n\n  constructor({\n    scene,\n    onSceneUpdated,\n  }: {\n    scene: Scene;\n    onSceneUpdated: () => void;\n  }) {\n    this.scene = scene;\n    this.onSceneUpdated = onSceneUpdated;\n  }\n\n  // it's ok to track fonts across multiple instances only once, so let's use\n  // a static member to reduce memory footprint\n  private static loadedFontFaces = new Set<string>();\n\n  /**\n   * if we load a (new) font, it's likely that text elements using it have\n   * already been rendered using a fallback font. Thus, we want invalidate\n   * their shapes and rerender. See #637.\n   *\n   * Invalidates text elements and rerenders scene, provided that at least one\n   * of the supplied fontFaces has not already been processed.\n   */\n  public onFontsLoaded = (fontFaces: readonly FontFace[]) => {\n    if (\n      // bail if all fonts with have been processed. We're checking just a\n      // subset of the font properties (though it should be enough), so it\n      // can technically bail on a false positive.\n      fontFaces.every((fontFace) => {\n        const sig = `${fontFace.family}-${fontFace.style}-${fontFace.weight}`;\n        if (Fonts.loadedFontFaces.has(sig)) {\n          return true;\n        }\n        Fonts.loadedFontFaces.add(sig);\n        return false;\n      })\n    ) {\n      return false;\n    }\n\n    let didUpdate = false;\n\n    this.scene.mapElements((element) => {\n      if (isTextElement(element) && !isBoundToContainer(element)) {\n        invalidateShapeForElement(element);\n        didUpdate = true;\n        return newElementWith(element, {\n          ...refreshTextDimensions(element),\n        });\n      }\n      return element;\n    });\n\n    if (didUpdate) {\n      this.onSceneUpdated();\n    }\n  };\n\n  public loadFontsForElements = async (\n    elements: readonly ExcalidrawElement[],\n  ) => {\n    const fontFaces = await Promise.all(\n      [\n        ...new Set(\n          elements\n            .filter((element) => isTextElement(element))\n            .map((element) => (element as ExcalidrawTextElement).fontFamily),\n        ),\n      ].map((fontFamily) => {\n        const fontString = getFontString({\n          fontFamily,\n          fontSize: 16,\n        });\n        if (!document.fonts?.check?.(fontString)) {\n          return document.fonts?.load?.(fontString);\n        }\n        return undefined;\n      }),\n    );\n    this.onFontsLoaded(fontFaces.flat().filter(Boolean) as FontFace[]);\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}