{"ast":null,"code":"export const getSizeFromPoints = points => {\n  const xs = points.map(point => point[0]);\n  const ys = points.map(point => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys)\n  };\n};\n\n/** @arg dimension, 0 for rescaling only x, 1 for y */\nexport const rescalePoints = (dimension, newSize, points, normalize) => {\n  const coordinates = points.map(point => point[dimension]);\n  const maxCoordinate = Math.max(...coordinates);\n  const minCoordinate = Math.min(...coordinates);\n  const size = maxCoordinate - minCoordinate;\n  const scale = size === 0 ? 1 : newSize / size;\n  let nextMinCoordinate = Infinity;\n  const scaledPoints = points.map(point => {\n    const newCoordinate = point[dimension] * scale;\n    const newPoint = [...point];\n    newPoint[dimension] = newCoordinate;\n    if (newCoordinate < nextMinCoordinate) {\n      nextMinCoordinate = newCoordinate;\n    }\n    return newPoint;\n  });\n  if (!normalize) {\n    return scaledPoints;\n  }\n  if (scaledPoints.length === 2) {\n    // we don't translate two-point lines\n    return scaledPoints;\n  }\n  const translation = minCoordinate - nextMinCoordinate;\n  const nextPoints = scaledPoints.map(scaledPoint => scaledPoint.map((value, currentDimension) => {\n    return currentDimension === dimension ? value + translation : value;\n  }));\n  return nextPoints;\n};","map":{"version":3,"names":["getSizeFromPoints","points","xs","map","point","ys","width","Math","max","min","height","rescalePoints","dimension","newSize","normalize","coordinates","maxCoordinate","minCoordinate","size","scale","nextMinCoordinate","Infinity","scaledPoints","newCoordinate","newPoint","length","translation","nextPoints","scaledPoint","value","currentDimension"],"sources":["D:/project/excalidraw-cn/src/points.ts"],"sourcesContent":["import { Point } from \"./types\";\n\nexport const getSizeFromPoints = (points: readonly Point[]) => {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys),\n  };\n};\n\n/** @arg dimension, 0 for rescaling only x, 1 for y */\nexport const rescalePoints = (\n  dimension: 0 | 1,\n  newSize: number,\n  points: readonly Point[],\n  normalize: boolean,\n): Point[] => {\n  const coordinates = points.map((point) => point[dimension]);\n  const maxCoordinate = Math.max(...coordinates);\n  const minCoordinate = Math.min(...coordinates);\n  const size = maxCoordinate - minCoordinate;\n  const scale = size === 0 ? 1 : newSize / size;\n\n  let nextMinCoordinate = Infinity;\n\n  const scaledPoints = points.map((point): Point => {\n    const newCoordinate = point[dimension] * scale;\n    const newPoint = [...point];\n    newPoint[dimension] = newCoordinate;\n    if (newCoordinate < nextMinCoordinate) {\n      nextMinCoordinate = newCoordinate;\n    }\n    return newPoint as unknown as Point;\n  });\n\n  if (!normalize) {\n    return scaledPoints;\n  }\n\n  if (scaledPoints.length === 2) {\n    // we don't translate two-point lines\n    return scaledPoints;\n  }\n\n  const translation = minCoordinate - nextMinCoordinate;\n\n  const nextPoints = scaledPoints.map(\n    (scaledPoint) =>\n      scaledPoint.map((value, currentDimension) => {\n        return currentDimension === dimension ? value + translation : value;\n      }) as [number, number],\n  );\n  return nextPoints;\n};\n"],"mappings":"AAEA,OAAO,MAAMA,iBAAiB,GAAIC,MAAwB,IAAK;EAC7D,MAAMC,EAAE,GAAGD,MAAM,CAACE,GAAG,CAAEC,KAAK,IAAKA,KAAK,CAAC,CAAC,CAAC,CAAC;EAC1C,MAAMC,EAAE,GAAGJ,MAAM,CAACE,GAAG,CAAEC,KAAK,IAAKA,KAAK,CAAC,CAAC,CAAC,CAAC;EAC1C,OAAO;IACLE,KAAK,EAAEC,IAAI,CAACC,GAAG,CAAC,GAAGN,EAAE,CAAC,GAAGK,IAAI,CAACE,GAAG,CAAC,GAAGP,EAAE,CAAC;IACxCQ,MAAM,EAAEH,IAAI,CAACC,GAAG,CAAC,GAAGH,EAAE,CAAC,GAAGE,IAAI,CAACE,GAAG,CAAC,GAAGJ,EAAE;EAC1C,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMM,aAAa,GAAGA,CAC3BC,SAAgB,EAChBC,OAAe,EACfZ,MAAwB,EACxBa,SAAkB,KACN;EACZ,MAAMC,WAAW,GAAGd,MAAM,CAACE,GAAG,CAAEC,KAAK,IAAKA,KAAK,CAACQ,SAAS,CAAC,CAAC;EAC3D,MAAMI,aAAa,GAAGT,IAAI,CAACC,GAAG,CAAC,GAAGO,WAAW,CAAC;EAC9C,MAAME,aAAa,GAAGV,IAAI,CAACE,GAAG,CAAC,GAAGM,WAAW,CAAC;EAC9C,MAAMG,IAAI,GAAGF,aAAa,GAAGC,aAAa;EAC1C,MAAME,KAAK,GAAGD,IAAI,KAAK,CAAC,GAAG,CAAC,GAAGL,OAAO,GAAGK,IAAI;EAE7C,IAAIE,iBAAiB,GAAGC,QAAQ;EAEhC,MAAMC,YAAY,GAAGrB,MAAM,CAACE,GAAG,CAAEC,KAAK,IAAY;IAChD,MAAMmB,aAAa,GAAGnB,KAAK,CAACQ,SAAS,CAAC,GAAGO,KAAK;IAC9C,MAAMK,QAAQ,GAAG,CAAC,GAAGpB,KAAK,CAAC;IAC3BoB,QAAQ,CAACZ,SAAS,CAAC,GAAGW,aAAa;IACnC,IAAIA,aAAa,GAAGH,iBAAiB,EAAE;MACrCA,iBAAiB,GAAGG,aAAa;IACnC;IACA,OAAOC,QAAQ;EACjB,CAAC,CAAC;EAEF,IAAI,CAACV,SAAS,EAAE;IACd,OAAOQ,YAAY;EACrB;EAEA,IAAIA,YAAY,CAACG,MAAM,KAAK,CAAC,EAAE;IAC7B;IACA,OAAOH,YAAY;EACrB;EAEA,MAAMI,WAAW,GAAGT,aAAa,GAAGG,iBAAiB;EAErD,MAAMO,UAAU,GAAGL,YAAY,CAACnB,GAAG,CAChCyB,WAAW,IACVA,WAAW,CAACzB,GAAG,CAAC,CAAC0B,KAAK,EAAEC,gBAAgB,KAAK;IAC3C,OAAOA,gBAAgB,KAAKlB,SAAS,GAAGiB,KAAK,GAAGH,WAAW,GAAGG,KAAK;EACrE,CAAC,CAAqB,CACzB;EACD,OAAOF,UAAU;AACnB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}