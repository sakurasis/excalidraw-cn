{"ast":null,"code":"import _createForOfIteratorHelper from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import _toConsumableArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import{bumpVersion}from\"./element/mutateElement\";import{isFrameElement}from\"./element/typeChecks\";import{groupByFrames}from\"./frame\";import{getElementsInGroup}from\"./groups\";import{getSelectedElements}from\"./scene\";import Scene from\"./scene/Scene\";import{arrayToMap,findIndex,findLastIndex}from\"./utils\";// elements that do not belong to a frame are considered a root element\nvar isRootElement=function isRootElement(element){return!element.frameId;};/**\n * Returns indices of elements to move based on selected elements.\n * Includes contiguous deleted elements that are between two selected elements,\n *  e.g.: [0 (selected), 1 (deleted), 2 (deleted), 3 (selected)]\n *\n * Specified elements (elementsToBeMoved) take precedence over\n * appState.selectedElementsIds\n */var getIndicesToMove=function getIndicesToMove(elements,appState,elementsToBeMoved){var selectedIndices=[];var deletedIndices=[];var includeDeletedIndex=null;var index=-1;var selectedElementIds=arrayToMap(elementsToBeMoved?elementsToBeMoved:getSelectedElements(elements,appState,{includeBoundTextElement:true}));while(++index<elements.length){var element=elements[index];if(selectedElementIds.get(element.id)){if(deletedIndices.length){selectedIndices=selectedIndices.concat(deletedIndices);deletedIndices=[];}selectedIndices.push(index);includeDeletedIndex=index+1;}else if(element.isDeleted&&includeDeletedIndex===index){includeDeletedIndex=index+1;deletedIndices.push(index);}else{deletedIndices=[];}}return selectedIndices;};var toContiguousGroups=function toContiguousGroups(array){var cursor=0;return array.reduce(function(acc,value,index){if(index>0&&array[index-1]!==value-1){cursor=++cursor;}(acc[cursor]||(acc[cursor]=[])).push(value);return acc;},[]);};/**\n * @returns index of target element, consindering tightly-bound elements\n * (currently non-linear elements bound to a container) as a one unit.\n * If no binding present, returns `undefined`.\n */var getTargetIndexAccountingForBinding=function getTargetIndexAccountingForBinding(nextElement,elements,direction){if(\"containerId\"in nextElement&&nextElement.containerId){if(direction===\"left\"){var containerElement=Scene.getScene(nextElement).getElement(nextElement.containerId);if(containerElement){return elements.indexOf(containerElement);}}else{return elements.indexOf(nextElement);}}else{var _nextElement$boundEle,_nextElement$boundEle2;var boundElementId=(_nextElement$boundEle=nextElement.boundElements)===null||_nextElement$boundEle===void 0?void 0:(_nextElement$boundEle2=_nextElement$boundEle.find(function(binding){return binding.type!==\"arrow\";}))===null||_nextElement$boundEle2===void 0?void 0:_nextElement$boundEle2.id;if(boundElementId){if(direction===\"left\"){return elements.indexOf(nextElement);}var boundTextElement=Scene.getScene(nextElement).getElement(boundElementId);if(boundTextElement){return elements.indexOf(boundTextElement);}}}};/**\n * Returns next candidate index that's available to be moved to. Currently that\n *  is a non-deleted element, and not inside a group (unless we're editing it).\n */var getTargetIndex=function getTargetIndex(appState,elements,boundaryIndex,direction){var sourceElement=elements[boundaryIndex];var indexFilter=function indexFilter(element){if(element.isDeleted){return false;}// if we're editing group, find closest sibling irrespective of whether\n// there's a different-group element between them (for legacy reasons)\nif(appState.editingGroupId){return element.groupIds.includes(appState.editingGroupId);}return true;};var candidateIndex=direction===\"left\"?findLastIndex(elements,indexFilter,Math.max(0,boundaryIndex-1)):findIndex(elements,indexFilter,boundaryIndex+1);var nextElement=elements[candidateIndex];if(!nextElement){return-1;}if(appState.editingGroupId){if(// candidate element is a sibling in current editing group → return\n(sourceElement===null||sourceElement===void 0?void 0:sourceElement.groupIds.join(\"\"))===(nextElement===null||nextElement===void 0?void 0:nextElement.groupIds.join(\"\"))){var _getTargetIndexAccoun;return(_getTargetIndexAccoun=getTargetIndexAccountingForBinding(nextElement,elements,direction))!==null&&_getTargetIndexAccoun!==void 0?_getTargetIndexAccoun:candidateIndex;}else if(!(nextElement!==null&&nextElement!==void 0&&nextElement.groupIds.includes(appState.editingGroupId))){// candidate element is outside current editing group → prevent\nreturn-1;}}if(!nextElement.groupIds.length){var _getTargetIndexAccoun2;return(_getTargetIndexAccoun2=getTargetIndexAccountingForBinding(nextElement,elements,direction))!==null&&_getTargetIndexAccoun2!==void 0?_getTargetIndexAccoun2:candidateIndex;}var siblingGroupId=appState.editingGroupId?nextElement.groupIds[nextElement.groupIds.indexOf(appState.editingGroupId)-1]:nextElement.groupIds[nextElement.groupIds.length-1];var elementsInSiblingGroup=getElementsInGroup(elements,siblingGroupId);if(elementsInSiblingGroup.length){// assumes getElementsInGroup() returned elements are sorted\n// by zIndex (ascending)\nreturn direction===\"left\"?elements.indexOf(elementsInSiblingGroup[0]):elements.indexOf(elementsInSiblingGroup[elementsInSiblingGroup.length-1]);}return candidateIndex;};var getTargetElementsMap=function getTargetElementsMap(elements,indices){return indices.reduce(function(acc,index){var element=elements[index];acc[element.id]=element;return acc;},{});};var _shiftElements=function _shiftElements(elements,appState,direction,elementsToBeMoved){var indicesToMove=getIndicesToMove(elements,appState,elementsToBeMoved);var targetElementsMap=getTargetElementsMap(elements,indicesToMove);var groupedIndices=toContiguousGroups(indicesToMove);if(direction===\"right\"){groupedIndices=groupedIndices.reverse();}groupedIndices.forEach(function(indices,i){var leadingIndex=indices[0];var trailingIndex=indices[indices.length-1];var boundaryIndex=direction===\"left\"?leadingIndex:trailingIndex;var targetIndex=getTargetIndex(appState,elements,boundaryIndex,direction);if(targetIndex===-1||boundaryIndex===targetIndex){return;}var leadingElements=direction===\"left\"?elements.slice(0,targetIndex):elements.slice(0,leadingIndex);var targetElements=elements.slice(leadingIndex,trailingIndex+1);var displacedElements=direction===\"left\"?elements.slice(targetIndex,leadingIndex):elements.slice(trailingIndex+1,targetIndex+1);var trailingElements=direction===\"left\"?elements.slice(trailingIndex+1):elements.slice(targetIndex+1);elements=direction===\"left\"?[].concat(_toConsumableArray(leadingElements),_toConsumableArray(targetElements),_toConsumableArray(displacedElements),_toConsumableArray(trailingElements)):[].concat(_toConsumableArray(leadingElements),_toConsumableArray(displacedElements),_toConsumableArray(targetElements),_toConsumableArray(trailingElements));});return elements.map(function(element){if(targetElementsMap[element.id]){return bumpVersion(element);}return element;});};var shiftElements=function shiftElements(appState,elements,direction,elementsToBeMoved){return shift(elements,appState,direction,_shiftElements,elementsToBeMoved);};var _shiftElementsToEnd=function _shiftElementsToEnd(elements,appState,direction){var indicesToMove=getIndicesToMove(elements,appState);var targetElementsMap=getTargetElementsMap(elements,indicesToMove);var displacedElements=[];var leadingIndex;var trailingIndex;if(direction===\"left\"){if(appState.editingGroupId){var groupElements=getElementsInGroup(elements,appState.editingGroupId);if(!groupElements.length){return elements;}leadingIndex=elements.indexOf(groupElements[0]);}else{leadingIndex=0;}trailingIndex=indicesToMove[indicesToMove.length-1];}else{if(appState.editingGroupId){var _groupElements=getElementsInGroup(elements,appState.editingGroupId);if(!_groupElements.length){return elements;}trailingIndex=elements.indexOf(_groupElements[_groupElements.length-1]);}else{trailingIndex=elements.length-1;}leadingIndex=indicesToMove[0];}for(var index=leadingIndex;index<trailingIndex+1;index++){if(!indicesToMove.includes(index)){displacedElements.push(elements[index]);}}var targetElements=Object.values(targetElementsMap).map(function(element){return bumpVersion(element);});var leadingElements=elements.slice(0,leadingIndex);var trailingElements=elements.slice(trailingIndex+1);return direction===\"left\"?[].concat(_toConsumableArray(leadingElements),_toConsumableArray(targetElements),displacedElements,_toConsumableArray(trailingElements)):[].concat(_toConsumableArray(leadingElements),displacedElements,_toConsumableArray(targetElements),_toConsumableArray(trailingElements));};var shiftElementsToEnd=function shiftElementsToEnd(elements,appState,direction,elementsToBeMoved){return shift(elements,appState,direction,_shiftElementsToEnd,elementsToBeMoved);};function shift(elements,appState,direction,shiftFunction,elementsToBeMoved){var elementsMap=arrayToMap(elements);var frameElementsMap=groupByFrames(elements);// in case root is non-existent, we promote children elements to root\nvar rootElements=elements.filter(function(element){return isRootElement(element)||element.frameId&&!elementsMap.has(element.frameId);});// and remove non-existet root\nvar _iterator=_createForOfIteratorHelper(frameElementsMap.keys()),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var frameId=_step.value;if(!elementsMap.has(frameId)){frameElementsMap.delete(frameId);}}// shift the root elements first\n}catch(err){_iterator.e(err);}finally{_iterator.f();}rootElements=shiftFunction(rootElements,appState,direction,elementsToBeMoved);// shift the elements in frames if needed\nframeElementsMap.forEach(function(frameElements,frameId){if(!appState.selectedElementIds[frameId]){frameElementsMap.set(frameId,shiftFunction(frameElements,appState,direction,elementsToBeMoved));}});// return the final elements\nvar finalElements=[];rootElements.forEach(function(element){if(isFrameElement(element)){var _frameElementsMap$get;finalElements=[].concat(_toConsumableArray(finalElements),_toConsumableArray((_frameElementsMap$get=frameElementsMap.get(element.id))!==null&&_frameElementsMap$get!==void 0?_frameElementsMap$get:[]),[element]);}else{finalElements=[].concat(_toConsumableArray(finalElements),[element]);}});return finalElements;}// public API\n// -----------------------------------------------------------------------------\nexport var moveOneLeft=function moveOneLeft(elements,appState,elementsToBeMoved){return shiftElements(appState,elements,\"left\",elementsToBeMoved);};export var moveOneRight=function moveOneRight(elements,appState,elementsToBeMoved){return shiftElements(appState,elements,\"right\",elementsToBeMoved);};export var moveAllLeft=function moveAllLeft(elements,appState,elementsToBeMoved){return shiftElementsToEnd(elements,appState,\"left\",elementsToBeMoved);};export var moveAllRight=function moveAllRight(elements,appState,elementsToBeMoved){return shiftElementsToEnd(elements,appState,\"right\",elementsToBeMoved);};","map":{"version":3,"names":["bumpVersion","isFrameElement","groupByFrames","getElementsInGroup","getSelectedElements","Scene","arrayToMap","findIndex","findLastIndex","isRootElement","element","frameId","getIndicesToMove","elements","appState","elementsToBeMoved","selectedIndices","deletedIndices","includeDeletedIndex","index","selectedElementIds","includeBoundTextElement","length","get","id","concat","push","isDeleted","toContiguousGroups","array","cursor","reduce","acc","value","getTargetIndexAccountingForBinding","nextElement","direction","containerId","containerElement","getScene","getElement","indexOf","_nextElement$boundEle","_nextElement$boundEle2","boundElementId","boundElements","find","binding","type","boundTextElement","getTargetIndex","boundaryIndex","sourceElement","indexFilter","editingGroupId","groupIds","includes","candidateIndex","Math","max","join","_getTargetIndexAccoun","_getTargetIndexAccoun2","siblingGroupId","elementsInSiblingGroup","getTargetElementsMap","indices","_shiftElements","indicesToMove","targetElementsMap","groupedIndices","reverse","forEach","i","leadingIndex","trailingIndex","targetIndex","leadingElements","slice","targetElements","displacedElements","trailingElements","_toConsumableArray","map","shiftElements","shift","_shiftElementsToEnd","groupElements","Object","values","shiftElementsToEnd","shiftFunction","elementsMap","frameElementsMap","rootElements","filter","has","_iterator","_createForOfIteratorHelper","keys","_step","s","n","done","delete","err","e","f","frameElements","set","finalElements","_frameElementsMap$get","moveOneLeft","moveOneRight","moveAllLeft","moveAllRight"],"sources":["D:/project/excalidraw-cn/src/zindex.ts"],"sourcesContent":["import { bumpVersion } from \"./element/mutateElement\";\nimport { isFrameElement } from \"./element/typeChecks\";\nimport { ExcalidrawElement } from \"./element/types\";\nimport { groupByFrames } from \"./frame\";\nimport { getElementsInGroup } from \"./groups\";\nimport { getSelectedElements } from \"./scene\";\nimport Scene from \"./scene/Scene\";\nimport { AppState } from \"./types\";\nimport { arrayToMap, findIndex, findLastIndex } from \"./utils\";\n\n// elements that do not belong to a frame are considered a root element\nconst isRootElement = (element: ExcalidrawElement) => {\n  return !element.frameId;\n};\n\n/**\n * Returns indices of elements to move based on selected elements.\n * Includes contiguous deleted elements that are between two selected elements,\n *  e.g.: [0 (selected), 1 (deleted), 2 (deleted), 3 (selected)]\n *\n * Specified elements (elementsToBeMoved) take precedence over\n * appState.selectedElementsIds\n */\nconst getIndicesToMove = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  let selectedIndices: number[] = [];\n  let deletedIndices: number[] = [];\n  let includeDeletedIndex = null;\n  let index = -1;\n  const selectedElementIds = arrayToMap(\n    elementsToBeMoved\n      ? elementsToBeMoved\n      : getSelectedElements(elements, appState, {\n          includeBoundTextElement: true,\n        }),\n  );\n  while (++index < elements.length) {\n    const element = elements[index];\n    if (selectedElementIds.get(element.id)) {\n      if (deletedIndices.length) {\n        selectedIndices = selectedIndices.concat(deletedIndices);\n        deletedIndices = [];\n      }\n      selectedIndices.push(index);\n      includeDeletedIndex = index + 1;\n    } else if (element.isDeleted && includeDeletedIndex === index) {\n      includeDeletedIndex = index + 1;\n      deletedIndices.push(index);\n    } else {\n      deletedIndices = [];\n    }\n  }\n  return selectedIndices;\n};\n\nconst toContiguousGroups = (array: number[]) => {\n  let cursor = 0;\n  return array.reduce((acc, value, index) => {\n    if (index > 0 && array[index - 1] !== value - 1) {\n      cursor = ++cursor;\n    }\n    (acc[cursor] || (acc[cursor] = [])).push(value);\n    return acc;\n  }, [] as number[][]);\n};\n\n/**\n * @returns index of target element, consindering tightly-bound elements\n * (currently non-linear elements bound to a container) as a one unit.\n * If no binding present, returns `undefined`.\n */\nconst getTargetIndexAccountingForBinding = (\n  nextElement: ExcalidrawElement,\n  elements: readonly ExcalidrawElement[],\n  direction: \"left\" | \"right\",\n) => {\n  if (\"containerId\" in nextElement && nextElement.containerId) {\n    if (direction === \"left\") {\n      const containerElement = Scene.getScene(nextElement)!.getElement(\n        nextElement.containerId,\n      );\n      if (containerElement) {\n        return elements.indexOf(containerElement);\n      }\n    } else {\n      return elements.indexOf(nextElement);\n    }\n  } else {\n    const boundElementId = nextElement.boundElements?.find(\n      (binding) => binding.type !== \"arrow\",\n    )?.id;\n    if (boundElementId) {\n      if (direction === \"left\") {\n        return elements.indexOf(nextElement);\n      }\n      const boundTextElement =\n        Scene.getScene(nextElement)!.getElement(boundElementId);\n\n      if (boundTextElement) {\n        return elements.indexOf(boundTextElement);\n      }\n    }\n  }\n};\n\n/**\n * Returns next candidate index that's available to be moved to. Currently that\n *  is a non-deleted element, and not inside a group (unless we're editing it).\n */\nconst getTargetIndex = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n  boundaryIndex: number,\n  direction: \"left\" | \"right\",\n) => {\n  const sourceElement = elements[boundaryIndex];\n\n  const indexFilter = (element: ExcalidrawElement) => {\n    if (element.isDeleted) {\n      return false;\n    }\n    // if we're editing group, find closest sibling irrespective of whether\n    // there's a different-group element between them (for legacy reasons)\n    if (appState.editingGroupId) {\n      return element.groupIds.includes(appState.editingGroupId);\n    }\n    return true;\n  };\n\n  const candidateIndex =\n    direction === \"left\"\n      ? findLastIndex(elements, indexFilter, Math.max(0, boundaryIndex - 1))\n      : findIndex(elements, indexFilter, boundaryIndex + 1);\n\n  const nextElement = elements[candidateIndex];\n\n  if (!nextElement) {\n    return -1;\n  }\n\n  if (appState.editingGroupId) {\n    if (\n      // candidate element is a sibling in current editing group → return\n      sourceElement?.groupIds.join(\"\") === nextElement?.groupIds.join(\"\")\n    ) {\n      return (\n        getTargetIndexAccountingForBinding(nextElement, elements, direction) ??\n        candidateIndex\n      );\n    } else if (!nextElement?.groupIds.includes(appState.editingGroupId)) {\n      // candidate element is outside current editing group → prevent\n      return -1;\n    }\n  }\n\n  if (!nextElement.groupIds.length) {\n    return (\n      getTargetIndexAccountingForBinding(nextElement, elements, direction) ??\n      candidateIndex\n    );\n  }\n\n  const siblingGroupId = appState.editingGroupId\n    ? nextElement.groupIds[\n        nextElement.groupIds.indexOf(appState.editingGroupId) - 1\n      ]\n    : nextElement.groupIds[nextElement.groupIds.length - 1];\n\n  const elementsInSiblingGroup = getElementsInGroup(elements, siblingGroupId);\n\n  if (elementsInSiblingGroup.length) {\n    // assumes getElementsInGroup() returned elements are sorted\n    // by zIndex (ascending)\n    return direction === \"left\"\n      ? elements.indexOf(elementsInSiblingGroup[0])\n      : elements.indexOf(\n          elementsInSiblingGroup[elementsInSiblingGroup.length - 1],\n        );\n  }\n\n  return candidateIndex;\n};\n\nconst getTargetElementsMap = <T extends ExcalidrawElement>(\n  elements: readonly T[],\n  indices: number[],\n) => {\n  return indices.reduce((acc, index) => {\n    const element = elements[index];\n    acc[element.id] = element;\n    return acc;\n  }, {} as Record<string, ExcalidrawElement>);\n};\n\nconst _shiftElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState, elementsToBeMoved);\n  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);\n  let groupedIndices = toContiguousGroups(indicesToMove);\n\n  if (direction === \"right\") {\n    groupedIndices = groupedIndices.reverse();\n  }\n\n  groupedIndices.forEach((indices, i) => {\n    const leadingIndex = indices[0];\n    const trailingIndex = indices[indices.length - 1];\n    const boundaryIndex = direction === \"left\" ? leadingIndex : trailingIndex;\n\n    const targetIndex = getTargetIndex(\n      appState,\n      elements,\n      boundaryIndex,\n      direction,\n    );\n\n    if (targetIndex === -1 || boundaryIndex === targetIndex) {\n      return;\n    }\n\n    const leadingElements =\n      direction === \"left\"\n        ? elements.slice(0, targetIndex)\n        : elements.slice(0, leadingIndex);\n    const targetElements = elements.slice(leadingIndex, trailingIndex + 1);\n    const displacedElements =\n      direction === \"left\"\n        ? elements.slice(targetIndex, leadingIndex)\n        : elements.slice(trailingIndex + 1, targetIndex + 1);\n    const trailingElements =\n      direction === \"left\"\n        ? elements.slice(trailingIndex + 1)\n        : elements.slice(targetIndex + 1);\n\n    elements =\n      direction === \"left\"\n        ? [\n            ...leadingElements,\n            ...targetElements,\n            ...displacedElements,\n            ...trailingElements,\n          ]\n        : [\n            ...leadingElements,\n            ...displacedElements,\n            ...targetElements,\n            ...trailingElements,\n          ];\n  });\n\n  return elements.map((element) => {\n    if (targetElementsMap[element.id]) {\n      return bumpVersion(element);\n    }\n    return element;\n  });\n};\n\nconst shiftElements = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n  direction: \"left\" | \"right\",\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  return shift(\n    elements,\n    appState,\n    direction,\n    _shiftElements,\n    elementsToBeMoved,\n  );\n};\n\nconst _shiftElementsToEnd = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);\n  const displacedElements: ExcalidrawElement[] = [];\n\n  let leadingIndex: number;\n  let trailingIndex: number;\n  if (direction === \"left\") {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      leadingIndex = elements.indexOf(groupElements[0]);\n    } else {\n      leadingIndex = 0;\n    }\n\n    trailingIndex = indicesToMove[indicesToMove.length - 1];\n  } else {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      trailingIndex = elements.indexOf(groupElements[groupElements.length - 1]);\n    } else {\n      trailingIndex = elements.length - 1;\n    }\n\n    leadingIndex = indicesToMove[0];\n  }\n\n  for (let index = leadingIndex; index < trailingIndex + 1; index++) {\n    if (!indicesToMove.includes(index)) {\n      displacedElements.push(elements[index]);\n    }\n  }\n\n  const targetElements = Object.values(targetElementsMap).map((element) => {\n    return bumpVersion(element);\n  });\n\n  const leadingElements = elements.slice(0, leadingIndex);\n  const trailingElements = elements.slice(trailingIndex + 1);\n\n  return direction === \"left\"\n    ? [\n        ...leadingElements,\n        ...targetElements,\n        ...displacedElements,\n        ...trailingElements,\n      ]\n    : [\n        ...leadingElements,\n        ...displacedElements,\n        ...targetElements,\n        ...trailingElements,\n      ];\n};\n\nconst shiftElementsToEnd = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  return shift(\n    elements,\n    appState,\n    direction,\n    _shiftElementsToEnd,\n    elementsToBeMoved,\n  );\n};\n\nfunction shift(\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n  shiftFunction: (\n    elements: ExcalidrawElement[],\n    appState: AppState,\n    direction: \"left\" | \"right\",\n    elementsToBeMoved?: readonly ExcalidrawElement[],\n  ) => ExcalidrawElement[] | readonly ExcalidrawElement[],\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) {\n  const elementsMap = arrayToMap(elements);\n  const frameElementsMap = groupByFrames(elements);\n\n  // in case root is non-existent, we promote children elements to root\n  let rootElements = elements.filter(\n    (element) =>\n      isRootElement(element) ||\n      (element.frameId && !elementsMap.has(element.frameId)),\n  );\n  // and remove non-existet root\n  for (const frameId of frameElementsMap.keys()) {\n    if (!elementsMap.has(frameId)) {\n      frameElementsMap.delete(frameId);\n    }\n  }\n\n  // shift the root elements first\n  rootElements = shiftFunction(\n    rootElements,\n    appState,\n    direction,\n    elementsToBeMoved,\n  ) as ExcalidrawElement[];\n\n  // shift the elements in frames if needed\n  frameElementsMap.forEach((frameElements, frameId) => {\n    if (!appState.selectedElementIds[frameId]) {\n      frameElementsMap.set(\n        frameId,\n        shiftFunction(\n          frameElements,\n          appState,\n          direction,\n          elementsToBeMoved,\n        ) as ExcalidrawElement[],\n      );\n    }\n  });\n\n  // return the final elements\n  let finalElements: ExcalidrawElement[] = [];\n\n  rootElements.forEach((element) => {\n    if (isFrameElement(element)) {\n      finalElements = [\n        ...finalElements,\n        ...(frameElementsMap.get(element.id) ?? []),\n        element,\n      ];\n    } else {\n      finalElements = [...finalElements, element];\n    }\n  });\n\n  return finalElements;\n}\n\n// public API\n// -----------------------------------------------------------------------------\n\nexport const moveOneLeft = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  return shiftElements(appState, elements, \"left\", elementsToBeMoved);\n};\n\nexport const moveOneRight = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  return shiftElements(appState, elements, \"right\", elementsToBeMoved);\n};\n\nexport const moveAllLeft = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  return shiftElementsToEnd(elements, appState, \"left\", elementsToBeMoved);\n};\n\nexport const moveAllRight = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  return shiftElementsToEnd(elements, appState, \"right\", elementsToBeMoved);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}