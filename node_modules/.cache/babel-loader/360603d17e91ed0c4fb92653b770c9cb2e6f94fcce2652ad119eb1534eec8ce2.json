{"ast":null,"code":"import { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport Scene from \"../scene/Scene\";\nimport { getSizeFromPoints } from \"../points\";\nimport { randomInteger } from \"../random\";\nimport { getUpdatedTimestamp } from \"../utils\";\n// This function tracks updates of text elements for the purposes for collaboration.\n// The version is used to compare updates when more than one user is working in\n// the same drawing. Note: this will trigger the component to update. Make sure you\n// are calling it either from a React event handler or within unstable_batchedUpdates().\nexport const mutateElement = function (element, updates) {\n  let informMutation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let didChange = false;\n\n  // casting to any because can't use `in` operator\n  // (see https://github.com/microsoft/TypeScript/issues/21732)\n  const {\n    points,\n    fileId\n  } = updates;\n  if (typeof points !== \"undefined\") {\n    updates = {\n      ...getSizeFromPoints(points),\n      ...updates\n    };\n  }\n  for (const key in updates) {\n    const value = updates[key];\n    if (typeof value !== \"undefined\") {\n      if (element[key] === value && (\n      // if object, always update because its attrs could have changed\n      // (except for specific keys we handle below)\n      typeof value !== \"object\" || value === null || key === \"groupIds\" || key === \"scale\")) {\n        continue;\n      }\n      if (key === \"scale\") {\n        const prevScale = element[key];\n        const nextScale = value;\n        if (prevScale[0] === nextScale[0] && prevScale[1] === nextScale[1]) {\n          continue;\n        }\n      } else if (key === \"points\") {\n        const prevPoints = element[key];\n        const nextPoints = value;\n        if (prevPoints.length === nextPoints.length) {\n          let didChangePoints = false;\n          let index = prevPoints.length;\n          while (--index) {\n            const prevPoint = prevPoints[index];\n            const nextPoint = nextPoints[index];\n            if (prevPoint[0] !== nextPoint[0] || prevPoint[1] !== nextPoint[1]) {\n              didChangePoints = true;\n              break;\n            }\n          }\n          if (!didChangePoints) {\n            continue;\n          }\n        }\n      }\n      element[key] = value;\n      didChange = true;\n    }\n  }\n  if (!didChange) {\n    return element;\n  }\n  if (typeof updates.height !== \"undefined\" || typeof updates.width !== \"undefined\" || typeof fileId != \"undefined\" || typeof points !== \"undefined\") {\n    invalidateShapeForElement(element);\n  }\n  element.version++;\n  element.versionNonce = randomInteger();\n  element.updated = getUpdatedTimestamp();\n  if (informMutation) {\n    var _Scene$getScene;\n    (_Scene$getScene = Scene.getScene(element)) === null || _Scene$getScene === void 0 ? void 0 : _Scene$getScene.informMutation();\n  }\n  return element;\n};\nexport const newElementWith = (element, updates) => {\n  let didChange = false;\n  for (const key in updates) {\n    const value = updates[key];\n    if (typeof value !== \"undefined\") {\n      if (element[key] === value && (\n      // if object, always update because its attrs could have changed\n      typeof value !== \"object\" || value === null)) {\n        continue;\n      }\n      didChange = true;\n    }\n  }\n  if (!didChange) {\n    return element;\n  }\n  return {\n    ...element,\n    ...updates,\n    updated: getUpdatedTimestamp(),\n    version: element.version + 1,\n    versionNonce: randomInteger()\n  };\n};\n\n/**\n * Mutates element, bumping `version`, `versionNonce`, and `updated`.\n *\n * NOTE: does not trigger re-render.\n */\nexport const bumpVersion = (element, version) => {\n  element.version = (version !== null && version !== void 0 ? version : element.version) + 1;\n  element.versionNonce = randomInteger();\n  element.updated = getUpdatedTimestamp();\n  return element;\n};","map":{"version":3,"names":["invalidateShapeForElement","Scene","getSizeFromPoints","randomInteger","getUpdatedTimestamp","mutateElement","element","updates","informMutation","arguments","length","undefined","didChange","points","fileId","key","value","prevScale","nextScale","prevPoints","nextPoints","didChangePoints","index","prevPoint","nextPoint","height","width","version","versionNonce","updated","_Scene$getScene","getScene","newElementWith","bumpVersion"],"sources":["D:/project/excalidraw-cn/src/element/mutateElement.ts"],"sourcesContent":["import { ExcalidrawElement } from \"./types\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport Scene from \"../scene/Scene\";\nimport { getSizeFromPoints } from \"../points\";\nimport { randomInteger } from \"../random\";\nimport { Point } from \"../types\";\nimport { getUpdatedTimestamp } from \"../utils\";\nimport { Mutable } from \"../utility-types\";\n\ntype ElementUpdate<TElement extends ExcalidrawElement> = Omit<\n  Partial<TElement>,\n  \"id\" | \"version\" | \"versionNonce\"\n>;\n\n// This function tracks updates of text elements for the purposes for collaboration.\n// The version is used to compare updates when more than one user is working in\n// the same drawing. Note: this will trigger the component to update. Make sure you\n// are calling it either from a React event handler or within unstable_batchedUpdates().\nexport const mutateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n  informMutation = true,\n): TElement => {\n  let didChange = false;\n\n  // casting to any because can't use `in` operator\n  // (see https://github.com/microsoft/TypeScript/issues/21732)\n  const { points, fileId } = updates as any;\n\n  if (typeof points !== \"undefined\") {\n    updates = { ...getSizeFromPoints(points), ...updates };\n  }\n\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update because its attrs could have changed\n        // (except for specific keys we handle below)\n        (typeof value !== \"object\" ||\n          value === null ||\n          key === \"groupIds\" ||\n          key === \"scale\")\n      ) {\n        continue;\n      }\n\n      if (key === \"scale\") {\n        const prevScale = (element as any)[key];\n        const nextScale = value;\n        if (prevScale[0] === nextScale[0] && prevScale[1] === nextScale[1]) {\n          continue;\n        }\n      } else if (key === \"points\") {\n        const prevPoints = (element as any)[key];\n        const nextPoints = value;\n        if (prevPoints.length === nextPoints.length) {\n          let didChangePoints = false;\n          let index = prevPoints.length;\n          while (--index) {\n            const prevPoint: Point = prevPoints[index];\n            const nextPoint: Point = nextPoints[index];\n            if (\n              prevPoint[0] !== nextPoint[0] ||\n              prevPoint[1] !== nextPoint[1]\n            ) {\n              didChangePoints = true;\n              break;\n            }\n          }\n          if (!didChangePoints) {\n            continue;\n          }\n        }\n      }\n\n      (element as any)[key] = value;\n      didChange = true;\n    }\n  }\n  if (!didChange) {\n    return element;\n  }\n\n  if (\n    typeof updates.height !== \"undefined\" ||\n    typeof updates.width !== \"undefined\" ||\n    typeof fileId != \"undefined\" ||\n    typeof points !== \"undefined\"\n  ) {\n    invalidateShapeForElement(element);\n  }\n\n  element.version++;\n  element.versionNonce = randomInteger();\n  element.updated = getUpdatedTimestamp();\n\n  if (informMutation) {\n    Scene.getScene(element)?.informMutation();\n  }\n\n  return element;\n};\n\nexport const newElementWith = <TElement extends ExcalidrawElement>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n): TElement => {\n  let didChange = false;\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update because its attrs could have changed\n        (typeof value !== \"object\" || value === null)\n      ) {\n        continue;\n      }\n      didChange = true;\n    }\n  }\n\n  if (!didChange) {\n    return element;\n  }\n\n  return {\n    ...element,\n    ...updates,\n    updated: getUpdatedTimestamp(),\n    version: element.version + 1,\n    versionNonce: randomInteger(),\n  };\n};\n\n/**\n * Mutates element, bumping `version`, `versionNonce`, and `updated`.\n *\n * NOTE: does not trigger re-render.\n */\nexport const bumpVersion = (\n  element: Mutable<ExcalidrawElement>,\n  version?: ExcalidrawElement[\"version\"],\n) => {\n  element.version = (version ?? element.version) + 1;\n  element.versionNonce = randomInteger();\n  element.updated = getUpdatedTimestamp();\n  return element;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}