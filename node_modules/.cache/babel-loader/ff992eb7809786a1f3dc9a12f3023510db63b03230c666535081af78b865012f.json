{"ast":null,"code":"import _slicedToArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import _regeneratorRuntime from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";import _asyncToGenerator from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import{deflate,inflate}from\"pako\";import{encryptData,decryptData}from\"./encryption\";// -----------------------------------------------------------------------------\n// byte (binary) strings\n// -----------------------------------------------------------------------------\n// fast, Buffer-compatible implem\nexport var toByteString=function toByteString(data){return new Promise(function(resolve,reject){var blob=typeof data===\"string\"?new Blob([new TextEncoder().encode(data)]):new Blob([data instanceof Uint8Array?data:new Uint8Array(data)]);var reader=new FileReader();reader.onload=function(event){if(!event.target||typeof event.target.result!==\"string\"){return reject(new Error(\"couldn't convert to byte string\"));}resolve(event.target.result);};reader.readAsBinaryString(blob);});};var byteStringToArrayBuffer=function byteStringToArrayBuffer(byteString){var buffer=new ArrayBuffer(byteString.length);var bufferView=new Uint8Array(buffer);for(var i=0,len=byteString.length;i<len;i++){bufferView[i]=byteString.charCodeAt(i);}return buffer;};var byteStringToString=function byteStringToString(byteString){return new TextDecoder(\"utf-8\").decode(byteStringToArrayBuffer(byteString));};// -----------------------------------------------------------------------------\n// base64\n// -----------------------------------------------------------------------------\n/**\n * @param isByteString set to true if already byte string to prevent bloat\n *  due to reencoding\n */export var stringToBase64=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(str){var isByteString,_args=arguments;return _regeneratorRuntime().wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:isByteString=_args.length>1&&_args[1]!==undefined?_args[1]:false;if(!isByteString){_context.next=5;break;}_context.t0=window.btoa(str);_context.next=10;break;case 5:_context.t1=window;_context.next=8;return toByteString(str);case 8:_context.t2=_context.sent;_context.t0=_context.t1.btoa.call(_context.t1,_context.t2);case 10:return _context.abrupt(\"return\",_context.t0);case 11:case\"end\":return _context.stop();}},_callee);}));return function stringToBase64(_x){return _ref.apply(this,arguments);};}();// async to align with stringToBase64\nexport var base64ToString=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(base64){var isByteString,_args2=arguments;return _regeneratorRuntime().wrap(function _callee2$(_context2){while(1)switch(_context2.prev=_context2.next){case 0:isByteString=_args2.length>1&&_args2[1]!==undefined?_args2[1]:false;return _context2.abrupt(\"return\",isByteString?window.atob(base64):byteStringToString(window.atob(base64)));case 2:case\"end\":return _context2.stop();}},_callee2);}));return function base64ToString(_x2){return _ref2.apply(this,arguments);};}();// -----------------------------------------------------------------------------\n// text encoding\n// -----------------------------------------------------------------------------\n/**\n * Encodes (and potentially compresses via zlib) text to byte string\n */export var encode=/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref3){var text,compress,deflated;return _regeneratorRuntime().wrap(function _callee3$(_context3){while(1)switch(_context3.prev=_context3.next){case 0:text=_ref3.text,compress=_ref3.compress;if(!(compress!==false)){_context3.next=11;break;}_context3.prev=2;_context3.next=5;return toByteString(deflate(text));case 5:deflated=_context3.sent;_context3.next=11;break;case 8:_context3.prev=8;_context3.t0=_context3[\"catch\"](2);console.error(\"encode: cannot deflate\",_context3.t0);case 11:_context3.t1=!!deflated;_context3.t2=deflated;if(_context3.t2){_context3.next=17;break;}_context3.next=16;return toByteString(text);case 16:_context3.t2=_context3.sent;case 17:_context3.t3=_context3.t2;return _context3.abrupt(\"return\",{version:\"1\",encoding:\"bstring\",compressed:_context3.t1,encoded:_context3.t3});case 19:case\"end\":return _context3.stop();}},_callee3,null,[[2,8]]);}));return function encode(_x3){return _ref4.apply(this,arguments);};}();export var decode=/*#__PURE__*/function(){var _ref5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(data){var decoded;return _regeneratorRuntime().wrap(function _callee4$(_context4){while(1)switch(_context4.prev=_context4.next){case 0:_context4.t0=data.encoding;_context4.next=_context4.t0===\"bstring\"?3:12;break;case 3:if(!data.compressed){_context4.next=7;break;}_context4.t1=data.encoded;_context4.next=10;break;case 7:_context4.next=9;return byteStringToString(data.encoded);case 9:_context4.t1=_context4.sent;case 10:decoded=_context4.t1;return _context4.abrupt(\"break\",13);case 12:throw new Error(\"decode: unknown encoding \\\"\".concat(data.encoding,\"\\\"\"));case 13:if(!data.compressed){_context4.next=15;break;}return _context4.abrupt(\"return\",inflate(new Uint8Array(byteStringToArrayBuffer(decoded)),{to:\"string\"}));case 15:return _context4.abrupt(\"return\",decoded);case 16:case\"end\":return _context4.stop();}},_callee4);}));return function decode(_x4){return _ref5.apply(this,arguments);};}();// -----------------------------------------------------------------------------\n// binary encoding\n// -----------------------------------------------------------------------------\n// -----------------------------------------------------------------------------\nvar CONCAT_BUFFERS_VERSION=1;/** how many bytes we use to encode how many bytes the next chunk has.\n * Corresponds to DataView setter methods (setUint32, setUint16, etc).\n *\n * NOTE ! values must not be changed, which would be backwards incompatible !\n */var VERSION_DATAVIEW_BYTES=4;var NEXT_CHUNK_SIZE_DATAVIEW_BYTES=4;// -----------------------------------------------------------------------------\nvar DATA_VIEW_BITS_MAP={1:8,2:16,4:32};// getter\n// setter\n/**\n * abstraction over DataView that serves as a typed getter/setter in case\n * you're using constants for the byte size and want to ensure there's no\n * discrepenancy in the encoding across refactors.\n *\n * DataView serves for an endian-agnostic handling of numbers in ArrayBuffers.\n */function dataView(buffer,bytes,offset,value){if(value!=null){if(value>Math.pow(2,DATA_VIEW_BITS_MAP[bytes])-1){throw new Error(\"attempting to set value higher than the allocated bytes (value: \".concat(value,\", bytes: \").concat(bytes,\")\"));}var _method=\"setUint\".concat(DATA_VIEW_BITS_MAP[bytes]);new DataView(buffer.buffer)[_method](offset,value);return buffer;}var method=\"getUint\".concat(DATA_VIEW_BITS_MAP[bytes]);return new DataView(buffer.buffer)[method](offset);}// -----------------------------------------------------------------------------\n/**\n * Resulting concatenated buffer has this format:\n *\n * [\n *   VERSION chunk (4 bytes)\n *   LENGTH chunk 1 (4 bytes)\n *   DATA chunk 1 (up to 2^32 bits)\n *   LENGTH chunk 2 (4 bytes)\n *   DATA chunk 2 (up to 2^32 bits)\n *   ...\n * ]\n *\n * @param buffers each buffer (chunk) must be at most 2^32 bits large (~4GB)\n */var concatBuffers=function concatBuffers(){for(var _len=arguments.length,buffers=new Array(_len),_key=0;_key<_len;_key++){buffers[_key]=arguments[_key];}var bufferView=new Uint8Array(VERSION_DATAVIEW_BYTES+NEXT_CHUNK_SIZE_DATAVIEW_BYTES*buffers.length+buffers.reduce(function(acc,buffer){return acc+buffer.byteLength;},0));var cursor=0;// as the first chunk we'll encode the version for backwards compatibility\ndataView(bufferView,VERSION_DATAVIEW_BYTES,cursor,CONCAT_BUFFERS_VERSION);cursor+=VERSION_DATAVIEW_BYTES;for(var _i=0,_buffers=buffers;_i<_buffers.length;_i++){var _buffer=_buffers[_i];dataView(bufferView,NEXT_CHUNK_SIZE_DATAVIEW_BYTES,cursor,_buffer.byteLength);cursor+=NEXT_CHUNK_SIZE_DATAVIEW_BYTES;bufferView.set(_buffer,cursor);cursor+=_buffer.byteLength;}return bufferView;};/** can only be used on buffers created via `concatBuffers()` */var splitBuffers=function splitBuffers(concatenatedBuffer){var buffers=[];var cursor=0;// first chunk is the version\nvar version=dataView(concatenatedBuffer,NEXT_CHUNK_SIZE_DATAVIEW_BYTES,cursor);// If version is outside of the supported versions, throw an error.\n// This usually means the buffer wasn't encoded using this API, so we'd only\n// waste compute.\nif(version>CONCAT_BUFFERS_VERSION){throw new Error(\"invalid version \".concat(version));}cursor+=VERSION_DATAVIEW_BYTES;while(true){var chunkSize=dataView(concatenatedBuffer,NEXT_CHUNK_SIZE_DATAVIEW_BYTES,cursor);cursor+=NEXT_CHUNK_SIZE_DATAVIEW_BYTES;buffers.push(concatenatedBuffer.slice(cursor,cursor+chunkSize));cursor+=chunkSize;if(cursor>=concatenatedBuffer.byteLength){break;}}return buffers;};// helpers for (de)compressing data with JSON metadata including encryption\n// -----------------------------------------------------------------------------\n/** @private */var _encryptAndCompress=/*#__PURE__*/function(){var _ref6=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(data,encryptionKey){var _yield$encryptData,encryptedBuffer,iv;return _regeneratorRuntime().wrap(function _callee5$(_context5){while(1)switch(_context5.prev=_context5.next){case 0:_context5.next=2;return encryptData(encryptionKey,deflate(data));case 2:_yield$encryptData=_context5.sent;encryptedBuffer=_yield$encryptData.encryptedBuffer;iv=_yield$encryptData.iv;return _context5.abrupt(\"return\",{iv:iv,buffer:new Uint8Array(encryptedBuffer)});case 6:case\"end\":return _context5.stop();}},_callee5);}));return function _encryptAndCompress(_x5,_x6){return _ref6.apply(this,arguments);};}();/**\n * The returned buffer has following format:\n * `[]` refers to a buffers wrapper (see `concatBuffers`)\n *\n * [\n *   encodingMetadataBuffer,\n *   iv,\n *   [\n *      contentsMetadataBuffer\n *      contentsBuffer\n *   ]\n * ]\n */export var compressData=/*#__PURE__*/function(){var _ref7=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(dataBuffer,options){var fileInfo,encodingMetadataBuffer,contentsMetadataBuffer,_yield$_encryptAndCom,iv,buffer;return _regeneratorRuntime().wrap(function _callee6$(_context6){while(1)switch(_context6.prev=_context6.next){case 0:fileInfo={version:2,compression:\"pako@1\",encryption:\"AES-GCM\"};encodingMetadataBuffer=new TextEncoder().encode(JSON.stringify(fileInfo));contentsMetadataBuffer=new TextEncoder().encode(JSON.stringify(options.metadata||null));_context6.next=5;return _encryptAndCompress(concatBuffers(contentsMetadataBuffer,dataBuffer),options.encryptionKey);case 5:_yield$_encryptAndCom=_context6.sent;iv=_yield$_encryptAndCom.iv;buffer=_yield$_encryptAndCom.buffer;return _context6.abrupt(\"return\",concatBuffers(encodingMetadataBuffer,iv,buffer));case 9:case\"end\":return _context6.stop();}},_callee6);}));return function compressData(_x7,_x8){return _ref7.apply(this,arguments);};}();/** @private */var _decryptAndDecompress=/*#__PURE__*/function(){var _ref8=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(iv,decryptedBuffer,decryptionKey,isCompressed){return _regeneratorRuntime().wrap(function _callee7$(_context7){while(1)switch(_context7.prev=_context7.next){case 0:_context7.t0=Uint8Array;_context7.next=3;return decryptData(iv,decryptedBuffer,decryptionKey);case 3:_context7.t1=_context7.sent;decryptedBuffer=new _context7.t0(_context7.t1);if(!isCompressed){_context7.next=7;break;}return _context7.abrupt(\"return\",inflate(decryptedBuffer));case 7:return _context7.abrupt(\"return\",decryptedBuffer);case 8:case\"end\":return _context7.stop();}},_callee7);}));return function _decryptAndDecompress(_x9,_x10,_x11,_x12){return _ref8.apply(this,arguments);};}();export var decompressData=/*#__PURE__*/function(){var _ref9=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(bufferView,options){var _splitBuffers,_splitBuffers2,encodingMetadataBuffer,iv,buffer,encodingMetadata,_splitBuffers3,_splitBuffers4,contentsMetadataBuffer,contentsBuffer,metadata;return _regeneratorRuntime().wrap(function _callee8$(_context8){while(1)switch(_context8.prev=_context8.next){case 0:// first chunk is encoding metadata (ignored for now)\n_splitBuffers=splitBuffers(bufferView),_splitBuffers2=_slicedToArray(_splitBuffers,3),encodingMetadataBuffer=_splitBuffers2[0],iv=_splitBuffers2[1],buffer=_splitBuffers2[2];encodingMetadata=JSON.parse(new TextDecoder().decode(encodingMetadataBuffer));_context8.prev=2;_context8.t0=splitBuffers;_context8.next=6;return _decryptAndDecompress(iv,buffer,options.decryptionKey,!!encodingMetadata.compression);case 6:_context8.t1=_context8.sent;_splitBuffers3=(0,_context8.t0)(_context8.t1);_splitBuffers4=_slicedToArray(_splitBuffers3,2);contentsMetadataBuffer=_splitBuffers4[0];contentsBuffer=_splitBuffers4[1];metadata=JSON.parse(new TextDecoder().decode(contentsMetadataBuffer));return _context8.abrupt(\"return\",{/** metadata source is always JSON so we can decode it here */metadata:metadata,/** data can be anything so the caller must decode it */data:contentsBuffer});case 15:_context8.prev=15;_context8.t2=_context8[\"catch\"](2);console.error(\"Error during decompressing and decrypting the file.\",encodingMetadata);throw _context8.t2;case 19:case\"end\":return _context8.stop();}},_callee8,null,[[2,15]]);}));return function decompressData(_x13,_x14){return _ref9.apply(this,arguments);};}();// -----------------------------------------------------------------------------","map":{"version":3,"names":["deflate","inflate","encryptData","decryptData","toByteString","data","Promise","resolve","reject","blob","Blob","TextEncoder","encode","Uint8Array","reader","FileReader","onload","event","target","result","Error","readAsBinaryString","byteStringToArrayBuffer","byteString","buffer","ArrayBuffer","length","bufferView","i","len","charCodeAt","byteStringToString","TextDecoder","decode","stringToBase64","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","str","isByteString","_args","arguments","wrap","_callee$","_context","prev","next","undefined","t0","window","btoa","t1","t2","sent","call","abrupt","stop","_x","apply","base64ToString","_ref2","_callee2","base64","_args2","_callee2$","_context2","atob","_x2","_ref4","_callee3","_ref3","text","compress","deflated","_callee3$","_context3","console","error","t3","version","encoding","compressed","encoded","_x3","_ref5","_callee4","decoded","_callee4$","_context4","concat","to","_x4","CONCAT_BUFFERS_VERSION","VERSION_DATAVIEW_BYTES","NEXT_CHUNK_SIZE_DATAVIEW_BYTES","DATA_VIEW_BITS_MAP","dataView","bytes","offset","value","Math","pow","method","DataView","concatBuffers","_len","buffers","Array","_key","reduce","acc","byteLength","cursor","_i","_buffers","set","splitBuffers","concatenatedBuffer","chunkSize","push","slice","_encryptAndCompress","_ref6","_callee5","encryptionKey","_yield$encryptData","encryptedBuffer","iv","_callee5$","_context5","_x5","_x6","compressData","_ref7","_callee6","dataBuffer","options","fileInfo","encodingMetadataBuffer","contentsMetadataBuffer","_yield$_encryptAndCom","_callee6$","_context6","compression","encryption","JSON","stringify","metadata","_x7","_x8","_decryptAndDecompress","_ref8","_callee7","decryptedBuffer","decryptionKey","isCompressed","_callee7$","_context7","_x9","_x10","_x11","_x12","decompressData","_ref9","_callee8","_splitBuffers","_splitBuffers2","encodingMetadata","_splitBuffers3","_splitBuffers4","contentsBuffer","_callee8$","_context8","_slicedToArray","parse","_x13","_x14"],"sources":["D:/project/excalidraw-cn/src/data/encode.ts"],"sourcesContent":["import { deflate, inflate } from \"pako\";\nimport { encryptData, decryptData } from \"./encryption\";\n\n// -----------------------------------------------------------------------------\n// byte (binary) strings\n// -----------------------------------------------------------------------------\n\n// fast, Buffer-compatible implem\nexport const toByteString = (\n  data: string | Uint8Array | ArrayBuffer,\n): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    const blob =\n      typeof data === \"string\"\n        ? new Blob([new TextEncoder().encode(data)])\n        : new Blob([data instanceof Uint8Array ? data : new Uint8Array(data)]);\n    const reader = new FileReader();\n    reader.onload = (event) => {\n      if (!event.target || typeof event.target.result !== \"string\") {\n        return reject(new Error(\"couldn't convert to byte string\"));\n      }\n      resolve(event.target.result);\n    };\n    reader.readAsBinaryString(blob);\n  });\n};\n\nconst byteStringToArrayBuffer = (byteString: string) => {\n  const buffer = new ArrayBuffer(byteString.length);\n  const bufferView = new Uint8Array(buffer);\n  for (let i = 0, len = byteString.length; i < len; i++) {\n    bufferView[i] = byteString.charCodeAt(i);\n  }\n  return buffer;\n};\n\nconst byteStringToString = (byteString: string) => {\n  return new TextDecoder(\"utf-8\").decode(byteStringToArrayBuffer(byteString));\n};\n\n// -----------------------------------------------------------------------------\n// base64\n// -----------------------------------------------------------------------------\n\n/**\n * @param isByteString set to true if already byte string to prevent bloat\n *  due to reencoding\n */\nexport const stringToBase64 = async (str: string, isByteString = false) => {\n  return isByteString ? window.btoa(str) : window.btoa(await toByteString(str));\n};\n\n// async to align with stringToBase64\nexport const base64ToString = async (base64: string, isByteString = false) => {\n  return isByteString\n    ? window.atob(base64)\n    : byteStringToString(window.atob(base64));\n};\n\n// -----------------------------------------------------------------------------\n// text encoding\n// -----------------------------------------------------------------------------\n\ntype EncodedData = {\n  encoded: string;\n  encoding: \"bstring\";\n  /** whether text is compressed (zlib) */\n  compressed: boolean;\n  /** version for potential migration purposes */\n  version?: string;\n};\n\n/**\n * Encodes (and potentially compresses via zlib) text to byte string\n */\nexport const encode = async ({\n  text,\n  compress,\n}: {\n  text: string;\n  /** defaults to `true`. If compression fails, falls back to bstring alone. */\n  compress?: boolean;\n}): Promise<EncodedData> => {\n  let deflated!: string;\n  if (compress !== false) {\n    try {\n      deflated = await toByteString(deflate(text));\n    } catch (error: any) {\n      console.error(\"encode: cannot deflate\", error);\n    }\n  }\n  return {\n    version: \"1\",\n    encoding: \"bstring\",\n    compressed: !!deflated,\n    encoded: deflated || (await toByteString(text)),\n  };\n};\n\nexport const decode = async (data: EncodedData): Promise<string> => {\n  let decoded: string;\n\n  switch (data.encoding) {\n    case \"bstring\":\n      // if compressed, do not double decode the bstring\n      decoded = data.compressed\n        ? data.encoded\n        : await byteStringToString(data.encoded);\n      break;\n    default:\n      throw new Error(`decode: unknown encoding \"${data.encoding}\"`);\n  }\n\n  if (data.compressed) {\n    return inflate(new Uint8Array(byteStringToArrayBuffer(decoded)), {\n      to: \"string\",\n    });\n  }\n\n  return decoded;\n};\n\n// -----------------------------------------------------------------------------\n// binary encoding\n// -----------------------------------------------------------------------------\n\ntype FileEncodingInfo = {\n  /* version 2 is the version we're shipping the initial image support with.\n    version 1 was a PR version that a lot of people were using anyway.\n    Thus, if there are issues we can check whether they're not using the\n    unoffic version */\n  version: 1 | 2;\n  compression: \"pako@1\" | null;\n  encryption: \"AES-GCM\" | null;\n};\n\n// -----------------------------------------------------------------------------\nconst CONCAT_BUFFERS_VERSION = 1;\n/** how many bytes we use to encode how many bytes the next chunk has.\n * Corresponds to DataView setter methods (setUint32, setUint16, etc).\n *\n * NOTE ! values must not be changed, which would be backwards incompatible !\n */\nconst VERSION_DATAVIEW_BYTES = 4;\nconst NEXT_CHUNK_SIZE_DATAVIEW_BYTES = 4;\n// -----------------------------------------------------------------------------\n\nconst DATA_VIEW_BITS_MAP = { 1: 8, 2: 16, 4: 32 } as const;\n\n// getter\nfunction dataView(buffer: Uint8Array, bytes: 1 | 2 | 4, offset: number): number;\n// setter\nfunction dataView(\n  buffer: Uint8Array,\n  bytes: 1 | 2 | 4,\n  offset: number,\n  value: number,\n): Uint8Array;\n/**\n * abstraction over DataView that serves as a typed getter/setter in case\n * you're using constants for the byte size and want to ensure there's no\n * discrepenancy in the encoding across refactors.\n *\n * DataView serves for an endian-agnostic handling of numbers in ArrayBuffers.\n */\nfunction dataView(\n  buffer: Uint8Array,\n  bytes: 1 | 2 | 4,\n  offset: number,\n  value?: number,\n): Uint8Array | number {\n  if (value != null) {\n    if (value > Math.pow(2, DATA_VIEW_BITS_MAP[bytes]) - 1) {\n      throw new Error(\n        `attempting to set value higher than the allocated bytes (value: ${value}, bytes: ${bytes})`,\n      );\n    }\n    const method = `setUint${DATA_VIEW_BITS_MAP[bytes]}` as const;\n    new DataView(buffer.buffer)[method](offset, value);\n    return buffer;\n  }\n  const method = `getUint${DATA_VIEW_BITS_MAP[bytes]}` as const;\n  return new DataView(buffer.buffer)[method](offset);\n}\n\n// -----------------------------------------------------------------------------\n\n/**\n * Resulting concatenated buffer has this format:\n *\n * [\n *   VERSION chunk (4 bytes)\n *   LENGTH chunk 1 (4 bytes)\n *   DATA chunk 1 (up to 2^32 bits)\n *   LENGTH chunk 2 (4 bytes)\n *   DATA chunk 2 (up to 2^32 bits)\n *   ...\n * ]\n *\n * @param buffers each buffer (chunk) must be at most 2^32 bits large (~4GB)\n */\nconst concatBuffers = (...buffers: Uint8Array[]) => {\n  const bufferView = new Uint8Array(\n    VERSION_DATAVIEW_BYTES +\n      NEXT_CHUNK_SIZE_DATAVIEW_BYTES * buffers.length +\n      buffers.reduce((acc, buffer) => acc + buffer.byteLength, 0),\n  );\n\n  let cursor = 0;\n\n  // as the first chunk we'll encode the version for backwards compatibility\n  dataView(bufferView, VERSION_DATAVIEW_BYTES, cursor, CONCAT_BUFFERS_VERSION);\n  cursor += VERSION_DATAVIEW_BYTES;\n\n  for (const buffer of buffers) {\n    dataView(\n      bufferView,\n      NEXT_CHUNK_SIZE_DATAVIEW_BYTES,\n      cursor,\n      buffer.byteLength,\n    );\n    cursor += NEXT_CHUNK_SIZE_DATAVIEW_BYTES;\n\n    bufferView.set(buffer, cursor);\n    cursor += buffer.byteLength;\n  }\n\n  return bufferView;\n};\n\n/** can only be used on buffers created via `concatBuffers()` */\nconst splitBuffers = (concatenatedBuffer: Uint8Array) => {\n  const buffers = [];\n\n  let cursor = 0;\n\n  // first chunk is the version\n  const version = dataView(\n    concatenatedBuffer,\n    NEXT_CHUNK_SIZE_DATAVIEW_BYTES,\n    cursor,\n  );\n  // If version is outside of the supported versions, throw an error.\n  // This usually means the buffer wasn't encoded using this API, so we'd only\n  // waste compute.\n  if (version > CONCAT_BUFFERS_VERSION) {\n    throw new Error(`invalid version ${version}`);\n  }\n\n  cursor += VERSION_DATAVIEW_BYTES;\n\n  while (true) {\n    const chunkSize = dataView(\n      concatenatedBuffer,\n      NEXT_CHUNK_SIZE_DATAVIEW_BYTES,\n      cursor,\n    );\n    cursor += NEXT_CHUNK_SIZE_DATAVIEW_BYTES;\n\n    buffers.push(concatenatedBuffer.slice(cursor, cursor + chunkSize));\n    cursor += chunkSize;\n    if (cursor >= concatenatedBuffer.byteLength) {\n      break;\n    }\n  }\n\n  return buffers;\n};\n\n// helpers for (de)compressing data with JSON metadata including encryption\n// -----------------------------------------------------------------------------\n\n/** @private */\nconst _encryptAndCompress = async (\n  data: Uint8Array | string,\n  encryptionKey: string,\n) => {\n  const { encryptedBuffer, iv } = await encryptData(\n    encryptionKey,\n    deflate(data),\n  );\n\n  return { iv, buffer: new Uint8Array(encryptedBuffer) };\n};\n\n/**\n * The returned buffer has following format:\n * `[]` refers to a buffers wrapper (see `concatBuffers`)\n *\n * [\n *   encodingMetadataBuffer,\n *   iv,\n *   [\n *      contentsMetadataBuffer\n *      contentsBuffer\n *   ]\n * ]\n */\nexport const compressData = async <T extends Record<string, any> = never>(\n  dataBuffer: Uint8Array,\n  options: {\n    encryptionKey: string;\n  } & ([T] extends [never]\n    ? {\n        metadata?: T;\n      }\n    : {\n        metadata: T;\n      }),\n): Promise<Uint8Array> => {\n  const fileInfo: FileEncodingInfo = {\n    version: 2,\n    compression: \"pako@1\",\n    encryption: \"AES-GCM\",\n  };\n\n  const encodingMetadataBuffer = new TextEncoder().encode(\n    JSON.stringify(fileInfo),\n  );\n\n  const contentsMetadataBuffer = new TextEncoder().encode(\n    JSON.stringify(options.metadata || null),\n  );\n\n  const { iv, buffer } = await _encryptAndCompress(\n    concatBuffers(contentsMetadataBuffer, dataBuffer),\n    options.encryptionKey,\n  );\n\n  return concatBuffers(encodingMetadataBuffer, iv, buffer);\n};\n\n/** @private */\nconst _decryptAndDecompress = async (\n  iv: Uint8Array,\n  decryptedBuffer: Uint8Array,\n  decryptionKey: string,\n  isCompressed: boolean,\n) => {\n  decryptedBuffer = new Uint8Array(\n    await decryptData(iv, decryptedBuffer, decryptionKey),\n  );\n\n  if (isCompressed) {\n    return inflate(decryptedBuffer);\n  }\n\n  return decryptedBuffer;\n};\n\nexport const decompressData = async <T extends Record<string, any>>(\n  bufferView: Uint8Array,\n  options: { decryptionKey: string },\n) => {\n  // first chunk is encoding metadata (ignored for now)\n  const [encodingMetadataBuffer, iv, buffer] = splitBuffers(bufferView);\n\n  const encodingMetadata: FileEncodingInfo = JSON.parse(\n    new TextDecoder().decode(encodingMetadataBuffer),\n  );\n\n  try {\n    const [contentsMetadataBuffer, contentsBuffer] = splitBuffers(\n      await _decryptAndDecompress(\n        iv,\n        buffer,\n        options.decryptionKey,\n        !!encodingMetadata.compression,\n      ),\n    );\n\n    const metadata = JSON.parse(\n      new TextDecoder().decode(contentsMetadataBuffer),\n    ) as T;\n\n    return {\n      /** metadata source is always JSON so we can decode it here */\n      metadata,\n      /** data can be anything so the caller must decode it */\n      data: contentsBuffer,\n    };\n  } catch (error: any) {\n    console.error(\n      `Error during decompressing and decrypting the file.`,\n      encodingMetadata,\n    );\n    throw error;\n  }\n};\n\n// -----------------------------------------------------------------------------\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}