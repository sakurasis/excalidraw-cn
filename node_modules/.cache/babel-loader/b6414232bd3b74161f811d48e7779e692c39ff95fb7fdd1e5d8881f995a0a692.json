{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { eventToSentryRequest, sessionToSentryRequest } from '@sentry/core';\nimport { SyncPromise } from '@sentry/utils';\nimport { BaseTransport } from './base';\n/** `XHR` based transport */\nvar XHRTransport = /** @class */function (_super) {\n  __extends(XHRTransport, _super);\n  function XHRTransport() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @inheritDoc\n   */\n  XHRTransport.prototype.sendEvent = function (event) {\n    return this._sendRequest(eventToSentryRequest(event, this._api), event);\n  };\n  /**\n   * @inheritDoc\n   */\n  XHRTransport.prototype.sendSession = function (session) {\n    return this._sendRequest(sessionToSentryRequest(session, this._api), session);\n  };\n  /**\n   * @param sentryRequest Prepared SentryRequest to be delivered\n   * @param originalPayload Original payload used to create SentryRequest\n   */\n  XHRTransport.prototype._sendRequest = function (sentryRequest, originalPayload) {\n    var _this = this;\n    if (this._isRateLimited(sentryRequest.type)) {\n      return Promise.reject({\n        event: originalPayload,\n        type: sentryRequest.type,\n        reason: \"Transport locked till \" + this._disabledUntil(sentryRequest.type) + \" due to too many requests.\",\n        status: 429\n      });\n    }\n    return this._buffer.add(new SyncPromise(function (resolve, reject) {\n      var request = new XMLHttpRequest();\n      request.onreadystatechange = function () {\n        if (request.readyState === 4) {\n          var headers = {\n            'x-sentry-rate-limits': request.getResponseHeader('X-Sentry-Rate-Limits'),\n            'retry-after': request.getResponseHeader('Retry-After')\n          };\n          _this._handleResponse({\n            requestType: sentryRequest.type,\n            response: request,\n            headers: headers,\n            resolve: resolve,\n            reject: reject\n          });\n        }\n      };\n      request.open('POST', sentryRequest.url);\n      for (var header in _this.options.headers) {\n        if (_this.options.headers.hasOwnProperty(header)) {\n          request.setRequestHeader(header, _this.options.headers[header]);\n        }\n      }\n      request.send(sentryRequest.body);\n    }));\n  };\n  return XHRTransport;\n}(BaseTransport);\nexport { XHRTransport };","map":{"version":3,"names":["eventToSentryRequest","sessionToSentryRequest","SyncPromise","BaseTransport","XHRTransport","_super","__extends","prototype","sendEvent","event","_sendRequest","_api","sendSession","session","sentryRequest","originalPayload","_this","_isRateLimited","type","Promise","reject","reason","_disabledUntil","status","_buffer","add","resolve","request","XMLHttpRequest","onreadystatechange","readyState","headers","getResponseHeader","_handleResponse","requestType","response","open","url","header","options","hasOwnProperty","setRequestHeader","send","body"],"sources":["D:\\project\\excalidraw-cn\\node_modules\\@sentry\\browser\\src\\transports\\xhr.ts"],"sourcesContent":["import { eventToSentryRequest, sessionToSentryRequest } from '@sentry/core';\nimport { Event, Response, SentryRequest, Session } from '@sentry/types';\nimport { SyncPromise } from '@sentry/utils';\n\nimport { BaseTransport } from './base';\n\n/** `XHR` based transport */\nexport class XHRTransport extends BaseTransport {\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event): PromiseLike<Response> {\n    return this._sendRequest(eventToSentryRequest(event, this._api), event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session): PromiseLike<Response> {\n    return this._sendRequest(sessionToSentryRequest(session, this._api), session);\n  }\n\n  /**\n   * @param sentryRequest Prepared SentryRequest to be delivered\n   * @param originalPayload Original payload used to create SentryRequest\n   */\n  private _sendRequest(sentryRequest: SentryRequest, originalPayload: Event | Session): PromiseLike<Response> {\n    if (this._isRateLimited(sentryRequest.type)) {\n      return Promise.reject({\n        event: originalPayload,\n        type: sentryRequest.type,\n        reason: `Transport locked till ${this._disabledUntil(sentryRequest.type)} due to too many requests.`,\n        status: 429,\n      });\n    }\n\n    return this._buffer.add(\n      new SyncPromise<Response>((resolve, reject) => {\n        const request = new XMLHttpRequest();\n\n        request.onreadystatechange = (): void => {\n          if (request.readyState === 4) {\n            const headers = {\n              'x-sentry-rate-limits': request.getResponseHeader('X-Sentry-Rate-Limits'),\n              'retry-after': request.getResponseHeader('Retry-After'),\n            };\n            this._handleResponse({ requestType: sentryRequest.type, response: request, headers, resolve, reject });\n          }\n        };\n\n        request.open('POST', sentryRequest.url);\n        for (const header in this.options.headers) {\n          if (this.options.headers.hasOwnProperty(header)) {\n            request.setRequestHeader(header, this.options.headers[header]);\n          }\n        }\n        request.send(sentryRequest.body);\n      }),\n    );\n  }\n}\n"],"mappings":";AAAA,SAASA,oBAAoB,EAAEC,sBAAsB,QAAQ,cAAc;AAE3E,SAASC,WAAW,QAAQ,eAAe;AAE3C,SAASC,aAAa,QAAQ,QAAQ;AAEtC;AACA,IAAAC,YAAA,0BAAAC,MAAA;EAAkCC,SAAA,CAAAF,YAAA,EAAAC,MAAA;EAAlC,SAAAD,aAAA;;EAqDA;EApDE;;;EAGOA,YAAA,CAAAG,SAAA,CAAAC,SAAS,GAAhB,UAAiBC,KAAY;IAC3B,OAAO,IAAI,CAACC,YAAY,CAACV,oBAAoB,CAACS,KAAK,EAAE,IAAI,CAACE,IAAI,CAAC,EAAEF,KAAK,CAAC;EACzE,CAAC;EAED;;;EAGOL,YAAA,CAAAG,SAAA,CAAAK,WAAW,GAAlB,UAAmBC,OAAgB;IACjC,OAAO,IAAI,CAACH,YAAY,CAACT,sBAAsB,CAACY,OAAO,EAAE,IAAI,CAACF,IAAI,CAAC,EAAEE,OAAO,CAAC;EAC/E,CAAC;EAED;;;;EAIQT,YAAA,CAAAG,SAAA,CAAAG,YAAY,GAApB,UAAqBI,aAA4B,EAAEC,eAAgC;IAAnF,IAAAC,KAAA;IACE,IAAI,IAAI,CAACC,cAAc,CAACH,aAAa,CAACI,IAAI,CAAC,EAAE;MAC3C,OAAOC,OAAO,CAACC,MAAM,CAAC;QACpBX,KAAK,EAAEM,eAAe;QACtBG,IAAI,EAAEJ,aAAa,CAACI,IAAI;QACxBG,MAAM,EAAE,2BAAyB,IAAI,CAACC,cAAc,CAACR,aAAa,CAACI,IAAI,CAAC,+BAA4B;QACpGK,MAAM,EAAE;OACT,CAAC;;IAGJ,OAAO,IAAI,CAACC,OAAO,CAACC,GAAG,CACrB,IAAIvB,WAAW,CAAW,UAACwB,OAAO,EAAEN,MAAM;MACxC,IAAMO,OAAO,GAAG,IAAIC,cAAc,EAAE;MAEpCD,OAAO,CAACE,kBAAkB,GAAG;QAC3B,IAAIF,OAAO,CAACG,UAAU,KAAK,CAAC,EAAE;UAC5B,IAAMC,OAAO,GAAG;YACd,sBAAsB,EAAEJ,OAAO,CAACK,iBAAiB,CAAC,sBAAsB,CAAC;YACzE,aAAa,EAAEL,OAAO,CAACK,iBAAiB,CAAC,aAAa;WACvD;UACDhB,KAAI,CAACiB,eAAe,CAAC;YAAEC,WAAW,EAAEpB,aAAa,CAACI,IAAI;YAAEiB,QAAQ,EAAER,OAAO;YAAEI,OAAO,EAAAA,OAAA;YAAEL,OAAO,EAAAA,OAAA;YAAEN,MAAM,EAAAA;UAAA,CAAE,CAAC;;MAE1G,CAAC;MAEDO,OAAO,CAACS,IAAI,CAAC,MAAM,EAAEtB,aAAa,CAACuB,GAAG,CAAC;MACvC,KAAK,IAAMC,MAAM,IAAItB,KAAI,CAACuB,OAAO,CAACR,OAAO,EAAE;QACzC,IAAIf,KAAI,CAACuB,OAAO,CAACR,OAAO,CAACS,cAAc,CAACF,MAAM,CAAC,EAAE;UAC/CX,OAAO,CAACc,gBAAgB,CAACH,MAAM,EAAEtB,KAAI,CAACuB,OAAO,CAACR,OAAO,CAACO,MAAM,CAAC,CAAC;;;MAGlEX,OAAO,CAACe,IAAI,CAAC5B,aAAa,CAAC6B,IAAI,CAAC;IAClC,CAAC,CAAC,CACH;EACH,CAAC;EACH,OAAAvC,YAAC;AAAD,CAAC,CArDiCD,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}