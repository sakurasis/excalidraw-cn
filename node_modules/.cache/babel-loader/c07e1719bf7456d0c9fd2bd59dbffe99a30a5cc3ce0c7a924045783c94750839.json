{"ast":null,"code":"import { __assign, __read, __rest, __spread } from \"tslib\";\n/** Extract sdk info from from the API metadata */\nfunction getSdkMetadataForEnvelopeHeader(api) {\n  if (!api.metadata || !api.metadata.sdk) {\n    return;\n  }\n  var _a = api.metadata.sdk,\n    name = _a.name,\n    version = _a.version;\n  return {\n    name: name,\n    version: version\n  };\n}\n/**\n * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.\n * Merge with existing data if any.\n **/\nfunction enhanceEventWithSdkInfo(event, sdkInfo) {\n  if (!sdkInfo) {\n    return event;\n  }\n  event.sdk = event.sdk || {\n    name: sdkInfo.name,\n    version: sdkInfo.version\n  };\n  event.sdk.name = event.sdk.name || sdkInfo.name;\n  event.sdk.version = event.sdk.version || sdkInfo.version;\n  event.sdk.integrations = __spread(event.sdk.integrations || [], sdkInfo.integrations || []);\n  event.sdk.packages = __spread(event.sdk.packages || [], sdkInfo.packages || []);\n  return event;\n}\n/** Creates a SentryRequest from an event. */\nexport function sessionToSentryRequest(session, api) {\n  var sdkInfo = getSdkMetadataForEnvelopeHeader(api);\n  var envelopeHeaders = JSON.stringify(__assign({\n    sent_at: new Date().toISOString()\n  }, sdkInfo && {\n    sdk: sdkInfo\n  }));\n  var itemHeaders = JSON.stringify({\n    type: 'session'\n  });\n  return {\n    body: envelopeHeaders + \"\\n\" + itemHeaders + \"\\n\" + JSON.stringify(session),\n    type: 'session',\n    url: api.getEnvelopeEndpointWithUrlEncodedAuth()\n  };\n}\n/** Creates a SentryRequest from an event. */\nexport function eventToSentryRequest(event, api) {\n  var sdkInfo = getSdkMetadataForEnvelopeHeader(api);\n  var eventType = event.type || 'event';\n  var useEnvelope = eventType === 'transaction';\n  var _a = event.debug_meta || {},\n    transactionSampling = _a.transactionSampling,\n    metadata = __rest(_a, [\"transactionSampling\"]);\n  var _b = transactionSampling || {},\n    samplingMethod = _b.method,\n    sampleRate = _b.rate;\n  if (Object.keys(metadata).length === 0) {\n    delete event.debug_meta;\n  } else {\n    event.debug_meta = metadata;\n  }\n  var req = {\n    body: JSON.stringify(sdkInfo ? enhanceEventWithSdkInfo(event, api.metadata.sdk) : event),\n    type: eventType,\n    url: useEnvelope ? api.getEnvelopeEndpointWithUrlEncodedAuth() : api.getStoreEndpointWithUrlEncodedAuth()\n  };\n  // https://develop.sentry.dev/sdk/envelopes/\n  // Since we don't need to manipulate envelopes nor store them, there is no\n  // exported concept of an Envelope with operations including serialization and\n  // deserialization. Instead, we only implement a minimal subset of the spec to\n  // serialize events inline here.\n  if (useEnvelope) {\n    var envelopeHeaders = JSON.stringify(__assign({\n      event_id: event.event_id,\n      sent_at: new Date().toISOString()\n    }, sdkInfo && {\n      sdk: sdkInfo\n    }));\n    var itemHeaders = JSON.stringify({\n      type: event.type,\n      // TODO: Right now, sampleRate may or may not be defined (it won't be in the cases of inheritance and\n      // explicitly-set sampling decisions). Are we good with that?\n      sample_rates: [{\n        id: samplingMethod,\n        rate: sampleRate\n      }]\n    });\n    // The trailing newline is optional. We intentionally don't send it to avoid\n    // sending unnecessary bytes.\n    //\n    // const envelope = `${envelopeHeaders}\\n${itemHeaders}\\n${req.body}\\n`;\n    var envelope = envelopeHeaders + \"\\n\" + itemHeaders + \"\\n\" + req.body;\n    req.body = envelope;\n  }\n  return req;\n}","map":{"version":3,"names":["getSdkMetadataForEnvelopeHeader","api","metadata","sdk","_a","name","version","enhanceEventWithSdkInfo","event","sdkInfo","integrations","__spread","packages","sessionToSentryRequest","session","envelopeHeaders","JSON","stringify","__assign","sent_at","Date","toISOString","itemHeaders","type","body","url","getEnvelopeEndpointWithUrlEncodedAuth","eventToSentryRequest","eventType","useEnvelope","debug_meta","transactionSampling","__rest","_b","samplingMethod","method","sampleRate","rate","Object","keys","length","req","getStoreEndpointWithUrlEncodedAuth","event_id","sample_rates","id","envelope"],"sources":["D:\\project\\excalidraw-cn\\node_modules\\@sentry\\core\\src\\request.ts"],"sourcesContent":["import { Event, SdkInfo, SentryRequest, Session } from '@sentry/types';\n\nimport { API } from './api';\n\n/** Extract sdk info from from the API metadata */\nfunction getSdkMetadataForEnvelopeHeader(api: API): SdkInfo | undefined {\n  if (!api.metadata || !api.metadata.sdk) {\n    return;\n  }\n  const { name, version } = api.metadata.sdk;\n  return { name, version };\n}\n\n/**\n * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.\n * Merge with existing data if any.\n **/\nfunction enhanceEventWithSdkInfo(event: Event, sdkInfo?: SdkInfo): Event {\n  if (!sdkInfo) {\n    return event;\n  }\n\n  event.sdk = event.sdk || {\n    name: sdkInfo.name,\n    version: sdkInfo.version,\n  };\n  event.sdk.name = event.sdk.name || sdkInfo.name;\n  event.sdk.version = event.sdk.version || sdkInfo.version;\n  event.sdk.integrations = [...(event.sdk.integrations || []), ...(sdkInfo.integrations || [])];\n  event.sdk.packages = [...(event.sdk.packages || []), ...(sdkInfo.packages || [])];\n  return event;\n}\n\n/** Creates a SentryRequest from an event. */\nexport function sessionToSentryRequest(session: Session, api: API): SentryRequest {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(api);\n  const envelopeHeaders = JSON.stringify({\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n  });\n  const itemHeaders = JSON.stringify({\n    type: 'session',\n  });\n\n  return {\n    body: `${envelopeHeaders}\\n${itemHeaders}\\n${JSON.stringify(session)}`,\n    type: 'session',\n    url: api.getEnvelopeEndpointWithUrlEncodedAuth(),\n  };\n}\n\n/** Creates a SentryRequest from an event. */\nexport function eventToSentryRequest(event: Event, api: API): SentryRequest {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(api);\n  const eventType = event.type || 'event';\n  const useEnvelope = eventType === 'transaction';\n\n  const { transactionSampling, ...metadata } = event.debug_meta || {};\n  const { method: samplingMethod, rate: sampleRate } = transactionSampling || {};\n  if (Object.keys(metadata).length === 0) {\n    delete event.debug_meta;\n  } else {\n    event.debug_meta = metadata;\n  }\n\n  const req: SentryRequest = {\n    body: JSON.stringify(sdkInfo ? enhanceEventWithSdkInfo(event, api.metadata.sdk) : event),\n    type: eventType,\n    url: useEnvelope ? api.getEnvelopeEndpointWithUrlEncodedAuth() : api.getStoreEndpointWithUrlEncodedAuth(),\n  };\n\n  // https://develop.sentry.dev/sdk/envelopes/\n\n  // Since we don't need to manipulate envelopes nor store them, there is no\n  // exported concept of an Envelope with operations including serialization and\n  // deserialization. Instead, we only implement a minimal subset of the spec to\n  // serialize events inline here.\n  if (useEnvelope) {\n    const envelopeHeaders = JSON.stringify({\n      event_id: event.event_id,\n      sent_at: new Date().toISOString(),\n      ...(sdkInfo && { sdk: sdkInfo }),\n    });\n    const itemHeaders = JSON.stringify({\n      type: event.type,\n\n      // TODO: Right now, sampleRate may or may not be defined (it won't be in the cases of inheritance and\n      // explicitly-set sampling decisions). Are we good with that?\n      sample_rates: [{ id: samplingMethod, rate: sampleRate }],\n\n      // The content-type is assumed to be 'application/json' and not part of\n      // the current spec for transaction items, so we don't bloat the request\n      // body with it.\n      //\n      // content_type: 'application/json',\n      //\n      // The length is optional. It must be the number of bytes in req.Body\n      // encoded as UTF-8. Since the server can figure this out and would\n      // otherwise refuse events that report the length incorrectly, we decided\n      // not to send the length to avoid problems related to reporting the wrong\n      // size and to reduce request body size.\n      //\n      // length: new TextEncoder().encode(req.body).length,\n    });\n    // The trailing newline is optional. We intentionally don't send it to avoid\n    // sending unnecessary bytes.\n    //\n    // const envelope = `${envelopeHeaders}\\n${itemHeaders}\\n${req.body}\\n`;\n    const envelope = `${envelopeHeaders}\\n${itemHeaders}\\n${req.body}`;\n    req.body = envelope;\n  }\n\n  return req;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}