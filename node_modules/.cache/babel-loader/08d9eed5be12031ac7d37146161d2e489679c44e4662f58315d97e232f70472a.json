{"ast":null,"code":"import { isTextElement, isExcalidrawElement, redrawTextBoundingBox } from \"../element\";\nimport { CODES, KEYS } from \"../keys\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { DEFAULT_FONT_SIZE, DEFAULT_FONT_FAMILY, DEFAULT_TEXT_ALIGN } from \"../constants\";\nimport { getBoundTextElement, getDefaultLineHeight } from \"../element/textElement\";\nimport { hasBoundTextElement, canApplyRoundnessTypeToElement, getDefaultRoundnessTypeForElement, isFrameElement } from \"../element/typeChecks\";\nimport { getSelectedElements } from \"../scene\";\n\n// `copiedStyles` is exported only for tests.\nexport let copiedStyles = \"{}\";\nexport const actionCopyStyles = register({\n  name: \"copyStyles\",\n  trackEvent: {\n    category: \"element\"\n  },\n  perform: (elements, appState) => {\n    const elementsCopied = [];\n    const element = elements.find(el => appState.selectedElementIds[el.id]);\n    elementsCopied.push(element);\n    if (element && hasBoundTextElement(element)) {\n      const boundTextElement = getBoundTextElement(element);\n      elementsCopied.push(boundTextElement);\n    }\n    if (element) {\n      copiedStyles = JSON.stringify(elementsCopied);\n    }\n    return {\n      appState: {\n        ...appState,\n        toast: {\n          message: t(\"toast.copyStyles\")\n        }\n      },\n      commitToHistory: false\n    };\n  },\n  contextItemLabel: \"labels.copyStyles\",\n  keyTest: event => event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.C\n});\nexport const actionPasteStyles = register({\n  name: \"pasteStyles\",\n  trackEvent: {\n    category: \"element\"\n  },\n  perform: (elements, appState) => {\n    const elementsCopied = JSON.parse(copiedStyles);\n    const pastedElement = elementsCopied[0];\n    const boundTextElement = elementsCopied[1];\n    if (!isExcalidrawElement(pastedElement)) {\n      return {\n        elements,\n        commitToHistory: false\n      };\n    }\n    const selectedElements = getSelectedElements(elements, appState, {\n      includeBoundTextElement: true\n    });\n    const selectedElementIds = selectedElements.map(element => element.id);\n    return {\n      elements: elements.map(element => {\n        if (selectedElementIds.includes(element.id)) {\n          var _elementStylesToCopyF, _elementStylesToCopyF2, _elementStylesToCopyF3, _elementStylesToCopyF4, _elementStylesToCopyF5, _elementStylesToCopyF6, _elementStylesToCopyF7;\n          let elementStylesToCopyFrom = pastedElement;\n          if (isTextElement(element) && element.containerId) {\n            elementStylesToCopyFrom = boundTextElement;\n          }\n          if (!elementStylesToCopyFrom) {\n            return element;\n          }\n          let newElement = newElementWith(element, {\n            backgroundColor: (_elementStylesToCopyF = elementStylesToCopyFrom) === null || _elementStylesToCopyF === void 0 ? void 0 : _elementStylesToCopyF.backgroundColor,\n            strokeWidth: (_elementStylesToCopyF2 = elementStylesToCopyFrom) === null || _elementStylesToCopyF2 === void 0 ? void 0 : _elementStylesToCopyF2.strokeWidth,\n            strokeColor: (_elementStylesToCopyF3 = elementStylesToCopyFrom) === null || _elementStylesToCopyF3 === void 0 ? void 0 : _elementStylesToCopyF3.strokeColor,\n            strokeStyle: (_elementStylesToCopyF4 = elementStylesToCopyFrom) === null || _elementStylesToCopyF4 === void 0 ? void 0 : _elementStylesToCopyF4.strokeStyle,\n            fillStyle: (_elementStylesToCopyF5 = elementStylesToCopyFrom) === null || _elementStylesToCopyF5 === void 0 ? void 0 : _elementStylesToCopyF5.fillStyle,\n            opacity: (_elementStylesToCopyF6 = elementStylesToCopyFrom) === null || _elementStylesToCopyF6 === void 0 ? void 0 : _elementStylesToCopyF6.opacity,\n            roughness: (_elementStylesToCopyF7 = elementStylesToCopyFrom) === null || _elementStylesToCopyF7 === void 0 ? void 0 : _elementStylesToCopyF7.roughness,\n            roundness: elementStylesToCopyFrom.roundness ? canApplyRoundnessTypeToElement(elementStylesToCopyFrom.roundness.type, element) ? elementStylesToCopyFrom.roundness : getDefaultRoundnessTypeForElement(element) : null\n          });\n          if (isTextElement(newElement)) {\n            var _elementStylesToCopyF8, _elementStylesToCopyF9, _elementStylesToCopyF10;\n            const fontSize = ((_elementStylesToCopyF8 = elementStylesToCopyFrom) === null || _elementStylesToCopyF8 === void 0 ? void 0 : _elementStylesToCopyF8.fontSize) || DEFAULT_FONT_SIZE;\n            const fontFamily = ((_elementStylesToCopyF9 = elementStylesToCopyFrom) === null || _elementStylesToCopyF9 === void 0 ? void 0 : _elementStylesToCopyF9.fontFamily) || DEFAULT_FONT_FAMILY;\n            newElement = newElementWith(newElement, {\n              fontSize,\n              fontFamily,\n              textAlign: ((_elementStylesToCopyF10 = elementStylesToCopyFrom) === null || _elementStylesToCopyF10 === void 0 ? void 0 : _elementStylesToCopyF10.textAlign) || DEFAULT_TEXT_ALIGN,\n              lineHeight: elementStylesToCopyFrom.lineHeight || getDefaultLineHeight(fontFamily)\n            });\n            let container = null;\n            if (newElement.containerId) {\n              container = selectedElements.find(element => isTextElement(newElement) && element.id === newElement.containerId) || null;\n            }\n            redrawTextBoundingBox(newElement, container);\n          }\n          if (newElement.type === \"arrow\") {\n            newElement = newElementWith(newElement, {\n              startArrowhead: elementStylesToCopyFrom.startArrowhead,\n              endArrowhead: elementStylesToCopyFrom.endArrowhead\n            });\n          }\n          if (isFrameElement(element)) {\n            newElement = newElementWith(newElement, {\n              roundness: null,\n              backgroundColor: \"transparent\"\n            });\n          }\n          return newElement;\n        }\n        return element;\n      }),\n      commitToHistory: true\n    };\n  },\n  contextItemLabel: \"labels.pasteStyles\",\n  keyTest: event => event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V\n});","map":{"version":3,"names":["isTextElement","isExcalidrawElement","redrawTextBoundingBox","CODES","KEYS","t","register","newElementWith","DEFAULT_FONT_SIZE","DEFAULT_FONT_FAMILY","DEFAULT_TEXT_ALIGN","getBoundTextElement","getDefaultLineHeight","hasBoundTextElement","canApplyRoundnessTypeToElement","getDefaultRoundnessTypeForElement","isFrameElement","getSelectedElements","copiedStyles","actionCopyStyles","name","trackEvent","category","perform","elements","appState","elementsCopied","element","find","el","selectedElementIds","id","push","boundTextElement","JSON","stringify","toast","message","commitToHistory","contextItemLabel","keyTest","event","CTRL_OR_CMD","altKey","code","C","actionPasteStyles","parse","pastedElement","selectedElements","includeBoundTextElement","map","includes","_elementStylesToCopyF","_elementStylesToCopyF2","_elementStylesToCopyF3","_elementStylesToCopyF4","_elementStylesToCopyF5","_elementStylesToCopyF6","_elementStylesToCopyF7","elementStylesToCopyFrom","containerId","newElement","backgroundColor","strokeWidth","strokeColor","strokeStyle","fillStyle","opacity","roughness","roundness","type","_elementStylesToCopyF8","_elementStylesToCopyF9","_elementStylesToCopyF10","fontSize","fontFamily","textAlign","lineHeight","container","startArrowhead","endArrowhead","V"],"sources":["D:/project/excalidraw-cn/src/actions/actionStyles.ts"],"sourcesContent":["import {\n  isTextElement,\n  isExcalidrawElement,\n  redrawTextBoundingBox,\n} from \"../element\";\nimport { CODES, KEYS } from \"../keys\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport {\n  DEFAULT_FONT_SIZE,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n} from \"../constants\";\nimport {\n  getBoundTextElement,\n  getDefaultLineHeight,\n} from \"../element/textElement\";\nimport {\n  hasBoundTextElement,\n  canApplyRoundnessTypeToElement,\n  getDefaultRoundnessTypeForElement,\n  isFrameElement,\n} from \"../element/typeChecks\";\nimport { getSelectedElements } from \"../scene\";\n\n// `copiedStyles` is exported only for tests.\nexport let copiedStyles: string = \"{}\";\n\nexport const actionCopyStyles = register({\n  name: \"copyStyles\",\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState) => {\n    const elementsCopied = [];\n    const element = elements.find((el) => appState.selectedElementIds[el.id]);\n    elementsCopied.push(element);\n    if (element && hasBoundTextElement(element)) {\n      const boundTextElement = getBoundTextElement(element);\n      elementsCopied.push(boundTextElement);\n    }\n    if (element) {\n      copiedStyles = JSON.stringify(elementsCopied);\n    }\n    return {\n      appState: {\n        ...appState,\n        toast: { message: t(\"toast.copyStyles\") },\n      },\n      commitToHistory: false,\n    };\n  },\n  contextItemLabel: \"labels.copyStyles\",\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.C,\n});\n\nexport const actionPasteStyles = register({\n  name: \"pasteStyles\",\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState) => {\n    const elementsCopied = JSON.parse(copiedStyles);\n    const pastedElement = elementsCopied[0];\n    const boundTextElement = elementsCopied[1];\n    if (!isExcalidrawElement(pastedElement)) {\n      return { elements, commitToHistory: false };\n    }\n\n    const selectedElements = getSelectedElements(elements, appState, {\n      includeBoundTextElement: true,\n    });\n    const selectedElementIds = selectedElements.map((element) => element.id);\n    return {\n      elements: elements.map((element) => {\n        if (selectedElementIds.includes(element.id)) {\n          let elementStylesToCopyFrom = pastedElement;\n          if (isTextElement(element) && element.containerId) {\n            elementStylesToCopyFrom = boundTextElement;\n          }\n          if (!elementStylesToCopyFrom) {\n            return element;\n          }\n          let newElement = newElementWith(element, {\n            backgroundColor: elementStylesToCopyFrom?.backgroundColor,\n            strokeWidth: elementStylesToCopyFrom?.strokeWidth,\n            strokeColor: elementStylesToCopyFrom?.strokeColor,\n            strokeStyle: elementStylesToCopyFrom?.strokeStyle,\n            fillStyle: elementStylesToCopyFrom?.fillStyle,\n            opacity: elementStylesToCopyFrom?.opacity,\n            roughness: elementStylesToCopyFrom?.roughness,\n            roundness: elementStylesToCopyFrom.roundness\n              ? canApplyRoundnessTypeToElement(\n                  elementStylesToCopyFrom.roundness.type,\n                  element,\n                )\n                ? elementStylesToCopyFrom.roundness\n                : getDefaultRoundnessTypeForElement(element)\n              : null,\n          });\n\n          if (isTextElement(newElement)) {\n            const fontSize =\n              elementStylesToCopyFrom?.fontSize || DEFAULT_FONT_SIZE;\n            const fontFamily =\n              elementStylesToCopyFrom?.fontFamily || DEFAULT_FONT_FAMILY;\n            newElement = newElementWith(newElement, {\n              fontSize,\n              fontFamily,\n              textAlign:\n                elementStylesToCopyFrom?.textAlign || DEFAULT_TEXT_ALIGN,\n              lineHeight:\n                elementStylesToCopyFrom.lineHeight ||\n                getDefaultLineHeight(fontFamily),\n            });\n            let container = null;\n            if (newElement.containerId) {\n              container =\n                selectedElements.find(\n                  (element) =>\n                    isTextElement(newElement) &&\n                    element.id === newElement.containerId,\n                ) || null;\n            }\n            redrawTextBoundingBox(newElement, container);\n          }\n\n          if (newElement.type === \"arrow\") {\n            newElement = newElementWith(newElement, {\n              startArrowhead: elementStylesToCopyFrom.startArrowhead,\n              endArrowhead: elementStylesToCopyFrom.endArrowhead,\n            });\n          }\n\n          if (isFrameElement(element)) {\n            newElement = newElementWith(newElement, {\n              roundness: null,\n              backgroundColor: \"transparent\",\n            });\n          }\n\n          return newElement;\n        }\n        return element;\n      }),\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.pasteStyles\",\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V,\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}