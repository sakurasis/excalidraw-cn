{"ast":null,"code":"import { CODES, KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { copyTextToSystemClipboard, copyToClipboard, probablySupportsClipboardBlob, probablySupportsClipboardWriteText } from \"../clipboard\";\nimport { actionDeleteSelected } from \"./actionDeleteSelected\";\nimport { exportCanvas } from \"../data/index\";\nimport { getNonDeletedElements, isTextElement } from \"../element\";\nimport { t } from \"../i18n\";\nexport const actionCopy = register({\n  name: \"copy\",\n  trackEvent: {\n    category: \"element\"\n  },\n  perform: (elements, appState, _, app) => {\n    const elementsToCopy = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n      includeElementsInFrames: true\n    });\n    copyToClipboard(elementsToCopy, app.files);\n    return {\n      commitToHistory: false\n    };\n  },\n  predicate: (elements, appState, appProps, app) => {\n    return app.device.isMobile && !!navigator.clipboard;\n  },\n  contextItemLabel: \"labels.copy\",\n  // don't supply a shortcut since we handle this conditionally via onCopy event\n  keyTest: undefined\n});\nexport const actionPaste = register({\n  name: \"paste\",\n  trackEvent: {\n    category: \"element\"\n  },\n  perform: (elements, appStates, data, app) => {\n    app.pasteFromClipboard(null);\n    return {\n      commitToHistory: false\n    };\n  },\n  predicate: (elements, appState, appProps, app) => {\n    return app.device.isMobile && !!navigator.clipboard;\n  },\n  contextItemLabel: \"labels.paste\",\n  // don't supply a shortcut since we handle this conditionally via onCopy event\n  keyTest: undefined\n});\nexport const actionCut = register({\n  name: \"cut\",\n  trackEvent: {\n    category: \"element\"\n  },\n  perform: (elements, appState, data, app) => {\n    actionCopy.perform(elements, appState, data, app);\n    return actionDeleteSelected.perform(elements, appState);\n  },\n  predicate: (elements, appState, appProps, app) => {\n    return app.device.isMobile && !!navigator.clipboard;\n  },\n  contextItemLabel: \"labels.cut\",\n  keyTest: event => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.X\n});\nexport const actionCopyAsSvg = register({\n  name: \"copyAsSvg\",\n  trackEvent: {\n    category: \"element\"\n  },\n  perform: async (elements, appState, _data, app) => {\n    if (!app.canvas) {\n      return {\n        commitToHistory: false\n      };\n    }\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n      includeElementsInFrames: true\n    });\n    try {\n      await exportCanvas(\"clipboard-svg\", selectedElements.length ? selectedElements : getNonDeletedElements(elements), appState, app.files, appState);\n      return {\n        commitToHistory: false\n      };\n    } catch (error) {\n      console.error(error);\n      return {\n        appState: {\n          ...appState,\n          errorMessage: error.message\n        },\n        commitToHistory: false\n      };\n    }\n  },\n  predicate: elements => {\n    return probablySupportsClipboardWriteText && elements.length > 0;\n  },\n  contextItemLabel: \"labels.copyAsSvg\"\n});\nexport const actionCopyAsPng = register({\n  name: \"copyAsPng\",\n  trackEvent: {\n    category: \"element\"\n  },\n  perform: async (elements, appState, _data, app) => {\n    if (!app.canvas) {\n      return {\n        commitToHistory: false\n      };\n    }\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n      includeElementsInFrames: true\n    });\n    try {\n      await exportCanvas(\"clipboard\", selectedElements.length ? selectedElements : getNonDeletedElements(elements), appState, app.files, appState);\n      return {\n        appState: {\n          ...appState,\n          toast: {\n            message: t(\"toast.copyToClipboardAsPng\", {\n              exportSelection: selectedElements.length ? t(\"toast.selection\") : t(\"toast.canvas\"),\n              exportColorScheme: appState.exportWithDarkMode ? t(\"buttons.darkMode\") : t(\"buttons.lightMode\")\n            })\n          }\n        },\n        commitToHistory: false\n      };\n    } catch (error) {\n      console.error(error);\n      return {\n        appState: {\n          ...appState,\n          errorMessage: error.message\n        },\n        commitToHistory: false\n      };\n    }\n  },\n  predicate: elements => {\n    return probablySupportsClipboardBlob && elements.length > 0;\n  },\n  contextItemLabel: \"labels.copyAsPng\",\n  keyTest: event => event.code === CODES.C && event.altKey && event.shiftKey\n});\nexport const copyText = register({\n  name: \"copyText\",\n  trackEvent: {\n    category: \"element\"\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true\n    });\n    const text = selectedElements.reduce((acc, element) => {\n      if (isTextElement(element)) {\n        acc.push(element.text);\n      }\n      return acc;\n    }, []).join(\"\\n\\n\");\n    copyTextToSystemClipboard(text);\n    return {\n      commitToHistory: false\n    };\n  },\n  predicate: (elements, appState, _, app) => {\n    return probablySupportsClipboardWriteText && app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true\n    }).some(isTextElement);\n  },\n  contextItemLabel: \"labels.copyText\"\n});","map":{"version":3,"names":["CODES","KEYS","register","copyTextToSystemClipboard","copyToClipboard","probablySupportsClipboardBlob","probablySupportsClipboardWriteText","actionDeleteSelected","exportCanvas","getNonDeletedElements","isTextElement","t","actionCopy","name","trackEvent","category","perform","elements","appState","_","app","elementsToCopy","scene","getSelectedElements","selectedElementIds","includeBoundTextElement","includeElementsInFrames","files","commitToHistory","predicate","appProps","device","isMobile","navigator","clipboard","contextItemLabel","keyTest","undefined","actionPaste","appStates","data","pasteFromClipboard","actionCut","event","CTRL_OR_CMD","key","X","actionCopyAsSvg","_data","canvas","selectedElements","length","error","console","errorMessage","message","actionCopyAsPng","toast","exportSelection","exportColorScheme","exportWithDarkMode","code","C","altKey","shiftKey","copyText","text","reduce","acc","element","push","join","some"],"sources":["D:/project/excalidraw-cn/src/actions/actionClipboard.tsx"],"sourcesContent":["import { CODES, KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport {\n  copyTextToSystemClipboard,\n  copyToClipboard,\n  probablySupportsClipboardBlob,\n  probablySupportsClipboardWriteText,\n} from \"../clipboard\";\nimport { actionDeleteSelected } from \"./actionDeleteSelected\";\nimport { exportCanvas } from \"../data/index\";\nimport { getNonDeletedElements, isTextElement } from \"../element\";\nimport { t } from \"../i18n\";\n\nexport const actionCopy = register({\n  name: \"copy\",\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, _, app) => {\n    const elementsToCopy = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n      includeElementsInFrames: true,\n    });\n\n    copyToClipboard(elementsToCopy, app.files);\n\n    return {\n      commitToHistory: false,\n    };\n  },\n  predicate: (elements, appState, appProps, app) => {\n    return app.device.isMobile && !!navigator.clipboard;\n  },\n  contextItemLabel: \"labels.copy\",\n  // don't supply a shortcut since we handle this conditionally via onCopy event\n  keyTest: undefined,\n});\n\nexport const actionPaste = register({\n  name: \"paste\",\n  trackEvent: { category: \"element\" },\n  perform: (elements: any, appStates: any, data, app) => {\n    app.pasteFromClipboard(null);\n    return {\n      commitToHistory: false,\n    };\n  },\n  predicate: (elements, appState, appProps, app) => {\n    return app.device.isMobile && !!navigator.clipboard;\n  },\n  contextItemLabel: \"labels.paste\",\n  // don't supply a shortcut since we handle this conditionally via onCopy event\n  keyTest: undefined,\n});\n\nexport const actionCut = register({\n  name: \"cut\",\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, data, app) => {\n    actionCopy.perform(elements, appState, data, app);\n    return actionDeleteSelected.perform(elements, appState);\n  },\n  predicate: (elements, appState, appProps, app) => {\n    return app.device.isMobile && !!navigator.clipboard;\n  },\n  contextItemLabel: \"labels.cut\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.X,\n});\n\nexport const actionCopyAsSvg = register({\n  name: \"copyAsSvg\",\n  trackEvent: { category: \"element\" },\n  perform: async (elements, appState, _data, app) => {\n    if (!app.canvas) {\n      return {\n        commitToHistory: false,\n      };\n    }\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n      includeElementsInFrames: true,\n    });\n    try {\n      await exportCanvas(\n        \"clipboard-svg\",\n        selectedElements.length\n          ? selectedElements\n          : getNonDeletedElements(elements),\n        appState,\n        app.files,\n        appState,\n      );\n      return {\n        commitToHistory: false,\n      };\n    } catch (error: any) {\n      console.error(error);\n      return {\n        appState: {\n          ...appState,\n          errorMessage: error.message,\n        },\n        commitToHistory: false,\n      };\n    }\n  },\n  predicate: (elements) => {\n    return probablySupportsClipboardWriteText && elements.length > 0;\n  },\n  contextItemLabel: \"labels.copyAsSvg\",\n});\n\nexport const actionCopyAsPng = register({\n  name: \"copyAsPng\",\n  trackEvent: { category: \"element\" },\n  perform: async (elements, appState, _data, app) => {\n    if (!app.canvas) {\n      return {\n        commitToHistory: false,\n      };\n    }\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n      includeElementsInFrames: true,\n    });\n    try {\n      await exportCanvas(\n        \"clipboard\",\n        selectedElements.length\n          ? selectedElements\n          : getNonDeletedElements(elements),\n        appState,\n        app.files,\n        appState,\n      );\n      return {\n        appState: {\n          ...appState,\n          toast: {\n            message: t(\"toast.copyToClipboardAsPng\", {\n              exportSelection: selectedElements.length\n                ? t(\"toast.selection\")\n                : t(\"toast.canvas\"),\n              exportColorScheme: appState.exportWithDarkMode\n                ? t(\"buttons.darkMode\")\n                : t(\"buttons.lightMode\"),\n            }),\n          },\n        },\n        commitToHistory: false,\n      };\n    } catch (error: any) {\n      console.error(error);\n      return {\n        appState: {\n          ...appState,\n          errorMessage: error.message,\n        },\n        commitToHistory: false,\n      };\n    }\n  },\n  predicate: (elements) => {\n    return probablySupportsClipboardBlob && elements.length > 0;\n  },\n  contextItemLabel: \"labels.copyAsPng\",\n  keyTest: (event) => event.code === CODES.C && event.altKey && event.shiftKey,\n});\n\nexport const copyText = register({\n  name: \"copyText\",\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n    });\n\n    const text = selectedElements\n      .reduce((acc: string[], element) => {\n        if (isTextElement(element)) {\n          acc.push(element.text);\n        }\n        return acc;\n      }, [])\n      .join(\"\\n\\n\");\n    copyTextToSystemClipboard(text);\n    return {\n      commitToHistory: false,\n    };\n  },\n  predicate: (elements, appState, _, app) => {\n    return (\n      probablySupportsClipboardWriteText &&\n      app.scene\n        .getSelectedElements({\n          selectedElementIds: appState.selectedElementIds,\n          includeBoundTextElement: true,\n        })\n        .some(isTextElement)\n    );\n  },\n  contextItemLabel: \"labels.copyText\",\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}