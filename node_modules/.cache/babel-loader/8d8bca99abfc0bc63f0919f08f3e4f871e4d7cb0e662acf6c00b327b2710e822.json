{"ast":null,"code":"import _regeneratorRuntime from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";import _toConsumableArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _asyncToGenerator from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import _objectSpread from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _createClass from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createClass.js\";import _classCallCheck from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import{isTextElement,refreshTextDimensions}from\"../element\";import{newElementWith}from\"../element/mutateElement\";import{isBoundToContainer}from\"../element/typeChecks\";import{invalidateShapeForElement}from\"../renderer/renderElement\";import{getFontString}from\"../utils\";export var Fonts=/*#__PURE__*/_createClass(function Fonts(_ref){var _this=this;var scene=_ref.scene,onSceneUpdated=_ref.onSceneUpdated;_classCallCheck(this,Fonts);this.scene=void 0;this.onSceneUpdated=void 0;/**\n   * if we load a (new) font, it's likely that text elements using it have\n   * already been rendered using a fallback font. Thus, we want invalidate\n   * their shapes and rerender. See #637.\n   *\n   * Invalidates text elements and rerenders scene, provided that at least one\n   * of the supplied fontFaces has not already been processed.\n   */this.onFontsLoaded=function(fontFaces){if(// bail if all fonts with have been processed. We're checking just a\n// subset of the font properties (though it should be enough), so it\n// can technically bail on a false positive.\nfontFaces.every(function(fontFace){var sig=\"\".concat(fontFace.family,\"-\").concat(fontFace.style,\"-\").concat(fontFace.weight);if(Fonts.loadedFontFaces.has(sig)){return true;}Fonts.loadedFontFaces.add(sig);return false;})){return false;}var didUpdate=false;_this.scene.mapElements(function(element){if(isTextElement(element)&&!isBoundToContainer(element)){invalidateShapeForElement(element);didUpdate=true;return newElementWith(element,_objectSpread({},refreshTextDimensions(element)));}return element;});if(didUpdate){_this.onSceneUpdated();}};this.loadFontsForElements=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(elements){var fontFaces;return _regeneratorRuntime().wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:_context.next=2;return Promise.all(_toConsumableArray(new Set(elements.filter(function(element){return isTextElement(element);}).map(function(element){return element.fontFamily;}))).map(function(fontFamily){var _document$fonts,_document$fonts$check;var fontString=getFontString({fontFamily:fontFamily,fontSize:16});if(!((_document$fonts=document.fonts)!==null&&_document$fonts!==void 0&&(_document$fonts$check=_document$fonts.check)!==null&&_document$fonts$check!==void 0&&_document$fonts$check.call(_document$fonts,fontString))){var _document$fonts2,_document$fonts2$load;return(_document$fonts2=document.fonts)===null||_document$fonts2===void 0?void 0:(_document$fonts2$load=_document$fonts2.load)===null||_document$fonts2$load===void 0?void 0:_document$fonts2$load.call(_document$fonts2,fontString);}return undefined;}));case 2:fontFaces=_context.sent;_this.onFontsLoaded(fontFaces.flat().filter(Boolean));case 4:case\"end\":return _context.stop();}},_callee);}));return function(_x){return _ref2.apply(this,arguments);};}();this.scene=scene;this.onSceneUpdated=onSceneUpdated;}// it's ok to track fonts across multiple instances only once, so let's use\n// a static member to reduce memory footprint\n);Fonts.loadedFontFaces=new Set();","map":{"version":3,"names":["isTextElement","refreshTextDimensions","newElementWith","isBoundToContainer","invalidateShapeForElement","getFontString","Fonts","_createClass","_ref","_this","scene","onSceneUpdated","_classCallCheck","onFontsLoaded","fontFaces","every","fontFace","sig","concat","family","style","weight","loadedFontFaces","has","add","didUpdate","mapElements","element","_objectSpread","loadFontsForElements","_ref2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","elements","wrap","_callee$","_context","prev","next","Promise","all","_toConsumableArray","Set","filter","map","fontFamily","_document$fonts","_document$fonts$check","fontString","fontSize","document","fonts","check","call","_document$fonts2","_document$fonts2$load","load","undefined","sent","flat","Boolean","stop","_x","apply","arguments"],"sources":["D:/project/excalidraw-cn/src/scene/Fonts.ts"],"sourcesContent":["import { isTextElement, refreshTextDimensions } from \"../element\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { isBoundToContainer } from \"../element/typeChecks\";\nimport { ExcalidrawElement, ExcalidrawTextElement } from \"../element/types\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport { getFontString } from \"../utils\";\nimport type Scene from \"./Scene\";\n\nexport class Fonts {\n  private scene: Scene;\n  private onSceneUpdated: () => void;\n\n  constructor({\n    scene,\n    onSceneUpdated,\n  }: {\n    scene: Scene;\n    onSceneUpdated: () => void;\n  }) {\n    this.scene = scene;\n    this.onSceneUpdated = onSceneUpdated;\n  }\n\n  // it's ok to track fonts across multiple instances only once, so let's use\n  // a static member to reduce memory footprint\n  private static loadedFontFaces = new Set<string>();\n\n  /**\n   * if we load a (new) font, it's likely that text elements using it have\n   * already been rendered using a fallback font. Thus, we want invalidate\n   * their shapes and rerender. See #637.\n   *\n   * Invalidates text elements and rerenders scene, provided that at least one\n   * of the supplied fontFaces has not already been processed.\n   */\n  public onFontsLoaded = (fontFaces: readonly FontFace[]) => {\n    if (\n      // bail if all fonts with have been processed. We're checking just a\n      // subset of the font properties (though it should be enough), so it\n      // can technically bail on a false positive.\n      fontFaces.every((fontFace) => {\n        const sig = `${fontFace.family}-${fontFace.style}-${fontFace.weight}`;\n        if (Fonts.loadedFontFaces.has(sig)) {\n          return true;\n        }\n        Fonts.loadedFontFaces.add(sig);\n        return false;\n      })\n    ) {\n      return false;\n    }\n\n    let didUpdate = false;\n\n    this.scene.mapElements((element) => {\n      if (isTextElement(element) && !isBoundToContainer(element)) {\n        invalidateShapeForElement(element);\n        didUpdate = true;\n        return newElementWith(element, {\n          ...refreshTextDimensions(element),\n        });\n      }\n      return element;\n    });\n\n    if (didUpdate) {\n      this.onSceneUpdated();\n    }\n  };\n\n  public loadFontsForElements = async (\n    elements: readonly ExcalidrawElement[],\n  ) => {\n    const fontFaces = await Promise.all(\n      [\n        ...new Set(\n          elements\n            .filter((element) => isTextElement(element))\n            .map((element) => (element as ExcalidrawTextElement).fontFamily),\n        ),\n      ].map((fontFamily) => {\n        const fontString = getFontString({\n          fontFamily,\n          fontSize: 16,\n        });\n        if (!document.fonts?.check?.(fontString)) {\n          return document.fonts?.load?.(fontString);\n        }\n        return undefined;\n      }),\n    );\n    this.onFontsLoaded(fontFaces.flat().filter(Boolean) as FontFace[]);\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}