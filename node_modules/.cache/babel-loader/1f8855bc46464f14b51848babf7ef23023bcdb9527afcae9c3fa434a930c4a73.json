{"ast":null,"code":"var crc32 = require('crc-32');\nmodule.exports = extractChunks;\n\n// Used for fast-ish conversion between uint8s and uint32s/int32s.\n// Also required in order to remain agnostic for both Node Buffers and\n// Uint8Arrays.\nvar uint8 = new Uint8Array(4);\nvar int32 = new Int32Array(uint8.buffer);\nvar uint32 = new Uint32Array(uint8.buffer);\nfunction extractChunks(data) {\n  if (data[0] !== 0x89) throw new Error('Invalid .png file header');\n  if (data[1] !== 0x50) throw new Error('Invalid .png file header');\n  if (data[2] !== 0x4E) throw new Error('Invalid .png file header');\n  if (data[3] !== 0x47) throw new Error('Invalid .png file header');\n  if (data[4] !== 0x0D) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?');\n  if (data[5] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?');\n  if (data[6] !== 0x1A) throw new Error('Invalid .png file header');\n  if (data[7] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?');\n  var ended = false;\n  var chunks = [];\n  var idx = 8;\n  while (idx < data.length) {\n    // Read the length of the current chunk,\n    // which is stored as a Uint32.\n    uint8[3] = data[idx++];\n    uint8[2] = data[idx++];\n    uint8[1] = data[idx++];\n    uint8[0] = data[idx++];\n\n    // Chunk includes name/type for CRC check (see below).\n    var length = uint32[0] + 4;\n    var chunk = new Uint8Array(length);\n    chunk[0] = data[idx++];\n    chunk[1] = data[idx++];\n    chunk[2] = data[idx++];\n    chunk[3] = data[idx++];\n\n    // Get the name in ASCII for identification.\n    var name = String.fromCharCode(chunk[0]) + String.fromCharCode(chunk[1]) + String.fromCharCode(chunk[2]) + String.fromCharCode(chunk[3]);\n\n    // The IHDR header MUST come first.\n    if (!chunks.length && name !== 'IHDR') {\n      throw new Error('IHDR header missing');\n    }\n\n    // The IEND header marks the end of the file,\n    // so on discovering it break out of the loop.\n    if (name === 'IEND') {\n      ended = true;\n      chunks.push({\n        name: name,\n        data: new Uint8Array(0)\n      });\n      break;\n    }\n\n    // Read the contents of the chunk out of the main buffer.\n    for (var i = 4; i < length; i++) {\n      chunk[i] = data[idx++];\n    }\n\n    // Read out the CRC value for comparison.\n    // It's stored as an Int32.\n    uint8[3] = data[idx++];\n    uint8[2] = data[idx++];\n    uint8[1] = data[idx++];\n    uint8[0] = data[idx++];\n    var crcActual = int32[0];\n    var crcExpect = crc32.buf(chunk);\n    if (crcExpect !== crcActual) {\n      throw new Error('CRC values for ' + name + ' header do not match, PNG file is likely corrupted');\n    }\n\n    // The chunk data is now copied to remove the 4 preceding\n    // bytes used for the chunk name/type.\n    var chunkData = new Uint8Array(chunk.buffer.slice(4));\n    chunks.push({\n      name: name,\n      data: chunkData\n    });\n  }\n  if (!ended) {\n    throw new Error('.png file ended prematurely: no IEND header was found');\n  }\n  return chunks;\n}","map":{"version":3,"names":["crc32","require","module","exports","extractChunks","uint8","Uint8Array","int32","Int32Array","buffer","uint32","Uint32Array","data","Error","ended","chunks","idx","length","chunk","name","String","fromCharCode","push","i","crcActual","crcExpect","buf","chunkData","slice"],"sources":["D:/project/excalidraw-cn/node_modules/png-chunks-extract/index.js"],"sourcesContent":["var crc32 = require('crc-32')\n\nmodule.exports = extractChunks\n\n// Used for fast-ish conversion between uint8s and uint32s/int32s.\n// Also required in order to remain agnostic for both Node Buffers and\n// Uint8Arrays.\nvar uint8 = new Uint8Array(4)\nvar int32 = new Int32Array(uint8.buffer)\nvar uint32 = new Uint32Array(uint8.buffer)\n\nfunction extractChunks (data) {\n  if (data[0] !== 0x89) throw new Error('Invalid .png file header')\n  if (data[1] !== 0x50) throw new Error('Invalid .png file header')\n  if (data[2] !== 0x4E) throw new Error('Invalid .png file header')\n  if (data[3] !== 0x47) throw new Error('Invalid .png file header')\n  if (data[4] !== 0x0D) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[5] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[6] !== 0x1A) throw new Error('Invalid .png file header')\n  if (data[7] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n\n  var ended = false\n  var chunks = []\n  var idx = 8\n\n  while (idx < data.length) {\n    // Read the length of the current chunk,\n    // which is stored as a Uint32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    // Chunk includes name/type for CRC check (see below).\n    var length = uint32[0] + 4\n    var chunk = new Uint8Array(length)\n    chunk[0] = data[idx++]\n    chunk[1] = data[idx++]\n    chunk[2] = data[idx++]\n    chunk[3] = data[idx++]\n\n    // Get the name in ASCII for identification.\n    var name = (\n      String.fromCharCode(chunk[0]) +\n      String.fromCharCode(chunk[1]) +\n      String.fromCharCode(chunk[2]) +\n      String.fromCharCode(chunk[3])\n    )\n\n    // The IHDR header MUST come first.\n    if (!chunks.length && name !== 'IHDR') {\n      throw new Error('IHDR header missing')\n    }\n\n    // The IEND header marks the end of the file,\n    // so on discovering it break out of the loop.\n    if (name === 'IEND') {\n      ended = true\n      chunks.push({\n        name: name,\n        data: new Uint8Array(0)\n      })\n\n      break\n    }\n\n    // Read the contents of the chunk out of the main buffer.\n    for (var i = 4; i < length; i++) {\n      chunk[i] = data[idx++]\n    }\n\n    // Read out the CRC value for comparison.\n    // It's stored as an Int32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    var crcActual = int32[0]\n    var crcExpect = crc32.buf(chunk)\n    if (crcExpect !== crcActual) {\n      throw new Error(\n        'CRC values for ' + name + ' header do not match, PNG file is likely corrupted'\n      )\n    }\n\n    // The chunk data is now copied to remove the 4 preceding\n    // bytes used for the chunk name/type.\n    var chunkData = new Uint8Array(chunk.buffer.slice(4))\n\n    chunks.push({\n      name: name,\n      data: chunkData\n    })\n  }\n\n  if (!ended) {\n    throw new Error('.png file ended prematurely: no IEND header was found')\n  }\n\n  return chunks\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}