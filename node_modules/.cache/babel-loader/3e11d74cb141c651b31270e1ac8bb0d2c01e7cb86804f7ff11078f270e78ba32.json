{"ast":null,"code":"import oc from \"open-color\";\nimport { getElementAbsoluteCoords, OMIT_SIDES_FOR_MULTIPLE_ELEMENTS, getTransformHandlesFromCoords, getTransformHandles, getElementBounds, getCommonBounds } from \"../element\";\nimport { roundRect } from \"./roundRect\";\nimport { getScrollBars, SCROLLBAR_COLOR, SCROLLBAR_WIDTH } from \"../scene/scrollbars\";\nimport { getSelectedElements } from \"../scene/selection\";\nimport { renderElement, renderElementToSvg } from \"./renderElement\";\nimport { getClientColor } from \"../clients\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { isSelectedViaGroup, getSelectedGroupIds, getElementsInGroup, selectGroupsFromGivenElements } from \"../groups\";\nimport { maxBindingGap } from \"../element/collision\";\nimport { isBindingEnabled } from \"../element/binding\";\nimport { OMIT_SIDES_FOR_FRAME, shouldShowBoundingBox } from \"../element/transformHandles\";\nimport { viewportCoordsToSceneCoords, throttleRAF, isOnlyExportingSingleFrame } from \"../utils\";\nimport { UserIdleState } from \"../types\";\nimport { FRAME_STYLE, THEME_FILTER } from \"../constants\";\nimport { EXTERNAL_LINK_IMG, getLinkHandleFromCoords } from \"../element/Hyperlink\";\nimport { isFrameElement, isLinearElement } from \"../element/typeChecks\";\nimport { elementOverlapsWithFrame, getTargetFrame, isElementInFrame } from \"../frame\";\nimport \"canvas-roundrect-polyfill\";\nexport const DEFAULT_SPACING = 2;\nconst strokeRectWithRotation = function (context, x, y, width, height, cx, cy, angle) {\n  let fill = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;\n  let radius = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n  if (fill) {\n    context.fillRect(x - cx, y - cy, width, height);\n  }\n  if (radius && context.roundRect) {\n    context.beginPath();\n    context.roundRect(x - cx, y - cy, width, height, radius);\n    context.stroke();\n    context.closePath();\n  } else {\n    context.strokeRect(x - cx, y - cy, width, height);\n  }\n  context.restore();\n};\nconst strokeDiamondWithRotation = (context, width, height, cx, cy, angle) => {\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.beginPath();\n  context.moveTo(0, height / 2);\n  context.lineTo(width / 2, 0);\n  context.lineTo(0, -height / 2);\n  context.lineTo(-width / 2, 0);\n  context.closePath();\n  context.stroke();\n  context.restore();\n};\nconst strokeEllipseWithRotation = (context, width, height, cx, cy, angle) => {\n  context.beginPath();\n  context.ellipse(cx, cy, width / 2, height / 2, angle, 0, Math.PI * 2);\n  context.stroke();\n};\nconst fillCircle = function (context, cx, cy, radius) {\n  let stroke = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  context.beginPath();\n  context.arc(cx, cy, radius, 0, Math.PI * 2);\n  context.fill();\n  if (stroke) {\n    context.stroke();\n  }\n};\nconst strokeGrid = (context, gridSize, offsetX, offsetY, width, height) => {\n  context.save();\n  context.strokeStyle = \"rgba(0,0,0,0.1)\";\n  context.beginPath();\n  for (let x = offsetX; x < offsetX + width + gridSize * 2; x += gridSize) {\n    context.moveTo(x, offsetY - gridSize);\n    context.lineTo(x, offsetY + height + gridSize * 2);\n  }\n  for (let y = offsetY; y < offsetY + height + gridSize * 2; y += gridSize) {\n    context.moveTo(offsetX - gridSize, y);\n    context.lineTo(offsetX + width + gridSize * 2, y);\n  }\n  context.stroke();\n  context.restore();\n};\nconst renderSingleLinearPoint = function (context, renderConfig, point, radius, isSelected) {\n  let isPhantomPoint = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  context.strokeStyle = \"#5e5ad8\";\n  context.setLineDash([]);\n  context.fillStyle = \"rgba(255, 255, 255, 0.9)\";\n  if (isSelected) {\n    context.fillStyle = \"rgba(134, 131, 226, 0.9)\";\n  } else if (isPhantomPoint) {\n    context.fillStyle = \"rgba(177, 151, 252, 0.7)\";\n  }\n  fillCircle(context, point[0], point[1], radius / renderConfig.zoom.value, !isPhantomPoint);\n};\nconst renderLinearPointHandles = (context, appState, renderConfig, element) => {\n  if (!appState.selectedLinearElement) {\n    return;\n  }\n  context.save();\n  context.translate(renderConfig.scrollX, renderConfig.scrollY);\n  context.lineWidth = 1 / renderConfig.zoom.value;\n  const points = LinearElementEditor.getPointsGlobalCoordinates(element);\n  const {\n    POINT_HANDLE_SIZE\n  } = LinearElementEditor;\n  const radius = appState.editingLinearElement ? POINT_HANDLE_SIZE : POINT_HANDLE_SIZE / 2;\n  points.forEach((point, idx) => {\n    var _appState$editingLine, _appState$editingLine2;\n    const isSelected = !!((_appState$editingLine = appState.editingLinearElement) !== null && _appState$editingLine !== void 0 && (_appState$editingLine2 = _appState$editingLine.selectedPointsIndices) !== null && _appState$editingLine2 !== void 0 && _appState$editingLine2.includes(idx));\n    renderSingleLinearPoint(context, renderConfig, point, radius, isSelected);\n  });\n\n  //Rendering segment mid points\n  const midPoints = LinearElementEditor.getEditorMidPoints(element, appState).filter(midPoint => midPoint !== null);\n  midPoints.forEach(segmentMidPoint => {\n    var _appState$selectedLin;\n    if (appState !== null && appState !== void 0 && (_appState$selectedLin = appState.selectedLinearElement) !== null && _appState$selectedLin !== void 0 && _appState$selectedLin.segmentMidPointHoveredCoords && LinearElementEditor.arePointsEqual(segmentMidPoint, appState.selectedLinearElement.segmentMidPointHoveredCoords)) {\n      // The order of renderingSingleLinearPoint and highLight points is different\n      // inside vs outside editor as hover states are different,\n      // in editor when hovered the original point is not visible as hover state fully covers it whereas outside the\n      // editor original point is visible and hover state is just an outer circle.\n      if (appState.editingLinearElement) {\n        renderSingleLinearPoint(context, renderConfig, segmentMidPoint, radius, false);\n        highlightPoint(segmentMidPoint, context, renderConfig);\n      } else {\n        highlightPoint(segmentMidPoint, context, renderConfig);\n        renderSingleLinearPoint(context, renderConfig, segmentMidPoint, radius, false);\n      }\n    } else if (appState.editingLinearElement || points.length === 2) {\n      renderSingleLinearPoint(context, renderConfig, segmentMidPoint, POINT_HANDLE_SIZE / 2, false, true);\n    }\n  });\n  context.restore();\n};\nconst highlightPoint = (point, context, renderConfig) => {\n  context.fillStyle = \"rgba(105, 101, 219, 0.4)\";\n  fillCircle(context, point[0], point[1], LinearElementEditor.POINT_HANDLE_SIZE / renderConfig.zoom.value, false);\n};\nconst renderLinearElementPointHighlight = (context, appState, renderConfig) => {\n  var _appState$editingLine3, _appState$editingLine4;\n  const {\n    elementId,\n    hoverPointIndex\n  } = appState.selectedLinearElement;\n  if ((_appState$editingLine3 = appState.editingLinearElement) !== null && _appState$editingLine3 !== void 0 && (_appState$editingLine4 = _appState$editingLine3.selectedPointsIndices) !== null && _appState$editingLine4 !== void 0 && _appState$editingLine4.includes(hoverPointIndex)) {\n    return;\n  }\n  const element = LinearElementEditor.getElement(elementId);\n  if (!element) {\n    return;\n  }\n  const point = LinearElementEditor.getPointAtIndexGlobalCoordinates(element, hoverPointIndex);\n  context.save();\n  context.translate(renderConfig.scrollX, renderConfig.scrollY);\n  highlightPoint(point, context, renderConfig);\n  context.restore();\n};\nconst frameClip = (frame, context, renderConfig) => {\n  context.translate(frame.x + renderConfig.scrollX, frame.y + renderConfig.scrollY);\n  context.beginPath();\n  if (context.roundRect && !renderConfig.isExporting) {\n    context.roundRect(0, 0, frame.width, frame.height, FRAME_STYLE.radius / renderConfig.zoom.value);\n  } else {\n    context.rect(0, 0, frame.width, frame.height);\n  }\n  context.clip();\n  context.translate(-(frame.x + renderConfig.scrollX), -(frame.y + renderConfig.scrollY));\n};\nexport const _renderScene = _ref =>\n// extra options passed to the renderer\n{\n  var _appState$editingLine6;\n  let {\n    elements,\n    appState,\n    scale,\n    rc,\n    canvas,\n    renderConfig\n  } = _ref;\n  if (canvas === null) {\n    return {\n      atLeastOneVisibleElement: false\n    };\n  }\n  const {\n    renderScrollbars = false,\n    renderSelection = true,\n    renderGrid = true,\n    isExporting\n  } = renderConfig;\n  const selectionColor = renderConfig.selectionColor || oc.black;\n  const context = canvas.getContext(\"2d\");\n  context.setTransform(1, 0, 0, 1, 0, 0);\n  context.save();\n  context.scale(scale, scale);\n  // When doing calculations based on canvas width we should used normalized one\n  const normalizedCanvasWidth = canvas.width / scale;\n  const normalizedCanvasHeight = canvas.height / scale;\n  if (isExporting && renderConfig.theme === \"dark\") {\n    context.filter = THEME_FILTER;\n  }\n\n  // Paint background\n  if (typeof renderConfig.viewBackgroundColor === \"string\") {\n    const hasTransparence = renderConfig.viewBackgroundColor === \"transparent\" || renderConfig.viewBackgroundColor.length === 5 ||\n    // #RGBA\n    renderConfig.viewBackgroundColor.length === 9 ||\n    // #RRGGBBA\n    /(hsla|rgba)\\(/.test(renderConfig.viewBackgroundColor);\n    if (hasTransparence) {\n      context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    }\n    context.save();\n    context.fillStyle = renderConfig.viewBackgroundColor;\n    context.fillRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    context.restore();\n  } else {\n    context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n  }\n\n  // Apply zoom\n  context.save();\n  context.scale(renderConfig.zoom.value, renderConfig.zoom.value);\n\n  // Grid\n  if (renderGrid && appState.gridSize) {\n    strokeGrid(context, appState.gridSize, -Math.ceil(renderConfig.zoom.value / appState.gridSize) * appState.gridSize + renderConfig.scrollX % appState.gridSize, -Math.ceil(renderConfig.zoom.value / appState.gridSize) * appState.gridSize + renderConfig.scrollY % appState.gridSize, normalizedCanvasWidth / renderConfig.zoom.value, normalizedCanvasHeight / renderConfig.zoom.value);\n  }\n\n  // Paint visible elements\n  const visibleElements = elements.filter(element => isVisibleElement(element, normalizedCanvasWidth, normalizedCanvasHeight, {\n    zoom: renderConfig.zoom,\n    offsetLeft: appState.offsetLeft,\n    offsetTop: appState.offsetTop,\n    scrollX: renderConfig.scrollX,\n    scrollY: renderConfig.scrollY\n  }));\n  const groupsToBeAddedToFrame = new Set();\n  visibleElements.forEach(element => {\n    if (element.groupIds.length > 0 && appState.frameToHighlight && appState.selectedElementIds[element.id] && (elementOverlapsWithFrame(element, appState.frameToHighlight) || element.groupIds.find(groupId => groupsToBeAddedToFrame.has(groupId)))) {\n      element.groupIds.forEach(groupId => groupsToBeAddedToFrame.add(groupId));\n    }\n  });\n  let editingLinearElement = undefined;\n  visibleElements.forEach(element => {\n    try {\n      var _appState$frameToHigh, _appState$editingLine5;\n      // - when exporting the whole canvas, we DO NOT apply clipping\n      // - when we are exporting a particular frame, apply clipping\n      //   if the containing frame is not selected, apply clipping\n      const frameId = element.frameId || ((_appState$frameToHigh = appState.frameToHighlight) === null || _appState$frameToHigh === void 0 ? void 0 : _appState$frameToHigh.id);\n      if (frameId && (renderConfig.isExporting && isOnlyExportingSingleFrame(elements) || !renderConfig.isExporting && appState.frameRendering.enabled && appState.frameRendering.clip)) {\n        context.save();\n        const frame = getTargetFrame(element, appState);\n        if (frame && isElementInFrame(element, elements, appState)) {\n          frameClip(frame, context, renderConfig);\n        }\n        renderElement(element, rc, context, renderConfig, appState);\n        context.restore();\n      } else {\n        renderElement(element, rc, context, renderConfig, appState);\n      }\n      // Getting the element using LinearElementEditor during collab mismatches version - being one head of visible elements due to\n      // ShapeCache returns empty hence making sure that we get the\n      // correct element from visible elements\n      if (((_appState$editingLine5 = appState.editingLinearElement) === null || _appState$editingLine5 === void 0 ? void 0 : _appState$editingLine5.elementId) === element.id) {\n        if (element) {\n          editingLinearElement = element;\n        }\n      }\n      if (!isExporting) {\n        renderLinkIcon(element, context, appState);\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  });\n  if (editingLinearElement) {\n    renderLinearPointHandles(context, appState, renderConfig, editingLinearElement);\n  }\n\n  // Paint selection element\n  if (appState.selectionElement) {\n    try {\n      renderElement(appState.selectionElement, rc, context, renderConfig, appState);\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  if (isBindingEnabled(appState)) {\n    appState.suggestedBindings.filter(binding => binding != null).forEach(suggestedBinding => {\n      renderBindingHighlight(context, renderConfig, suggestedBinding);\n    });\n  }\n  if (appState.frameToHighlight) {\n    renderFrameHighlight(context, renderConfig, appState.frameToHighlight);\n  }\n  if (appState.elementsToHighlight) {\n    renderElementsBoxHighlight(context, renderConfig, appState.elementsToHighlight, appState);\n  }\n  const locallySelectedElements = getSelectedElements(elements, appState);\n  const isFrameSelected = locallySelectedElements.some(element => isFrameElement(element));\n\n  // Getting the element using LinearElementEditor during collab mismatches version - being one head of visible elements due to\n  // ShapeCache returns empty hence making sure that we get the\n  // correct element from visible elements\n  if (locallySelectedElements.length === 1 && ((_appState$editingLine6 = appState.editingLinearElement) === null || _appState$editingLine6 === void 0 ? void 0 : _appState$editingLine6.elementId) === locallySelectedElements[0].id) {\n    renderLinearPointHandles(context, appState, renderConfig, locallySelectedElements[0]);\n  }\n  if (appState.selectedLinearElement && appState.selectedLinearElement.hoverPointIndex >= 0) {\n    renderLinearElementPointHighlight(context, appState, renderConfig);\n  }\n  // Paint selected elements\n  if (renderSelection && !appState.multiElement && !appState.editingLinearElement) {\n    var _appState$selectedLin2;\n    const showBoundingBox = shouldShowBoundingBox(locallySelectedElements, appState);\n    const locallySelectedIds = locallySelectedElements.map(element => element.id);\n    const isSingleLinearElementSelected = locallySelectedElements.length === 1 && isLinearElement(locallySelectedElements[0]);\n    // render selected linear element points\n    if (isSingleLinearElementSelected && ((_appState$selectedLin2 = appState.selectedLinearElement) === null || _appState$selectedLin2 === void 0 ? void 0 : _appState$selectedLin2.elementId) === locallySelectedElements[0].id && !locallySelectedElements[0].locked) {\n      renderLinearPointHandles(context, appState, renderConfig, locallySelectedElements[0]);\n    }\n    if (showBoundingBox) {\n      const selections = elements.reduce((acc, element) => {\n        const selectionColors = [];\n        // local user\n        if (locallySelectedIds.includes(element.id) && !isSelectedViaGroup(appState, element)) {\n          selectionColors.push(selectionColor);\n        }\n        // remote users\n        if (renderConfig.remoteSelectedElementIds[element.id]) {\n          selectionColors.push(...renderConfig.remoteSelectedElementIds[element.id].map(socketId => {\n            const background = getClientColor(socketId);\n            return background;\n          }));\n        }\n        if (selectionColors.length) {\n          const [elementX1, elementY1, elementX2, elementY2, cx, cy] = getElementAbsoluteCoords(element, true);\n          acc.push({\n            angle: element.angle,\n            elementX1,\n            elementY1,\n            elementX2,\n            elementY2,\n            selectionColors,\n            dashed: !!renderConfig.remoteSelectedElementIds[element.id],\n            cx,\n            cy\n          });\n        }\n        return acc;\n      }, []);\n      const addSelectionForGroupId = groupId => {\n        const groupElements = getElementsInGroup(elements, groupId);\n        const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(groupElements);\n        selections.push({\n          angle: 0,\n          elementX1,\n          elementX2,\n          elementY1,\n          elementY2,\n          selectionColors: [oc.black],\n          dashed: true,\n          cx: elementX1 + (elementX2 - elementX1) / 2,\n          cy: elementY1 + (elementY2 - elementY1) / 2\n        });\n      };\n      for (const groupId of getSelectedGroupIds(appState)) {\n        // TODO: support multiplayer selected group IDs\n        addSelectionForGroupId(groupId);\n      }\n      if (appState.editingGroupId) {\n        addSelectionForGroupId(appState.editingGroupId);\n      }\n      selections.forEach(selection => renderSelectionBorder(context, renderConfig, selection));\n    }\n    // Paint resize transformHandles\n    context.save();\n    context.translate(renderConfig.scrollX, renderConfig.scrollY);\n    if (locallySelectedElements.length === 1) {\n      context.fillStyle = oc.white;\n      const transformHandles = getTransformHandles(locallySelectedElements[0], renderConfig.zoom, \"mouse\" // when we render we don't know which pointer type so use mouse\n      );\n\n      if (!appState.viewModeEnabled && showBoundingBox) {\n        renderTransformHandles(context, renderConfig, transformHandles, locallySelectedElements[0].angle);\n      }\n    } else if (locallySelectedElements.length > 1 && !appState.isRotating) {\n      const dashedLinePadding = DEFAULT_SPACING * 2 / renderConfig.zoom.value;\n      context.fillStyle = oc.white;\n      const [x1, y1, x2, y2] = getCommonBounds(locallySelectedElements);\n      const initialLineDash = context.getLineDash();\n      context.setLineDash([2 / renderConfig.zoom.value]);\n      const lineWidth = context.lineWidth;\n      context.lineWidth = 1 / renderConfig.zoom.value;\n      context.strokeStyle = selectionColor;\n      strokeRectWithRotation(context, x1 - dashedLinePadding, y1 - dashedLinePadding, x2 - x1 + dashedLinePadding * 2, y2 - y1 + dashedLinePadding * 2, (x1 + x2) / 2, (y1 + y2) / 2, 0);\n      context.lineWidth = lineWidth;\n      context.setLineDash(initialLineDash);\n      const transformHandles = getTransformHandlesFromCoords([x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2], 0, renderConfig.zoom, \"mouse\", isFrameSelected ? OMIT_SIDES_FOR_FRAME : OMIT_SIDES_FOR_MULTIPLE_ELEMENTS);\n      if (locallySelectedElements.some(element => !element.locked)) {\n        renderTransformHandles(context, renderConfig, transformHandles, 0);\n      }\n    }\n    context.restore();\n  }\n\n  // Reset zoom\n  context.restore();\n\n  // Paint remote pointers\n  for (const clientId in renderConfig.remotePointerViewportCoords) {\n    let {\n      x,\n      y\n    } = renderConfig.remotePointerViewportCoords[clientId];\n    x -= appState.offsetLeft;\n    y -= appState.offsetTop;\n    const width = 11;\n    const height = 14;\n    const isOutOfBounds = x < 0 || x > normalizedCanvasWidth - width || y < 0 || y > normalizedCanvasHeight - height;\n    x = Math.max(x, 0);\n    x = Math.min(x, normalizedCanvasWidth - width);\n    y = Math.max(y, 0);\n    y = Math.min(y, normalizedCanvasHeight - height);\n    const background = getClientColor(clientId);\n    context.save();\n    context.strokeStyle = background;\n    context.fillStyle = background;\n    const userState = renderConfig.remotePointerUserStates[clientId];\n    const isInactive = isOutOfBounds || userState === UserIdleState.IDLE || userState === UserIdleState.AWAY;\n    if (isInactive) {\n      context.globalAlpha = 0.3;\n    }\n    if (renderConfig.remotePointerButton && renderConfig.remotePointerButton[clientId] === \"down\") {\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 3;\n      context.strokeStyle = \"#ffffff88\";\n      context.stroke();\n      context.closePath();\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 1;\n      context.strokeStyle = background;\n      context.stroke();\n      context.closePath();\n    }\n\n    // Background (white outline) for arrow\n    context.fillStyle = oc.white;\n    context.strokeStyle = oc.white;\n    context.lineWidth = 6;\n    context.lineJoin = \"round\";\n    context.beginPath();\n    context.moveTo(x, y);\n    context.lineTo(x + 0, y + 14);\n    context.lineTo(x + 4, y + 9);\n    context.lineTo(x + 11, y + 8);\n    context.closePath();\n    context.stroke();\n    context.fill();\n\n    // Arrow\n    context.fillStyle = background;\n    context.strokeStyle = background;\n    context.lineWidth = 2;\n    context.lineJoin = \"round\";\n    context.beginPath();\n    if (isInactive) {\n      context.moveTo(x - 1, y - 1);\n      context.lineTo(x - 1, y + 15);\n      context.lineTo(x + 5, y + 10);\n      context.lineTo(x + 12, y + 9);\n      context.closePath();\n      context.fill();\n    } else {\n      context.moveTo(x, y);\n      context.lineTo(x + 0, y + 14);\n      context.lineTo(x + 4, y + 9);\n      context.lineTo(x + 11, y + 8);\n      context.closePath();\n      context.fill();\n      context.stroke();\n    }\n    const username = renderConfig.remotePointerUsernames[clientId] || \"\";\n    if (!isOutOfBounds && username) {\n      context.font = \"600 12px sans-serif\"; // font has to be set before context.measureText()\n\n      const offsetX = x + width / 2;\n      const offsetY = y + height + 2;\n      const paddingHorizontal = 5;\n      const paddingVertical = 3;\n      const measure = context.measureText(username);\n      const measureHeight = measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;\n      const finalHeight = Math.max(measureHeight, 12);\n      const boxX = offsetX - 1;\n      const boxY = offsetY - 1;\n      const boxWidth = measure.width + 2 + paddingHorizontal * 2 + 2;\n      const boxHeight = finalHeight + 2 + paddingVertical * 2 + 2;\n      if (context.roundRect) {\n        context.beginPath();\n        context.roundRect(boxX, boxY, boxWidth, boxHeight, 8);\n        context.fillStyle = background;\n        context.fill();\n        context.strokeStyle = oc.white;\n        context.stroke();\n      } else {\n        roundRect(context, boxX, boxY, boxWidth, boxHeight, 8, oc.white);\n      }\n      context.fillStyle = oc.black;\n      context.fillText(username, offsetX + paddingHorizontal + 1, offsetY + paddingVertical + measure.actualBoundingBoxAscent + Math.floor((finalHeight - measureHeight) / 2) + 2);\n    }\n    context.restore();\n    context.closePath();\n  }\n\n  // Paint scrollbars\n  let scrollBars;\n  if (renderScrollbars) {\n    scrollBars = getScrollBars(elements, normalizedCanvasWidth, normalizedCanvasHeight, renderConfig);\n    context.save();\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach(scrollBar => {\n      if (scrollBar) {\n        roundRect(context, scrollBar.x, scrollBar.y, scrollBar.width, scrollBar.height, SCROLLBAR_WIDTH / 2);\n      }\n    });\n    context.restore();\n  }\n  context.restore();\n  return {\n    atLeastOneVisibleElement: visibleElements.length > 0,\n    scrollBars\n  };\n};\nconst renderSceneThrottled = throttleRAF(config => {\n  var _config$callback;\n  const ret = _renderScene(config);\n  (_config$callback = config.callback) === null || _config$callback === void 0 ? void 0 : _config$callback.call(config, ret);\n}, {\n  trailing: true\n});\n\n/** renderScene throttled to animation framerate */\nexport const renderScene = (config, throttle) => {\n  var _config$callback2;\n  if (throttle) {\n    renderSceneThrottled(config);\n    return undefined;\n  }\n  const ret = _renderScene(config);\n  (_config$callback2 = config.callback) === null || _config$callback2 === void 0 ? void 0 : _config$callback2.call(config, ret);\n  return ret;\n};\nconst renderTransformHandles = (context, renderConfig, transformHandles, angle) => {\n  Object.keys(transformHandles).forEach(key => {\n    const transformHandle = transformHandles[key];\n    if (transformHandle !== undefined) {\n      const [x, y, width, height] = transformHandle;\n      context.save();\n      context.lineWidth = 1 / renderConfig.zoom.value;\n      if (renderConfig.selectionColor) {\n        context.strokeStyle = renderConfig.selectionColor;\n      }\n      if (key === \"rotation\") {\n        fillCircle(context, x + width / 2, y + height / 2, width / 2);\n        // prefer round corners if roundRect API is available\n      } else if (context.roundRect) {\n        context.beginPath();\n        context.roundRect(x, y, width, height, 2 / renderConfig.zoom.value);\n        context.fill();\n        context.stroke();\n      } else {\n        strokeRectWithRotation(context, x, y, width, height, x + width / 2, y + height / 2, angle, true // fill before stroke\n        );\n      }\n\n      context.restore();\n    }\n  });\n};\nconst renderSelectionBorder = function (context, renderConfig, elementProperties) {\n  let padding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_SPACING * 2;\n  const {\n    angle,\n    elementX1,\n    elementY1,\n    elementX2,\n    elementY2,\n    selectionColors,\n    cx,\n    cy,\n    dashed\n  } = elementProperties;\n  const elementWidth = elementX2 - elementX1;\n  const elementHeight = elementY2 - elementY1;\n  const linePadding = padding / renderConfig.zoom.value;\n  const lineWidth = 8 / renderConfig.zoom.value;\n  const spaceWidth = 4 / renderConfig.zoom.value;\n  context.save();\n  context.translate(renderConfig.scrollX, renderConfig.scrollY);\n  context.lineWidth = 1 / renderConfig.zoom.value;\n  const count = selectionColors.length;\n  for (let index = 0; index < count; ++index) {\n    context.strokeStyle = selectionColors[index];\n    if (dashed) {\n      context.setLineDash([lineWidth, spaceWidth + (lineWidth + spaceWidth) * (count - 1)]);\n    }\n    context.lineDashOffset = (lineWidth + spaceWidth) * index;\n    strokeRectWithRotation(context, elementX1 - linePadding, elementY1 - linePadding, elementWidth + linePadding * 2, elementHeight + linePadding * 2, cx, cy, angle);\n  }\n  context.restore();\n};\nconst renderBindingHighlight = (context, renderConfig, suggestedBinding) => {\n  const renderHighlight = Array.isArray(suggestedBinding) ? renderBindingHighlightForSuggestedPointBinding : renderBindingHighlightForBindableElement;\n  context.save();\n  context.translate(renderConfig.scrollX, renderConfig.scrollY);\n  renderHighlight(context, suggestedBinding);\n  context.restore();\n};\nconst renderBindingHighlightForBindableElement = (context, element) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const threshold = maxBindingGap(element, width, height);\n\n  // So that we don't overlap the element itself\n  const strokeOffset = 4;\n  context.strokeStyle = \"rgba(0,0,0,.05)\";\n  context.lineWidth = threshold - strokeOffset;\n  const padding = strokeOffset / 2 + threshold / 2;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"image\":\n    case \"frame\":\n      strokeRectWithRotation(context, x1 - padding, y1 - padding, width + padding * 2, height + padding * 2, x1 + width / 2, y1 + height / 2, element.angle);\n      break;\n    case \"diamond\":\n      const side = Math.hypot(width, height);\n      const wPadding = padding * side / height;\n      const hPadding = padding * side / width;\n      strokeDiamondWithRotation(context, width + wPadding * 2, height + hPadding * 2, x1 + width / 2, y1 + height / 2, element.angle);\n      break;\n    case \"ellipse\":\n      strokeEllipseWithRotation(context, width + padding * 2, height + padding * 2, x1 + width / 2, y1 + height / 2, element.angle);\n      break;\n  }\n};\nconst renderFrameHighlight = (context, renderConfig, frame) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(frame);\n  const width = x2 - x1;\n  const height = y2 - y1;\n  context.strokeStyle = \"rgb(0,118,255)\";\n  context.lineWidth = FRAME_STYLE.strokeWidth * 2 / renderConfig.zoom.value;\n  context.save();\n  context.translate(renderConfig.scrollX, renderConfig.scrollY);\n  strokeRectWithRotation(context, x1, y1, width, height, x1 + width / 2, y1 + height / 2, frame.angle, false, FRAME_STYLE.radius / renderConfig.zoom.value);\n  context.restore();\n};\nconst renderElementsBoxHighlight = (context, renderConfig, elements, appState) => {\n  const individualElements = elements.filter(element => element.groupIds.length === 0);\n  const elementsInGroups = elements.filter(element => element.groupIds.length > 0);\n  const getSelectionFromElements = elements => {\n    const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(elements);\n    return {\n      angle: 0,\n      elementX1,\n      elementX2,\n      elementY1,\n      elementY2,\n      selectionColors: [\"rgb(0,118,255)\"],\n      dashed: false,\n      cx: elementX1 + (elementX2 - elementX1) / 2,\n      cy: elementY1 + (elementY2 - elementY1) / 2\n    };\n  };\n  const getSelectionForGroupId = groupId => {\n    const groupElements = getElementsInGroup(elements, groupId);\n    return getSelectionFromElements(groupElements);\n  };\n  Object.entries(selectGroupsFromGivenElements(elementsInGroups, appState)).filter(_ref2 => {\n    let [id, isSelected] = _ref2;\n    return isSelected;\n  }).map(_ref3 => {\n    let [id, isSelected] = _ref3;\n    return id;\n  }).map(groupId => getSelectionForGroupId(groupId)).concat(individualElements.map(element => getSelectionFromElements([element]))).forEach(selection => renderSelectionBorder(context, renderConfig, selection));\n};\nconst renderBindingHighlightForSuggestedPointBinding = (context, suggestedBinding) => {\n  const [element, startOrEnd, bindableElement] = suggestedBinding;\n  const threshold = maxBindingGap(bindableElement, bindableElement.width, bindableElement.height);\n  context.strokeStyle = \"rgba(0,0,0,0)\";\n  context.fillStyle = \"rgba(0,0,0,.05)\";\n  const pointIndices = startOrEnd === \"both\" ? [0, -1] : startOrEnd === \"start\" ? [0] : [-1];\n  pointIndices.forEach(index => {\n    const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(element, index);\n    fillCircle(context, x, y, threshold);\n  });\n};\nlet linkCanvasCache;\nconst renderLinkIcon = (element, context, appState) => {\n  if (element.link && !appState.selectedElementIds[element.id]) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const [x, y, width, height] = getLinkHandleFromCoords([x1, y1, x2, y2], element.angle, appState);\n    const centerX = x + width / 2;\n    const centerY = y + height / 2;\n    context.save();\n    context.translate(appState.scrollX + centerX, appState.scrollY + centerY);\n    context.rotate(element.angle);\n    if (!linkCanvasCache || linkCanvasCache.zoom !== appState.zoom.value) {\n      linkCanvasCache = document.createElement(\"canvas\");\n      linkCanvasCache.zoom = appState.zoom.value;\n      linkCanvasCache.width = width * window.devicePixelRatio * appState.zoom.value;\n      linkCanvasCache.height = height * window.devicePixelRatio * appState.zoom.value;\n      const linkCanvasCacheContext = linkCanvasCache.getContext(\"2d\");\n      linkCanvasCacheContext.scale(window.devicePixelRatio * appState.zoom.value, window.devicePixelRatio * appState.zoom.value);\n      linkCanvasCacheContext.fillStyle = \"#fff\";\n      linkCanvasCacheContext.fillRect(0, 0, width, height);\n      linkCanvasCacheContext.drawImage(EXTERNAL_LINK_IMG, 0, 0, width, height);\n      linkCanvasCacheContext.restore();\n      context.drawImage(linkCanvasCache, x - centerX, y - centerY, width, height);\n    } else {\n      context.drawImage(linkCanvasCache, x - centerX, y - centerY, width, height);\n    }\n    context.restore();\n  }\n};\nexport const isVisibleElement = (element, canvasWidth, canvasHeight, viewTransformations) => {\n  const [x1, y1, x2, y2] = getElementBounds(element); // scene coordinates\n  const topLeftSceneCoords = viewportCoordsToSceneCoords({\n    clientX: viewTransformations.offsetLeft,\n    clientY: viewTransformations.offsetTop\n  }, viewTransformations);\n  const bottomRightSceneCoords = viewportCoordsToSceneCoords({\n    clientX: viewTransformations.offsetLeft + canvasWidth,\n    clientY: viewTransformations.offsetTop + canvasHeight\n  }, viewTransformations);\n  return topLeftSceneCoords.x <= x2 && topLeftSceneCoords.y <= y2 && bottomRightSceneCoords.x >= x1 && bottomRightSceneCoords.y >= y1;\n};\n\n// This should be only called for exporting purposes\nexport const renderSceneToSvg = function (elements, rsvg, svgRoot, files) {\n  let {\n    offsetX = 0,\n    offsetY = 0,\n    exportWithDarkMode = false,\n    exportingFrameId = null\n  } = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  if (!svgRoot) {\n    return;\n  }\n\n  // render elements\n  elements.forEach(element => {\n    if (!element.isDeleted) {\n      try {\n        renderElementToSvg(element, rsvg, svgRoot, files, element.x + offsetX, element.y + offsetY, exportWithDarkMode, exportingFrameId);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  });\n};","map":{"version":3,"names":["oc","getElementAbsoluteCoords","OMIT_SIDES_FOR_MULTIPLE_ELEMENTS","getTransformHandlesFromCoords","getTransformHandles","getElementBounds","getCommonBounds","roundRect","getScrollBars","SCROLLBAR_COLOR","SCROLLBAR_WIDTH","getSelectedElements","renderElement","renderElementToSvg","getClientColor","LinearElementEditor","isSelectedViaGroup","getSelectedGroupIds","getElementsInGroup","selectGroupsFromGivenElements","maxBindingGap","isBindingEnabled","OMIT_SIDES_FOR_FRAME","shouldShowBoundingBox","viewportCoordsToSceneCoords","throttleRAF","isOnlyExportingSingleFrame","UserIdleState","FRAME_STYLE","THEME_FILTER","EXTERNAL_LINK_IMG","getLinkHandleFromCoords","isFrameElement","isLinearElement","elementOverlapsWithFrame","getTargetFrame","isElementInFrame","DEFAULT_SPACING","strokeRectWithRotation","context","x","y","width","height","cx","cy","angle","fill","arguments","length","undefined","radius","save","translate","rotate","fillRect","beginPath","stroke","closePath","strokeRect","restore","strokeDiamondWithRotation","moveTo","lineTo","strokeEllipseWithRotation","ellipse","Math","PI","fillCircle","arc","strokeGrid","gridSize","offsetX","offsetY","strokeStyle","renderSingleLinearPoint","renderConfig","point","isSelected","isPhantomPoint","setLineDash","fillStyle","zoom","value","renderLinearPointHandles","appState","element","selectedLinearElement","scrollX","scrollY","lineWidth","points","getPointsGlobalCoordinates","POINT_HANDLE_SIZE","editingLinearElement","forEach","idx","_appState$editingLine","_appState$editingLine2","selectedPointsIndices","includes","midPoints","getEditorMidPoints","filter","midPoint","segmentMidPoint","_appState$selectedLin","segmentMidPointHoveredCoords","arePointsEqual","highlightPoint","renderLinearElementPointHighlight","_appState$editingLine3","_appState$editingLine4","elementId","hoverPointIndex","getElement","getPointAtIndexGlobalCoordinates","frameClip","frame","isExporting","rect","clip","_renderScene","_ref","_appState$editingLine6","elements","scale","rc","canvas","atLeastOneVisibleElement","renderScrollbars","renderSelection","renderGrid","selectionColor","black","getContext","setTransform","normalizedCanvasWidth","normalizedCanvasHeight","theme","viewBackgroundColor","hasTransparence","test","clearRect","ceil","visibleElements","isVisibleElement","offsetLeft","offsetTop","groupsToBeAddedToFrame","Set","groupIds","frameToHighlight","selectedElementIds","id","find","groupId","has","add","_appState$frameToHigh","_appState$editingLine5","frameId","frameRendering","enabled","renderLinkIcon","error","console","selectionElement","suggestedBindings","binding","suggestedBinding","renderBindingHighlight","renderFrameHighlight","elementsToHighlight","renderElementsBoxHighlight","locallySelectedElements","isFrameSelected","some","multiElement","_appState$selectedLin2","showBoundingBox","locallySelectedIds","map","isSingleLinearElementSelected","locked","selections","reduce","acc","selectionColors","push","remoteSelectedElementIds","socketId","background","elementX1","elementY1","elementX2","elementY2","dashed","addSelectionForGroupId","groupElements","editingGroupId","selection","renderSelectionBorder","white","transformHandles","viewModeEnabled","renderTransformHandles","isRotating","dashedLinePadding","x1","y1","x2","y2","initialLineDash","getLineDash","clientId","remotePointerViewportCoords","isOutOfBounds","max","min","userState","remotePointerUserStates","isInactive","IDLE","AWAY","globalAlpha","remotePointerButton","lineJoin","username","remotePointerUsernames","font","paddingHorizontal","paddingVertical","measure","measureText","measureHeight","actualBoundingBoxDescent","actualBoundingBoxAscent","finalHeight","boxX","boxY","boxWidth","boxHeight","fillText","floor","scrollBars","horizontal","vertical","scrollBar","renderSceneThrottled","config","_config$callback","ret","callback","call","trailing","renderScene","throttle","_config$callback2","Object","keys","key","transformHandle","elementProperties","padding","elementWidth","elementHeight","linePadding","spaceWidth","count","index","lineDashOffset","renderHighlight","Array","isArray","renderBindingHighlightForSuggestedPointBinding","renderBindingHighlightForBindableElement","threshold","strokeOffset","type","side","hypot","wPadding","hPadding","strokeWidth","individualElements","elementsInGroups","getSelectionFromElements","getSelectionForGroupId","entries","_ref2","_ref3","concat","startOrEnd","bindableElement","pointIndices","linkCanvasCache","link","centerX","centerY","document","createElement","window","devicePixelRatio","linkCanvasCacheContext","drawImage","canvasWidth","canvasHeight","viewTransformations","topLeftSceneCoords","clientX","clientY","bottomRightSceneCoords","renderSceneToSvg","rsvg","svgRoot","files","exportWithDarkMode","exportingFrameId","isDeleted"],"sources":["D:/project/excalidraw-cn/src/renderer/renderScene.ts"],"sourcesContent":["import { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport oc from \"open-color\";\n\nimport { AppState, BinaryFiles, Point, Zoom } from \"../types\";\nimport {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  ExcalidrawLinearElement,\n  NonDeleted,\n  GroupId,\n  ExcalidrawBindableElement,\n  ExcalidrawFrameElement,\n} from \"../element/types\";\nimport {\n  getElementAbsoluteCoords,\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n  getElementBounds,\n  getCommonBounds,\n} from \"../element\";\n\nimport { roundRect } from \"./roundRect\";\nimport { RenderConfig } from \"../scene/types\";\nimport {\n  getScrollBars,\n  SCROLLBAR_COLOR,\n  SCROLLBAR_WIDTH,\n} from \"../scene/scrollbars\";\nimport { getSelectedElements } from \"../scene/selection\";\n\nimport { renderElement, renderElementToSvg } from \"./renderElement\";\nimport { getClientColor } from \"../clients\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport {\n  isSelectedViaGroup,\n  getSelectedGroupIds,\n  getElementsInGroup,\n  selectGroupsFromGivenElements,\n} from \"../groups\";\nimport { maxBindingGap } from \"../element/collision\";\nimport {\n  SuggestedBinding,\n  SuggestedPointBinding,\n  isBindingEnabled,\n} from \"../element/binding\";\nimport {\n  OMIT_SIDES_FOR_FRAME,\n  shouldShowBoundingBox,\n  TransformHandles,\n  TransformHandleType,\n} from \"../element/transformHandles\";\nimport {\n  viewportCoordsToSceneCoords,\n  throttleRAF,\n  isOnlyExportingSingleFrame,\n} from \"../utils\";\nimport { UserIdleState } from \"../types\";\nimport { FRAME_STYLE, THEME_FILTER } from \"../constants\";\nimport {\n  EXTERNAL_LINK_IMG,\n  getLinkHandleFromCoords,\n} from \"../element/Hyperlink\";\nimport { isFrameElement, isLinearElement } from \"../element/typeChecks\";\nimport {\n  elementOverlapsWithFrame,\n  getTargetFrame,\n  isElementInFrame,\n} from \"../frame\";\nimport \"canvas-roundrect-polyfill\";\n\nexport const DEFAULT_SPACING = 2;\n\nconst strokeRectWithRotation = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n  fill: boolean = false,\n  /** should account for zoom */\n  radius: number = 0,\n) => {\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n  if (fill) {\n    context.fillRect(x - cx, y - cy, width, height);\n  }\n  if (radius && context.roundRect) {\n    context.beginPath();\n    context.roundRect(x - cx, y - cy, width, height, radius);\n    context.stroke();\n    context.closePath();\n  } else {\n    context.strokeRect(x - cx, y - cy, width, height);\n  }\n  context.restore();\n};\n\nconst strokeDiamondWithRotation = (\n  context: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n) => {\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.beginPath();\n  context.moveTo(0, height / 2);\n  context.lineTo(width / 2, 0);\n  context.lineTo(0, -height / 2);\n  context.lineTo(-width / 2, 0);\n  context.closePath();\n  context.stroke();\n  context.restore();\n};\n\nconst strokeEllipseWithRotation = (\n  context: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n) => {\n  context.beginPath();\n  context.ellipse(cx, cy, width / 2, height / 2, angle, 0, Math.PI * 2);\n  context.stroke();\n};\n\nconst fillCircle = (\n  context: CanvasRenderingContext2D,\n  cx: number,\n  cy: number,\n  radius: number,\n  stroke = true,\n) => {\n  context.beginPath();\n  context.arc(cx, cy, radius, 0, Math.PI * 2);\n  context.fill();\n  if (stroke) {\n    context.stroke();\n  }\n};\n\nconst strokeGrid = (\n  context: CanvasRenderingContext2D,\n  gridSize: number,\n  offsetX: number,\n  offsetY: number,\n  width: number,\n  height: number,\n) => {\n  context.save();\n  context.strokeStyle = \"rgba(0,0,0,0.1)\";\n  context.beginPath();\n  for (let x = offsetX; x < offsetX + width + gridSize * 2; x += gridSize) {\n    context.moveTo(x, offsetY - gridSize);\n    context.lineTo(x, offsetY + height + gridSize * 2);\n  }\n  for (let y = offsetY; y < offsetY + height + gridSize * 2; y += gridSize) {\n    context.moveTo(offsetX - gridSize, y);\n    context.lineTo(offsetX + width + gridSize * 2, y);\n  }\n  context.stroke();\n  context.restore();\n};\n\nconst renderSingleLinearPoint = (\n  context: CanvasRenderingContext2D,\n  renderConfig: RenderConfig,\n  point: Point,\n  radius: number,\n  isSelected: boolean,\n  isPhantomPoint = false,\n) => {\n  context.strokeStyle = \"#5e5ad8\";\n  context.setLineDash([]);\n  context.fillStyle = \"rgba(255, 255, 255, 0.9)\";\n  if (isSelected) {\n    context.fillStyle = \"rgba(134, 131, 226, 0.9)\";\n  } else if (isPhantomPoint) {\n    context.fillStyle = \"rgba(177, 151, 252, 0.7)\";\n  }\n\n  fillCircle(\n    context,\n    point[0],\n    point[1],\n    radius / renderConfig.zoom.value,\n    !isPhantomPoint,\n  );\n};\n\nconst renderLinearPointHandles = (\n  context: CanvasRenderingContext2D,\n  appState: AppState,\n  renderConfig: RenderConfig,\n  element: NonDeleted<ExcalidrawLinearElement>,\n) => {\n  if (!appState.selectedLinearElement) {\n    return;\n  }\n  context.save();\n  context.translate(renderConfig.scrollX, renderConfig.scrollY);\n  context.lineWidth = 1 / renderConfig.zoom.value;\n  const points = LinearElementEditor.getPointsGlobalCoordinates(element);\n\n  const { POINT_HANDLE_SIZE } = LinearElementEditor;\n  const radius = appState.editingLinearElement\n    ? POINT_HANDLE_SIZE\n    : POINT_HANDLE_SIZE / 2;\n  points.forEach((point, idx) => {\n    const isSelected =\n      !!appState.editingLinearElement?.selectedPointsIndices?.includes(idx);\n\n    renderSingleLinearPoint(context, renderConfig, point, radius, isSelected);\n  });\n\n  //Rendering segment mid points\n  const midPoints = LinearElementEditor.getEditorMidPoints(\n    element,\n    appState,\n  ).filter((midPoint) => midPoint !== null) as Point[];\n\n  midPoints.forEach((segmentMidPoint) => {\n    if (\n      appState?.selectedLinearElement?.segmentMidPointHoveredCoords &&\n      LinearElementEditor.arePointsEqual(\n        segmentMidPoint,\n        appState.selectedLinearElement.segmentMidPointHoveredCoords,\n      )\n    ) {\n      // The order of renderingSingleLinearPoint and highLight points is different\n      // inside vs outside editor as hover states are different,\n      // in editor when hovered the original point is not visible as hover state fully covers it whereas outside the\n      // editor original point is visible and hover state is just an outer circle.\n      if (appState.editingLinearElement) {\n        renderSingleLinearPoint(\n          context,\n          renderConfig,\n          segmentMidPoint,\n          radius,\n          false,\n        );\n        highlightPoint(segmentMidPoint, context, renderConfig);\n      } else {\n        highlightPoint(segmentMidPoint, context, renderConfig);\n        renderSingleLinearPoint(\n          context,\n          renderConfig,\n          segmentMidPoint,\n          radius,\n          false,\n        );\n      }\n    } else if (appState.editingLinearElement || points.length === 2) {\n      renderSingleLinearPoint(\n        context,\n        renderConfig,\n        segmentMidPoint,\n        POINT_HANDLE_SIZE / 2,\n        false,\n        true,\n      );\n    }\n  });\n\n  context.restore();\n};\n\nconst highlightPoint = (\n  point: Point,\n  context: CanvasRenderingContext2D,\n  renderConfig: RenderConfig,\n) => {\n  context.fillStyle = \"rgba(105, 101, 219, 0.4)\";\n\n  fillCircle(\n    context,\n    point[0],\n    point[1],\n    LinearElementEditor.POINT_HANDLE_SIZE / renderConfig.zoom.value,\n    false,\n  );\n};\nconst renderLinearElementPointHighlight = (\n  context: CanvasRenderingContext2D,\n  appState: AppState,\n  renderConfig: RenderConfig,\n) => {\n  const { elementId, hoverPointIndex } = appState.selectedLinearElement!;\n  if (\n    appState.editingLinearElement?.selectedPointsIndices?.includes(\n      hoverPointIndex,\n    )\n  ) {\n    return;\n  }\n  const element = LinearElementEditor.getElement(elementId);\n  if (!element) {\n    return;\n  }\n  const point = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    element,\n    hoverPointIndex,\n  );\n  context.save();\n  context.translate(renderConfig.scrollX, renderConfig.scrollY);\n\n  highlightPoint(point, context, renderConfig);\n  context.restore();\n};\n\nconst frameClip = (\n  frame: ExcalidrawFrameElement,\n  context: CanvasRenderingContext2D,\n  renderConfig: RenderConfig,\n) => {\n  context.translate(\n    frame.x + renderConfig.scrollX,\n    frame.y + renderConfig.scrollY,\n  );\n  context.beginPath();\n  if (context.roundRect && !renderConfig.isExporting) {\n    context.roundRect(\n      0,\n      0,\n      frame.width,\n      frame.height,\n      FRAME_STYLE.radius / renderConfig.zoom.value,\n    );\n  } else {\n    context.rect(0, 0, frame.width, frame.height);\n  }\n  context.clip();\n  context.translate(\n    -(frame.x + renderConfig.scrollX),\n    -(frame.y + renderConfig.scrollY),\n  );\n};\n\nexport const _renderScene = ({\n  elements,\n  appState,\n  scale,\n  rc,\n  canvas,\n  renderConfig,\n}: {\n  elements: readonly NonDeletedExcalidrawElement[];\n  appState: AppState;\n  scale: number;\n  rc: RoughCanvas;\n  canvas: HTMLCanvasElement;\n  renderConfig: RenderConfig;\n}) =>\n  // extra options passed to the renderer\n  {\n    if (canvas === null) {\n      return { atLeastOneVisibleElement: false };\n    }\n    const {\n      renderScrollbars = false,\n      renderSelection = true,\n      renderGrid = true,\n      isExporting,\n    } = renderConfig;\n\n    const selectionColor = renderConfig.selectionColor || oc.black;\n\n    const context = canvas.getContext(\"2d\")!;\n\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    context.save();\n    context.scale(scale, scale);\n    // When doing calculations based on canvas width we should used normalized one\n    const normalizedCanvasWidth = canvas.width / scale;\n    const normalizedCanvasHeight = canvas.height / scale;\n\n    if (isExporting && renderConfig.theme === \"dark\") {\n      context.filter = THEME_FILTER;\n    }\n\n    // Paint background\n    if (typeof renderConfig.viewBackgroundColor === \"string\") {\n      const hasTransparence =\n        renderConfig.viewBackgroundColor === \"transparent\" ||\n        renderConfig.viewBackgroundColor.length === 5 || // #RGBA\n        renderConfig.viewBackgroundColor.length === 9 || // #RRGGBBA\n        /(hsla|rgba)\\(/.test(renderConfig.viewBackgroundColor);\n      if (hasTransparence) {\n        context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n      }\n      context.save();\n      context.fillStyle = renderConfig.viewBackgroundColor;\n      context.fillRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n      context.restore();\n    } else {\n      context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    }\n\n    // Apply zoom\n    context.save();\n    context.scale(renderConfig.zoom.value, renderConfig.zoom.value);\n\n    // Grid\n    if (renderGrid && appState.gridSize) {\n      strokeGrid(\n        context,\n        appState.gridSize,\n        -Math.ceil(renderConfig.zoom.value / appState.gridSize) *\n          appState.gridSize +\n          (renderConfig.scrollX % appState.gridSize),\n        -Math.ceil(renderConfig.zoom.value / appState.gridSize) *\n          appState.gridSize +\n          (renderConfig.scrollY % appState.gridSize),\n        normalizedCanvasWidth / renderConfig.zoom.value,\n        normalizedCanvasHeight / renderConfig.zoom.value,\n      );\n    }\n\n    // Paint visible elements\n    const visibleElements = elements.filter((element) =>\n      isVisibleElement(element, normalizedCanvasWidth, normalizedCanvasHeight, {\n        zoom: renderConfig.zoom,\n        offsetLeft: appState.offsetLeft,\n        offsetTop: appState.offsetTop,\n        scrollX: renderConfig.scrollX,\n        scrollY: renderConfig.scrollY,\n      }),\n    );\n\n    const groupsToBeAddedToFrame = new Set<string>();\n\n    visibleElements.forEach((element) => {\n      if (\n        element.groupIds.length > 0 &&\n        appState.frameToHighlight &&\n        appState.selectedElementIds[element.id] &&\n        (elementOverlapsWithFrame(element, appState.frameToHighlight) ||\n          element.groupIds.find((groupId) =>\n            groupsToBeAddedToFrame.has(groupId),\n          ))\n      ) {\n        element.groupIds.forEach((groupId) =>\n          groupsToBeAddedToFrame.add(groupId),\n        );\n      }\n    });\n\n    let editingLinearElement: NonDeleted<ExcalidrawLinearElement> | undefined =\n      undefined;\n\n    visibleElements.forEach((element) => {\n      try {\n        // - when exporting the whole canvas, we DO NOT apply clipping\n        // - when we are exporting a particular frame, apply clipping\n        //   if the containing frame is not selected, apply clipping\n        const frameId = element.frameId || appState.frameToHighlight?.id;\n\n        if (\n          frameId &&\n          ((renderConfig.isExporting && isOnlyExportingSingleFrame(elements)) ||\n            (!renderConfig.isExporting &&\n              appState.frameRendering.enabled &&\n              appState.frameRendering.clip))\n        ) {\n          context.save();\n\n          const frame = getTargetFrame(element, appState);\n\n          if (frame && isElementInFrame(element, elements, appState)) {\n            frameClip(frame, context, renderConfig);\n          }\n          renderElement(element, rc, context, renderConfig, appState);\n          context.restore();\n        } else {\n          renderElement(element, rc, context, renderConfig, appState);\n        }\n        // Getting the element using LinearElementEditor during collab mismatches version - being one head of visible elements due to\n        // ShapeCache returns empty hence making sure that we get the\n        // correct element from visible elements\n        if (appState.editingLinearElement?.elementId === element.id) {\n          if (element) {\n            editingLinearElement =\n              element as NonDeleted<ExcalidrawLinearElement>;\n          }\n        }\n        if (!isExporting) {\n          renderLinkIcon(element, context, appState);\n        }\n      } catch (error: any) {\n        console.error(error);\n      }\n    });\n\n    if (editingLinearElement) {\n      renderLinearPointHandles(\n        context,\n        appState,\n        renderConfig,\n        editingLinearElement,\n      );\n    }\n\n    // Paint selection element\n    if (appState.selectionElement) {\n      try {\n        renderElement(\n          appState.selectionElement,\n          rc,\n          context,\n          renderConfig,\n          appState,\n        );\n      } catch (error: any) {\n        console.error(error);\n      }\n    }\n\n    if (isBindingEnabled(appState)) {\n      appState.suggestedBindings\n        .filter((binding) => binding != null)\n        .forEach((suggestedBinding) => {\n          renderBindingHighlight(context, renderConfig, suggestedBinding!);\n        });\n    }\n\n    if (appState.frameToHighlight) {\n      renderFrameHighlight(context, renderConfig, appState.frameToHighlight);\n    }\n\n    if (appState.elementsToHighlight) {\n      renderElementsBoxHighlight(\n        context,\n        renderConfig,\n        appState.elementsToHighlight,\n        appState,\n      );\n    }\n\n    const locallySelectedElements = getSelectedElements(elements, appState);\n    const isFrameSelected = locallySelectedElements.some((element) =>\n      isFrameElement(element),\n    );\n\n    // Getting the element using LinearElementEditor during collab mismatches version - being one head of visible elements due to\n    // ShapeCache returns empty hence making sure that we get the\n    // correct element from visible elements\n    if (\n      locallySelectedElements.length === 1 &&\n      appState.editingLinearElement?.elementId === locallySelectedElements[0].id\n    ) {\n      renderLinearPointHandles(\n        context,\n        appState,\n        renderConfig,\n        locallySelectedElements[0] as NonDeleted<ExcalidrawLinearElement>,\n      );\n    }\n\n    if (\n      appState.selectedLinearElement &&\n      appState.selectedLinearElement.hoverPointIndex >= 0\n    ) {\n      renderLinearElementPointHighlight(context, appState, renderConfig);\n    }\n    // Paint selected elements\n    if (\n      renderSelection &&\n      !appState.multiElement &&\n      !appState.editingLinearElement\n    ) {\n      const showBoundingBox = shouldShowBoundingBox(\n        locallySelectedElements,\n        appState,\n      );\n\n      const locallySelectedIds = locallySelectedElements.map(\n        (element) => element.id,\n      );\n      const isSingleLinearElementSelected =\n        locallySelectedElements.length === 1 &&\n        isLinearElement(locallySelectedElements[0]);\n      // render selected linear element points\n      if (\n        isSingleLinearElementSelected &&\n        appState.selectedLinearElement?.elementId ===\n          locallySelectedElements[0].id &&\n        !locallySelectedElements[0].locked\n      ) {\n        renderLinearPointHandles(\n          context,\n          appState,\n          renderConfig,\n          locallySelectedElements[0] as ExcalidrawLinearElement,\n        );\n      }\n      if (showBoundingBox) {\n        const selections = elements.reduce((acc, element) => {\n          const selectionColors = [];\n          // local user\n          if (\n            locallySelectedIds.includes(element.id) &&\n            !isSelectedViaGroup(appState, element)\n          ) {\n            selectionColors.push(selectionColor);\n          }\n          // remote users\n          if (renderConfig.remoteSelectedElementIds[element.id]) {\n            selectionColors.push(\n              ...renderConfig.remoteSelectedElementIds[element.id].map(\n                (socketId) => {\n                  const background = getClientColor(socketId);\n                  return background;\n                },\n              ),\n            );\n          }\n\n          if (selectionColors.length) {\n            const [elementX1, elementY1, elementX2, elementY2, cx, cy] =\n              getElementAbsoluteCoords(element, true);\n            acc.push({\n              angle: element.angle,\n              elementX1,\n              elementY1,\n              elementX2,\n              elementY2,\n              selectionColors,\n              dashed: !!renderConfig.remoteSelectedElementIds[element.id],\n              cx,\n              cy,\n            });\n          }\n          return acc;\n        }, [] as { angle: number; elementX1: number; elementY1: number; elementX2: number; elementY2: number; selectionColors: string[]; dashed?: boolean; cx: number; cy: number }[]);\n\n        const addSelectionForGroupId = (groupId: GroupId) => {\n          const groupElements = getElementsInGroup(elements, groupId);\n          const [elementX1, elementY1, elementX2, elementY2] =\n            getCommonBounds(groupElements);\n          selections.push({\n            angle: 0,\n            elementX1,\n            elementX2,\n            elementY1,\n            elementY2,\n            selectionColors: [oc.black],\n            dashed: true,\n            cx: elementX1 + (elementX2 - elementX1) / 2,\n            cy: elementY1 + (elementY2 - elementY1) / 2,\n          });\n        };\n\n        for (const groupId of getSelectedGroupIds(appState)) {\n          // TODO: support multiplayer selected group IDs\n          addSelectionForGroupId(groupId);\n        }\n\n        if (appState.editingGroupId) {\n          addSelectionForGroupId(appState.editingGroupId);\n        }\n\n        selections.forEach((selection) =>\n          renderSelectionBorder(context, renderConfig, selection),\n        );\n      }\n      // Paint resize transformHandles\n      context.save();\n      context.translate(renderConfig.scrollX, renderConfig.scrollY);\n\n      if (locallySelectedElements.length === 1) {\n        context.fillStyle = oc.white;\n        const transformHandles = getTransformHandles(\n          locallySelectedElements[0],\n          renderConfig.zoom,\n          \"mouse\", // when we render we don't know which pointer type so use mouse\n        );\n        if (!appState.viewModeEnabled && showBoundingBox) {\n          renderTransformHandles(\n            context,\n            renderConfig,\n            transformHandles,\n            locallySelectedElements[0].angle,\n          );\n        }\n      } else if (locallySelectedElements.length > 1 && !appState.isRotating) {\n        const dashedLinePadding =\n          (DEFAULT_SPACING * 2) / renderConfig.zoom.value;\n        context.fillStyle = oc.white;\n        const [x1, y1, x2, y2] = getCommonBounds(locallySelectedElements);\n        const initialLineDash = context.getLineDash();\n        context.setLineDash([2 / renderConfig.zoom.value]);\n        const lineWidth = context.lineWidth;\n        context.lineWidth = 1 / renderConfig.zoom.value;\n        context.strokeStyle = selectionColor;\n        strokeRectWithRotation(\n          context,\n          x1 - dashedLinePadding,\n          y1 - dashedLinePadding,\n          x2 - x1 + dashedLinePadding * 2,\n          y2 - y1 + dashedLinePadding * 2,\n          (x1 + x2) / 2,\n          (y1 + y2) / 2,\n          0,\n        );\n        context.lineWidth = lineWidth;\n        context.setLineDash(initialLineDash);\n        const transformHandles = getTransformHandlesFromCoords(\n          [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2],\n          0,\n          renderConfig.zoom,\n          \"mouse\",\n          isFrameSelected\n            ? OMIT_SIDES_FOR_FRAME\n            : OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n        );\n        if (locallySelectedElements.some((element) => !element.locked)) {\n          renderTransformHandles(context, renderConfig, transformHandles, 0);\n        }\n      }\n      context.restore();\n    }\n\n    // Reset zoom\n    context.restore();\n\n    // Paint remote pointers\n    for (const clientId in renderConfig.remotePointerViewportCoords) {\n      let { x, y } = renderConfig.remotePointerViewportCoords[clientId];\n\n      x -= appState.offsetLeft;\n      y -= appState.offsetTop;\n\n      const width = 11;\n      const height = 14;\n\n      const isOutOfBounds =\n        x < 0 ||\n        x > normalizedCanvasWidth - width ||\n        y < 0 ||\n        y > normalizedCanvasHeight - height;\n\n      x = Math.max(x, 0);\n      x = Math.min(x, normalizedCanvasWidth - width);\n      y = Math.max(y, 0);\n      y = Math.min(y, normalizedCanvasHeight - height);\n\n      const background = getClientColor(clientId);\n\n      context.save();\n      context.strokeStyle = background;\n      context.fillStyle = background;\n\n      const userState = renderConfig.remotePointerUserStates[clientId];\n      const isInactive =\n        isOutOfBounds ||\n        userState === UserIdleState.IDLE ||\n        userState === UserIdleState.AWAY;\n\n      if (isInactive) {\n        context.globalAlpha = 0.3;\n      }\n\n      if (\n        renderConfig.remotePointerButton &&\n        renderConfig.remotePointerButton[clientId] === \"down\"\n      ) {\n        context.beginPath();\n        context.arc(x, y, 15, 0, 2 * Math.PI, false);\n        context.lineWidth = 3;\n        context.strokeStyle = \"#ffffff88\";\n        context.stroke();\n        context.closePath();\n\n        context.beginPath();\n        context.arc(x, y, 15, 0, 2 * Math.PI, false);\n        context.lineWidth = 1;\n        context.strokeStyle = background;\n        context.stroke();\n        context.closePath();\n      }\n\n      // Background (white outline) for arrow\n      context.fillStyle = oc.white;\n      context.strokeStyle = oc.white;\n      context.lineWidth = 6;\n      context.lineJoin = \"round\";\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + 0, y + 14);\n      context.lineTo(x + 4, y + 9);\n      context.lineTo(x + 11, y + 8);\n      context.closePath();\n      context.stroke();\n      context.fill();\n\n      // Arrow\n      context.fillStyle = background;\n      context.strokeStyle = background;\n      context.lineWidth = 2;\n      context.lineJoin = \"round\";\n      context.beginPath();\n      if (isInactive) {\n        context.moveTo(x - 1, y - 1);\n        context.lineTo(x - 1, y + 15);\n        context.lineTo(x + 5, y + 10);\n        context.lineTo(x + 12, y + 9);\n        context.closePath();\n        context.fill();\n      } else {\n        context.moveTo(x, y);\n        context.lineTo(x + 0, y + 14);\n        context.lineTo(x + 4, y + 9);\n        context.lineTo(x + 11, y + 8);\n        context.closePath();\n        context.fill();\n        context.stroke();\n      }\n\n      const username = renderConfig.remotePointerUsernames[clientId] || \"\";\n\n      if (!isOutOfBounds && username) {\n        context.font = \"600 12px sans-serif\"; // font has to be set before context.measureText()\n\n        const offsetX = x + width / 2;\n        const offsetY = y + height + 2;\n        const paddingHorizontal = 5;\n        const paddingVertical = 3;\n        const measure = context.measureText(username);\n        const measureHeight =\n          measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;\n        const finalHeight = Math.max(measureHeight, 12);\n\n        const boxX = offsetX - 1;\n        const boxY = offsetY - 1;\n        const boxWidth = measure.width + 2 + paddingHorizontal * 2 + 2;\n        const boxHeight = finalHeight + 2 + paddingVertical * 2 + 2;\n        if (context.roundRect) {\n          context.beginPath();\n          context.roundRect(boxX, boxY, boxWidth, boxHeight, 8);\n          context.fillStyle = background;\n          context.fill();\n          context.strokeStyle = oc.white;\n          context.stroke();\n        } else {\n          roundRect(context, boxX, boxY, boxWidth, boxHeight, 8, oc.white);\n        }\n        context.fillStyle = oc.black;\n\n        context.fillText(\n          username,\n          offsetX + paddingHorizontal + 1,\n          offsetY +\n            paddingVertical +\n            measure.actualBoundingBoxAscent +\n            Math.floor((finalHeight - measureHeight) / 2) +\n            2,\n        );\n      }\n\n      context.restore();\n      context.closePath();\n    }\n\n    // Paint scrollbars\n    let scrollBars;\n    if (renderScrollbars) {\n      scrollBars = getScrollBars(\n        elements,\n        normalizedCanvasWidth,\n        normalizedCanvasHeight,\n        renderConfig,\n      );\n\n      context.save();\n      context.fillStyle = SCROLLBAR_COLOR;\n      context.strokeStyle = \"rgba(255,255,255,0.8)\";\n      [scrollBars.horizontal, scrollBars.vertical].forEach((scrollBar) => {\n        if (scrollBar) {\n          roundRect(\n            context,\n            scrollBar.x,\n            scrollBar.y,\n            scrollBar.width,\n            scrollBar.height,\n            SCROLLBAR_WIDTH / 2,\n          );\n        }\n      });\n      context.restore();\n    }\n\n    context.restore();\n    return { atLeastOneVisibleElement: visibleElements.length > 0, scrollBars };\n  };\n\nconst renderSceneThrottled = throttleRAF(\n  (config: {\n    elements: readonly NonDeletedExcalidrawElement[];\n    appState: AppState;\n    scale: number;\n    rc: RoughCanvas;\n    canvas: HTMLCanvasElement;\n    renderConfig: RenderConfig;\n    callback?: (data: ReturnType<typeof _renderScene>) => void;\n  }) => {\n    const ret = _renderScene(config);\n    config.callback?.(ret);\n  },\n  { trailing: true },\n);\n\n/** renderScene throttled to animation framerate */\nexport const renderScene = <T extends boolean = false>(\n  config: {\n    elements: readonly NonDeletedExcalidrawElement[];\n    appState: AppState;\n    scale: number;\n    rc: RoughCanvas;\n    canvas: HTMLCanvasElement;\n    renderConfig: RenderConfig;\n    callback?: (data: ReturnType<typeof _renderScene>) => void;\n  },\n  /** Whether to throttle rendering. Defaults to false.\n   * When throttling, no value is returned. Use the callback instead. */\n  throttle?: T,\n): T extends true ? void : ReturnType<typeof _renderScene> => {\n  if (throttle) {\n    renderSceneThrottled(config);\n    return undefined as T extends true ? void : ReturnType<typeof _renderScene>;\n  }\n  const ret = _renderScene(config);\n  config.callback?.(ret);\n  return ret as T extends true ? void : ReturnType<typeof _renderScene>;\n};\n\nconst renderTransformHandles = (\n  context: CanvasRenderingContext2D,\n  renderConfig: RenderConfig,\n  transformHandles: TransformHandles,\n  angle: number,\n): void => {\n  Object.keys(transformHandles).forEach((key) => {\n    const transformHandle = transformHandles[key as TransformHandleType];\n    if (transformHandle !== undefined) {\n      const [x, y, width, height] = transformHandle;\n\n      context.save();\n      context.lineWidth = 1 / renderConfig.zoom.value;\n      if (renderConfig.selectionColor) {\n        context.strokeStyle = renderConfig.selectionColor;\n      }\n      if (key === \"rotation\") {\n        fillCircle(context, x + width / 2, y + height / 2, width / 2);\n        // prefer round corners if roundRect API is available\n      } else if (context.roundRect) {\n        context.beginPath();\n        context.roundRect(x, y, width, height, 2 / renderConfig.zoom.value);\n        context.fill();\n        context.stroke();\n      } else {\n        strokeRectWithRotation(\n          context,\n          x,\n          y,\n          width,\n          height,\n          x + width / 2,\n          y + height / 2,\n          angle,\n          true, // fill before stroke\n        );\n      }\n      context.restore();\n    }\n  });\n};\n\nconst renderSelectionBorder = (\n  context: CanvasRenderingContext2D,\n  renderConfig: RenderConfig,\n  elementProperties: {\n    angle: number;\n    elementX1: number;\n    elementY1: number;\n    elementX2: number;\n    elementY2: number;\n    selectionColors: string[];\n    dashed?: boolean;\n    cx: number;\n    cy: number;\n  },\n  padding = DEFAULT_SPACING * 2,\n) => {\n  const {\n    angle,\n    elementX1,\n    elementY1,\n    elementX2,\n    elementY2,\n    selectionColors,\n    cx,\n    cy,\n    dashed,\n  } = elementProperties;\n  const elementWidth = elementX2 - elementX1;\n  const elementHeight = elementY2 - elementY1;\n\n  const linePadding = padding / renderConfig.zoom.value;\n  const lineWidth = 8 / renderConfig.zoom.value;\n  const spaceWidth = 4 / renderConfig.zoom.value;\n\n  context.save();\n  context.translate(renderConfig.scrollX, renderConfig.scrollY);\n  context.lineWidth = 1 / renderConfig.zoom.value;\n\n  const count = selectionColors.length;\n  for (let index = 0; index < count; ++index) {\n    context.strokeStyle = selectionColors[index];\n    if (dashed) {\n      context.setLineDash([\n        lineWidth,\n        spaceWidth + (lineWidth + spaceWidth) * (count - 1),\n      ]);\n    }\n    context.lineDashOffset = (lineWidth + spaceWidth) * index;\n    strokeRectWithRotation(\n      context,\n      elementX1 - linePadding,\n      elementY1 - linePadding,\n      elementWidth + linePadding * 2,\n      elementHeight + linePadding * 2,\n      cx,\n      cy,\n      angle,\n    );\n  }\n  context.restore();\n};\n\nconst renderBindingHighlight = (\n  context: CanvasRenderingContext2D,\n  renderConfig: RenderConfig,\n  suggestedBinding: SuggestedBinding,\n) => {\n  const renderHighlight = Array.isArray(suggestedBinding)\n    ? renderBindingHighlightForSuggestedPointBinding\n    : renderBindingHighlightForBindableElement;\n\n  context.save();\n  context.translate(renderConfig.scrollX, renderConfig.scrollY);\n  renderHighlight(context, suggestedBinding as any);\n\n  context.restore();\n};\n\nconst renderBindingHighlightForBindableElement = (\n  context: CanvasRenderingContext2D,\n  element: ExcalidrawBindableElement,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const threshold = maxBindingGap(element, width, height);\n\n  // So that we don't overlap the element itself\n  const strokeOffset = 4;\n  context.strokeStyle = \"rgba(0,0,0,.05)\";\n  context.lineWidth = threshold - strokeOffset;\n  const padding = strokeOffset / 2 + threshold / 2;\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"image\":\n    case \"frame\":\n      strokeRectWithRotation(\n        context,\n        x1 - padding,\n        y1 - padding,\n        width + padding * 2,\n        height + padding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n    case \"diamond\":\n      const side = Math.hypot(width, height);\n      const wPadding = (padding * side) / height;\n      const hPadding = (padding * side) / width;\n      strokeDiamondWithRotation(\n        context,\n        width + wPadding * 2,\n        height + hPadding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n    case \"ellipse\":\n      strokeEllipseWithRotation(\n        context,\n        width + padding * 2,\n        height + padding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n  }\n};\n\nconst renderFrameHighlight = (\n  context: CanvasRenderingContext2D,\n  renderConfig: RenderConfig,\n  frame: NonDeleted<ExcalidrawFrameElement>,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(frame);\n  const width = x2 - x1;\n  const height = y2 - y1;\n\n  context.strokeStyle = \"rgb(0,118,255)\";\n  context.lineWidth = (FRAME_STYLE.strokeWidth * 2) / renderConfig.zoom.value;\n\n  context.save();\n  context.translate(renderConfig.scrollX, renderConfig.scrollY);\n  strokeRectWithRotation(\n    context,\n    x1,\n    y1,\n    width,\n    height,\n    x1 + width / 2,\n    y1 + height / 2,\n    frame.angle,\n    false,\n    FRAME_STYLE.radius / renderConfig.zoom.value,\n  );\n  context.restore();\n};\n\nconst renderElementsBoxHighlight = (\n  context: CanvasRenderingContext2D,\n  renderConfig: RenderConfig,\n  elements: NonDeleted<ExcalidrawElement>[],\n  appState: AppState,\n) => {\n  const individualElements = elements.filter(\n    (element) => element.groupIds.length === 0,\n  );\n\n  const elementsInGroups = elements.filter(\n    (element) => element.groupIds.length > 0,\n  );\n\n  const getSelectionFromElements = (elements: ExcalidrawElement[]) => {\n    const [elementX1, elementY1, elementX2, elementY2] =\n      getCommonBounds(elements);\n    return {\n      angle: 0,\n      elementX1,\n      elementX2,\n      elementY1,\n      elementY2,\n      selectionColors: [\"rgb(0,118,255)\"],\n      dashed: false,\n      cx: elementX1 + (elementX2 - elementX1) / 2,\n      cy: elementY1 + (elementY2 - elementY1) / 2,\n    };\n  };\n\n  const getSelectionForGroupId = (groupId: GroupId) => {\n    const groupElements = getElementsInGroup(elements, groupId);\n    return getSelectionFromElements(groupElements);\n  };\n\n  Object.entries(selectGroupsFromGivenElements(elementsInGroups, appState))\n    .filter(([id, isSelected]) => isSelected)\n    .map(([id, isSelected]) => id)\n    .map((groupId) => getSelectionForGroupId(groupId))\n    .concat(\n      individualElements.map((element) => getSelectionFromElements([element])),\n    )\n    .forEach((selection) =>\n      renderSelectionBorder(context, renderConfig, selection),\n    );\n};\n\nconst renderBindingHighlightForSuggestedPointBinding = (\n  context: CanvasRenderingContext2D,\n  suggestedBinding: SuggestedPointBinding,\n) => {\n  const [element, startOrEnd, bindableElement] = suggestedBinding;\n\n  const threshold = maxBindingGap(\n    bindableElement,\n    bindableElement.width,\n    bindableElement.height,\n  );\n\n  context.strokeStyle = \"rgba(0,0,0,0)\";\n  context.fillStyle = \"rgba(0,0,0,.05)\";\n\n  const pointIndices =\n    startOrEnd === \"both\" ? [0, -1] : startOrEnd === \"start\" ? [0] : [-1];\n  pointIndices.forEach((index) => {\n    const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n      element,\n      index,\n    );\n    fillCircle(context, x, y, threshold);\n  });\n};\n\nlet linkCanvasCache: any;\nconst renderLinkIcon = (\n  element: NonDeletedExcalidrawElement,\n  context: CanvasRenderingContext2D,\n  appState: AppState,\n) => {\n  if (element.link && !appState.selectedElementIds[element.id]) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const [x, y, width, height] = getLinkHandleFromCoords(\n      [x1, y1, x2, y2],\n      element.angle,\n      appState,\n    );\n    const centerX = x + width / 2;\n    const centerY = y + height / 2;\n    context.save();\n    context.translate(appState.scrollX + centerX, appState.scrollY + centerY);\n    context.rotate(element.angle);\n\n    if (!linkCanvasCache || linkCanvasCache.zoom !== appState.zoom.value) {\n      linkCanvasCache = document.createElement(\"canvas\");\n      linkCanvasCache.zoom = appState.zoom.value;\n      linkCanvasCache.width =\n        width * window.devicePixelRatio * appState.zoom.value;\n      linkCanvasCache.height =\n        height * window.devicePixelRatio * appState.zoom.value;\n      const linkCanvasCacheContext = linkCanvasCache.getContext(\"2d\")!;\n      linkCanvasCacheContext.scale(\n        window.devicePixelRatio * appState.zoom.value,\n        window.devicePixelRatio * appState.zoom.value,\n      );\n      linkCanvasCacheContext.fillStyle = \"#fff\";\n      linkCanvasCacheContext.fillRect(0, 0, width, height);\n      linkCanvasCacheContext.drawImage(EXTERNAL_LINK_IMG, 0, 0, width, height);\n      linkCanvasCacheContext.restore();\n      context.drawImage(\n        linkCanvasCache,\n        x - centerX,\n        y - centerY,\n        width,\n        height,\n      );\n    } else {\n      context.drawImage(\n        linkCanvasCache,\n        x - centerX,\n        y - centerY,\n        width,\n        height,\n      );\n    }\n    context.restore();\n  }\n};\n\nexport const isVisibleElement = (\n  element: ExcalidrawElement,\n  canvasWidth: number,\n  canvasHeight: number,\n  viewTransformations: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n) => {\n  const [x1, y1, x2, y2] = getElementBounds(element); // scene coordinates\n  const topLeftSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft,\n      clientY: viewTransformations.offsetTop,\n    },\n    viewTransformations,\n  );\n  const bottomRightSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + canvasWidth,\n      clientY: viewTransformations.offsetTop + canvasHeight,\n    },\n    viewTransformations,\n  );\n\n  return (\n    topLeftSceneCoords.x <= x2 &&\n    topLeftSceneCoords.y <= y2 &&\n    bottomRightSceneCoords.x >= x1 &&\n    bottomRightSceneCoords.y >= y1\n  );\n};\n\n// This should be only called for exporting purposes\nexport const renderSceneToSvg = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  files: BinaryFiles,\n  {\n    offsetX = 0,\n    offsetY = 0,\n    exportWithDarkMode = false,\n    exportingFrameId = null,\n  }: {\n    offsetX?: number;\n    offsetY?: number;\n    exportWithDarkMode?: boolean;\n    exportingFrameId?: string | null;\n  } = {},\n) => {\n  if (!svgRoot) {\n    return;\n  }\n\n  // render elements\n  elements.forEach((element) => {\n    if (!element.isDeleted) {\n      try {\n        renderElementToSvg(\n          element,\n          rsvg,\n          svgRoot,\n          files,\n          element.x + offsetX,\n          element.y + offsetY,\n          exportWithDarkMode,\n          exportingFrameId,\n        );\n      } catch (error: any) {\n        console.error(error);\n      }\n    }\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}