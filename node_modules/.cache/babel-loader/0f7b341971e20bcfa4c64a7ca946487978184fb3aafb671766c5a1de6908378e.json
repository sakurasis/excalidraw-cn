{"ast":null,"code":"import { getSelectedElements } from \"./scene\";\nimport { getBoundTextElement } from \"./element/textElement\";\nimport { makeNextSelectedElementIds } from \"./scene/selection\";\nexport const selectGroup = (groupId, appState, elements) => {\n  const elementsInGroup = elements.filter(element => element.groupIds.includes(groupId));\n  if (elementsInGroup.length < 2) {\n    if (appState.selectedGroupIds[groupId] || appState.editingGroupId === groupId) {\n      return {\n        ...appState,\n        selectedGroupIds: {\n          ...appState.selectedGroupIds,\n          [groupId]: false\n        },\n        editingGroupId: null\n      };\n    }\n    return appState;\n  }\n  return {\n    ...appState,\n    selectedGroupIds: {\n      ...appState.selectedGroupIds,\n      [groupId]: true\n    },\n    selectedElementIds: {\n      ...appState.selectedElementIds,\n      ...Object.fromEntries(elementsInGroup.map(element => [element.id, true]))\n    }\n  };\n};\n\n/**\n * If the element's group is selected, don't render an individual\n * selection border around it.\n */\nexport const isSelectedViaGroup = (appState, element) => getSelectedGroupForElement(appState, element) != null;\nexport const getSelectedGroupForElement = (appState, element) => element.groupIds.filter(groupId => groupId !== appState.editingGroupId).find(groupId => appState.selectedGroupIds[groupId]);\nexport const getSelectedGroupIds = appState => Object.entries(appState.selectedGroupIds).filter(_ref => {\n  let [groupId, isSelected] = _ref;\n  return isSelected;\n}).map(_ref2 => {\n  let [groupId, isSelected] = _ref2;\n  return groupId;\n});\n\n/**\n * When you select an element, you often want to actually select the whole group it's in, unless\n * you're currently editing that group.\n */\nexport const selectGroupsForSelectedElements = (appState, elements, prevAppState, app) => {\n  let nextAppState = {\n    ...appState,\n    selectedGroupIds: {}\n  };\n  const selectedElements = app ? app.scene.getSelectedElements({\n    selectedElementIds: appState.selectedElementIds,\n    // supplying elements explicitly in case we're passed non-state elements\n    elements\n  }) : getSelectedElements(elements, appState);\n  if (!selectedElements.length) {\n    return {\n      ...nextAppState,\n      editingGroupId: null,\n      selectedElementIds: makeNextSelectedElementIds(nextAppState.selectedElementIds, prevAppState)\n    };\n  }\n  for (const selectedElement of selectedElements) {\n    let groupIds = selectedElement.groupIds;\n    if (appState.editingGroupId) {\n      // handle the case where a group is nested within a group\n      const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n      if (indexOfEditingGroup > -1) {\n        groupIds = groupIds.slice(0, indexOfEditingGroup);\n      }\n    }\n    if (groupIds.length > 0) {\n      const groupId = groupIds[groupIds.length - 1];\n      nextAppState = selectGroup(groupId, nextAppState, elements);\n    }\n  }\n  nextAppState.selectedElementIds = makeNextSelectedElementIds(nextAppState.selectedElementIds, prevAppState);\n  return nextAppState;\n};\n\n// given a list of elements, return the the actual group ids that should be selected\n// or used to update the elements\nexport const selectGroupsFromGivenElements = (elements, appState) => {\n  let nextAppState = {\n    ...appState,\n    selectedGroupIds: {}\n  };\n  for (const element of elements) {\n    let groupIds = element.groupIds;\n    if (appState.editingGroupId) {\n      const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n      if (indexOfEditingGroup > -1) {\n        groupIds = groupIds.slice(0, indexOfEditingGroup);\n      }\n    }\n    if (groupIds.length > 0) {\n      const groupId = groupIds[groupIds.length - 1];\n      nextAppState = selectGroup(groupId, nextAppState, elements);\n    }\n  }\n  return nextAppState.selectedGroupIds;\n};\nexport const editGroupForSelectedElement = (appState, element) => {\n  return {\n    ...appState,\n    editingGroupId: element.groupIds.length ? element.groupIds[0] : null,\n    selectedGroupIds: {},\n    selectedElementIds: {\n      [element.id]: true\n    }\n  };\n};\nexport const isElementInGroup = (element, groupId) => element.groupIds.includes(groupId);\nexport const getElementsInGroup = (elements, groupId) => elements.filter(element => isElementInGroup(element, groupId));\nexport const getSelectedGroupIdForElement = (element, selectedGroupIds) => element.groupIds.find(groupId => selectedGroupIds[groupId]);\nexport const getNewGroupIdsForDuplication = (groupIds, editingGroupId, mapper) => {\n  const copy = [...groupIds];\n  const positionOfEditingGroupId = editingGroupId ? groupIds.indexOf(editingGroupId) : -1;\n  const endIndex = positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  for (let index = 0; index < endIndex; index++) {\n    copy[index] = mapper(copy[index]);\n  }\n  return copy;\n};\nexport const addToGroup = (prevGroupIds, newGroupId, editingGroupId) => {\n  // insert before the editingGroupId, or push to the end.\n  const groupIds = [...prevGroupIds];\n  const positionOfEditingGroupId = editingGroupId ? groupIds.indexOf(editingGroupId) : -1;\n  const positionToInsert = positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  groupIds.splice(positionToInsert, 0, newGroupId);\n  return groupIds;\n};\nexport const removeFromSelectedGroups = (groupIds, selectedGroupIds) => groupIds.filter(groupId => !selectedGroupIds[groupId]);\nexport const getMaximumGroups = elements => {\n  const groups = new Map();\n  elements.forEach(element => {\n    const groupId = element.groupIds.length === 0 ? element.id : element.groupIds[element.groupIds.length - 1];\n    const currentGroupMembers = groups.get(groupId) || [];\n\n    // Include bound text if present when grouping\n    const boundTextElement = getBoundTextElement(element);\n    if (boundTextElement) {\n      currentGroupMembers.push(boundTextElement);\n    }\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n  return Array.from(groups.values());\n};\nexport const elementsAreInSameGroup = elements => {\n  const allGroups = elements.flatMap(element => element.groupIds);\n  const groupCount = new Map();\n  let maxGroup = 0;\n  for (const group of allGroups) {\n    var _groupCount$get;\n    groupCount.set(group, ((_groupCount$get = groupCount.get(group)) !== null && _groupCount$get !== void 0 ? _groupCount$get : 0) + 1);\n    if (groupCount.get(group) > maxGroup) {\n      maxGroup = groupCount.get(group);\n    }\n  }\n  return maxGroup === elements.length;\n};","map":{"version":3,"names":["getSelectedElements","getBoundTextElement","makeNextSelectedElementIds","selectGroup","groupId","appState","elements","elementsInGroup","filter","element","groupIds","includes","length","selectedGroupIds","editingGroupId","selectedElementIds","Object","fromEntries","map","id","isSelectedViaGroup","getSelectedGroupForElement","find","getSelectedGroupIds","entries","_ref","isSelected","_ref2","selectGroupsForSelectedElements","prevAppState","app","nextAppState","selectedElements","scene","selectedElement","indexOfEditingGroup","indexOf","slice","selectGroupsFromGivenElements","editGroupForSelectedElement","isElementInGroup","getElementsInGroup","getSelectedGroupIdForElement","getNewGroupIdsForDuplication","mapper","copy","positionOfEditingGroupId","endIndex","index","addToGroup","prevGroupIds","newGroupId","positionToInsert","splice","removeFromSelectedGroups","getMaximumGroups","groups","Map","forEach","currentGroupMembers","get","boundTextElement","push","set","Array","from","values","elementsAreInSameGroup","allGroups","flatMap","groupCount","maxGroup","group","_groupCount$get"],"sources":["D:/project/excalidraw-cn/src/groups.ts"],"sourcesContent":["import {\n  GroupId,\n  ExcalidrawElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n} from \"./element/types\";\nimport { AppClassProperties, AppState } from \"./types\";\nimport { getSelectedElements } from \"./scene\";\nimport { getBoundTextElement } from \"./element/textElement\";\nimport { makeNextSelectedElementIds } from \"./scene/selection\";\n\nexport const selectGroup = (\n  groupId: GroupId,\n  appState: AppState,\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n): AppState => {\n  const elementsInGroup = elements.filter((element) =>\n    element.groupIds.includes(groupId),\n  );\n\n  if (elementsInGroup.length < 2) {\n    if (\n      appState.selectedGroupIds[groupId] ||\n      appState.editingGroupId === groupId\n    ) {\n      return {\n        ...appState,\n        selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: false },\n        editingGroupId: null,\n      };\n    }\n    return appState;\n  }\n\n  return {\n    ...appState,\n    selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: true },\n    selectedElementIds: {\n      ...appState.selectedElementIds,\n      ...Object.fromEntries(\n        elementsInGroup.map((element) => [element.id, true]),\n      ),\n    },\n  };\n};\n\n/**\n * If the element's group is selected, don't render an individual\n * selection border around it.\n */\nexport const isSelectedViaGroup = (\n  appState: AppState,\n  element: ExcalidrawElement,\n) => getSelectedGroupForElement(appState, element) != null;\n\nexport const getSelectedGroupForElement = (\n  appState: AppState,\n  element: ExcalidrawElement,\n) =>\n  element.groupIds\n    .filter((groupId) => groupId !== appState.editingGroupId)\n    .find((groupId) => appState.selectedGroupIds[groupId]);\n\nexport const getSelectedGroupIds = (appState: AppState): GroupId[] =>\n  Object.entries(appState.selectedGroupIds)\n    .filter(([groupId, isSelected]) => isSelected)\n    .map(([groupId, isSelected]) => groupId);\n\n/**\n * When you select an element, you often want to actually select the whole group it's in, unless\n * you're currently editing that group.\n */\nexport const selectGroupsForSelectedElements = (\n  appState: AppState,\n  elements: readonly NonDeletedExcalidrawElement[],\n  prevAppState: AppState,\n  /**\n   * supply null in cases where you don't have access to App instance and\n   * you don't care about optimizing selectElements retrieval\n   */\n  app: AppClassProperties | null,\n): AppState => {\n  let nextAppState: AppState = { ...appState, selectedGroupIds: {} };\n\n  const selectedElements = app\n    ? app.scene.getSelectedElements({\n        selectedElementIds: appState.selectedElementIds,\n        // supplying elements explicitly in case we're passed non-state elements\n        elements,\n      })\n    : getSelectedElements(elements, appState);\n\n  if (!selectedElements.length) {\n    return {\n      ...nextAppState,\n      editingGroupId: null,\n      selectedElementIds: makeNextSelectedElementIds(\n        nextAppState.selectedElementIds,\n        prevAppState,\n      ),\n    };\n  }\n\n  for (const selectedElement of selectedElements) {\n    let groupIds = selectedElement.groupIds;\n    if (appState.editingGroupId) {\n      // handle the case where a group is nested within a group\n      const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n      if (indexOfEditingGroup > -1) {\n        groupIds = groupIds.slice(0, indexOfEditingGroup);\n      }\n    }\n    if (groupIds.length > 0) {\n      const groupId = groupIds[groupIds.length - 1];\n      nextAppState = selectGroup(groupId, nextAppState, elements);\n    }\n  }\n\n  nextAppState.selectedElementIds = makeNextSelectedElementIds(\n    nextAppState.selectedElementIds,\n    prevAppState,\n  );\n\n  return nextAppState;\n};\n\n// given a list of elements, return the the actual group ids that should be selected\n// or used to update the elements\nexport const selectGroupsFromGivenElements = (\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n  appState: AppState,\n) => {\n  let nextAppState: AppState = { ...appState, selectedGroupIds: {} };\n\n  for (const element of elements) {\n    let groupIds = element.groupIds;\n    if (appState.editingGroupId) {\n      const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n      if (indexOfEditingGroup > -1) {\n        groupIds = groupIds.slice(0, indexOfEditingGroup);\n      }\n    }\n    if (groupIds.length > 0) {\n      const groupId = groupIds[groupIds.length - 1];\n      nextAppState = selectGroup(groupId, nextAppState, elements);\n    }\n  }\n\n  return nextAppState.selectedGroupIds;\n};\n\nexport const editGroupForSelectedElement = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n): AppState => {\n  return {\n    ...appState,\n    editingGroupId: element.groupIds.length ? element.groupIds[0] : null,\n    selectedGroupIds: {},\n    selectedElementIds: {\n      [element.id]: true,\n    },\n  };\n};\n\nexport const isElementInGroup = (element: ExcalidrawElement, groupId: string) =>\n  element.groupIds.includes(groupId);\n\nexport const getElementsInGroup = (\n  elements: readonly ExcalidrawElement[],\n  groupId: string,\n) => elements.filter((element) => isElementInGroup(element, groupId));\n\nexport const getSelectedGroupIdForElement = (\n  element: ExcalidrawElement,\n  selectedGroupIds: { [groupId: string]: boolean },\n) => element.groupIds.find((groupId) => selectedGroupIds[groupId]);\n\nexport const getNewGroupIdsForDuplication = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  editingGroupId: AppState[\"editingGroupId\"],\n  mapper: (groupId: GroupId) => GroupId,\n) => {\n  const copy = [...groupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const endIndex =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  for (let index = 0; index < endIndex; index++) {\n    copy[index] = mapper(copy[index]);\n  }\n\n  return copy;\n};\n\nexport const addToGroup = (\n  prevGroupIds: ExcalidrawElement[\"groupIds\"],\n  newGroupId: GroupId,\n  editingGroupId: AppState[\"editingGroupId\"],\n) => {\n  // insert before the editingGroupId, or push to the end.\n  const groupIds = [...prevGroupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const positionToInsert =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  groupIds.splice(positionToInsert, 0, newGroupId);\n  return groupIds;\n};\n\nexport const removeFromSelectedGroups = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  selectedGroupIds: { [groupId: string]: boolean },\n) => groupIds.filter((groupId) => !selectedGroupIds[groupId]);\n\nexport const getMaximumGroups = (\n  elements: ExcalidrawElement[],\n): ExcalidrawElement[][] => {\n  const groups: Map<String, ExcalidrawElement[]> = new Map<\n    String,\n    ExcalidrawElement[]\n  >();\n\n  elements.forEach((element: ExcalidrawElement) => {\n    const groupId =\n      element.groupIds.length === 0\n        ? element.id\n        : element.groupIds[element.groupIds.length - 1];\n\n    const currentGroupMembers = groups.get(groupId) || [];\n\n    // Include bound text if present when grouping\n    const boundTextElement = getBoundTextElement(element);\n    if (boundTextElement) {\n      currentGroupMembers.push(boundTextElement);\n    }\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n\n  return Array.from(groups.values());\n};\n\nexport const elementsAreInSameGroup = (elements: ExcalidrawElement[]) => {\n  const allGroups = elements.flatMap((element) => element.groupIds);\n  const groupCount = new Map<string, number>();\n  let maxGroup = 0;\n\n  for (const group of allGroups) {\n    groupCount.set(group, (groupCount.get(group) ?? 0) + 1);\n    if (groupCount.get(group)! > maxGroup) {\n      maxGroup = groupCount.get(group)!;\n    }\n  }\n\n  return maxGroup === elements.length;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}