{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nimport { parsePath, normalize, absolutize } from 'path-data-parser';\nvar helper = {\n  randOffset: randOffset,\n  randOffsetWithRange: randOffsetWithRange,\n  ellipse: ellipse,\n  doubleLineOps: doubleLineFillOps\n};\nexport function line(x1, y1, x2, y2, o) {\n  return {\n    type: 'path',\n    ops: _doubleLine(x1, y1, x2, y2, o)\n  };\n}\nexport function linearPath(points, close, o) {\n  var len = (points || []).length;\n  if (len > 2) {\n    var ops = [];\n    for (var i = 0; i < len - 1; i++) {\n      ops.push.apply(ops, _toConsumableArray(_doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o)));\n    }\n    if (close) {\n      ops.push.apply(ops, _toConsumableArray(_doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o)));\n    }\n    return {\n      type: 'path',\n      ops: ops\n    };\n  } else if (len === 2) {\n    return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n  }\n  return {\n    type: 'path',\n    ops: []\n  };\n}\nexport function polygon(points, o) {\n  return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n  var points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n  return polygon(points, o);\n}\nexport function curve(points, o) {\n  var o1 = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n  if (!o.disableMultiStroke) {\n    var o2 = _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n    o1 = o1.concat(o2);\n  }\n  return {\n    type: 'path',\n    ops: o1\n  };\n}\nexport function ellipse(x, y, width, height, o) {\n  var params = generateEllipseParams(width, height, o);\n  return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n  var psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n  var stepCount = Math.ceil(Math.max(o.curveStepCount, o.curveStepCount / Math.sqrt(200) * psq));\n  var increment = Math.PI * 2 / stepCount;\n  var rx = Math.abs(width / 2);\n  var ry = Math.abs(height / 2);\n  var curveFitRandomness = 1 - o.curveFitting;\n  rx += _offsetOpt(rx * curveFitRandomness, o);\n  ry += _offsetOpt(ry * curveFitRandomness, o);\n  return {\n    increment: increment,\n    rx: rx,\n    ry: ry\n  };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n  var _computeEllipsePoints2 = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o),\n    _computeEllipsePoints3 = _slicedToArray(_computeEllipsePoints2, 2),\n    ap1 = _computeEllipsePoints3[0],\n    cp1 = _computeEllipsePoints3[1];\n  var o1 = _curve(ap1, null, o);\n  if (!o.disableMultiStroke && o.roughness !== 0) {\n    var _computeEllipsePoints4 = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o),\n      _computeEllipsePoints5 = _slicedToArray(_computeEllipsePoints4, 1),\n      ap2 = _computeEllipsePoints5[0];\n    var o2 = _curve(ap2, null, o);\n    o1 = o1.concat(o2);\n  }\n  return {\n    estimatedPoints: cp1,\n    opset: {\n      type: 'path',\n      ops: o1\n    }\n  };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n  var cx = x;\n  var cy = y;\n  var rx = Math.abs(width / 2);\n  var ry = Math.abs(height / 2);\n  rx += _offsetOpt(rx * 0.01, o);\n  ry += _offsetOpt(ry * 0.01, o);\n  var strt = start;\n  var stp = stop;\n  while (strt < 0) {\n    strt += Math.PI * 2;\n    stp += Math.PI * 2;\n  }\n  if (stp - strt > Math.PI * 2) {\n    strt = 0;\n    stp = Math.PI * 2;\n  }\n  var ellipseInc = Math.PI * 2 / o.curveStepCount;\n  var arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n  var ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n  if (!o.disableMultiStroke) {\n    var o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n    ops.push.apply(ops, _toConsumableArray(o2));\n  }\n  if (closed) {\n    if (roughClosure) {\n      ops.push.apply(ops, _toConsumableArray(_doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o)).concat(_toConsumableArray(_doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o))));\n    } else {\n      ops.push({\n        op: 'lineTo',\n        data: [cx, cy]\n      }, {\n        op: 'lineTo',\n        data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)]\n      });\n    }\n  }\n  return {\n    type: 'path',\n    ops: ops\n  };\n}\nexport function svgPath(path, o) {\n  var segments = normalize(absolutize(parsePath(path)));\n  var ops = [];\n  var first = [0, 0];\n  var current = [0, 0];\n  var _iterator = _createForOfIteratorHelper(segments),\n    _step;\n  try {\n    var _loop = function _loop() {\n      var _step$value = _step.value,\n        key = _step$value.key,\n        data = _step$value.data;\n      switch (key) {\n        case 'M':\n          {\n            var ro = 1 * (o.maxRandomnessOffset || 0);\n            var pv = o.preserveVertices;\n            ops.push({\n              op: 'move',\n              data: data.map(function (d) {\n                return d + (pv ? 0 : _offsetOpt(ro, o));\n              })\n            });\n            current = [data[0], data[1]];\n            first = [data[0], data[1]];\n            break;\n          }\n        case 'L':\n          ops.push.apply(ops, _toConsumableArray(_doubleLine(current[0], current[1], data[0], data[1], o)));\n          current = [data[0], data[1]];\n          break;\n        case 'C':\n          {\n            var _data = _slicedToArray(data, 6),\n              x1 = _data[0],\n              y1 = _data[1],\n              x2 = _data[2],\n              y2 = _data[3],\n              x = _data[4],\n              y = _data[5];\n            ops.push.apply(ops, _toConsumableArray(_bezierTo(x1, y1, x2, y2, x, y, current, o)));\n            current = [x, y];\n            break;\n          }\n        case 'Z':\n          ops.push.apply(ops, _toConsumableArray(_doubleLine(current[0], current[1], first[0], first[1], o)));\n          current = [first[0], first[1]];\n          break;\n      }\n    };\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    type: 'path',\n    ops: ops\n  };\n}\n// Fills\nexport function solidFillPolygon(polygonList, o) {\n  var ops = [];\n  var _iterator2 = _createForOfIteratorHelper(polygonList),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var points = _step2.value;\n      if (points.length) {\n        var offset = o.maxRandomnessOffset || 0;\n        var len = points.length;\n        if (len > 2) {\n          ops.push({\n            op: 'move',\n            data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]\n          });\n          for (var i = 1; i < len; i++) {\n            ops.push({\n              op: 'lineTo',\n              data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]\n            });\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return {\n    type: 'fillPath',\n    ops: ops\n  };\n}\nexport function patternFillPolygons(polygonList, o) {\n  return getFiller(o, helper).fillPolygons(polygonList, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n  var cx = x;\n  var cy = y;\n  var rx = Math.abs(width / 2);\n  var ry = Math.abs(height / 2);\n  rx += _offsetOpt(rx * 0.01, o);\n  ry += _offsetOpt(ry * 0.01, o);\n  var strt = start;\n  var stp = stop;\n  while (strt < 0) {\n    strt += Math.PI * 2;\n    stp += Math.PI * 2;\n  }\n  if (stp - strt > Math.PI * 2) {\n    strt = 0;\n    stp = Math.PI * 2;\n  }\n  var increment = (stp - strt) / o.curveStepCount;\n  var points = [];\n  for (var angle = strt; angle <= stp; angle = angle + increment) {\n    points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n  }\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  points.push([cx, cy]);\n  return patternFillPolygons([points], o);\n}\nexport function randOffset(x, o) {\n  return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n  return _offset(min, max, o);\n}\nexport function doubleLineFillOps(x1, y1, x2, y2, o) {\n  return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n  var result = Object.assign({}, ops);\n  result.randomizer = undefined;\n  if (ops.seed) {\n    result.seed = ops.seed + 1;\n  }\n  return result;\n}\nfunction random(ops) {\n  if (!ops.randomizer) {\n    ops.randomizer = new Random(ops.seed || 0);\n  }\n  return ops.randomizer.next();\n}\nfunction _offset(min, max, ops) {\n  var roughnessGain = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  return ops.roughness * roughnessGain * (random(ops) * (max - min) + min);\n}\nfunction _offsetOpt(x, ops) {\n  var roughnessGain = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o) {\n  var filling = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n  var o1 = _line(x1, y1, x2, y2, o, true, false);\n  if (singleStroke) {\n    return o1;\n  }\n  var o2 = _line(x1, y1, x2, y2, o, true, true);\n  return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n  var lengthSq = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\n  var length = Math.sqrt(lengthSq);\n  var roughnessGain = 1;\n  if (length < 200) {\n    roughnessGain = 1;\n  } else if (length > 500) {\n    roughnessGain = 0.4;\n  } else {\n    roughnessGain = -0.0016668 * length + 1.233334;\n  }\n  var offset = o.maxRandomnessOffset || 0;\n  if (offset * offset * 100 > lengthSq) {\n    offset = length / 10;\n  }\n  var halfOffset = offset / 2;\n  var divergePoint = 0.2 + random(o) * 0.2;\n  var midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n  var midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n  midDispX = _offsetOpt(midDispX, o, roughnessGain);\n  midDispY = _offsetOpt(midDispY, o, roughnessGain);\n  var ops = [];\n  var randomHalf = function randomHalf() {\n    return _offsetOpt(halfOffset, o, roughnessGain);\n  };\n  var randomFull = function randomFull() {\n    return _offsetOpt(offset, o, roughnessGain);\n  };\n  var preserveVertices = o.preserveVertices;\n  if (move) {\n    if (overlay) {\n      ops.push({\n        op: 'move',\n        data: [x1 + (preserveVertices ? 0 : randomHalf()), y1 + (preserveVertices ? 0 : randomHalf())]\n      });\n    } else {\n      ops.push({\n        op: 'move',\n        data: [x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)), y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain))]\n      });\n    }\n  }\n  if (overlay) {\n    ops.push({\n      op: 'bcurveTo',\n      data: [midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(), midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(), midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(), midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(), x2 + (preserveVertices ? 0 : randomHalf()), y2 + (preserveVertices ? 0 : randomHalf())]\n    });\n  } else {\n    ops.push({\n      op: 'bcurveTo',\n      data: [midDispX + x1 + (x2 - x1) * divergePoint + randomFull(), midDispY + y1 + (y2 - y1) * divergePoint + randomFull(), midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(), midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(), x2 + (preserveVertices ? 0 : randomFull()), y2 + (preserveVertices ? 0 : randomFull())]\n    });\n  }\n  return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n  var ps = [];\n  ps.push([points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]);\n  ps.push([points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]);\n  for (var i = 1; i < points.length; i++) {\n    ps.push([points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]);\n    if (i === points.length - 1) {\n      ps.push([points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]);\n    }\n  }\n  return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n  var len = points.length;\n  var ops = [];\n  if (len > 3) {\n    var b = [];\n    var s = 1 - o.curveTightness;\n    ops.push({\n      op: 'move',\n      data: [points[1][0], points[1][1]]\n    });\n    for (var i = 1; i + 2 < len; i++) {\n      var cachedVertArray = points[i];\n      b[0] = [cachedVertArray[0], cachedVertArray[1]];\n      b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n      b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n      b[3] = [points[i + 1][0], points[i + 1][1]];\n      ops.push({\n        op: 'bcurveTo',\n        data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]]\n      });\n    }\n    if (closePoint && closePoint.length === 2) {\n      var ro = o.maxRandomnessOffset;\n      ops.push({\n        op: 'lineTo',\n        data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)]\n      });\n    }\n  } else if (len === 3) {\n    ops.push({\n      op: 'move',\n      data: [points[1][0], points[1][1]]\n    });\n    ops.push({\n      op: 'bcurveTo',\n      data: [points[1][0], points[1][1], points[2][0], points[2][1], points[2][0], points[2][1]]\n    });\n  } else if (len === 2) {\n    ops.push.apply(ops, _toConsumableArray(_doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o)));\n  }\n  return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n  var coreOnly = o.roughness === 0;\n  var corePoints = [];\n  var allPoints = [];\n  if (coreOnly) {\n    increment = increment / 4;\n    allPoints.push([cx + rx * Math.cos(-increment), cy + ry * Math.sin(-increment)]);\n    for (var angle = 0; angle <= Math.PI * 2; angle = angle + increment) {\n      var p = [cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)];\n      corePoints.push(p);\n      allPoints.push(p);\n    }\n    allPoints.push([cx + rx * Math.cos(0), cy + ry * Math.sin(0)]);\n    allPoints.push([cx + rx * Math.cos(increment), cy + ry * Math.sin(increment)]);\n  } else {\n    var radOffset = _offsetOpt(0.5, o) - Math.PI / 2;\n    allPoints.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)]);\n    var endAngle = Math.PI * 2 + radOffset - 0.01;\n    for (var _angle = radOffset; _angle < endAngle; _angle = _angle + increment) {\n      var _p = [_offsetOpt(offset, o) + cx + rx * Math.cos(_angle), _offsetOpt(offset, o) + cy + ry * Math.sin(_angle)];\n      corePoints.push(_p);\n      allPoints.push(_p);\n    }\n    allPoints.push([_offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5), _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)]);\n    allPoints.push([_offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap), _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)]);\n    allPoints.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)]);\n  }\n  return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n  var radOffset = strt + _offsetOpt(0.1, o);\n  var points = [];\n  points.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)]);\n  for (var angle = radOffset; angle <= stp; angle = angle + increment) {\n    points.push([_offsetOpt(offset, o) + cx + rx * Math.cos(angle), _offsetOpt(offset, o) + cy + ry * Math.sin(angle)]);\n  }\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n  var ops = [];\n  var ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n  var f = [0, 0];\n  var iterations = o.disableMultiStroke ? 1 : 2;\n  var preserveVertices = o.preserveVertices;\n  for (var i = 0; i < iterations; i++) {\n    if (i === 0) {\n      ops.push({\n        op: 'move',\n        data: [current[0], current[1]]\n      });\n    } else {\n      ops.push({\n        op: 'move',\n        data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))]\n      });\n    }\n    f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n    ops.push({\n      op: 'bcurveTo',\n      data: [x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o), x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o), f[0], f[1]]\n    });\n  }\n  return ops;\n}","map":{"version":3,"names":["getFiller","Random","parsePath","normalize","absolutize","helper","randOffset","randOffsetWithRange","ellipse","doubleLineOps","doubleLineFillOps","line","x1","y1","x2","y2","o","type","ops","_doubleLine","linearPath","points","close","len","length","i","push","apply","_toConsumableArray","polygon","rectangle","x","y","width","height","curve","o1","_curveWithOffset","roughness","disableMultiStroke","o2","cloneOptionsAlterSeed","concat","params","generateEllipseParams","ellipseWithParams","opset","psq","Math","sqrt","PI","pow","stepCount","ceil","max","curveStepCount","increment","rx","abs","ry","curveFitRandomness","curveFitting","_offsetOpt","ellipseParams","_computeEllipsePoints2","_computeEllipsePoints","_offset","_computeEllipsePoints3","_slicedToArray","ap1","cp1","_curve","_computeEllipsePoints4","_computeEllipsePoints5","ap2","estimatedPoints","arc","start","stop","closed","roughClosure","cx","cy","strt","stp","ellipseInc","arcInc","min","_arc","cos","sin","op","data","svgPath","path","segments","first","current","_iterator","_createForOfIteratorHelper","_step","_loop","_step$value","value","key","ro","maxRandomnessOffset","pv","preserveVertices","map","d","_data","_bezierTo","s","n","done","err","e","f","solidFillPolygon","polygonList","_iterator2","_step2","offset","patternFillPolygons","fillPolygons","patternFillArc","angle","result","Object","assign","randomizer","undefined","seed","random","next","roughnessGain","arguments","filling","singleStroke","disableMultiStrokeFill","_line","move","overlay","lengthSq","halfOffset","divergePoint","midDispX","bowing","midDispY","randomHalf","randomFull","ps","closePoint","b","curveTightness","cachedVertArray","overlap","coreOnly","corePoints","allPoints","p","radOffset","endAngle","ros","iterations"],"sources":["D:/project/excalidraw-cn/node_modules/roughjs/bin/renderer.js"],"sourcesContent":["import { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nimport { parsePath, normalize, absolutize } from 'path-data-parser';\nconst helper = {\n    randOffset,\n    randOffsetWithRange,\n    ellipse,\n    doubleLineOps: doubleLineFillOps,\n};\nexport function line(x1, y1, x2, y2, o) {\n    return { type: 'path', ops: _doubleLine(x1, y1, x2, y2, o) };\n}\nexport function linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n        const ops = [];\n        for (let i = 0; i < (len - 1); i++) {\n            ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n        }\n        if (close) {\n            ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n        }\n        return { type: 'path', ops };\n    }\n    else if (len === 2) {\n        return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n    return { type: 'path', ops: [] };\n}\nexport function polygon(points, o) {\n    return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n    const points = [\n        [x, y],\n        [x + width, y],\n        [x + width, y + height],\n        [x, y + height],\n    ];\n    return polygon(points, o);\n}\nexport function curve(points, o) {\n    let o1 = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n    if (!o.disableMultiStroke) {\n        const o2 = _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n        o1 = o1.concat(o2);\n    }\n    return { type: 'path', ops: o1 };\n}\nexport function ellipse(x, y, width, height, o) {\n    const params = generateEllipseParams(width, height, o);\n    return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n    const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n    const stepCount = Math.ceil(Math.max(o.curveStepCount, (o.curveStepCount / Math.sqrt(200)) * psq));\n    const increment = (Math.PI * 2) / stepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    const curveFitRandomness = 1 - o.curveFitting;\n    rx += _offsetOpt(rx * curveFitRandomness, o);\n    ry += _offsetOpt(ry * curveFitRandomness, o);\n    return { increment, rx, ry };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n    const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n    let o1 = _curve(ap1, null, o);\n    if ((!o.disableMultiStroke) && (o.roughness !== 0)) {\n        const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n        const o2 = _curve(ap2, null, o);\n        o1 = o1.concat(o2);\n    }\n    return {\n        estimatedPoints: cp1,\n        opset: { type: 'path', ops: o1 },\n    };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    if (!o.disableMultiStroke) {\n        const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        ops.push(...o2);\n    }\n    if (closed) {\n        if (roughClosure) {\n            ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n        }\n        else {\n            ops.push({ op: 'lineTo', data: [cx, cy] }, { op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n        }\n    }\n    return { type: 'path', ops };\n}\nexport function svgPath(path, o) {\n    const segments = normalize(absolutize(parsePath(path)));\n    const ops = [];\n    let first = [0, 0];\n    let current = [0, 0];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M': {\n                const ro = 1 * (o.maxRandomnessOffset || 0);\n                const pv = o.preserveVertices;\n                ops.push({ op: 'move', data: data.map((d) => d + (pv ? 0 : _offsetOpt(ro, o))) });\n                current = [data[0], data[1]];\n                first = [data[0], data[1]];\n                break;\n            }\n            case 'L':\n                ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n                current = [data[0], data[1]];\n                break;\n            case 'C': {\n                const [x1, y1, x2, y2, x, y] = data;\n                ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n                current = [x, y];\n                break;\n            }\n            case 'Z':\n                ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n                current = [first[0], first[1]];\n                break;\n        }\n    }\n    return { type: 'path', ops };\n}\n// Fills\nexport function solidFillPolygon(polygonList, o) {\n    const ops = [];\n    for (const points of polygonList) {\n        if (points.length) {\n            const offset = o.maxRandomnessOffset || 0;\n            const len = points.length;\n            if (len > 2) {\n                ops.push({ op: 'move', data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)] });\n                for (let i = 1; i < len; i++) {\n                    ops.push({ op: 'lineTo', data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)] });\n                }\n            }\n        }\n    }\n    return { type: 'fillPath', ops };\n}\nexport function patternFillPolygons(polygonList, o) {\n    return getFiller(o, helper).fillPolygons(polygonList, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const increment = (stp - strt) / o.curveStepCount;\n    const points = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n        points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n    }\n    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n    points.push([cx, cy]);\n    return patternFillPolygons([points], o);\n}\nexport function randOffset(x, o) {\n    return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n    return _offset(min, max, o);\n}\nexport function doubleLineFillOps(x1, y1, x2, y2, o) {\n    return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n    const result = Object.assign({}, ops);\n    result.randomizer = undefined;\n    if (ops.seed) {\n        result.seed = ops.seed + 1;\n    }\n    return result;\n}\nfunction random(ops) {\n    if (!ops.randomizer) {\n        ops.randomizer = new Random(ops.seed || 0);\n    }\n    return ops.randomizer.next();\n}\nfunction _offset(min, max, ops, roughnessGain = 1) {\n    return ops.roughness * roughnessGain * ((random(ops) * (max - min)) + min);\n}\nfunction _offsetOpt(x, ops, roughnessGain = 1) {\n    return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o, filling = false) {\n    const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n    const o1 = _line(x1, y1, x2, y2, o, true, false);\n    if (singleStroke) {\n        return o1;\n    }\n    const o2 = _line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    const length = Math.sqrt(lengthSq);\n    let roughnessGain = 1;\n    if (length < 200) {\n        roughnessGain = 1;\n    }\n    else if (length > 500) {\n        roughnessGain = 0.4;\n    }\n    else {\n        roughnessGain = (-0.0016668) * length + 1.233334;\n    }\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n        offset = length / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + random(o) * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = _offsetOpt(midDispX, o, roughnessGain);\n    midDispY = _offsetOpt(midDispY, o, roughnessGain);\n    const ops = [];\n    const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n    const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n    const preserveVertices = o.preserveVertices;\n    if (move) {\n        if (overlay) {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : randomHalf()),\n                    y1 + (preserveVertices ? 0 : randomHalf()),\n                ],\n            });\n        }\n        else {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                    y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                ],\n            });\n        }\n    }\n    if (overlay) {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),\n                x2 + (preserveVertices ? 0 : randomHalf()),\n                y2 + (preserveVertices ? 0 : randomHalf()),\n            ],\n        });\n    }\n    else {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),\n                x2 + (preserveVertices ? 0 : randomFull()),\n                y2 + (preserveVertices ? 0 : randomFull()),\n            ],\n        });\n    }\n    return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n    const ps = [];\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n        ps.push([\n            points[i][0] + _offsetOpt(offset, o),\n            points[i][1] + _offsetOpt(offset, o),\n        ]);\n        if (i === (points.length - 1)) {\n            ps.push([\n                points[i][0] + _offsetOpt(offset, o),\n                points[i][1] + _offsetOpt(offset, o),\n            ]);\n        }\n    }\n    return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n    const len = points.length;\n    const ops = [];\n    if (len > 3) {\n        const b = [];\n        const s = 1 - o.curveTightness;\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        for (let i = 1; (i + 2) < len; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n        }\n        if (closePoint && closePoint.length === 2) {\n            const ro = o.maxRandomnessOffset;\n            ops.push({ op: 'lineTo', data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });\n        }\n    }\n    else if (len === 3) {\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                points[1][0], points[1][1],\n                points[2][0], points[2][1],\n                points[2][0], points[2][1],\n            ],\n        });\n    }\n    else if (len === 2) {\n        ops.push(..._doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n    }\n    return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const coreOnly = o.roughness === 0;\n    const corePoints = [];\n    const allPoints = [];\n    if (coreOnly) {\n        increment = increment / 4;\n        allPoints.push([\n            cx + rx * Math.cos(-increment),\n            cy + ry * Math.sin(-increment),\n        ]);\n        for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {\n            const p = [\n                cx + rx * Math.cos(angle),\n                cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            cx + rx * Math.cos(0),\n            cy + ry * Math.sin(0),\n        ]);\n        allPoints.push([\n            cx + rx * Math.cos(increment),\n            cy + ry * Math.sin(increment),\n        ]);\n    }\n    else {\n        const radOffset = _offsetOpt(0.5, o) - (Math.PI / 2);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n        ]);\n        const endAngle = Math.PI * 2 + radOffset - 0.01;\n        for (let angle = radOffset; angle < endAngle; angle = angle + increment) {\n            const p = [\n                _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n                _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n            _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5),\n        ]);\n    }\n    return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + _offsetOpt(0.1, o);\n    const points = [];\n    points.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n        points.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n        ]);\n    }\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n    const ops = [];\n    const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n    let f = [0, 0];\n    const iterations = o.disableMultiStroke ? 1 : 2;\n    const preserveVertices = o.preserveVertices;\n    for (let i = 0; i < iterations; i++) {\n        if (i === 0) {\n            ops.push({ op: 'move', data: [current[0], current[1]] });\n        }\n        else {\n            ops.push({ op: 'move', data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))] });\n        }\n        f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o),\n                x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o),\n                f[0], f[1],\n            ],\n        });\n    }\n    return ops;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}