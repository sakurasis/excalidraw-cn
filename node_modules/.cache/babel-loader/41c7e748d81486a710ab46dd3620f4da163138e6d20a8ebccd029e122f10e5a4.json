{"ast":null,"code":"const COMMAND = 0;\nconst NUMBER = 1;\nconst EOD = 2;\nconst PARAMS = {\n  A: 7,\n  a: 7,\n  C: 6,\n  c: 6,\n  H: 1,\n  h: 1,\n  L: 2,\n  l: 2,\n  M: 2,\n  m: 2,\n  Q: 4,\n  q: 4,\n  S: 4,\n  s: 4,\n  T: 2,\n  t: 2,\n  V: 1,\n  v: 1,\n  Z: 0,\n  z: 0\n};\nfunction tokenize(d) {\n  const tokens = new Array();\n  while (d !== '') {\n    if (d.match(/^([ \\t\\r\\n,]+)/)) {\n      d = d.substr(RegExp.$1.length);\n    } else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n      tokens[tokens.length] = {\n        type: COMMAND,\n        text: RegExp.$1\n      };\n      d = d.substr(RegExp.$1.length);\n    } else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n      tokens[tokens.length] = {\n        type: NUMBER,\n        text: `${parseFloat(RegExp.$1)}`\n      };\n      d = d.substr(RegExp.$1.length);\n    } else {\n      return [];\n    }\n  }\n  tokens[tokens.length] = {\n    type: EOD,\n    text: ''\n  };\n  return tokens;\n}\nfunction isType(token, type) {\n  return token.type === type;\n}\nexport function parsePath(d) {\n  const segments = [];\n  const tokens = tokenize(d);\n  let mode = 'BOD';\n  let index = 0;\n  let token = tokens[index];\n  while (!isType(token, EOD)) {\n    let paramsCount = 0;\n    const params = [];\n    if (mode === 'BOD') {\n      if (token.text === 'M' || token.text === 'm') {\n        index++;\n        paramsCount = PARAMS[token.text];\n        mode = token.text;\n      } else {\n        return parsePath('M0,0' + d);\n      }\n    } else if (isType(token, NUMBER)) {\n      paramsCount = PARAMS[mode];\n    } else {\n      index++;\n      paramsCount = PARAMS[token.text];\n      mode = token.text;\n    }\n    if (index + paramsCount < tokens.length) {\n      for (let i = index; i < index + paramsCount; i++) {\n        const numbeToken = tokens[i];\n        if (isType(numbeToken, NUMBER)) {\n          params[params.length] = +numbeToken.text;\n        } else {\n          throw new Error('Param not a number: ' + mode + ',' + numbeToken.text);\n        }\n      }\n      if (typeof PARAMS[mode] === 'number') {\n        const segment = {\n          key: mode,\n          data: params\n        };\n        segments.push(segment);\n        index += paramsCount;\n        token = tokens[index];\n        if (mode === 'M') mode = 'L';\n        if (mode === 'm') mode = 'l';\n      } else {\n        throw new Error('Bad segment: ' + mode);\n      }\n    } else {\n      throw new Error('Path data ended short');\n    }\n  }\n  return segments;\n}\nexport function serialize(segments) {\n  const tokens = [];\n  for (const {\n    key,\n    data\n  } of segments) {\n    tokens.push(key);\n    switch (key) {\n      case 'C':\n      case 'c':\n        tokens.push(data[0], `${data[1]},`, data[2], `${data[3]},`, data[4], data[5]);\n        break;\n      case 'S':\n      case 's':\n      case 'Q':\n      case 'q':\n        tokens.push(data[0], `${data[1]},`, data[2], data[3]);\n        break;\n      default:\n        tokens.push(...data);\n        break;\n    }\n  }\n  return tokens.join(' ');\n}","map":{"version":3,"names":["COMMAND","NUMBER","EOD","PARAMS","A","a","C","c","H","h","L","l","M","m","Q","q","S","s","T","t","V","v","Z","z","tokenize","d","tokens","Array","match","substr","RegExp","$1","length","type","text","parseFloat","isType","token","parsePath","segments","mode","index","paramsCount","params","i","numbeToken","Error","segment","key","data","push","serialize","join"],"sources":["D:/project/excalidraw-cn/node_modules/path-data-parser/lib/parser.js"],"sourcesContent":["const COMMAND = 0;\nconst NUMBER = 1;\nconst EOD = 2;\nconst PARAMS = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };\nfunction tokenize(d) {\n    const tokens = new Array();\n    while (d !== '') {\n        if (d.match(/^([ \\t\\r\\n,]+)/)) {\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n            tokens[tokens.length] = { type: COMMAND, text: RegExp.$1 };\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n            tokens[tokens.length] = { type: NUMBER, text: `${parseFloat(RegExp.$1)}` };\n            d = d.substr(RegExp.$1.length);\n        }\n        else {\n            return [];\n        }\n    }\n    tokens[tokens.length] = { type: EOD, text: '' };\n    return tokens;\n}\nfunction isType(token, type) {\n    return token.type === type;\n}\nexport function parsePath(d) {\n    const segments = [];\n    const tokens = tokenize(d);\n    let mode = 'BOD';\n    let index = 0;\n    let token = tokens[index];\n    while (!isType(token, EOD)) {\n        let paramsCount = 0;\n        const params = [];\n        if (mode === 'BOD') {\n            if (token.text === 'M' || token.text === 'm') {\n                index++;\n                paramsCount = PARAMS[token.text];\n                mode = token.text;\n            }\n            else {\n                return parsePath('M0,0' + d);\n            }\n        }\n        else if (isType(token, NUMBER)) {\n            paramsCount = PARAMS[mode];\n        }\n        else {\n            index++;\n            paramsCount = PARAMS[token.text];\n            mode = token.text;\n        }\n        if ((index + paramsCount) < tokens.length) {\n            for (let i = index; i < index + paramsCount; i++) {\n                const numbeToken = tokens[i];\n                if (isType(numbeToken, NUMBER)) {\n                    params[params.length] = +numbeToken.text;\n                }\n                else {\n                    throw new Error('Param not a number: ' + mode + ',' + numbeToken.text);\n                }\n            }\n            if (typeof PARAMS[mode] === 'number') {\n                const segment = { key: mode, data: params };\n                segments.push(segment);\n                index += paramsCount;\n                token = tokens[index];\n                if (mode === 'M')\n                    mode = 'L';\n                if (mode === 'm')\n                    mode = 'l';\n            }\n            else {\n                throw new Error('Bad segment: ' + mode);\n            }\n        }\n        else {\n            throw new Error('Path data ended short');\n        }\n    }\n    return segments;\n}\nexport function serialize(segments) {\n    const tokens = [];\n    for (const { key, data } of segments) {\n        tokens.push(key);\n        switch (key) {\n            case 'C':\n            case 'c':\n                tokens.push(data[0], `${data[1]},`, data[2], `${data[3]},`, data[4], data[5]);\n                break;\n            case 'S':\n            case 's':\n            case 'Q':\n            case 'q':\n                tokens.push(data[0], `${data[1]},`, data[2], data[3]);\n                break;\n            default:\n                tokens.push(...data);\n                break;\n        }\n    }\n    return tokens.join(' ');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}