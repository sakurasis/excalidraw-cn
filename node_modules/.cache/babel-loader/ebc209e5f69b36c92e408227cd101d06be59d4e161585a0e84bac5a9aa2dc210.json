{"ast":null,"code":"import { getFontString, arrayToMap, isTestEnv } from \"../utils\";\nimport { mutateElement } from \"./mutateElement\";\nimport { BOUND_TEXT_PADDING, DEFAULT_FONT_FAMILY, DEFAULT_FONT_SIZE, FONT_FAMILY, isSafari, TEXT_ALIGN, VERTICAL_ALIGN } from \"../constants\";\nimport Scene from \"../scene/Scene\";\nimport { isTextElement } from \".\";\nimport { isBoundToContainer, isArrowElement } from \"./typeChecks\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { isTextBindableContainer } from \"./typeChecks\";\nimport { getElementAbsoluteCoords } from \"../element\";\nimport { getSelectedElements } from \"../scene\";\nimport { isHittingElementNotConsideringBoundingBox } from \"./collision\";\nimport { resetOriginalContainerCache, updateOriginalContainerCache } from \"./textWysiwyg\";\nexport const normalizeText = text => {\n  return text\n  // replace tabs with spaces so they render and measure correctly\n  .replace(/\\t/g, \"        \")\n  // normalize newlines\n  .replace(/\\r?\\n|\\r/g, \"\\n\");\n};\nexport const splitIntoLines = text => {\n  return normalizeText(text).split(\"\\n\");\n};\nexport const redrawTextBoundingBox = (textElement, container) => {\n  let maxWidth = undefined;\n  const boundTextUpdates = {\n    x: textElement.x,\n    y: textElement.y,\n    text: textElement.text,\n    width: textElement.width,\n    height: textElement.height,\n    baseline: textElement.baseline\n  };\n  boundTextUpdates.text = textElement.text;\n  if (container) {\n    maxWidth = getBoundTextMaxWidth(container);\n    boundTextUpdates.text = wrapText(textElement.originalText, getFontString(textElement), maxWidth);\n  }\n  const metrics = measureText(boundTextUpdates.text, getFontString(textElement), textElement.lineHeight);\n  boundTextUpdates.width = metrics.width;\n  boundTextUpdates.height = metrics.height;\n  boundTextUpdates.baseline = metrics.baseline;\n  if (container) {\n    const containerDims = getContainerDims(container);\n    const maxContainerHeight = getBoundTextMaxHeight(container, textElement);\n    let nextHeight = containerDims.height;\n    if (metrics.height > maxContainerHeight) {\n      nextHeight = computeContainerDimensionForBoundText(metrics.height, container.type);\n      mutateElement(container, {\n        height: nextHeight\n      });\n      updateOriginalContainerCache(container.id, nextHeight);\n    }\n    const updatedTextElement = {\n      ...textElement,\n      ...boundTextUpdates\n    };\n    const {\n      x,\n      y\n    } = computeBoundTextPosition(container, updatedTextElement);\n    boundTextUpdates.x = x;\n    boundTextUpdates.y = y;\n  }\n  mutateElement(textElement, boundTextUpdates);\n};\nexport const bindTextToShapeAfterDuplication = (sceneElements, oldElements, oldIdToDuplicatedId) => {\n  const sceneElementMap = arrayToMap(sceneElements);\n  oldElements.forEach(element => {\n    const newElementId = oldIdToDuplicatedId.get(element.id);\n    const boundTextElementId = getBoundTextElementId(element);\n    if (boundTextElementId) {\n      const newTextElementId = oldIdToDuplicatedId.get(boundTextElementId);\n      if (newTextElementId) {\n        const newContainer = sceneElementMap.get(newElementId);\n        if (newContainer) {\n          mutateElement(newContainer, {\n            boundElements: (element.boundElements || []).filter(boundElement => boundElement.id !== newTextElementId && boundElement.id !== boundTextElementId).concat({\n              type: \"text\",\n              id: newTextElementId\n            })\n          });\n        }\n        const newTextElement = sceneElementMap.get(newTextElementId);\n        if (newTextElement && isTextElement(newTextElement)) {\n          mutateElement(newTextElement, {\n            containerId: newContainer ? newElementId : null\n          });\n        }\n      }\n    }\n  });\n};\nexport const handleBindTextResize = (container, transformHandleType) => {\n  const boundTextElementId = getBoundTextElementId(container);\n  if (!boundTextElementId) {\n    return;\n  }\n  resetOriginalContainerCache(container.id);\n  let textElement = Scene.getScene(container).getElement(boundTextElementId);\n  if (textElement && textElement.text) {\n    if (!container) {\n      return;\n    }\n    textElement = Scene.getScene(container).getElement(boundTextElementId);\n    let text = textElement.text;\n    let nextHeight = textElement.height;\n    let nextWidth = textElement.width;\n    const containerDims = getContainerDims(container);\n    const maxWidth = getBoundTextMaxWidth(container);\n    const maxHeight = getBoundTextMaxHeight(container, textElement);\n    let containerHeight = containerDims.height;\n    let nextBaseLine = textElement.baseline;\n    if (transformHandleType !== \"n\" && transformHandleType !== \"s\") {\n      if (text) {\n        text = wrapText(textElement.originalText, getFontString(textElement), maxWidth);\n      }\n      const metrics = measureText(text, getFontString(textElement), textElement.lineHeight);\n      nextHeight = metrics.height;\n      nextWidth = metrics.width;\n      nextBaseLine = metrics.baseline;\n    }\n    // increase height in case text element height exceeds\n    if (nextHeight > maxHeight) {\n      containerHeight = computeContainerDimensionForBoundText(nextHeight, container.type);\n      const diff = containerHeight - containerDims.height;\n      // fix the y coord when resizing from ne/nw/n\n      const updatedY = !isArrowElement(container) && (transformHandleType === \"ne\" || transformHandleType === \"nw\" || transformHandleType === \"n\") ? container.y - diff : container.y;\n      mutateElement(container, {\n        height: containerHeight,\n        y: updatedY\n      });\n    }\n    mutateElement(textElement, {\n      text,\n      width: nextWidth,\n      height: nextHeight,\n      baseline: nextBaseLine\n    });\n    if (!isArrowElement(container)) {\n      mutateElement(textElement, computeBoundTextPosition(container, textElement));\n    }\n  }\n};\nexport const computeBoundTextPosition = (container, boundTextElement) => {\n  if (isArrowElement(container)) {\n    return LinearElementEditor.getBoundTextElementPosition(container, boundTextElement);\n  }\n  const containerCoords = getContainerCoords(container);\n  const maxContainerHeight = getBoundTextMaxHeight(container, boundTextElement);\n  const maxContainerWidth = getBoundTextMaxWidth(container);\n  let x;\n  let y;\n  if (boundTextElement.verticalAlign === VERTICAL_ALIGN.TOP) {\n    y = containerCoords.y;\n  } else if (boundTextElement.verticalAlign === VERTICAL_ALIGN.BOTTOM) {\n    y = containerCoords.y + (maxContainerHeight - boundTextElement.height);\n  } else {\n    y = containerCoords.y + (maxContainerHeight / 2 - boundTextElement.height / 2);\n  }\n  if (boundTextElement.textAlign === TEXT_ALIGN.LEFT) {\n    x = containerCoords.x;\n  } else if (boundTextElement.textAlign === TEXT_ALIGN.RIGHT) {\n    x = containerCoords.x + (maxContainerWidth - boundTextElement.width);\n  } else {\n    x = containerCoords.x + (maxContainerWidth / 2 - boundTextElement.width / 2);\n  }\n  return {\n    x,\n    y\n  };\n};\n\n// https://github.com/grassator/canvas-text-editor/blob/master/lib/FontMetrics.js\n\nexport const measureText = (text, font, lineHeight) => {\n  text = text.split(\"\\n\")\n  // replace empty lines with single space because leading/trailing empty\n  // lines would be stripped from computation\n  .map(x => x || \" \").join(\"\\n\");\n  const fontSize = parseFloat(font);\n  const height = getTextHeight(text, fontSize, lineHeight);\n  const width = getTextWidth(text, font);\n  const baseline = measureBaseline(text, font, lineHeight);\n  return {\n    width,\n    height,\n    baseline\n  };\n};\nexport const measureBaseline = (text, font, lineHeight, wrapInContainer) => {\n  const container = document.createElement(\"div\");\n  container.style.position = \"absolute\";\n  container.style.whiteSpace = \"pre\";\n  container.style.font = font;\n  container.style.minHeight = \"1em\";\n  if (wrapInContainer) {\n    container.style.overflow = \"hidden\";\n    container.style.wordBreak = \"break-word\";\n    container.style.whiteSpace = \"pre-wrap\";\n  }\n  container.style.lineHeight = String(lineHeight);\n  container.innerText = text;\n\n  // Baseline is important for positioning text on canvas\n  document.body.appendChild(container);\n  const span = document.createElement(\"span\");\n  span.style.display = \"inline-block\";\n  span.style.overflow = \"hidden\";\n  span.style.width = \"1px\";\n  span.style.height = \"1px\";\n  container.appendChild(span);\n  let baseline = span.offsetTop + span.offsetHeight;\n  const height = container.offsetHeight;\n  if (isSafari) {\n    const canvasHeight = getTextHeight(text, parseFloat(font), lineHeight);\n    const fontSize = parseFloat(font);\n    // In Safari the font size gets rounded off when rendering hence calculating the safari height and shifting the baseline if it differs\n    // from the actual canvas height\n    const domHeight = getTextHeight(text, Math.round(fontSize), lineHeight);\n    if (canvasHeight > height) {\n      baseline += canvasHeight - domHeight;\n    }\n    if (height > canvasHeight) {\n      baseline -= domHeight - canvasHeight;\n    }\n  }\n  document.body.removeChild(container);\n  return baseline;\n};\n\n/**\n * To get unitless line-height (if unknown) we can calculate it by dividing\n * height-per-line by fontSize.\n */\nexport const detectLineHeight = textElement => {\n  const lineCount = splitIntoLines(textElement.text).length;\n  return textElement.height / lineCount / textElement.fontSize;\n};\n\n/**\n * We calculate the line height from the font size and the unitless line height,\n * aligning with the W3C spec.\n */\nexport const getLineHeightInPx = (fontSize, lineHeight) => {\n  return fontSize * lineHeight;\n};\n\n// FIXME rename to getApproxMinContainerHeight\nexport const getApproxMinLineHeight = (fontSize, lineHeight) => {\n  return getLineHeightInPx(fontSize, lineHeight) + BOUND_TEXT_PADDING * 2;\n};\nlet canvas;\nconst getLineWidth = (text, font) => {\n  if (!canvas) {\n    canvas = document.createElement(\"canvas\");\n  }\n  const canvas2dContext = canvas.getContext(\"2d\");\n  canvas2dContext.font = font;\n  const width = canvas2dContext.measureText(text).width;\n\n  // since in test env the canvas measureText algo\n  // doesn't measure text and instead just returns number of\n  // characters hence we assume that each letteris 10px\n  if (isTestEnv()) {\n    return width * 10;\n  }\n  return width;\n};\nexport const getTextWidth = (text, font) => {\n  const lines = splitIntoLines(text);\n  let width = 0;\n  lines.forEach(line => {\n    width = Math.max(width, getLineWidth(line, font));\n  });\n  return width;\n};\nexport const getTextHeight = (text, fontSize, lineHeight) => {\n  const lineCount = splitIntoLines(text).length;\n  return getLineHeightInPx(fontSize, lineHeight) * lineCount;\n};\nexport const parseTokens = text => {\n  // Splitting words containing \"-\" as those are treated as separate words\n  // by css wrapping algorithm eg non-profit => non-, profit\n  const words = text.split(\"-\");\n  if (words.length > 1) {\n    // non-proft org => ['non-', 'profit org']\n    words.forEach((word, index) => {\n      if (index !== words.length - 1) {\n        words[index] = word += \"-\";\n      }\n    });\n  }\n  // Joining the words with space and splitting them again with space to get the\n  // final list of tokens\n  // ['non-', 'profit org'] =>,'non- proft org' => ['non-','profit','org']\n  return words.join(\" \").split(\" \");\n};\nexport const wrapText = (text, font, maxWidth) => {\n  // if maxWidth is not finite or NaN which can happen in case of bugs in\n  // computation, we need to make sure we don't continue as we'll end up\n  // in an infinite loop\n  if (!Number.isFinite(maxWidth) || maxWidth < 0) {\n    return text;\n  }\n  const lines = [];\n  const originalLines = text.split(\"\\n\");\n  const spaceWidth = getLineWidth(\" \", font);\n  let currentLine = \"\";\n  let currentLineWidthTillNow = 0;\n  const push = str => {\n    if (str.trim()) {\n      lines.push(str);\n    }\n  };\n  const resetParams = () => {\n    currentLine = \"\";\n    currentLineWidthTillNow = 0;\n  };\n  originalLines.forEach(originalLine => {\n    const currentLineWidth = getTextWidth(originalLine, font);\n\n    // Push the line if its <= maxWidth\n    if (currentLineWidth <= maxWidth) {\n      lines.push(originalLine);\n      return; // continue\n    }\n\n    const words = parseTokens(originalLine);\n    resetParams();\n    let index = 0;\n    while (index < words.length) {\n      const currentWordWidth = getLineWidth(words[index], font);\n\n      // This will only happen when single word takes entire width\n      if (currentWordWidth === maxWidth) {\n        push(words[index]);\n        index++;\n      }\n\n      // Start breaking longer words exceeding max width\n      else if (currentWordWidth > maxWidth) {\n        // push current line since the current word exceeds the max width\n        // so will be appended in next line\n\n        push(currentLine);\n        resetParams();\n        while (words[index].length > 0) {\n          const currentChar = String.fromCodePoint(words[index].codePointAt(0));\n          const width = charWidth.calculate(currentChar, font);\n          currentLineWidthTillNow += width;\n          words[index] = words[index].slice(currentChar.length);\n          if (currentLineWidthTillNow >= maxWidth) {\n            push(currentLine);\n            currentLine = currentChar;\n            currentLineWidthTillNow = width;\n          } else {\n            currentLine += currentChar;\n          }\n        }\n        // push current line if appending space exceeds max width\n        if (currentLineWidthTillNow + spaceWidth >= maxWidth) {\n          push(currentLine);\n          resetParams();\n          // space needs to be appended before next word\n          // as currentLine contains chars which couldn't be appended\n          // to previous line unless the line ends with hyphen to sync\n          // with css word-wrap\n        } else if (!currentLine.endsWith(\"-\")) {\n          currentLine += \" \";\n          currentLineWidthTillNow += spaceWidth;\n        }\n        index++;\n      } else {\n        // Start appending words in a line till max width reached\n        while (currentLineWidthTillNow < maxWidth && index < words.length) {\n          const word = words[index];\n          currentLineWidthTillNow = getLineWidth(currentLine + word, font);\n          if (currentLineWidthTillNow > maxWidth) {\n            push(currentLine);\n            resetParams();\n            break;\n          }\n          index++;\n\n          // if word ends with \"-\" then we don't need to add space\n          // to sync with css word-wrap\n          const shouldAppendSpace = !word.endsWith(\"-\");\n          currentLine += word;\n          if (shouldAppendSpace) {\n            currentLine += \" \";\n          }\n\n          // Push the word if appending space exceeds max width\n          if (currentLineWidthTillNow + spaceWidth >= maxWidth) {\n            if (shouldAppendSpace) {\n              lines.push(currentLine.slice(0, -1));\n            } else {\n              lines.push(currentLine);\n            }\n            resetParams();\n            break;\n          }\n        }\n      }\n    }\n    if (currentLine.slice(-1) === \" \") {\n      // only remove last trailing space which we have added when joining words\n      currentLine = currentLine.slice(0, -1);\n      push(currentLine);\n    }\n  });\n  return lines.join(\"\\n\");\n};\nexport const charWidth = (() => {\n  const cachedCharWidth = {};\n  const calculate = (char, font) => {\n    const ascii = char.charCodeAt(0);\n    if (!cachedCharWidth[font]) {\n      cachedCharWidth[font] = [];\n    }\n    if (!cachedCharWidth[font][ascii]) {\n      const width = getLineWidth(char, font);\n      cachedCharWidth[font][ascii] = width;\n    }\n    return cachedCharWidth[font][ascii];\n  };\n  const getCache = font => {\n    return cachedCharWidth[font];\n  };\n  return {\n    calculate,\n    getCache\n  };\n})();\nconst DUMMY_TEXT = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".toLocaleUpperCase();\n\n// FIXME rename to getApproxMinContainerWidth\nexport const getApproxMinLineWidth = (font, lineHeight) => {\n  const maxCharWidth = getMaxCharWidth(font);\n  if (maxCharWidth === 0) {\n    return measureText(DUMMY_TEXT.split(\"\").join(\"\\n\"), font, lineHeight).width + BOUND_TEXT_PADDING * 2;\n  }\n  return maxCharWidth + BOUND_TEXT_PADDING * 2;\n};\nexport const getMinCharWidth = font => {\n  const cache = charWidth.getCache(font);\n  if (!cache) {\n    return 0;\n  }\n  const cacheWithOutEmpty = cache.filter(val => val !== undefined);\n  return Math.min(...cacheWithOutEmpty);\n};\nexport const getMaxCharWidth = font => {\n  const cache = charWidth.getCache(font);\n  if (!cache) {\n    return 0;\n  }\n  const cacheWithOutEmpty = cache.filter(val => val !== undefined);\n  return Math.max(...cacheWithOutEmpty);\n};\nexport const getApproxCharsToFitInWidth = (font, width) => {\n  // Generally lower case is used so converting to lower case\n  const dummyText = DUMMY_TEXT.toLocaleLowerCase();\n  const batchLength = 6;\n  let index = 0;\n  let widthTillNow = 0;\n  let str = \"\";\n  while (widthTillNow <= width) {\n    const batch = dummyText.substr(index, index + batchLength);\n    str += batch;\n    widthTillNow += getLineWidth(str, font);\n    if (index === dummyText.length - 1) {\n      index = 0;\n    }\n    index = index + batchLength;\n  }\n  while (widthTillNow > width) {\n    str = str.substr(0, str.length - 1);\n    widthTillNow = getLineWidth(str, font);\n  }\n  return str.length;\n};\nexport const getBoundTextElementId = container => {\n  var _container$boundEleme, _container$boundEleme2, _container$boundEleme3;\n  return container !== null && container !== void 0 && (_container$boundEleme = container.boundElements) !== null && _container$boundEleme !== void 0 && _container$boundEleme.length ? (container === null || container === void 0 ? void 0 : (_container$boundEleme2 = container.boundElements) === null || _container$boundEleme2 === void 0 ? void 0 : (_container$boundEleme3 = _container$boundEleme2.filter(ele => ele.type === \"text\")[0]) === null || _container$boundEleme3 === void 0 ? void 0 : _container$boundEleme3.id) || null : null;\n};\nexport const getBoundTextElement = element => {\n  if (!element) {\n    return null;\n  }\n  const boundTextElementId = getBoundTextElementId(element);\n  if (boundTextElementId) {\n    var _Scene$getScene;\n    return ((_Scene$getScene = Scene.getScene(element)) === null || _Scene$getScene === void 0 ? void 0 : _Scene$getScene.getElement(boundTextElementId)) || null;\n  }\n  return null;\n};\nexport const getContainerElement = element => {\n  if (!element) {\n    return null;\n  }\n  if (element.containerId) {\n    var _Scene$getScene2;\n    return ((_Scene$getScene2 = Scene.getScene(element)) === null || _Scene$getScene2 === void 0 ? void 0 : _Scene$getScene2.getElement(element.containerId)) || null;\n  }\n  return null;\n};\nexport const getContainerDims = element => {\n  const MIN_WIDTH = 300;\n  if (isArrowElement(element)) {\n    const width = Math.max(element.width, MIN_WIDTH);\n    const height = element.height;\n    return {\n      width,\n      height\n    };\n  }\n  return {\n    width: element.width,\n    height: element.height\n  };\n};\nexport const getContainerCenter = (container, appState) => {\n  if (!isArrowElement(container)) {\n    return {\n      x: container.x + container.width / 2,\n      y: container.y + container.height / 2\n    };\n  }\n  const points = LinearElementEditor.getPointsGlobalCoordinates(container);\n  if (points.length % 2 === 1) {\n    const index = Math.floor(container.points.length / 2);\n    const midPoint = LinearElementEditor.getPointGlobalCoordinates(container, container.points[index]);\n    return {\n      x: midPoint[0],\n      y: midPoint[1]\n    };\n  }\n  const index = container.points.length / 2 - 1;\n  let midSegmentMidpoint = LinearElementEditor.getEditorMidPoints(container, appState)[index];\n  if (!midSegmentMidpoint) {\n    midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(container, points[index], points[index + 1], index + 1);\n  }\n  return {\n    x: midSegmentMidpoint[0],\n    y: midSegmentMidpoint[1]\n  };\n};\nexport const getContainerCoords = container => {\n  let offsetX = BOUND_TEXT_PADDING;\n  let offsetY = BOUND_TEXT_PADDING;\n  if (container.type === \"ellipse\") {\n    // The derivation of coordinates is explained in https://github.com/excalidraw/excalidraw/pull/6172\n    offsetX += container.width / 2 * (1 - Math.sqrt(2) / 2);\n    offsetY += container.height / 2 * (1 - Math.sqrt(2) / 2);\n  }\n  // The derivation of coordinates is explained in https://github.com/excalidraw/excalidraw/pull/6265\n  if (container.type === \"diamond\") {\n    offsetX += container.width / 4;\n    offsetY += container.height / 4;\n  }\n  return {\n    x: container.x + offsetX,\n    y: container.y + offsetY\n  };\n};\nexport const getTextElementAngle = textElement => {\n  const container = getContainerElement(textElement);\n  if (!container || isArrowElement(container)) {\n    return textElement.angle;\n  }\n  return container.angle;\n};\nexport const getBoundTextElementOffset = boundTextElement => {\n  const container = getContainerElement(boundTextElement);\n  if (!container || !boundTextElement) {\n    return 0;\n  }\n  if (isArrowElement(container)) {\n    return BOUND_TEXT_PADDING * 8;\n  }\n  return BOUND_TEXT_PADDING;\n};\nexport const getBoundTextElementPosition = (container, boundTextElement) => {\n  if (isArrowElement(container)) {\n    return LinearElementEditor.getBoundTextElementPosition(container, boundTextElement);\n  }\n};\nexport const shouldAllowVerticalAlign = selectedElements => {\n  return selectedElements.some(element => {\n    const hasBoundContainer = isBoundToContainer(element);\n    if (hasBoundContainer) {\n      const container = getContainerElement(element);\n      if (isTextElement(element) && isArrowElement(container)) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  });\n};\nexport const suppportsHorizontalAlign = selectedElements => {\n  return selectedElements.some(element => {\n    const hasBoundContainer = isBoundToContainer(element);\n    if (hasBoundContainer) {\n      const container = getContainerElement(element);\n      if (isTextElement(element) && isArrowElement(container)) {\n        return false;\n      }\n      return true;\n    }\n    return isTextElement(element);\n  });\n};\nexport const getTextBindableContainerAtPosition = (elements, appState, x, y) => {\n  const selectedElements = getSelectedElements(elements, appState);\n  if (selectedElements.length === 1) {\n    return isTextBindableContainer(selectedElements[0], false) ? selectedElements[0] : null;\n  }\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  for (let index = elements.length - 1; index >= 0; --index) {\n    if (elements[index].isDeleted) {\n      continue;\n    }\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(elements[index]);\n    if (isArrowElement(elements[index]) && isHittingElementNotConsideringBoundingBox(elements[index], appState, null, [x, y])) {\n      hitElement = elements[index];\n      break;\n    } else if (x1 < x && x < x2 && y1 < y && y < y2) {\n      hitElement = elements[index];\n      break;\n    }\n  }\n  return isTextBindableContainer(hitElement, false) ? hitElement : null;\n};\nconst VALID_CONTAINER_TYPES = new Set([\"rectangle\", \"ellipse\", \"diamond\", \"arrow\"]);\nexport const isValidTextContainer = element => VALID_CONTAINER_TYPES.has(element.type);\nexport const computeContainerDimensionForBoundText = (dimension, containerType) => {\n  dimension = Math.ceil(dimension);\n  const padding = BOUND_TEXT_PADDING * 2;\n  if (containerType === \"ellipse\") {\n    return Math.round((dimension + padding) / Math.sqrt(2) * 2);\n  }\n  if (containerType === \"arrow\") {\n    return dimension + padding * 8;\n  }\n  if (containerType === \"diamond\") {\n    return 2 * (dimension + padding);\n  }\n  return dimension + padding;\n};\nexport const getBoundTextMaxWidth = container => {\n  const width = getContainerDims(container).width;\n  if (isArrowElement(container)) {\n    return width - BOUND_TEXT_PADDING * 8 * 2;\n  }\n  if (container.type === \"ellipse\") {\n    // The width of the largest rectangle inscribed inside an ellipse is\n    // Math.round((ellipse.width / 2) * Math.sqrt(2)) which is derived from\n    // equation of an ellipse -https://github.com/excalidraw/excalidraw/pull/6172\n    return Math.round(width / 2 * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;\n  }\n  if (container.type === \"diamond\") {\n    // The width of the largest rectangle inscribed inside a rhombus is\n    // Math.round(width / 2) - https://github.com/excalidraw/excalidraw/pull/6265\n    return Math.round(width / 2) - BOUND_TEXT_PADDING * 2;\n  }\n  return width - BOUND_TEXT_PADDING * 2;\n};\nexport const getBoundTextMaxHeight = (container, boundTextElement) => {\n  const height = getContainerDims(container).height;\n  if (isArrowElement(container)) {\n    const containerHeight = height - BOUND_TEXT_PADDING * 8 * 2;\n    if (containerHeight <= 0) {\n      return boundTextElement.height;\n    }\n    return height;\n  }\n  if (container.type === \"ellipse\") {\n    // The height of the largest rectangle inscribed inside an ellipse is\n    // Math.round((ellipse.height / 2) * Math.sqrt(2)) which is derived from\n    // equation of an ellipse - https://github.com/excalidraw/excalidraw/pull/6172\n    return Math.round(height / 2 * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;\n  }\n  if (container.type === \"diamond\") {\n    // The height of the largest rectangle inscribed inside a rhombus is\n    // Math.round(height / 2) - https://github.com/excalidraw/excalidraw/pull/6265\n    return Math.round(height / 2) - BOUND_TEXT_PADDING * 2;\n  }\n  return height - BOUND_TEXT_PADDING * 2;\n};\nexport const isMeasureTextSupported = () => {\n  const width = getTextWidth(DUMMY_TEXT, getFontString({\n    fontSize: DEFAULT_FONT_SIZE,\n    fontFamily: DEFAULT_FONT_FAMILY\n  }));\n  return width > 0;\n};\n\n/**\n * Unitless line height\n *\n * In previous versions we used `normal` line height, which browsers interpret\n * differently, and based on font-family and font-size.\n *\n * To make line heights consistent across browsers we hardcode the values for\n * each of our fonts based on most common average line-heights.\n * See https://github.com/excalidraw/excalidraw/pull/6360#issuecomment-1477635971\n * where the values come from.\n */\nconst DEFAULT_LINE_HEIGHT = {\n  // ~1.25 is the average for Virgil in WebKit and Blink.\n  // Gecko (FF) uses ~1.28.\n  [FONT_FAMILY.Virgil]: 1.25,\n  // ~1.15 is the average for Virgil in WebKit and Blink.\n  // Gecko if all over the place.\n  [FONT_FAMILY.Helvetica]: 1.15,\n  // ~1.2 is the average for Virgil in WebKit and Blink, and kinda Gecko too\n  [FONT_FAMILY.Cascadia]: 1.2\n};\nexport const getDefaultLineHeight = fontFamily => {\n  if (fontFamily in DEFAULT_LINE_HEIGHT) {\n    return DEFAULT_LINE_HEIGHT[fontFamily];\n  }\n  return DEFAULT_LINE_HEIGHT[DEFAULT_FONT_FAMILY];\n};","map":{"version":3,"names":["getFontString","arrayToMap","isTestEnv","mutateElement","BOUND_TEXT_PADDING","DEFAULT_FONT_FAMILY","DEFAULT_FONT_SIZE","FONT_FAMILY","isSafari","TEXT_ALIGN","VERTICAL_ALIGN","Scene","isTextElement","isBoundToContainer","isArrowElement","LinearElementEditor","isTextBindableContainer","getElementAbsoluteCoords","getSelectedElements","isHittingElementNotConsideringBoundingBox","resetOriginalContainerCache","updateOriginalContainerCache","normalizeText","text","replace","splitIntoLines","split","redrawTextBoundingBox","textElement","container","maxWidth","undefined","boundTextUpdates","x","y","width","height","baseline","getBoundTextMaxWidth","wrapText","originalText","metrics","measureText","lineHeight","containerDims","getContainerDims","maxContainerHeight","getBoundTextMaxHeight","nextHeight","computeContainerDimensionForBoundText","type","id","updatedTextElement","computeBoundTextPosition","bindTextToShapeAfterDuplication","sceneElements","oldElements","oldIdToDuplicatedId","sceneElementMap","forEach","element","newElementId","get","boundTextElementId","getBoundTextElementId","newTextElementId","newContainer","boundElements","filter","boundElement","concat","newTextElement","containerId","handleBindTextResize","transformHandleType","getScene","getElement","nextWidth","maxHeight","containerHeight","nextBaseLine","diff","updatedY","boundTextElement","getBoundTextElementPosition","containerCoords","getContainerCoords","maxContainerWidth","verticalAlign","TOP","BOTTOM","textAlign","LEFT","RIGHT","font","map","join","fontSize","parseFloat","getTextHeight","getTextWidth","measureBaseline","wrapInContainer","document","createElement","style","position","whiteSpace","minHeight","overflow","wordBreak","String","innerText","body","appendChild","span","display","offsetTop","offsetHeight","canvasHeight","domHeight","Math","round","removeChild","detectLineHeight","lineCount","length","getLineHeightInPx","getApproxMinLineHeight","canvas","getLineWidth","canvas2dContext","getContext","lines","line","max","parseTokens","words","word","index","Number","isFinite","originalLines","spaceWidth","currentLine","currentLineWidthTillNow","push","str","trim","resetParams","originalLine","currentLineWidth","currentWordWidth","currentChar","fromCodePoint","codePointAt","charWidth","calculate","slice","endsWith","shouldAppendSpace","cachedCharWidth","char","ascii","charCodeAt","getCache","DUMMY_TEXT","toLocaleUpperCase","getApproxMinLineWidth","maxCharWidth","getMaxCharWidth","getMinCharWidth","cache","cacheWithOutEmpty","val","min","getApproxCharsToFitInWidth","dummyText","toLocaleLowerCase","batchLength","widthTillNow","batch","substr","_container$boundEleme","_container$boundEleme2","_container$boundEleme3","ele","getBoundTextElement","_Scene$getScene","getContainerElement","_Scene$getScene2","MIN_WIDTH","getContainerCenter","appState","points","getPointsGlobalCoordinates","floor","midPoint","getPointGlobalCoordinates","midSegmentMidpoint","getEditorMidPoints","getSegmentMidPoint","offsetX","offsetY","sqrt","getTextElementAngle","angle","getBoundTextElementOffset","shouldAllowVerticalAlign","selectedElements","some","hasBoundContainer","suppportsHorizontalAlign","getTextBindableContainerAtPosition","elements","hitElement","isDeleted","x1","y1","x2","y2","VALID_CONTAINER_TYPES","Set","isValidTextContainer","has","dimension","containerType","ceil","padding","isMeasureTextSupported","fontFamily","DEFAULT_LINE_HEIGHT","Virgil","Helvetica","Cascadia","getDefaultLineHeight"],"sources":["D:/project/excalidraw-cn/src/element/textElement.ts"],"sourcesContent":["import { getFontString, arrayToMap, isTestEnv } from \"../utils\";\nimport {\n  ExcalidrawElement,\n  ExcalidrawTextContainer,\n  ExcalidrawTextElement,\n  ExcalidrawTextElementWithContainer,\n  FontFamilyValues,\n  FontString,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\nimport { mutateElement } from \"./mutateElement\";\nimport {\n  BOUND_TEXT_PADDING,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  FONT_FAMILY,\n  isSafari,\n  TEXT_ALIGN,\n  VERTICAL_ALIGN,\n} from \"../constants\";\nimport { MaybeTransformHandleType } from \"./transformHandles\";\nimport Scene from \"../scene/Scene\";\nimport { isTextElement } from \".\";\nimport { isBoundToContainer, isArrowElement } from \"./typeChecks\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { AppState } from \"../types\";\nimport { isTextBindableContainer } from \"./typeChecks\";\nimport { getElementAbsoluteCoords } from \"../element\";\nimport { getSelectedElements } from \"../scene\";\nimport { isHittingElementNotConsideringBoundingBox } from \"./collision\";\nimport {\n  resetOriginalContainerCache,\n  updateOriginalContainerCache,\n} from \"./textWysiwyg\";\nimport { ExtractSetType } from \"../utility-types\";\n\nexport const normalizeText = (text: string) => {\n  return (\n    text\n      // replace tabs with spaces so they render and measure correctly\n      .replace(/\\t/g, \"        \")\n      // normalize newlines\n      .replace(/\\r?\\n|\\r/g, \"\\n\")\n  );\n};\n\nexport const splitIntoLines = (text: string) => {\n  return normalizeText(text).split(\"\\n\");\n};\n\nexport const redrawTextBoundingBox = (\n  textElement: ExcalidrawTextElement,\n  container: ExcalidrawElement | null,\n) => {\n  let maxWidth = undefined;\n  const boundTextUpdates = {\n    x: textElement.x,\n    y: textElement.y,\n    text: textElement.text,\n    width: textElement.width,\n    height: textElement.height,\n    baseline: textElement.baseline,\n  };\n\n  boundTextUpdates.text = textElement.text;\n\n  if (container) {\n    maxWidth = getBoundTextMaxWidth(container);\n    boundTextUpdates.text = wrapText(\n      textElement.originalText,\n      getFontString(textElement),\n      maxWidth,\n    );\n  }\n  const metrics = measureText(\n    boundTextUpdates.text,\n    getFontString(textElement),\n    textElement.lineHeight,\n  );\n\n  boundTextUpdates.width = metrics.width;\n  boundTextUpdates.height = metrics.height;\n  boundTextUpdates.baseline = metrics.baseline;\n\n  if (container) {\n    const containerDims = getContainerDims(container);\n    const maxContainerHeight = getBoundTextMaxHeight(\n      container,\n      textElement as ExcalidrawTextElementWithContainer,\n    );\n\n    let nextHeight = containerDims.height;\n    if (metrics.height > maxContainerHeight) {\n      nextHeight = computeContainerDimensionForBoundText(\n        metrics.height,\n        container.type,\n      );\n      mutateElement(container, { height: nextHeight });\n      updateOriginalContainerCache(container.id, nextHeight);\n    }\n    const updatedTextElement = {\n      ...textElement,\n      ...boundTextUpdates,\n    } as ExcalidrawTextElementWithContainer;\n    const { x, y } = computeBoundTextPosition(container, updatedTextElement);\n    boundTextUpdates.x = x;\n    boundTextUpdates.y = y;\n  }\n\n  mutateElement(textElement, boundTextUpdates);\n};\n\nexport const bindTextToShapeAfterDuplication = (\n  sceneElements: ExcalidrawElement[],\n  oldElements: ExcalidrawElement[],\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n): void => {\n  const sceneElementMap = arrayToMap(sceneElements) as Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement\n  >;\n  oldElements.forEach((element) => {\n    const newElementId = oldIdToDuplicatedId.get(element.id) as string;\n    const boundTextElementId = getBoundTextElementId(element);\n\n    if (boundTextElementId) {\n      const newTextElementId = oldIdToDuplicatedId.get(boundTextElementId);\n      if (newTextElementId) {\n        const newContainer = sceneElementMap.get(newElementId);\n        if (newContainer) {\n          mutateElement(newContainer, {\n            boundElements: (element.boundElements || [])\n              .filter(\n                (boundElement) =>\n                  boundElement.id !== newTextElementId &&\n                  boundElement.id !== boundTextElementId,\n              )\n              .concat({\n                type: \"text\",\n                id: newTextElementId,\n              }),\n          });\n        }\n        const newTextElement = sceneElementMap.get(newTextElementId);\n        if (newTextElement && isTextElement(newTextElement)) {\n          mutateElement(newTextElement, {\n            containerId: newContainer ? newElementId : null,\n          });\n        }\n      }\n    }\n  });\n};\n\nexport const handleBindTextResize = (\n  container: NonDeletedExcalidrawElement,\n  transformHandleType: MaybeTransformHandleType,\n) => {\n  const boundTextElementId = getBoundTextElementId(container);\n  if (!boundTextElementId) {\n    return;\n  }\n  resetOriginalContainerCache(container.id);\n  let textElement = Scene.getScene(container)!.getElement(\n    boundTextElementId,\n  ) as ExcalidrawTextElement;\n  if (textElement && textElement.text) {\n    if (!container) {\n      return;\n    }\n\n    textElement = Scene.getScene(container)!.getElement(\n      boundTextElementId,\n    ) as ExcalidrawTextElement;\n    let text = textElement.text;\n    let nextHeight = textElement.height;\n    let nextWidth = textElement.width;\n    const containerDims = getContainerDims(container);\n    const maxWidth = getBoundTextMaxWidth(container);\n    const maxHeight = getBoundTextMaxHeight(\n      container,\n      textElement as ExcalidrawTextElementWithContainer,\n    );\n    let containerHeight = containerDims.height;\n    let nextBaseLine = textElement.baseline;\n    if (transformHandleType !== \"n\" && transformHandleType !== \"s\") {\n      if (text) {\n        text = wrapText(\n          textElement.originalText,\n          getFontString(textElement),\n          maxWidth,\n        );\n      }\n      const metrics = measureText(\n        text,\n        getFontString(textElement),\n        textElement.lineHeight,\n      );\n      nextHeight = metrics.height;\n      nextWidth = metrics.width;\n      nextBaseLine = metrics.baseline;\n    }\n    // increase height in case text element height exceeds\n    if (nextHeight > maxHeight) {\n      containerHeight = computeContainerDimensionForBoundText(\n        nextHeight,\n        container.type,\n      );\n\n      const diff = containerHeight - containerDims.height;\n      // fix the y coord when resizing from ne/nw/n\n      const updatedY =\n        !isArrowElement(container) &&\n        (transformHandleType === \"ne\" ||\n          transformHandleType === \"nw\" ||\n          transformHandleType === \"n\")\n          ? container.y - diff\n          : container.y;\n      mutateElement(container, {\n        height: containerHeight,\n        y: updatedY,\n      });\n    }\n\n    mutateElement(textElement, {\n      text,\n      width: nextWidth,\n      height: nextHeight,\n      baseline: nextBaseLine,\n    });\n\n    if (!isArrowElement(container)) {\n      mutateElement(\n        textElement,\n        computeBoundTextPosition(\n          container,\n          textElement as ExcalidrawTextElementWithContainer,\n        ),\n      );\n    }\n  }\n};\n\nexport const computeBoundTextPosition = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n) => {\n  if (isArrowElement(container)) {\n    return LinearElementEditor.getBoundTextElementPosition(\n      container,\n      boundTextElement,\n    );\n  }\n  const containerCoords = getContainerCoords(container);\n  const maxContainerHeight = getBoundTextMaxHeight(container, boundTextElement);\n  const maxContainerWidth = getBoundTextMaxWidth(container);\n\n  let x;\n  let y;\n  if (boundTextElement.verticalAlign === VERTICAL_ALIGN.TOP) {\n    y = containerCoords.y;\n  } else if (boundTextElement.verticalAlign === VERTICAL_ALIGN.BOTTOM) {\n    y = containerCoords.y + (maxContainerHeight - boundTextElement.height);\n  } else {\n    y =\n      containerCoords.y +\n      (maxContainerHeight / 2 - boundTextElement.height / 2);\n  }\n  if (boundTextElement.textAlign === TEXT_ALIGN.LEFT) {\n    x = containerCoords.x;\n  } else if (boundTextElement.textAlign === TEXT_ALIGN.RIGHT) {\n    x = containerCoords.x + (maxContainerWidth - boundTextElement.width);\n  } else {\n    x =\n      containerCoords.x + (maxContainerWidth / 2 - boundTextElement.width / 2);\n  }\n  return { x, y };\n};\n\n// https://github.com/grassator/canvas-text-editor/blob/master/lib/FontMetrics.js\n\nexport const measureText = (\n  text: string,\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  text = text\n    .split(\"\\n\")\n    // replace empty lines with single space because leading/trailing empty\n    // lines would be stripped from computation\n    .map((x) => x || \" \")\n    .join(\"\\n\");\n  const fontSize = parseFloat(font);\n  const height = getTextHeight(text, fontSize, lineHeight);\n  const width = getTextWidth(text, font);\n  const baseline = measureBaseline(text, font, lineHeight);\n  return { width, height, baseline };\n};\n\nexport const measureBaseline = (\n  text: string,\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n  wrapInContainer?: boolean,\n) => {\n  const container = document.createElement(\"div\");\n  container.style.position = \"absolute\";\n  container.style.whiteSpace = \"pre\";\n  container.style.font = font;\n  container.style.minHeight = \"1em\";\n  if (wrapInContainer) {\n    container.style.overflow = \"hidden\";\n    container.style.wordBreak = \"break-word\";\n    container.style.whiteSpace = \"pre-wrap\";\n  }\n\n  container.style.lineHeight = String(lineHeight);\n\n  container.innerText = text;\n\n  // Baseline is important for positioning text on canvas\n  document.body.appendChild(container);\n\n  const span = document.createElement(\"span\");\n  span.style.display = \"inline-block\";\n  span.style.overflow = \"hidden\";\n  span.style.width = \"1px\";\n  span.style.height = \"1px\";\n  container.appendChild(span);\n  let baseline = span.offsetTop + span.offsetHeight;\n  const height = container.offsetHeight;\n\n  if (isSafari) {\n    const canvasHeight = getTextHeight(text, parseFloat(font), lineHeight);\n    const fontSize = parseFloat(font);\n    // In Safari the font size gets rounded off when rendering hence calculating the safari height and shifting the baseline if it differs\n    // from the actual canvas height\n    const domHeight = getTextHeight(text, Math.round(fontSize), lineHeight);\n    if (canvasHeight > height) {\n      baseline += canvasHeight - domHeight;\n    }\n\n    if (height > canvasHeight) {\n      baseline -= domHeight - canvasHeight;\n    }\n  }\n  document.body.removeChild(container);\n  return baseline;\n};\n\n/**\n * To get unitless line-height (if unknown) we can calculate it by dividing\n * height-per-line by fontSize.\n */\nexport const detectLineHeight = (textElement: ExcalidrawTextElement) => {\n  const lineCount = splitIntoLines(textElement.text).length;\n  return (textElement.height /\n    lineCount /\n    textElement.fontSize) as ExcalidrawTextElement[\"lineHeight\"];\n};\n\n/**\n * We calculate the line height from the font size and the unitless line height,\n * aligning with the W3C spec.\n */\nexport const getLineHeightInPx = (\n  fontSize: ExcalidrawTextElement[\"fontSize\"],\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  return fontSize * lineHeight;\n};\n\n// FIXME rename to getApproxMinContainerHeight\nexport const getApproxMinLineHeight = (\n  fontSize: ExcalidrawTextElement[\"fontSize\"],\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  return getLineHeightInPx(fontSize, lineHeight) + BOUND_TEXT_PADDING * 2;\n};\n\nlet canvas: HTMLCanvasElement | undefined;\n\nconst getLineWidth = (text: string, font: FontString) => {\n  if (!canvas) {\n    canvas = document.createElement(\"canvas\");\n  }\n  const canvas2dContext = canvas.getContext(\"2d\")!;\n  canvas2dContext.font = font;\n  const width = canvas2dContext.measureText(text).width;\n\n  // since in test env the canvas measureText algo\n  // doesn't measure text and instead just returns number of\n  // characters hence we assume that each letteris 10px\n  if (isTestEnv()) {\n    return width * 10;\n  }\n  return width;\n};\n\nexport const getTextWidth = (text: string, font: FontString) => {\n  const lines = splitIntoLines(text);\n  let width = 0;\n  lines.forEach((line) => {\n    width = Math.max(width, getLineWidth(line, font));\n  });\n  return width;\n};\n\nexport const getTextHeight = (\n  text: string,\n  fontSize: number,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  const lineCount = splitIntoLines(text).length;\n  return getLineHeightInPx(fontSize, lineHeight) * lineCount;\n};\n\nexport const parseTokens = (text: string) => {\n  // Splitting words containing \"-\" as those are treated as separate words\n  // by css wrapping algorithm eg non-profit => non-, profit\n  const words = text.split(\"-\");\n  if (words.length > 1) {\n    // non-proft org => ['non-', 'profit org']\n    words.forEach((word, index) => {\n      if (index !== words.length - 1) {\n        words[index] = word += \"-\";\n      }\n    });\n  }\n  // Joining the words with space and splitting them again with space to get the\n  // final list of tokens\n  // ['non-', 'profit org'] =>,'non- proft org' => ['non-','profit','org']\n  return words.join(\" \").split(\" \");\n};\n\nexport const wrapText = (text: string, font: FontString, maxWidth: number) => {\n  // if maxWidth is not finite or NaN which can happen in case of bugs in\n  // computation, we need to make sure we don't continue as we'll end up\n  // in an infinite loop\n  if (!Number.isFinite(maxWidth) || maxWidth < 0) {\n    return text;\n  }\n\n  const lines: Array<string> = [];\n  const originalLines = text.split(\"\\n\");\n  const spaceWidth = getLineWidth(\" \", font);\n\n  let currentLine = \"\";\n  let currentLineWidthTillNow = 0;\n\n  const push = (str: string) => {\n    if (str.trim()) {\n      lines.push(str);\n    }\n  };\n\n  const resetParams = () => {\n    currentLine = \"\";\n    currentLineWidthTillNow = 0;\n  };\n  originalLines.forEach((originalLine) => {\n    const currentLineWidth = getTextWidth(originalLine, font);\n\n    // Push the line if its <= maxWidth\n    if (currentLineWidth <= maxWidth) {\n      lines.push(originalLine);\n      return; // continue\n    }\n\n    const words = parseTokens(originalLine);\n    resetParams();\n\n    let index = 0;\n\n    while (index < words.length) {\n      const currentWordWidth = getLineWidth(words[index], font);\n\n      // This will only happen when single word takes entire width\n      if (currentWordWidth === maxWidth) {\n        push(words[index]);\n        index++;\n      }\n\n      // Start breaking longer words exceeding max width\n      else if (currentWordWidth > maxWidth) {\n        // push current line since the current word exceeds the max width\n        // so will be appended in next line\n\n        push(currentLine);\n\n        resetParams();\n\n        while (words[index].length > 0) {\n          const currentChar = String.fromCodePoint(\n            words[index].codePointAt(0)!,\n          );\n          const width = charWidth.calculate(currentChar, font);\n          currentLineWidthTillNow += width;\n          words[index] = words[index].slice(currentChar.length);\n\n          if (currentLineWidthTillNow >= maxWidth) {\n            push(currentLine);\n            currentLine = currentChar;\n            currentLineWidthTillNow = width;\n          } else {\n            currentLine += currentChar;\n          }\n        }\n        // push current line if appending space exceeds max width\n        if (currentLineWidthTillNow + spaceWidth >= maxWidth) {\n          push(currentLine);\n          resetParams();\n          // space needs to be appended before next word\n          // as currentLine contains chars which couldn't be appended\n          // to previous line unless the line ends with hyphen to sync\n          // with css word-wrap\n        } else if (!currentLine.endsWith(\"-\")) {\n          currentLine += \" \";\n          currentLineWidthTillNow += spaceWidth;\n        }\n        index++;\n      } else {\n        // Start appending words in a line till max width reached\n        while (currentLineWidthTillNow < maxWidth && index < words.length) {\n          const word = words[index];\n          currentLineWidthTillNow = getLineWidth(currentLine + word, font);\n\n          if (currentLineWidthTillNow > maxWidth) {\n            push(currentLine);\n            resetParams();\n\n            break;\n          }\n          index++;\n\n          // if word ends with \"-\" then we don't need to add space\n          // to sync with css word-wrap\n          const shouldAppendSpace = !word.endsWith(\"-\");\n          currentLine += word;\n\n          if (shouldAppendSpace) {\n            currentLine += \" \";\n          }\n\n          // Push the word if appending space exceeds max width\n          if (currentLineWidthTillNow + spaceWidth >= maxWidth) {\n            if (shouldAppendSpace) {\n              lines.push(currentLine.slice(0, -1));\n            } else {\n              lines.push(currentLine);\n            }\n            resetParams();\n            break;\n          }\n        }\n      }\n    }\n    if (currentLine.slice(-1) === \" \") {\n      // only remove last trailing space which we have added when joining words\n      currentLine = currentLine.slice(0, -1);\n      push(currentLine);\n    }\n  });\n  return lines.join(\"\\n\");\n};\n\nexport const charWidth = (() => {\n  const cachedCharWidth: { [key: FontString]: Array<number> } = {};\n\n  const calculate = (char: string, font: FontString) => {\n    const ascii = char.charCodeAt(0);\n    if (!cachedCharWidth[font]) {\n      cachedCharWidth[font] = [];\n    }\n    if (!cachedCharWidth[font][ascii]) {\n      const width = getLineWidth(char, font);\n      cachedCharWidth[font][ascii] = width;\n    }\n\n    return cachedCharWidth[font][ascii];\n  };\n\n  const getCache = (font: FontString) => {\n    return cachedCharWidth[font];\n  };\n  return {\n    calculate,\n    getCache,\n  };\n})();\n\nconst DUMMY_TEXT = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".toLocaleUpperCase();\n\n// FIXME rename to getApproxMinContainerWidth\nexport const getApproxMinLineWidth = (\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  const maxCharWidth = getMaxCharWidth(font);\n  if (maxCharWidth === 0) {\n    return (\n      measureText(DUMMY_TEXT.split(\"\").join(\"\\n\"), font, lineHeight).width +\n      BOUND_TEXT_PADDING * 2\n    );\n  }\n  return maxCharWidth + BOUND_TEXT_PADDING * 2;\n};\n\nexport const getMinCharWidth = (font: FontString) => {\n  const cache = charWidth.getCache(font);\n  if (!cache) {\n    return 0;\n  }\n  const cacheWithOutEmpty = cache.filter((val) => val !== undefined);\n\n  return Math.min(...cacheWithOutEmpty);\n};\n\nexport const getMaxCharWidth = (font: FontString) => {\n  const cache = charWidth.getCache(font);\n  if (!cache) {\n    return 0;\n  }\n  const cacheWithOutEmpty = cache.filter((val) => val !== undefined);\n  return Math.max(...cacheWithOutEmpty);\n};\n\nexport const getApproxCharsToFitInWidth = (font: FontString, width: number) => {\n  // Generally lower case is used so converting to lower case\n  const dummyText = DUMMY_TEXT.toLocaleLowerCase();\n  const batchLength = 6;\n  let index = 0;\n  let widthTillNow = 0;\n  let str = \"\";\n  while (widthTillNow <= width) {\n    const batch = dummyText.substr(index, index + batchLength);\n    str += batch;\n    widthTillNow += getLineWidth(str, font);\n    if (index === dummyText.length - 1) {\n      index = 0;\n    }\n    index = index + batchLength;\n  }\n\n  while (widthTillNow > width) {\n    str = str.substr(0, str.length - 1);\n    widthTillNow = getLineWidth(str, font);\n  }\n  return str.length;\n};\n\nexport const getBoundTextElementId = (container: ExcalidrawElement | null) => {\n  return container?.boundElements?.length\n    ? container?.boundElements?.filter((ele) => ele.type === \"text\")[0]?.id ||\n        null\n    : null;\n};\n\nexport const getBoundTextElement = (element: ExcalidrawElement | null) => {\n  if (!element) {\n    return null;\n  }\n  const boundTextElementId = getBoundTextElementId(element);\n  if (boundTextElementId) {\n    return (\n      (Scene.getScene(element)?.getElement(\n        boundTextElementId,\n      ) as ExcalidrawTextElementWithContainer) || null\n    );\n  }\n  return null;\n};\n\nexport const getContainerElement = (\n  element:\n    | (ExcalidrawElement & {\n        containerId: ExcalidrawElement[\"id\"] | null;\n      })\n    | null,\n) => {\n  if (!element) {\n    return null;\n  }\n  if (element.containerId) {\n    return Scene.getScene(element)?.getElement(element.containerId) || null;\n  }\n  return null;\n};\n\nexport const getContainerDims = (element: ExcalidrawElement) => {\n  const MIN_WIDTH = 300;\n  if (isArrowElement(element)) {\n    const width = Math.max(element.width, MIN_WIDTH);\n    const height = element.height;\n    return { width, height };\n  }\n  return { width: element.width, height: element.height };\n};\n\nexport const getContainerCenter = (\n  container: ExcalidrawElement,\n  appState: AppState,\n) => {\n  if (!isArrowElement(container)) {\n    return {\n      x: container.x + container.width / 2,\n      y: container.y + container.height / 2,\n    };\n  }\n  const points = LinearElementEditor.getPointsGlobalCoordinates(container);\n  if (points.length % 2 === 1) {\n    const index = Math.floor(container.points.length / 2);\n    const midPoint = LinearElementEditor.getPointGlobalCoordinates(\n      container,\n      container.points[index],\n    );\n    return { x: midPoint[0], y: midPoint[1] };\n  }\n  const index = container.points.length / 2 - 1;\n  let midSegmentMidpoint = LinearElementEditor.getEditorMidPoints(\n    container,\n    appState,\n  )[index];\n  if (!midSegmentMidpoint) {\n    midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(\n      container,\n      points[index],\n      points[index + 1],\n      index + 1,\n    );\n  }\n  return { x: midSegmentMidpoint[0], y: midSegmentMidpoint[1] };\n};\n\nexport const getContainerCoords = (container: NonDeletedExcalidrawElement) => {\n  let offsetX = BOUND_TEXT_PADDING;\n  let offsetY = BOUND_TEXT_PADDING;\n\n  if (container.type === \"ellipse\") {\n    // The derivation of coordinates is explained in https://github.com/excalidraw/excalidraw/pull/6172\n    offsetX += (container.width / 2) * (1 - Math.sqrt(2) / 2);\n    offsetY += (container.height / 2) * (1 - Math.sqrt(2) / 2);\n  }\n  // The derivation of coordinates is explained in https://github.com/excalidraw/excalidraw/pull/6265\n  if (container.type === \"diamond\") {\n    offsetX += container.width / 4;\n    offsetY += container.height / 4;\n  }\n  return {\n    x: container.x + offsetX,\n    y: container.y + offsetY,\n  };\n};\n\nexport const getTextElementAngle = (textElement: ExcalidrawTextElement) => {\n  const container = getContainerElement(textElement);\n  if (!container || isArrowElement(container)) {\n    return textElement.angle;\n  }\n  return container.angle;\n};\n\nexport const getBoundTextElementOffset = (\n  boundTextElement: ExcalidrawTextElement | null,\n) => {\n  const container = getContainerElement(boundTextElement);\n  if (!container || !boundTextElement) {\n    return 0;\n  }\n  if (isArrowElement(container)) {\n    return BOUND_TEXT_PADDING * 8;\n  }\n\n  return BOUND_TEXT_PADDING;\n};\n\nexport const getBoundTextElementPosition = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n) => {\n  if (isArrowElement(container)) {\n    return LinearElementEditor.getBoundTextElementPosition(\n      container,\n      boundTextElement,\n    );\n  }\n};\n\nexport const shouldAllowVerticalAlign = (\n  selectedElements: NonDeletedExcalidrawElement[],\n) => {\n  return selectedElements.some((element) => {\n    const hasBoundContainer = isBoundToContainer(element);\n    if (hasBoundContainer) {\n      const container = getContainerElement(element);\n      if (isTextElement(element) && isArrowElement(container)) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  });\n};\n\nexport const suppportsHorizontalAlign = (\n  selectedElements: NonDeletedExcalidrawElement[],\n) => {\n  return selectedElements.some((element) => {\n    const hasBoundContainer = isBoundToContainer(element);\n    if (hasBoundContainer) {\n      const container = getContainerElement(element);\n      if (isTextElement(element) && isArrowElement(container)) {\n        return false;\n      }\n      return true;\n    }\n\n    return isTextElement(element);\n  });\n};\n\nexport const getTextBindableContainerAtPosition = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  x: number,\n  y: number,\n): ExcalidrawTextContainer | null => {\n  const selectedElements = getSelectedElements(elements, appState);\n  if (selectedElements.length === 1) {\n    return isTextBindableContainer(selectedElements[0], false)\n      ? selectedElements[0]\n      : null;\n  }\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  for (let index = elements.length - 1; index >= 0; --index) {\n    if (elements[index].isDeleted) {\n      continue;\n    }\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(elements[index]);\n    if (\n      isArrowElement(elements[index]) &&\n      isHittingElementNotConsideringBoundingBox(\n        elements[index],\n        appState,\n        null,\n        [x, y],\n      )\n    ) {\n      hitElement = elements[index];\n      break;\n    } else if (x1 < x && x < x2 && y1 < y && y < y2) {\n      hitElement = elements[index];\n      break;\n    }\n  }\n\n  return isTextBindableContainer(hitElement, false) ? hitElement : null;\n};\n\nconst VALID_CONTAINER_TYPES = new Set([\n  \"rectangle\",\n  \"ellipse\",\n  \"diamond\",\n  \"arrow\",\n]);\n\nexport const isValidTextContainer = (element: ExcalidrawElement) =>\n  VALID_CONTAINER_TYPES.has(element.type);\n\nexport const computeContainerDimensionForBoundText = (\n  dimension: number,\n  containerType: ExtractSetType<typeof VALID_CONTAINER_TYPES>,\n) => {\n  dimension = Math.ceil(dimension);\n  const padding = BOUND_TEXT_PADDING * 2;\n\n  if (containerType === \"ellipse\") {\n    return Math.round(((dimension + padding) / Math.sqrt(2)) * 2);\n  }\n  if (containerType === \"arrow\") {\n    return dimension + padding * 8;\n  }\n  if (containerType === \"diamond\") {\n    return 2 * (dimension + padding);\n  }\n  return dimension + padding;\n};\n\nexport const getBoundTextMaxWidth = (container: ExcalidrawElement) => {\n  const width = getContainerDims(container).width;\n  if (isArrowElement(container)) {\n    return width - BOUND_TEXT_PADDING * 8 * 2;\n  }\n\n  if (container.type === \"ellipse\") {\n    // The width of the largest rectangle inscribed inside an ellipse is\n    // Math.round((ellipse.width / 2) * Math.sqrt(2)) which is derived from\n    // equation of an ellipse -https://github.com/excalidraw/excalidraw/pull/6172\n    return Math.round((width / 2) * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;\n  }\n  if (container.type === \"diamond\") {\n    // The width of the largest rectangle inscribed inside a rhombus is\n    // Math.round(width / 2) - https://github.com/excalidraw/excalidraw/pull/6265\n    return Math.round(width / 2) - BOUND_TEXT_PADDING * 2;\n  }\n  return width - BOUND_TEXT_PADDING * 2;\n};\n\nexport const getBoundTextMaxHeight = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n) => {\n  const height = getContainerDims(container).height;\n  if (isArrowElement(container)) {\n    const containerHeight = height - BOUND_TEXT_PADDING * 8 * 2;\n    if (containerHeight <= 0) {\n      return boundTextElement.height;\n    }\n    return height;\n  }\n  if (container.type === \"ellipse\") {\n    // The height of the largest rectangle inscribed inside an ellipse is\n    // Math.round((ellipse.height / 2) * Math.sqrt(2)) which is derived from\n    // equation of an ellipse - https://github.com/excalidraw/excalidraw/pull/6172\n    return Math.round((height / 2) * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;\n  }\n  if (container.type === \"diamond\") {\n    // The height of the largest rectangle inscribed inside a rhombus is\n    // Math.round(height / 2) - https://github.com/excalidraw/excalidraw/pull/6265\n    return Math.round(height / 2) - BOUND_TEXT_PADDING * 2;\n  }\n  return height - BOUND_TEXT_PADDING * 2;\n};\n\nexport const isMeasureTextSupported = () => {\n  const width = getTextWidth(\n    DUMMY_TEXT,\n    getFontString({\n      fontSize: DEFAULT_FONT_SIZE,\n      fontFamily: DEFAULT_FONT_FAMILY,\n    }),\n  );\n  return width > 0;\n};\n\n/**\n * Unitless line height\n *\n * In previous versions we used `normal` line height, which browsers interpret\n * differently, and based on font-family and font-size.\n *\n * To make line heights consistent across browsers we hardcode the values for\n * each of our fonts based on most common average line-heights.\n * See https://github.com/excalidraw/excalidraw/pull/6360#issuecomment-1477635971\n * where the values come from.\n */\nconst DEFAULT_LINE_HEIGHT = {\n  // ~1.25 is the average for Virgil in WebKit and Blink.\n  // Gecko (FF) uses ~1.28.\n  [FONT_FAMILY.Virgil]: 1.25 as ExcalidrawTextElement[\"lineHeight\"],\n  // ~1.15 is the average for Virgil in WebKit and Blink.\n  // Gecko if all over the place.\n  [FONT_FAMILY.Helvetica]: 1.15 as ExcalidrawTextElement[\"lineHeight\"],\n  // ~1.2 is the average for Virgil in WebKit and Blink, and kinda Gecko too\n  [FONT_FAMILY.Cascadia]: 1.2 as ExcalidrawTextElement[\"lineHeight\"],\n};\n\nexport const getDefaultLineHeight = (fontFamily: FontFamilyValues) => {\n  if (fontFamily in DEFAULT_LINE_HEIGHT) {\n    return DEFAULT_LINE_HEIGHT[fontFamily];\n  }\n  return DEFAULT_LINE_HEIGHT[DEFAULT_FONT_FAMILY];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}