{"ast":null,"code":"import rough from \"roughjs/bin/rough\";\nimport { getCommonBounds, getElementAbsoluteCoords } from \"../element/bounds\";\nimport { renderScene, renderSceneToSvg } from \"../renderer/renderScene\";\nimport { distance, isOnlyExportingSingleFrame } from \"../utils\";\nimport { DEFAULT_EXPORT_PADDING, SVG_NS, THEME_FILTER } from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\nimport { serializeAsJSON } from \"../data/json\";\nimport { getInitializedImageElements, updateImageCache } from \"../element/image\";\nimport Scene from \"./Scene\";\nexport const SVG_EXPORT_TAG = `<!-- svg-source:excalidraw -->`;\nexport const exportToCanvas = async function (elements, appState, files, _ref) {\n  let {\n    exportBackground,\n    exportPadding = DEFAULT_EXPORT_PADDING,\n    viewBackgroundColor\n  } = _ref;\n  let createCanvas = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : (width, height) => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width * appState.exportScale;\n    canvas.height = height * appState.exportScale;\n    return {\n      canvas,\n      scale: appState.exportScale\n    };\n  };\n  const [minX, minY, width, height] = getCanvasSize(elements, exportPadding);\n  const {\n    canvas,\n    scale = 1\n  } = createCanvas(width, height);\n  const defaultAppState = getDefaultAppState();\n  const {\n    imageCache\n  } = await updateImageCache({\n    imageCache: new Map(),\n    fileIds: getInitializedImageElements(elements).map(element => element.fileId),\n    files\n  });\n  const onlyExportingSingleFrame = isOnlyExportingSingleFrame(elements);\n  renderScene({\n    elements,\n    appState,\n    scale,\n    rc: rough.canvas(canvas),\n    canvas,\n    renderConfig: {\n      viewBackgroundColor: exportBackground ? viewBackgroundColor : null,\n      scrollX: -minX + (onlyExportingSingleFrame ? 0 : exportPadding),\n      scrollY: -minY + (onlyExportingSingleFrame ? 0 : exportPadding),\n      zoom: defaultAppState.zoom,\n      remotePointerViewportCoords: {},\n      remoteSelectedElementIds: {},\n      shouldCacheIgnoreZoom: false,\n      remotePointerUsernames: {},\n      remotePointerUserStates: {},\n      theme: appState.exportWithDarkMode ? \"dark\" : \"light\",\n      imageCache,\n      renderScrollbars: false,\n      renderSelection: false,\n      renderGrid: false,\n      isExporting: true\n    }\n  });\n  return canvas;\n};\nexport const exportToSvg = async (elements, appState, files, opts) => {\n  var _Scene$getScene, _Scene$getScene$getNo;\n  const {\n    exportPadding = DEFAULT_EXPORT_PADDING,\n    viewBackgroundColor,\n    exportScale = 1,\n    exportEmbedScene\n  } = appState;\n  let metadata = \"\";\n  if (exportEmbedScene) {\n    try {\n      var _opts$serializeAsJSON;\n      metadata = await (await import( /* webpackChunkName: \"image\" */\"../../src/data/image\")).encodeSvgMetadata({\n        text: opts !== null && opts !== void 0 && opts.serializeAsJSON ? opts === null || opts === void 0 ? void 0 : (_opts$serializeAsJSON = opts.serializeAsJSON) === null || _opts$serializeAsJSON === void 0 ? void 0 : _opts$serializeAsJSON.call(opts) : serializeAsJSON(elements, appState, files || {}, \"local\")\n      });\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  const [minX, minY, width, height] = getCanvasSize(elements, exportPadding);\n\n  // initialize SVG root\n  const svgRoot = document.createElementNS(SVG_NS, \"svg\");\n  svgRoot.setAttribute(\"version\", \"1.1\");\n  svgRoot.setAttribute(\"xmlns\", SVG_NS);\n  svgRoot.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n  svgRoot.setAttribute(\"width\", `${width * exportScale}`);\n  svgRoot.setAttribute(\"height\", `${height * exportScale}`);\n  if (appState.exportWithDarkMode) {\n    svgRoot.setAttribute(\"filter\", THEME_FILTER);\n  }\n  let assetPath = \"https://excalidraw.com/\";\n\n  // Asset path needs to be determined only when using package\n  if (process.env.IS_EXCALIDRAW_NPM_PACKAGE) {\n    var _assetPath;\n    assetPath = window.EXCALIDRAW_ASSET_PATH || `https://unpkg.com/${process.env.PKG_NAME}@${process.env.PKG_VERSION}`;\n    if ((_assetPath = assetPath) !== null && _assetPath !== void 0 && _assetPath.startsWith(\"/\")) {\n      assetPath = assetPath.replace(\"/\", `${window.location.origin}/`);\n    }\n    assetPath = `${assetPath}/dist/excalidraw-assets/`;\n  }\n\n  // do not apply clipping when we're exporting the whole scene\n  const isExportingWholeCanvas = ((_Scene$getScene = Scene.getScene(elements[0])) === null || _Scene$getScene === void 0 ? void 0 : (_Scene$getScene$getNo = _Scene$getScene.getNonDeletedElements()) === null || _Scene$getScene$getNo === void 0 ? void 0 : _Scene$getScene$getNo.length) === elements.length;\n  const onlyExportingSingleFrame = isOnlyExportingSingleFrame(elements);\n  const offsetX = -minX + (onlyExportingSingleFrame ? 0 : exportPadding);\n  const offsetY = -minY + (onlyExportingSingleFrame ? 0 : exportPadding);\n  const exportingFrame = isExportingWholeCanvas || !onlyExportingSingleFrame ? undefined : elements.find(element => element.type === \"frame\");\n  let exportingFrameClipPath = \"\";\n  if (exportingFrame) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(exportingFrame);\n    const cx = (x2 - x1) / 2 - (exportingFrame.x - x1);\n    const cy = (y2 - y1) / 2 - (exportingFrame.y - y1);\n    exportingFrameClipPath = `<clipPath id=${exportingFrame.id}>\n            <rect transform=\"translate(${exportingFrame.x + offsetX} ${exportingFrame.y + offsetY}) rotate(${exportingFrame.angle} ${cx} ${cy})\"\n          width=\"${exportingFrame.width}\"\n          height=\"${exportingFrame.height}\"\n          >\n          </rect>\n        </clipPath>`;\n  }\n  svgRoot.innerHTML = `\n  ${SVG_EXPORT_TAG}\n  ${metadata}\n  <defs>\n    <style class=\"style-fonts\">\n      @font-face {\n        font-family: \"Virgil\";\n        src: url(\"${assetPath}Virgil.woff2\");\n      }\n      @font-face {\n        font-family: \"Cascadia\";\n        src: url(\"${assetPath}Cascadia.woff2\");\n      }\n    </style>\n    ${exportingFrameClipPath}\n  </defs>\n  `;\n\n  // render background rect\n  if (appState.exportBackground && viewBackgroundColor) {\n    const rect = svgRoot.ownerDocument.createElementNS(SVG_NS, \"rect\");\n    rect.setAttribute(\"x\", \"0\");\n    rect.setAttribute(\"y\", \"0\");\n    rect.setAttribute(\"width\", `${width}`);\n    rect.setAttribute(\"height\", `${height}`);\n    rect.setAttribute(\"fill\", viewBackgroundColor);\n    svgRoot.appendChild(rect);\n  }\n  const rsvg = rough.svg(svgRoot);\n  renderSceneToSvg(elements, rsvg, svgRoot, files || {}, {\n    offsetX,\n    offsetY,\n    exportWithDarkMode: appState.exportWithDarkMode,\n    exportingFrameId: (exportingFrame === null || exportingFrame === void 0 ? void 0 : exportingFrame.id) || null\n  });\n  return svgRoot;\n};\n\n// calculate smallest area to fit the contents in\nconst getCanvasSize = (elements, exportPadding) => {\n  var _Scene$getScene2, _Scene$getScene2$getN;\n  // we should decide if we are exporting the whole canvas\n  // if so, we are not clipping elements in the frame\n  // and therefore, we should not do anything special\n\n  const isExportingWholeCanvas = ((_Scene$getScene2 = Scene.getScene(elements[0])) === null || _Scene$getScene2 === void 0 ? void 0 : (_Scene$getScene2$getN = _Scene$getScene2.getNonDeletedElements()) === null || _Scene$getScene2$getN === void 0 ? void 0 : _Scene$getScene2$getN.length) === elements.length;\n  const onlyExportingSingleFrame = isOnlyExportingSingleFrame(elements);\n  if (!isExportingWholeCanvas || onlyExportingSingleFrame) {\n    const frames = elements.filter(element => element.type === \"frame\");\n    const exportedFrameIds = frames.reduce((acc, frame) => {\n      acc[frame.id] = true;\n      return acc;\n    }, {});\n\n    // elements in a frame do not affect the canvas size if we're not exporting\n    // the whole canvas\n    elements = elements.filter(element => {\n      var _element$frameId;\n      return !exportedFrameIds[(_element$frameId = element.frameId) !== null && _element$frameId !== void 0 ? _element$frameId : \"\"];\n    });\n  }\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  const width = distance(minX, maxX) + (onlyExportingSingleFrame ? 0 : exportPadding * 2);\n  const height = distance(minY, maxY) + (onlyExportingSingleFrame ? 0 : exportPadding * 2);\n  return [minX, minY, width, height];\n};\nexport const getExportSize = (elements, exportPadding, scale) => {\n  const [,, width, height] = getCanvasSize(elements, exportPadding).map(dimension => Math.trunc(dimension * scale));\n  return [width, height];\n};","map":{"version":3,"names":["rough","getCommonBounds","getElementAbsoluteCoords","renderScene","renderSceneToSvg","distance","isOnlyExportingSingleFrame","DEFAULT_EXPORT_PADDING","SVG_NS","THEME_FILTER","getDefaultAppState","serializeAsJSON","getInitializedImageElements","updateImageCache","Scene","SVG_EXPORT_TAG","exportToCanvas","elements","appState","files","_ref","exportBackground","exportPadding","viewBackgroundColor","createCanvas","arguments","length","undefined","width","height","canvas","document","createElement","exportScale","scale","minX","minY","getCanvasSize","defaultAppState","imageCache","Map","fileIds","map","element","fileId","onlyExportingSingleFrame","rc","renderConfig","scrollX","scrollY","zoom","remotePointerViewportCoords","remoteSelectedElementIds","shouldCacheIgnoreZoom","remotePointerUsernames","remotePointerUserStates","theme","exportWithDarkMode","renderScrollbars","renderSelection","renderGrid","isExporting","exportToSvg","opts","_Scene$getScene","_Scene$getScene$getNo","exportEmbedScene","metadata","_opts$serializeAsJSON","encodeSvgMetadata","text","call","error","console","svgRoot","createElementNS","setAttribute","assetPath","process","env","IS_EXCALIDRAW_NPM_PACKAGE","_assetPath","window","EXCALIDRAW_ASSET_PATH","PKG_NAME","PKG_VERSION","startsWith","replace","location","origin","isExportingWholeCanvas","getScene","getNonDeletedElements","offsetX","offsetY","exportingFrame","find","type","exportingFrameClipPath","x1","y1","x2","y2","cx","x","cy","y","id","angle","innerHTML","rect","ownerDocument","appendChild","rsvg","svg","exportingFrameId","_Scene$getScene2","_Scene$getScene2$getN","frames","filter","exportedFrameIds","reduce","acc","frame","_element$frameId","frameId","maxX","maxY","getExportSize","dimension","Math","trunc"],"sources":["D:/project/excalidraw-cn/src/scene/export.ts"],"sourcesContent":["import rough from \"roughjs/bin/rough\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds, getElementAbsoluteCoords } from \"../element/bounds\";\nimport { renderScene, renderSceneToSvg } from \"../renderer/renderScene\";\nimport { distance, isOnlyExportingSingleFrame } from \"../utils\";\nimport { AppState, BinaryFiles } from \"../types\";\nimport { DEFAULT_EXPORT_PADDING, SVG_NS, THEME_FILTER } from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\nimport { serializeAsJSON } from \"../data/json\";\nimport {\n  getInitializedImageElements,\n  updateImageCache,\n} from \"../element/image\";\nimport Scene from \"./Scene\";\n\nexport const SVG_EXPORT_TAG = `<!-- svg-source:excalidraw -->`;\n\nexport const exportToCanvas = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  files: BinaryFiles,\n  {\n    exportBackground,\n    exportPadding = DEFAULT_EXPORT_PADDING,\n    viewBackgroundColor,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    viewBackgroundColor: string;\n  },\n  createCanvas: (\n    width: number,\n    height: number,\n  ) => { canvas: HTMLCanvasElement; scale: number } = (width, height) => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width * appState.exportScale;\n    canvas.height = height * appState.exportScale;\n    return { canvas, scale: appState.exportScale };\n  },\n) => {\n  const [minX, minY, width, height] = getCanvasSize(elements, exportPadding);\n\n  const { canvas, scale = 1 } = createCanvas(width, height);\n\n  const defaultAppState = getDefaultAppState();\n\n  const { imageCache } = await updateImageCache({\n    imageCache: new Map(),\n    fileIds: getInitializedImageElements(elements).map(\n      (element) => element.fileId,\n    ),\n    files,\n  });\n\n  const onlyExportingSingleFrame = isOnlyExportingSingleFrame(elements);\n\n  renderScene({\n    elements,\n    appState,\n    scale,\n    rc: rough.canvas(canvas),\n    canvas,\n    renderConfig: {\n      viewBackgroundColor: exportBackground ? viewBackgroundColor : null,\n      scrollX: -minX + (onlyExportingSingleFrame ? 0 : exportPadding),\n      scrollY: -minY + (onlyExportingSingleFrame ? 0 : exportPadding),\n      zoom: defaultAppState.zoom,\n      remotePointerViewportCoords: {},\n      remoteSelectedElementIds: {},\n      shouldCacheIgnoreZoom: false,\n      remotePointerUsernames: {},\n      remotePointerUserStates: {},\n      theme: appState.exportWithDarkMode ? \"dark\" : \"light\",\n      imageCache,\n      renderScrollbars: false,\n      renderSelection: false,\n      renderGrid: false,\n      isExporting: true,\n    },\n  });\n\n  return canvas;\n};\n\nexport const exportToSvg = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    exportScale?: number;\n    viewBackgroundColor: string;\n    exportWithDarkMode?: boolean;\n    exportEmbedScene?: boolean;\n    renderFrame?: boolean;\n  },\n  files: BinaryFiles | null,\n  opts?: {\n    serializeAsJSON?: () => string;\n  },\n): Promise<SVGSVGElement> => {\n  const {\n    exportPadding = DEFAULT_EXPORT_PADDING,\n    viewBackgroundColor,\n    exportScale = 1,\n    exportEmbedScene,\n  } = appState;\n  let metadata = \"\";\n  if (exportEmbedScene) {\n    try {\n      metadata = await (\n        await import(/* webpackChunkName: \"image\" */ \"../../src/data/image\")\n      ).encodeSvgMetadata({\n        text: opts?.serializeAsJSON\n          ? opts?.serializeAsJSON?.()\n          : serializeAsJSON(elements, appState, files || {}, \"local\"),\n      });\n    } catch (error: any) {\n      console.error(error);\n    }\n  }\n  const [minX, minY, width, height] = getCanvasSize(elements, exportPadding);\n\n  // initialize SVG root\n  const svgRoot = document.createElementNS(SVG_NS, \"svg\");\n  svgRoot.setAttribute(\"version\", \"1.1\");\n  svgRoot.setAttribute(\"xmlns\", SVG_NS);\n  svgRoot.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n  svgRoot.setAttribute(\"width\", `${width * exportScale}`);\n  svgRoot.setAttribute(\"height\", `${height * exportScale}`);\n  if (appState.exportWithDarkMode) {\n    svgRoot.setAttribute(\"filter\", THEME_FILTER);\n  }\n\n  let assetPath = \"https://excalidraw.com/\";\n\n  // Asset path needs to be determined only when using package\n  if (process.env.IS_EXCALIDRAW_NPM_PACKAGE) {\n    assetPath =\n      window.EXCALIDRAW_ASSET_PATH ||\n      `https://unpkg.com/${process.env.PKG_NAME}@${process.env.PKG_VERSION}`;\n\n    if (assetPath?.startsWith(\"/\")) {\n      assetPath = assetPath.replace(\"/\", `${window.location.origin}/`);\n    }\n    assetPath = `${assetPath}/dist/excalidraw-assets/`;\n  }\n\n  // do not apply clipping when we're exporting the whole scene\n  const isExportingWholeCanvas =\n    Scene.getScene(elements[0])?.getNonDeletedElements()?.length ===\n    elements.length;\n\n  const onlyExportingSingleFrame = isOnlyExportingSingleFrame(elements);\n\n  const offsetX = -minX + (onlyExportingSingleFrame ? 0 : exportPadding);\n  const offsetY = -minY + (onlyExportingSingleFrame ? 0 : exportPadding);\n\n  const exportingFrame =\n    isExportingWholeCanvas || !onlyExportingSingleFrame\n      ? undefined\n      : elements.find((element) => element.type === \"frame\");\n\n  let exportingFrameClipPath = \"\";\n  if (exportingFrame) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(exportingFrame);\n    const cx = (x2 - x1) / 2 - (exportingFrame.x - x1);\n    const cy = (y2 - y1) / 2 - (exportingFrame.y - y1);\n\n    exportingFrameClipPath = `<clipPath id=${exportingFrame.id}>\n            <rect transform=\"translate(${exportingFrame.x + offsetX} ${\n      exportingFrame.y + offsetY\n    }) rotate(${exportingFrame.angle} ${cx} ${cy})\"\n          width=\"${exportingFrame.width}\"\n          height=\"${exportingFrame.height}\"\n          >\n          </rect>\n        </clipPath>`;\n  }\n\n  svgRoot.innerHTML = `\n  ${SVG_EXPORT_TAG}\n  ${metadata}\n  <defs>\n    <style class=\"style-fonts\">\n      @font-face {\n        font-family: \"Virgil\";\n        src: url(\"${assetPath}Virgil.woff2\");\n      }\n      @font-face {\n        font-family: \"Cascadia\";\n        src: url(\"${assetPath}Cascadia.woff2\");\n      }\n    </style>\n    ${exportingFrameClipPath}\n  </defs>\n  `;\n\n  // render background rect\n  if (appState.exportBackground && viewBackgroundColor) {\n    const rect = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"rect\");\n    rect.setAttribute(\"x\", \"0\");\n    rect.setAttribute(\"y\", \"0\");\n    rect.setAttribute(\"width\", `${width}`);\n    rect.setAttribute(\"height\", `${height}`);\n    rect.setAttribute(\"fill\", viewBackgroundColor);\n    svgRoot.appendChild(rect);\n  }\n\n  const rsvg = rough.svg(svgRoot);\n  renderSceneToSvg(elements, rsvg, svgRoot, files || {}, {\n    offsetX,\n    offsetY,\n    exportWithDarkMode: appState.exportWithDarkMode,\n    exportingFrameId: exportingFrame?.id || null,\n  });\n\n  return svgRoot;\n};\n\n// calculate smallest area to fit the contents in\nconst getCanvasSize = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  exportPadding: number,\n): [number, number, number, number] => {\n  // we should decide if we are exporting the whole canvas\n  // if so, we are not clipping elements in the frame\n  // and therefore, we should not do anything special\n\n  const isExportingWholeCanvas =\n    Scene.getScene(elements[0])?.getNonDeletedElements()?.length ===\n    elements.length;\n\n  const onlyExportingSingleFrame = isOnlyExportingSingleFrame(elements);\n\n  if (!isExportingWholeCanvas || onlyExportingSingleFrame) {\n    const frames = elements.filter((element) => element.type === \"frame\");\n\n    const exportedFrameIds = frames.reduce((acc, frame) => {\n      acc[frame.id] = true;\n      return acc;\n    }, {} as Record<string, true>);\n\n    // elements in a frame do not affect the canvas size if we're not exporting\n    // the whole canvas\n    elements = elements.filter(\n      (element) => !exportedFrameIds[element.frameId ?? \"\"],\n    );\n  }\n\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  const width =\n    distance(minX, maxX) + (onlyExportingSingleFrame ? 0 : exportPadding * 2);\n  const height =\n    distance(minY, maxY) + (onlyExportingSingleFrame ? 0 : exportPadding * 2);\n\n  return [minX, minY, width, height];\n};\n\nexport const getExportSize = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  exportPadding: number,\n  scale: number,\n): [number, number] => {\n  const [, , width, height] = getCanvasSize(elements, exportPadding).map(\n    (dimension) => Math.trunc(dimension * scale),\n  );\n\n  return [width, height];\n};\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,mBAAmB;AAErC,SAASC,eAAe,EAAEC,wBAAwB,QAAQ,mBAAmB;AAC7E,SAASC,WAAW,EAAEC,gBAAgB,QAAQ,yBAAyB;AACvE,SAASC,QAAQ,EAAEC,0BAA0B,QAAQ,UAAU;AAE/D,SAASC,sBAAsB,EAAEC,MAAM,EAAEC,YAAY,QAAQ,cAAc;AAC3E,SAASC,kBAAkB,QAAQ,aAAa;AAChD,SAASC,eAAe,QAAQ,cAAc;AAC9C,SACEC,2BAA2B,EAC3BC,gBAAgB,QACX,kBAAkB;AACzB,OAAOC,KAAK,MAAM,SAAS;AAE3B,OAAO,MAAMC,cAAc,GAAI,gCAA+B;AAE9D,OAAO,MAAMC,cAAc,GAAG,eAAAA,CAC5BC,QAAgD,EAChDC,QAAkB,EAClBC,KAAkB,EAAAC,IAAA,EAmBf;EAAA,IAlBH;IACEC,gBAAgB;IAChBC,aAAa,GAAGf,sBAAsB;IACtCgB;EAKF,CAAC,GAAAH,IAAA;EAAA,IACDI,YAGiD,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAACG,KAAK,EAAEC,MAAM,KAAK;IACrE,MAAMC,MAAM,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;IAC/CF,MAAM,CAACF,KAAK,GAAGA,KAAK,GAAGV,QAAQ,CAACe,WAAW;IAC3CH,MAAM,CAACD,MAAM,GAAGA,MAAM,GAAGX,QAAQ,CAACe,WAAW;IAC7C,OAAO;MAAEH,MAAM;MAAEI,KAAK,EAAEhB,QAAQ,CAACe;IAAY,CAAC;EAChD,CAAC;EAED,MAAM,CAACE,IAAI,EAAEC,IAAI,EAAER,KAAK,EAAEC,MAAM,CAAC,GAAGQ,aAAa,CAACpB,QAAQ,EAAEK,aAAa,CAAC;EAE1E,MAAM;IAAEQ,MAAM;IAAEI,KAAK,GAAG;EAAE,CAAC,GAAGV,YAAY,CAACI,KAAK,EAAEC,MAAM,CAAC;EAEzD,MAAMS,eAAe,GAAG5B,kBAAkB,EAAE;EAE5C,MAAM;IAAE6B;EAAW,CAAC,GAAG,MAAM1B,gBAAgB,CAAC;IAC5C0B,UAAU,EAAE,IAAIC,GAAG,EAAE;IACrBC,OAAO,EAAE7B,2BAA2B,CAACK,QAAQ,CAAC,CAACyB,GAAG,CAC/CC,OAAO,IAAKA,OAAO,CAACC,MAAM,CAC5B;IACDzB;EACF,CAAC,CAAC;EAEF,MAAM0B,wBAAwB,GAAGvC,0BAA0B,CAACW,QAAQ,CAAC;EAErEd,WAAW,CAAC;IACVc,QAAQ;IACRC,QAAQ;IACRgB,KAAK;IACLY,EAAE,EAAE9C,KAAK,CAAC8B,MAAM,CAACA,MAAM,CAAC;IACxBA,MAAM;IACNiB,YAAY,EAAE;MACZxB,mBAAmB,EAAEF,gBAAgB,GAAGE,mBAAmB,GAAG,IAAI;MAClEyB,OAAO,EAAE,CAACb,IAAI,IAAIU,wBAAwB,GAAG,CAAC,GAAGvB,aAAa,CAAC;MAC/D2B,OAAO,EAAE,CAACb,IAAI,IAAIS,wBAAwB,GAAG,CAAC,GAAGvB,aAAa,CAAC;MAC/D4B,IAAI,EAAEZ,eAAe,CAACY,IAAI;MAC1BC,2BAA2B,EAAE,CAAC,CAAC;MAC/BC,wBAAwB,EAAE,CAAC,CAAC;MAC5BC,qBAAqB,EAAE,KAAK;MAC5BC,sBAAsB,EAAE,CAAC,CAAC;MAC1BC,uBAAuB,EAAE,CAAC,CAAC;MAC3BC,KAAK,EAAEtC,QAAQ,CAACuC,kBAAkB,GAAG,MAAM,GAAG,OAAO;MACrDlB,UAAU;MACVmB,gBAAgB,EAAE,KAAK;MACvBC,eAAe,EAAE,KAAK;MACtBC,UAAU,EAAE,KAAK;MACjBC,WAAW,EAAE;IACf;EACF,CAAC,CAAC;EAEF,OAAO/B,MAAM;AACf,CAAC;AAED,OAAO,MAAMgC,WAAW,GAAG,MAAAA,CACzB7C,QAAgD,EAChDC,QAQC,EACDC,KAAyB,EACzB4C,IAEC,KAC0B;EAAA,IAAAC,eAAA,EAAAC,qBAAA;EAC3B,MAAM;IACJ3C,aAAa,GAAGf,sBAAsB;IACtCgB,mBAAmB;IACnBU,WAAW,GAAG,CAAC;IACfiC;EACF,CAAC,GAAGhD,QAAQ;EACZ,IAAIiD,QAAQ,GAAG,EAAE;EACjB,IAAID,gBAAgB,EAAE;IACpB,IAAI;MAAA,IAAAE,qBAAA;MACFD,QAAQ,GAAG,MAAM,CACf,MAAM,MAAM,EAAC,+BAAgC,sBAAsB,CAAC,EACpEE,iBAAiB,CAAC;QAClBC,IAAI,EAAEP,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEpD,eAAe,GACvBoD,IAAI,aAAJA,IAAI,wBAAAK,qBAAA,GAAJL,IAAI,CAAEpD,eAAe,cAAAyD,qBAAA,uBAArBA,qBAAA,CAAAG,IAAA,CAAAR,IAAI,CAAqB,GACzBpD,eAAe,CAACM,QAAQ,EAAEC,QAAQ,EAAEC,KAAK,IAAI,CAAC,CAAC,EAAE,OAAO;MAC9D,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOqD,KAAU,EAAE;MACnBC,OAAO,CAACD,KAAK,CAACA,KAAK,CAAC;IACtB;EACF;EACA,MAAM,CAACrC,IAAI,EAAEC,IAAI,EAAER,KAAK,EAAEC,MAAM,CAAC,GAAGQ,aAAa,CAACpB,QAAQ,EAAEK,aAAa,CAAC;;EAE1E;EACA,MAAMoD,OAAO,GAAG3C,QAAQ,CAAC4C,eAAe,CAACnE,MAAM,EAAE,KAAK,CAAC;EACvDkE,OAAO,CAACE,YAAY,CAAC,SAAS,EAAE,KAAK,CAAC;EACtCF,OAAO,CAACE,YAAY,CAAC,OAAO,EAAEpE,MAAM,CAAC;EACrCkE,OAAO,CAACE,YAAY,CAAC,SAAS,EAAG,OAAMhD,KAAM,IAAGC,MAAO,EAAC,CAAC;EACzD6C,OAAO,CAACE,YAAY,CAAC,OAAO,EAAG,GAAEhD,KAAK,GAAGK,WAAY,EAAC,CAAC;EACvDyC,OAAO,CAACE,YAAY,CAAC,QAAQ,EAAG,GAAE/C,MAAM,GAAGI,WAAY,EAAC,CAAC;EACzD,IAAIf,QAAQ,CAACuC,kBAAkB,EAAE;IAC/BiB,OAAO,CAACE,YAAY,CAAC,QAAQ,EAAEnE,YAAY,CAAC;EAC9C;EAEA,IAAIoE,SAAS,GAAG,yBAAyB;;EAEzC;EACA,IAAIC,OAAO,CAACC,GAAG,CAACC,yBAAyB,EAAE;IAAA,IAAAC,UAAA;IACzCJ,SAAS,GACPK,MAAM,CAACC,qBAAqB,IAC3B,qBAAoBL,OAAO,CAACC,GAAG,CAACK,QAAS,IAAGN,OAAO,CAACC,GAAG,CAACM,WAAY,EAAC;IAExE,KAAAJ,UAAA,GAAIJ,SAAS,cAAAI,UAAA,eAATA,UAAA,CAAWK,UAAU,CAAC,GAAG,CAAC,EAAE;MAC9BT,SAAS,GAAGA,SAAS,CAACU,OAAO,CAAC,GAAG,EAAG,GAAEL,MAAM,CAACM,QAAQ,CAACC,MAAO,GAAE,CAAC;IAClE;IACAZ,SAAS,GAAI,GAAEA,SAAU,0BAAyB;EACpD;;EAEA;EACA,MAAMa,sBAAsB,GAC1B,EAAA1B,eAAA,GAAAlD,KAAK,CAAC6E,QAAQ,CAAC1E,QAAQ,CAAC,CAAC,CAAC,CAAC,cAAA+C,eAAA,wBAAAC,qBAAA,GAA3BD,eAAA,CAA6B4B,qBAAqB,EAAE,cAAA3B,qBAAA,uBAApDA,qBAAA,CAAsDvC,MAAM,MAC5DT,QAAQ,CAACS,MAAM;EAEjB,MAAMmB,wBAAwB,GAAGvC,0BAA0B,CAACW,QAAQ,CAAC;EAErE,MAAM4E,OAAO,GAAG,CAAC1D,IAAI,IAAIU,wBAAwB,GAAG,CAAC,GAAGvB,aAAa,CAAC;EACtE,MAAMwE,OAAO,GAAG,CAAC1D,IAAI,IAAIS,wBAAwB,GAAG,CAAC,GAAGvB,aAAa,CAAC;EAEtE,MAAMyE,cAAc,GAClBL,sBAAsB,IAAI,CAAC7C,wBAAwB,GAC/ClB,SAAS,GACTV,QAAQ,CAAC+E,IAAI,CAAErD,OAAO,IAAKA,OAAO,CAACsD,IAAI,KAAK,OAAO,CAAC;EAE1D,IAAIC,sBAAsB,GAAG,EAAE;EAC/B,IAAIH,cAAc,EAAE;IAClB,MAAM,CAACI,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,GAAGpG,wBAAwB,CAAC6F,cAAc,CAAC;IACjE,MAAMQ,EAAE,GAAG,CAACF,EAAE,GAAGF,EAAE,IAAI,CAAC,IAAIJ,cAAc,CAACS,CAAC,GAAGL,EAAE,CAAC;IAClD,MAAMM,EAAE,GAAG,CAACH,EAAE,GAAGF,EAAE,IAAI,CAAC,IAAIL,cAAc,CAACW,CAAC,GAAGN,EAAE,CAAC;IAElDF,sBAAsB,GAAI,gBAAeH,cAAc,CAACY,EAAG;AAC/D,yCAAyCZ,cAAc,CAACS,CAAC,GAAGX,OAAQ,IAC9DE,cAAc,CAACW,CAAC,GAAGZ,OACpB,YAAWC,cAAc,CAACa,KAAM,IAAGL,EAAG,IAAGE,EAAG;AACjD,mBAAmBV,cAAc,CAACnE,KAAM;AACxC,oBAAoBmE,cAAc,CAAClE,MAAO;AAC1C;AACA;AACA,oBAAoB;EAClB;EAEA6C,OAAO,CAACmC,SAAS,GAAI;AACvB,IAAI9F,cAAe;AACnB,IAAIoD,QAAS;AACb;AACA;AACA;AACA;AACA,oBAAoBU,SAAU;AAC9B;AACA;AACA;AACA,oBAAoBA,SAAU;AAC9B;AACA;AACA,MAAMqB,sBAAuB;AAC7B;AACA,GAAG;;EAED;EACA,IAAIhF,QAAQ,CAACG,gBAAgB,IAAIE,mBAAmB,EAAE;IACpD,MAAMuF,IAAI,GAAGpC,OAAO,CAACqC,aAAa,CAAEpC,eAAe,CAACnE,MAAM,EAAE,MAAM,CAAC;IACnEsG,IAAI,CAAClC,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;IAC3BkC,IAAI,CAAClC,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;IAC3BkC,IAAI,CAAClC,YAAY,CAAC,OAAO,EAAG,GAAEhD,KAAM,EAAC,CAAC;IACtCkF,IAAI,CAAClC,YAAY,CAAC,QAAQ,EAAG,GAAE/C,MAAO,EAAC,CAAC;IACxCiF,IAAI,CAAClC,YAAY,CAAC,MAAM,EAAErD,mBAAmB,CAAC;IAC9CmD,OAAO,CAACsC,WAAW,CAACF,IAAI,CAAC;EAC3B;EAEA,MAAMG,IAAI,GAAGjH,KAAK,CAACkH,GAAG,CAACxC,OAAO,CAAC;EAC/BtE,gBAAgB,CAACa,QAAQ,EAAEgG,IAAI,EAAEvC,OAAO,EAAEvD,KAAK,IAAI,CAAC,CAAC,EAAE;IACrD0E,OAAO;IACPC,OAAO;IACPrC,kBAAkB,EAAEvC,QAAQ,CAACuC,kBAAkB;IAC/C0D,gBAAgB,EAAE,CAAApB,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEY,EAAE,KAAI;EAC1C,CAAC,CAAC;EAEF,OAAOjC,OAAO;AAChB,CAAC;;AAED;AACA,MAAMrC,aAAa,GAAGA,CACpBpB,QAAgD,EAChDK,aAAqB,KACgB;EAAA,IAAA8F,gBAAA,EAAAC,qBAAA;EACrC;EACA;EACA;;EAEA,MAAM3B,sBAAsB,GAC1B,EAAA0B,gBAAA,GAAAtG,KAAK,CAAC6E,QAAQ,CAAC1E,QAAQ,CAAC,CAAC,CAAC,CAAC,cAAAmG,gBAAA,wBAAAC,qBAAA,GAA3BD,gBAAA,CAA6BxB,qBAAqB,EAAE,cAAAyB,qBAAA,uBAApDA,qBAAA,CAAsD3F,MAAM,MAC5DT,QAAQ,CAACS,MAAM;EAEjB,MAAMmB,wBAAwB,GAAGvC,0BAA0B,CAACW,QAAQ,CAAC;EAErE,IAAI,CAACyE,sBAAsB,IAAI7C,wBAAwB,EAAE;IACvD,MAAMyE,MAAM,GAAGrG,QAAQ,CAACsG,MAAM,CAAE5E,OAAO,IAAKA,OAAO,CAACsD,IAAI,KAAK,OAAO,CAAC;IAErE,MAAMuB,gBAAgB,GAAGF,MAAM,CAACG,MAAM,CAAC,CAACC,GAAG,EAAEC,KAAK,KAAK;MACrDD,GAAG,CAACC,KAAK,CAAChB,EAAE,CAAC,GAAG,IAAI;MACpB,OAAOe,GAAG;IACZ,CAAC,EAAE,CAAC,CAAC,CAAyB;;IAE9B;IACA;IACAzG,QAAQ,GAAGA,QAAQ,CAACsG,MAAM,CACvB5E,OAAO;MAAA,IAAAiF,gBAAA;MAAA,OAAK,CAACJ,gBAAgB,EAAAI,gBAAA,GAACjF,OAAO,CAACkF,OAAO,cAAAD,gBAAA,cAAAA,gBAAA,GAAI,EAAE,CAAC;IAAA,EACtD;EACH;EAEA,MAAM,CAACzF,IAAI,EAAEC,IAAI,EAAE0F,IAAI,EAAEC,IAAI,CAAC,GAAG9H,eAAe,CAACgB,QAAQ,CAAC;EAC1D,MAAMW,KAAK,GACTvB,QAAQ,CAAC8B,IAAI,EAAE2F,IAAI,CAAC,IAAIjF,wBAAwB,GAAG,CAAC,GAAGvB,aAAa,GAAG,CAAC,CAAC;EAC3E,MAAMO,MAAM,GACVxB,QAAQ,CAAC+B,IAAI,EAAE2F,IAAI,CAAC,IAAIlF,wBAAwB,GAAG,CAAC,GAAGvB,aAAa,GAAG,CAAC,CAAC;EAE3E,OAAO,CAACa,IAAI,EAAEC,IAAI,EAAER,KAAK,EAAEC,MAAM,CAAC;AACpC,CAAC;AAED,OAAO,MAAMmG,aAAa,GAAGA,CAC3B/G,QAAgD,EAChDK,aAAqB,EACrBY,KAAa,KACQ;EACrB,MAAM,IAAKN,KAAK,EAAEC,MAAM,CAAC,GAAGQ,aAAa,CAACpB,QAAQ,EAAEK,aAAa,CAAC,CAACoB,GAAG,CACnEuF,SAAS,IAAKC,IAAI,CAACC,KAAK,CAACF,SAAS,GAAG/F,KAAK,CAAC,CAC7C;EAED,OAAO,CAACN,KAAK,EAAEC,MAAM,CAAC;AACxB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}