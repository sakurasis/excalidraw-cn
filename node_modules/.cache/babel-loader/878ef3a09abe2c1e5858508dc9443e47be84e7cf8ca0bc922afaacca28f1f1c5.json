{"ast":null,"code":"import _slicedToArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import{getElementAbsoluteCoords,getElementBounds}from\"../element\";import{isBoundToContainer}from\"../element/typeChecks\";import{elementOverlapsWithFrame,getContainingFrame,getFrameElements}from\"../frame\";import{isShallowEqual}from\"../utils\";/**\n * Frames and their containing elements are not to be selected at the same time.\n * Given an array of selected elements, if there are frames and their containing elements\n * we only keep the frames.\n * @param selectedElements\n */export var excludeElementsInFramesFromSelection=function excludeElementsInFramesFromSelection(selectedElements){var framesInSelection=new Set();selectedElements.forEach(function(element){if(element.type===\"frame\"){framesInSelection.add(element.id);}});return selectedElements.filter(function(element){if(element.frameId&&framesInSelection.has(element.frameId)){return false;}return true;});};export var getElementsWithinSelection=function getElementsWithinSelection(elements,selection){var excludeElementsInFrames=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;var _getElementAbsoluteCo=getElementAbsoluteCoords(selection),_getElementAbsoluteCo2=_slicedToArray(_getElementAbsoluteCo,4),selectionX1=_getElementAbsoluteCo2[0],selectionY1=_getElementAbsoluteCo2[1],selectionX2=_getElementAbsoluteCo2[2],selectionY2=_getElementAbsoluteCo2[3];var elementsInSelection=elements.filter(function(element){var _getElementBounds=getElementBounds(element),_getElementBounds2=_slicedToArray(_getElementBounds,4),elementX1=_getElementBounds2[0],elementY1=_getElementBounds2[1],elementX2=_getElementBounds2[2],elementY2=_getElementBounds2[3];var containingFrame=getContainingFrame(element);if(containingFrame){var _getElementBounds3=getElementBounds(containingFrame),_getElementBounds4=_slicedToArray(_getElementBounds3,4),fx1=_getElementBounds4[0],fy1=_getElementBounds4[1],fx2=_getElementBounds4[2],fy2=_getElementBounds4[3];elementX1=Math.max(fx1,elementX1);elementY1=Math.max(fy1,elementY1);elementX2=Math.min(fx2,elementX2);elementY2=Math.min(fy2,elementY2);}return element.locked===false&&element.type!==\"selection\"&&!isBoundToContainer(element)&&selectionX1<=elementX1&&selectionY1<=elementY1&&selectionX2>=elementX2&&selectionY2>=elementY2;});elementsInSelection=excludeElementsInFrames?excludeElementsInFramesFromSelection(elementsInSelection):elementsInSelection;elementsInSelection=elementsInSelection.filter(function(element){var containingFrame=getContainingFrame(element);if(containingFrame){return elementOverlapsWithFrame(element,containingFrame);}return true;});return elementsInSelection;};// FIXME move this into the editor instance to keep utility methods stateless\nexport var isSomeElementSelected=function(){var lastElements=null;var lastSelectedElementIds=null;var isSelected=null;var ret=function ret(elements,appState){if(isSelected!=null&&elements===lastElements&&appState.selectedElementIds===lastSelectedElementIds){return isSelected;}isSelected=elements.some(function(element){return appState.selectedElementIds[element.id];});lastElements=elements;lastSelectedElementIds=appState.selectedElementIds;return isSelected;};ret.clearCache=function(){lastElements=null;lastSelectedElementIds=null;isSelected=null;};return ret;}();/**\n * Returns common attribute (picked by `getAttribute` callback) of selected\n *  elements. If elements don't share the same value, returns `null`.\n */export var getCommonAttributeOfSelectedElements=function getCommonAttributeOfSelectedElements(elements,appState,getAttribute){var attributes=Array.from(new Set(getSelectedElements(elements,appState).map(function(element){return getAttribute(element);})));return attributes.length===1?attributes[0]:null;};export var getSelectedElements=function getSelectedElements(elements,appState,opts){var selectedElements=elements.filter(function(element){if(appState.selectedElementIds[element.id]){return element;}if(opts!==null&&opts!==void 0&&opts.includeBoundTextElement&&isBoundToContainer(element)&&appState.selectedElementIds[element===null||element===void 0?void 0:element.containerId]){return element;}return null;});if(opts!==null&&opts!==void 0&&opts.includeElementsInFrames){var elementsToInclude=[];selectedElements.forEach(function(element){if(element.type===\"frame\"){getFrameElements(elements,element.id).forEach(function(e){return elementsToInclude.push(e);});}elementsToInclude.push(element);});return elementsToInclude;}return selectedElements;};export var getTargetElements=function getTargetElements(elements,appState){return appState.editingElement?[appState.editingElement]:getSelectedElements(elements,appState,{includeBoundTextElement:true});};/**\n * returns prevState's selectedElementids if no change from previous, so as to\n * retain reference identity for memoization\n */export var makeNextSelectedElementIds=function makeNextSelectedElementIds(nextSelectedElementIds,prevState){if(isShallowEqual(prevState.selectedElementIds,nextSelectedElementIds)){return prevState.selectedElementIds;}return nextSelectedElementIds;};","map":{"version":3,"names":["getElementAbsoluteCoords","getElementBounds","isBoundToContainer","elementOverlapsWithFrame","getContainingFrame","getFrameElements","isShallowEqual","excludeElementsInFramesFromSelection","selectedElements","framesInSelection","Set","forEach","element","type","add","id","filter","frameId","has","getElementsWithinSelection","elements","selection","excludeElementsInFrames","arguments","length","undefined","_getElementAbsoluteCo","_getElementAbsoluteCo2","_slicedToArray","selectionX1","selectionY1","selectionX2","selectionY2","elementsInSelection","_getElementBounds","_getElementBounds2","elementX1","elementY1","elementX2","elementY2","containingFrame","_getElementBounds3","_getElementBounds4","fx1","fy1","fx2","fy2","Math","max","min","locked","isSomeElementSelected","lastElements","lastSelectedElementIds","isSelected","ret","appState","selectedElementIds","some","clearCache","getCommonAttributeOfSelectedElements","getAttribute","attributes","Array","from","getSelectedElements","map","opts","includeBoundTextElement","containerId","includeElementsInFrames","elementsToInclude","e","push","getTargetElements","editingElement","makeNextSelectedElementIds","nextSelectedElementIds","prevState"],"sources":["D:/project/excalidraw-cn/src/scene/selection.ts"],"sourcesContent":["import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport { getElementAbsoluteCoords, getElementBounds } from \"../element\";\nimport { AppState } from \"../types\";\nimport { isBoundToContainer } from \"../element/typeChecks\";\nimport {\n  elementOverlapsWithFrame,\n  getContainingFrame,\n  getFrameElements,\n} from \"../frame\";\nimport { isShallowEqual } from \"../utils\";\n\n/**\n * Frames and their containing elements are not to be selected at the same time.\n * Given an array of selected elements, if there are frames and their containing elements\n * we only keep the frames.\n * @param selectedElements\n */\nexport const excludeElementsInFramesFromSelection = <\n  T extends ExcalidrawElement,\n>(\n  selectedElements: readonly T[],\n) => {\n  const framesInSelection = new Set<T[\"id\"]>();\n\n  selectedElements.forEach((element) => {\n    if (element.type === \"frame\") {\n      framesInSelection.add(element.id);\n    }\n  });\n\n  return selectedElements.filter((element) => {\n    if (element.frameId && framesInSelection.has(element.frameId)) {\n      return false;\n    }\n    return true;\n  });\n};\n\nexport const getElementsWithinSelection = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selection: NonDeletedExcalidrawElement,\n  excludeElementsInFrames: boolean = true,\n) => {\n  const [selectionX1, selectionY1, selectionX2, selectionY2] =\n    getElementAbsoluteCoords(selection);\n\n  let elementsInSelection = elements.filter((element) => {\n    let [elementX1, elementY1, elementX2, elementY2] =\n      getElementBounds(element);\n\n    const containingFrame = getContainingFrame(element);\n    if (containingFrame) {\n      const [fx1, fy1, fx2, fy2] = getElementBounds(containingFrame);\n\n      elementX1 = Math.max(fx1, elementX1);\n      elementY1 = Math.max(fy1, elementY1);\n      elementX2 = Math.min(fx2, elementX2);\n      elementY2 = Math.min(fy2, elementY2);\n    }\n\n    return (\n      element.locked === false &&\n      element.type !== \"selection\" &&\n      !isBoundToContainer(element) &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2\n    );\n  });\n\n  elementsInSelection = excludeElementsInFrames\n    ? excludeElementsInFramesFromSelection(elementsInSelection)\n    : elementsInSelection;\n\n  elementsInSelection = elementsInSelection.filter((element) => {\n    const containingFrame = getContainingFrame(element);\n\n    if (containingFrame) {\n      return elementOverlapsWithFrame(element, containingFrame);\n    }\n\n    return true;\n  });\n\n  return elementsInSelection;\n};\n\n// FIXME move this into the editor instance to keep utility methods stateless\nexport const isSomeElementSelected = (function () {\n  let lastElements: readonly NonDeletedExcalidrawElement[] | null = null;\n  let lastSelectedElementIds: AppState[\"selectedElementIds\"] | null = null;\n  let isSelected: boolean | null = null;\n\n  const ret = (\n    elements: readonly NonDeletedExcalidrawElement[],\n    appState: Pick<AppState, \"selectedElementIds\">,\n  ): boolean => {\n    if (\n      isSelected != null &&\n      elements === lastElements &&\n      appState.selectedElementIds === lastSelectedElementIds\n    ) {\n      return isSelected;\n    }\n\n    isSelected = elements.some(\n      (element) => appState.selectedElementIds[element.id],\n    );\n    lastElements = elements;\n    lastSelectedElementIds = appState.selectedElementIds;\n\n    return isSelected;\n  };\n\n  ret.clearCache = () => {\n    lastElements = null;\n    lastSelectedElementIds = null;\n    isSelected = null;\n  };\n\n  return ret;\n})();\n\n/**\n * Returns common attribute (picked by `getAttribute` callback) of selected\n *  elements. If elements don't share the same value, returns `null`.\n */\nexport const getCommonAttributeOfSelectedElements = <T>(\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: Pick<AppState, \"selectedElementIds\">,\n  getAttribute: (element: ExcalidrawElement) => T,\n): T | null => {\n  const attributes = Array.from(\n    new Set(\n      getSelectedElements(elements, appState).map((element) =>\n        getAttribute(element),\n      ),\n    ),\n  );\n  return attributes.length === 1 ? attributes[0] : null;\n};\n\nexport const getSelectedElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: Pick<AppState, \"selectedElementIds\">,\n  opts?: {\n    includeBoundTextElement?: boolean;\n    includeElementsInFrames?: boolean;\n  },\n) => {\n  const selectedElements = elements.filter((element) => {\n    if (appState.selectedElementIds[element.id]) {\n      return element;\n    }\n    if (\n      opts?.includeBoundTextElement &&\n      isBoundToContainer(element) &&\n      appState.selectedElementIds[element?.containerId]\n    ) {\n      return element;\n    }\n    return null;\n  });\n\n  if (opts?.includeElementsInFrames) {\n    const elementsToInclude: ExcalidrawElement[] = [];\n    selectedElements.forEach((element) => {\n      if (element.type === \"frame\") {\n        getFrameElements(elements, element.id).forEach((e) =>\n          elementsToInclude.push(e),\n        );\n      }\n      elementsToInclude.push(element);\n    });\n\n    return elementsToInclude;\n  }\n\n  return selectedElements;\n};\n\nexport const getTargetElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: Pick<AppState, \"selectedElementIds\" | \"editingElement\">,\n) =>\n  appState.editingElement\n    ? [appState.editingElement]\n    : getSelectedElements(elements, appState, {\n        includeBoundTextElement: true,\n      });\n\n/**\n * returns prevState's selectedElementids if no change from previous, so as to\n * retain reference identity for memoization\n */\nexport const makeNextSelectedElementIds = (\n  nextSelectedElementIds: AppState[\"selectedElementIds\"],\n  prevState: Pick<AppState, \"selectedElementIds\">,\n) => {\n  if (isShallowEqual(prevState.selectedElementIds, nextSelectedElementIds)) {\n    return prevState.selectedElementIds;\n  }\n\n  return nextSelectedElementIds;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}