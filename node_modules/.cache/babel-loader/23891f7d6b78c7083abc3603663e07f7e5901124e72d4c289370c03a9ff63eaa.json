{"ast":null,"code":"import _toConsumableArray from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar COMMAND = 0;\nvar NUMBER = 1;\nvar EOD = 2;\nvar PARAMS = {\n  A: 7,\n  a: 7,\n  C: 6,\n  c: 6,\n  H: 1,\n  h: 1,\n  L: 2,\n  l: 2,\n  M: 2,\n  m: 2,\n  Q: 4,\n  q: 4,\n  S: 4,\n  s: 4,\n  T: 2,\n  t: 2,\n  V: 1,\n  v: 1,\n  Z: 0,\n  z: 0\n};\nfunction tokenize(d) {\n  var tokens = new Array();\n  while (d !== '') {\n    if (d.match(/^([ \\t\\r\\n,]+)/)) {\n      d = d.substr(RegExp.$1.length);\n    } else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n      tokens[tokens.length] = {\n        type: COMMAND,\n        text: RegExp.$1\n      };\n      d = d.substr(RegExp.$1.length);\n    } else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n      tokens[tokens.length] = {\n        type: NUMBER,\n        text: \"\".concat(parseFloat(RegExp.$1))\n      };\n      d = d.substr(RegExp.$1.length);\n    } else {\n      return [];\n    }\n  }\n  tokens[tokens.length] = {\n    type: EOD,\n    text: ''\n  };\n  return tokens;\n}\nfunction isType(token, type) {\n  return token.type === type;\n}\nexport function parsePath(d) {\n  var segments = [];\n  var tokens = tokenize(d);\n  var mode = 'BOD';\n  var index = 0;\n  var token = tokens[index];\n  while (!isType(token, EOD)) {\n    var paramsCount = 0;\n    var params = [];\n    if (mode === 'BOD') {\n      if (token.text === 'M' || token.text === 'm') {\n        index++;\n        paramsCount = PARAMS[token.text];\n        mode = token.text;\n      } else {\n        return parsePath('M0,0' + d);\n      }\n    } else if (isType(token, NUMBER)) {\n      paramsCount = PARAMS[mode];\n    } else {\n      index++;\n      paramsCount = PARAMS[token.text];\n      mode = token.text;\n    }\n    if (index + paramsCount < tokens.length) {\n      for (var i = index; i < index + paramsCount; i++) {\n        var numbeToken = tokens[i];\n        if (isType(numbeToken, NUMBER)) {\n          params[params.length] = +numbeToken.text;\n        } else {\n          throw new Error('Param not a number: ' + mode + ',' + numbeToken.text);\n        }\n      }\n      if (typeof PARAMS[mode] === 'number') {\n        var segment = {\n          key: mode,\n          data: params\n        };\n        segments.push(segment);\n        index += paramsCount;\n        token = tokens[index];\n        if (mode === 'M') mode = 'L';\n        if (mode === 'm') mode = 'l';\n      } else {\n        throw new Error('Bad segment: ' + mode);\n      }\n    } else {\n      throw new Error('Path data ended short');\n    }\n  }\n  return segments;\n}\nexport function serialize(segments) {\n  var tokens = [];\n  var _iterator = _createForOfIteratorHelper(segments),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n        key = _step$value.key,\n        data = _step$value.data;\n      tokens.push(key);\n      switch (key) {\n        case 'C':\n        case 'c':\n          tokens.push(data[0], \"\".concat(data[1], \",\"), data[2], \"\".concat(data[3], \",\"), data[4], data[5]);\n          break;\n        case 'S':\n        case 's':\n        case 'Q':\n        case 'q':\n          tokens.push(data[0], \"\".concat(data[1], \",\"), data[2], data[3]);\n          break;\n        default:\n          tokens.push.apply(tokens, _toConsumableArray(data));\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return tokens.join(' ');\n}","map":{"version":3,"names":["COMMAND","NUMBER","EOD","PARAMS","A","a","C","c","H","h","L","l","M","m","Q","q","S","s","T","t","V","v","Z","z","tokenize","d","tokens","Array","match","substr","RegExp","$1","length","type","text","concat","parseFloat","isType","token","parsePath","segments","mode","index","paramsCount","params","i","numbeToken","Error","segment","key","data","push","serialize","_iterator","_createForOfIteratorHelper","_step","n","done","_step$value","value","apply","_toConsumableArray","err","e","f","join"],"sources":["D:/project/excalidraw-cn/node_modules/path-data-parser/lib/parser.js"],"sourcesContent":["const COMMAND = 0;\nconst NUMBER = 1;\nconst EOD = 2;\nconst PARAMS = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };\nfunction tokenize(d) {\n    const tokens = new Array();\n    while (d !== '') {\n        if (d.match(/^([ \\t\\r\\n,]+)/)) {\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n            tokens[tokens.length] = { type: COMMAND, text: RegExp.$1 };\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n            tokens[tokens.length] = { type: NUMBER, text: `${parseFloat(RegExp.$1)}` };\n            d = d.substr(RegExp.$1.length);\n        }\n        else {\n            return [];\n        }\n    }\n    tokens[tokens.length] = { type: EOD, text: '' };\n    return tokens;\n}\nfunction isType(token, type) {\n    return token.type === type;\n}\nexport function parsePath(d) {\n    const segments = [];\n    const tokens = tokenize(d);\n    let mode = 'BOD';\n    let index = 0;\n    let token = tokens[index];\n    while (!isType(token, EOD)) {\n        let paramsCount = 0;\n        const params = [];\n        if (mode === 'BOD') {\n            if (token.text === 'M' || token.text === 'm') {\n                index++;\n                paramsCount = PARAMS[token.text];\n                mode = token.text;\n            }\n            else {\n                return parsePath('M0,0' + d);\n            }\n        }\n        else if (isType(token, NUMBER)) {\n            paramsCount = PARAMS[mode];\n        }\n        else {\n            index++;\n            paramsCount = PARAMS[token.text];\n            mode = token.text;\n        }\n        if ((index + paramsCount) < tokens.length) {\n            for (let i = index; i < index + paramsCount; i++) {\n                const numbeToken = tokens[i];\n                if (isType(numbeToken, NUMBER)) {\n                    params[params.length] = +numbeToken.text;\n                }\n                else {\n                    throw new Error('Param not a number: ' + mode + ',' + numbeToken.text);\n                }\n            }\n            if (typeof PARAMS[mode] === 'number') {\n                const segment = { key: mode, data: params };\n                segments.push(segment);\n                index += paramsCount;\n                token = tokens[index];\n                if (mode === 'M')\n                    mode = 'L';\n                if (mode === 'm')\n                    mode = 'l';\n            }\n            else {\n                throw new Error('Bad segment: ' + mode);\n            }\n        }\n        else {\n            throw new Error('Path data ended short');\n        }\n    }\n    return segments;\n}\nexport function serialize(segments) {\n    const tokens = [];\n    for (const { key, data } of segments) {\n        tokens.push(key);\n        switch (key) {\n            case 'C':\n            case 'c':\n                tokens.push(data[0], `${data[1]},`, data[2], `${data[3]},`, data[4], data[5]);\n                break;\n            case 'S':\n            case 's':\n            case 'Q':\n            case 'q':\n                tokens.push(data[0], `${data[1]},`, data[2], data[3]);\n                break;\n            default:\n                tokens.push(...data);\n                break;\n        }\n    }\n    return tokens.join(' ');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}