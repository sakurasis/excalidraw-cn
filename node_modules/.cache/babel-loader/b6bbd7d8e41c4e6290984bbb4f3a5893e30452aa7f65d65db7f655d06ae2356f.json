{"ast":null,"code":"import { ENCRYPTION_KEY_BITS } from \"../constants\";\nimport { blobToArrayBuffer } from \"./blob\";\nexport const IV_LENGTH_BYTES = 12;\nexport const createIV = () => {\n  const arr = new Uint8Array(IV_LENGTH_BYTES);\n  return window.crypto.getRandomValues(arr);\n};\nexport const generateEncryptionKey = async returnAs => {\n  const key = await window.crypto.subtle.generateKey({\n    name: \"AES-GCM\",\n    length: ENCRYPTION_KEY_BITS\n  }, true,\n  // extractable\n  [\"encrypt\", \"decrypt\"]);\n  return returnAs === \"cryptoKey\" ? key : (await window.crypto.subtle.exportKey(\"jwk\", key)).k;\n};\nexport const getCryptoKey = (key, usage) => window.crypto.subtle.importKey(\"jwk\", {\n  alg: \"A128GCM\",\n  ext: true,\n  k: key,\n  key_ops: [\"encrypt\", \"decrypt\"],\n  kty: \"oct\"\n}, {\n  name: \"AES-GCM\",\n  length: ENCRYPTION_KEY_BITS\n}, false,\n// extractable\n[usage]);\nexport const encryptData = async (key, data) => {\n  const importedKey = typeof key === \"string\" ? await getCryptoKey(key, \"encrypt\") : key;\n  const iv = createIV();\n  const buffer = typeof data === \"string\" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : data instanceof Blob ? await blobToArrayBuffer(data) : data;\n\n  // We use symmetric encryption. AES-GCM is the recommended algorithm and\n  // includes checks that the ciphertext has not been modified by an attacker.\n  const encryptedBuffer = await window.crypto.subtle.encrypt({\n    name: \"AES-GCM\",\n    iv\n  }, importedKey, buffer);\n  return {\n    encryptedBuffer,\n    iv\n  };\n};\nexport const decryptData = async (iv, encrypted, privateKey) => {\n  const key = await getCryptoKey(privateKey, \"decrypt\");\n  return window.crypto.subtle.decrypt({\n    name: \"AES-GCM\",\n    iv\n  }, key, encrypted);\n};","map":{"version":3,"names":["ENCRYPTION_KEY_BITS","blobToArrayBuffer","IV_LENGTH_BYTES","createIV","arr","Uint8Array","window","crypto","getRandomValues","generateEncryptionKey","returnAs","key","subtle","generateKey","name","length","exportKey","k","getCryptoKey","usage","importKey","alg","ext","key_ops","kty","encryptData","data","importedKey","iv","buffer","TextEncoder","encode","Blob","encryptedBuffer","encrypt","decryptData","encrypted","privateKey","decrypt"],"sources":["D:/project/excalidraw-cn/src/data/encryption.ts"],"sourcesContent":["import { ENCRYPTION_KEY_BITS } from \"../constants\";\nimport { blobToArrayBuffer } from \"./blob\";\n\nexport const IV_LENGTH_BYTES = 12;\n\nexport const createIV = () => {\n  const arr = new Uint8Array(IV_LENGTH_BYTES);\n  return window.crypto.getRandomValues(arr);\n};\n\nexport const generateEncryptionKey = async <\n  T extends \"string\" | \"cryptoKey\" = \"string\",\n>(\n  returnAs?: T,\n): Promise<T extends \"cryptoKey\" ? CryptoKey : string> => {\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: ENCRYPTION_KEY_BITS,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n  return (\n    returnAs === \"cryptoKey\"\n      ? key\n      : (await window.crypto.subtle.exportKey(\"jwk\", key)).k\n  ) as T extends \"cryptoKey\" ? CryptoKey : string;\n};\n\nexport const getCryptoKey = (key: string, usage: KeyUsage) =>\n  window.crypto.subtle.importKey(\n    \"jwk\",\n    {\n      alg: \"A128GCM\",\n      ext: true,\n      k: key,\n      key_ops: [\"encrypt\", \"decrypt\"],\n      kty: \"oct\",\n    },\n    {\n      name: \"AES-GCM\",\n      length: ENCRYPTION_KEY_BITS,\n    },\n    false, // extractable\n    [usage],\n  );\n\nexport const encryptData = async (\n  key: string | CryptoKey,\n  data: Uint8Array | ArrayBuffer | Blob | File | string,\n): Promise<{ encryptedBuffer: ArrayBuffer; iv: Uint8Array }> => {\n  const importedKey =\n    typeof key === \"string\" ? await getCryptoKey(key, \"encrypt\") : key;\n  const iv = createIV();\n  const buffer: ArrayBuffer | Uint8Array =\n    typeof data === \"string\"\n      ? new TextEncoder().encode(data)\n      : data instanceof Uint8Array\n      ? data\n      : data instanceof Blob\n      ? await blobToArrayBuffer(data)\n      : data;\n\n  // We use symmetric encryption. AES-GCM is the recommended algorithm and\n  // includes checks that the ciphertext has not been modified by an attacker.\n  const encryptedBuffer = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    importedKey,\n    buffer as ArrayBuffer | Uint8Array,\n  );\n\n  return { encryptedBuffer, iv };\n};\n\nexport const decryptData = async (\n  iv: Uint8Array,\n  encrypted: Uint8Array | ArrayBuffer,\n  privateKey: string,\n): Promise<ArrayBuffer> => {\n  const key = await getCryptoKey(privateKey, \"decrypt\");\n  return window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    key,\n    encrypted,\n  );\n};\n"],"mappings":"AAAA,SAASA,mBAAmB,QAAQ,cAAc;AAClD,SAASC,iBAAiB,QAAQ,QAAQ;AAE1C,OAAO,MAAMC,eAAe,GAAG,EAAE;AAEjC,OAAO,MAAMC,QAAQ,GAAGA,CAAA,KAAM;EAC5B,MAAMC,GAAG,GAAG,IAAIC,UAAU,CAACH,eAAe,CAAC;EAC3C,OAAOI,MAAM,CAACC,MAAM,CAACC,eAAe,CAACJ,GAAG,CAAC;AAC3C,CAAC;AAED,OAAO,MAAMK,qBAAqB,GAAG,MAGnCC,QAAY,IAC4C;EACxD,MAAMC,GAAG,GAAG,MAAML,MAAM,CAACC,MAAM,CAACK,MAAM,CAACC,WAAW,CAChD;IACEC,IAAI,EAAE,SAAS;IACfC,MAAM,EAAEf;EACV,CAAC,EACD,IAAI;EAAE;EACN,CAAC,SAAS,EAAE,SAAS,CAAC,CACvB;EACD,OACEU,QAAQ,KAAK,WAAW,GACpBC,GAAG,GACH,CAAC,MAAML,MAAM,CAACC,MAAM,CAACK,MAAM,CAACI,SAAS,CAAC,KAAK,EAAEL,GAAG,CAAC,EAAEM,CAAC;AAE5D,CAAC;AAED,OAAO,MAAMC,YAAY,GAAGA,CAACP,GAAW,EAAEQ,KAAe,KACvDb,MAAM,CAACC,MAAM,CAACK,MAAM,CAACQ,SAAS,CAC5B,KAAK,EACL;EACEC,GAAG,EAAE,SAAS;EACdC,GAAG,EAAE,IAAI;EACTL,CAAC,EAAEN,GAAG;EACNY,OAAO,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC;EAC/BC,GAAG,EAAE;AACP,CAAC,EACD;EACEV,IAAI,EAAE,SAAS;EACfC,MAAM,EAAEf;AACV,CAAC,EACD,KAAK;AAAE;AACP,CAACmB,KAAK,CAAC,CACR;AAEH,OAAO,MAAMM,WAAW,GAAG,MAAAA,CACzBd,GAAuB,EACvBe,IAAqD,KACS;EAC9D,MAAMC,WAAW,GACf,OAAOhB,GAAG,KAAK,QAAQ,GAAG,MAAMO,YAAY,CAACP,GAAG,EAAE,SAAS,CAAC,GAAGA,GAAG;EACpE,MAAMiB,EAAE,GAAGzB,QAAQ,EAAE;EACrB,MAAM0B,MAAgC,GACpC,OAAOH,IAAI,KAAK,QAAQ,GACpB,IAAII,WAAW,EAAE,CAACC,MAAM,CAACL,IAAI,CAAC,GAC9BA,IAAI,YAAYrB,UAAU,GAC1BqB,IAAI,GACJA,IAAI,YAAYM,IAAI,GACpB,MAAM/B,iBAAiB,CAACyB,IAAI,CAAC,GAC7BA,IAAI;;EAEV;EACA;EACA,MAAMO,eAAe,GAAG,MAAM3B,MAAM,CAACC,MAAM,CAACK,MAAM,CAACsB,OAAO,CACxD;IACEpB,IAAI,EAAE,SAAS;IACfc;EACF,CAAC,EACDD,WAAW,EACXE,MAAM,CACP;EAED,OAAO;IAAEI,eAAe;IAAEL;EAAG,CAAC;AAChC,CAAC;AAED,OAAO,MAAMO,WAAW,GAAG,MAAAA,CACzBP,EAAc,EACdQ,SAAmC,EACnCC,UAAkB,KACO;EACzB,MAAM1B,GAAG,GAAG,MAAMO,YAAY,CAACmB,UAAU,EAAE,SAAS,CAAC;EACrD,OAAO/B,MAAM,CAACC,MAAM,CAACK,MAAM,CAAC0B,OAAO,CACjC;IACExB,IAAI,EAAE,SAAS;IACfc;EACF,CAAC,EACDjB,GAAG,EACHyB,SAAS,CACV;AACH,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}