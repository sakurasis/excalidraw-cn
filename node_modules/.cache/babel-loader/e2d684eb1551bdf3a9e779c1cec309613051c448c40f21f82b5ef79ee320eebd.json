{"ast":null,"code":"import { extractExceptionKeysForMessage, isEvent, normalizeToSize } from '@sentry/utils';\nimport { computeStackTrace } from './tracekit';\nvar STACKTRACE_LIMIT = 50;\n/**\n * This function creates an exception from an TraceKitStackTrace\n * @param stacktrace TraceKitStackTrace that will be converted to an exception\n * @hidden\n */\nexport function exceptionFromStacktrace(stacktrace) {\n  var frames = prepareFramesForEvent(stacktrace.stack);\n  var exception = {\n    type: stacktrace.name,\n    value: stacktrace.message\n  };\n  if (frames && frames.length) {\n    exception.stacktrace = {\n      frames: frames\n    };\n  }\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n  return exception;\n}\n/**\n * @hidden\n */\nexport function eventFromPlainObject(exception, syntheticException, rejection) {\n  var event = {\n    exception: {\n      values: [{\n        type: isEvent(exception) ? exception.constructor.name : rejection ? 'UnhandledRejection' : 'Error',\n        value: \"Non-Error \" + (rejection ? 'promise rejection' : 'exception') + \" captured with keys: \" + extractExceptionKeysForMessage(exception)\n      }]\n    },\n    extra: {\n      __serialized__: normalizeToSize(exception)\n    }\n  };\n  if (syntheticException) {\n    var stacktrace = computeStackTrace(syntheticException);\n    var frames_1 = prepareFramesForEvent(stacktrace.stack);\n    event.stacktrace = {\n      frames: frames_1\n    };\n  }\n  return event;\n}\n/**\n * @hidden\n */\nexport function eventFromStacktrace(stacktrace) {\n  var exception = exceptionFromStacktrace(stacktrace);\n  return {\n    exception: {\n      values: [exception]\n    }\n  };\n}\n/**\n * @hidden\n */\nexport function prepareFramesForEvent(stack) {\n  if (!stack || !stack.length) {\n    return [];\n  }\n  var localStack = stack;\n  var firstFrameFunction = localStack[0].func || '';\n  var lastFrameFunction = localStack[localStack.length - 1].func || '';\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack.slice(0, STACKTRACE_LIMIT).map(function (frame) {\n    return {\n      colno: frame.column === null ? undefined : frame.column,\n      filename: frame.url || localStack[0].url,\n      function: frame.func || '?',\n      in_app: true,\n      lineno: frame.line === null ? undefined : frame.line\n    };\n  }).reverse();\n}","map":{"version":3,"names":["extractExceptionKeysForMessage","isEvent","normalizeToSize","computeStackTrace","STACKTRACE_LIMIT","exceptionFromStacktrace","stacktrace","frames","prepareFramesForEvent","stack","exception","type","name","value","message","length","undefined","eventFromPlainObject","syntheticException","rejection","event","values","constructor","extra","__serialized__","frames_1","eventFromStacktrace","localStack","firstFrameFunction","func","lastFrameFunction","indexOf","slice","map","frame","colno","column","filename","url","function","in_app","lineno","line","reverse"],"sources":["D:\\project\\excalidraw-cn\\node_modules\\@sentry\\browser\\src\\parsers.ts"],"sourcesContent":["import { Event, Exception, StackFrame } from '@sentry/types';\nimport { extractExceptionKeysForMessage, isEvent, normalizeToSize } from '@sentry/utils';\n\nimport { computeStackTrace, StackFrame as TraceKitStackFrame, StackTrace as TraceKitStackTrace } from './tracekit';\n\nconst STACKTRACE_LIMIT = 50;\n\n/**\n * This function creates an exception from an TraceKitStackTrace\n * @param stacktrace TraceKitStackTrace that will be converted to an exception\n * @hidden\n */\nexport function exceptionFromStacktrace(stacktrace: TraceKitStackTrace): Exception {\n  const frames = prepareFramesForEvent(stacktrace.stack);\n\n  const exception: Exception = {\n    type: stacktrace.name,\n    value: stacktrace.message,\n  };\n\n  if (frames && frames.length) {\n    exception.stacktrace = { frames };\n  }\n\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n\n  return exception;\n}\n\n/**\n * @hidden\n */\nexport function eventFromPlainObject(\n  exception: Record<string, unknown>,\n  syntheticException?: Error,\n  rejection?: boolean,\n): Event {\n  const event: Event = {\n    exception: {\n      values: [\n        {\n          type: isEvent(exception) ? exception.constructor.name : rejection ? 'UnhandledRejection' : 'Error',\n          value: `Non-Error ${\n            rejection ? 'promise rejection' : 'exception'\n          } captured with keys: ${extractExceptionKeysForMessage(exception)}`,\n        },\n      ],\n    },\n    extra: {\n      __serialized__: normalizeToSize(exception),\n    },\n  };\n\n  if (syntheticException) {\n    const stacktrace = computeStackTrace(syntheticException);\n    const frames = prepareFramesForEvent(stacktrace.stack);\n    event.stacktrace = {\n      frames,\n    };\n  }\n\n  return event;\n}\n\n/**\n * @hidden\n */\nexport function eventFromStacktrace(stacktrace: TraceKitStackTrace): Event {\n  const exception = exceptionFromStacktrace(stacktrace);\n\n  return {\n    exception: {\n      values: [exception],\n    },\n  };\n}\n\n/**\n * @hidden\n */\nexport function prepareFramesForEvent(stack: TraceKitStackFrame[]): StackFrame[] {\n  if (!stack || !stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n\n  const firstFrameFunction = localStack[0].func || '';\n  const lastFrameFunction = localStack[localStack.length - 1].func || '';\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack\n    .slice(0, STACKTRACE_LIMIT)\n    .map(\n      (frame: TraceKitStackFrame): StackFrame => ({\n        colno: frame.column === null ? undefined : frame.column,\n        filename: frame.url || localStack[0].url,\n        function: frame.func || '?',\n        in_app: true,\n        lineno: frame.line === null ? undefined : frame.line,\n      }),\n    )\n    .reverse();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}