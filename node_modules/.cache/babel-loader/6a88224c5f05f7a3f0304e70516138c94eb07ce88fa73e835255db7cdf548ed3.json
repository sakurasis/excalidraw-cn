{"ast":null,"code":"import { createContext, useState, useEffect, useRef, createElement, useContext, useReducer, useDebugValue, useCallback } from 'react';\nimport { atom as atom$1 } from 'jotai/vanilla';\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = promise => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = suspensePromise => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = suspensePromise => {\n  var _a;\n  const {\n    b: basePromise,\n    c: cancelPromise\n  } = suspensePromise[SUSPENSE_PROMISE];\n  if (cancelPromise) {\n    cancelPromise();\n    (_a = promiseAbortMap.get(basePromise)) == null ? void 0 : _a();\n  }\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (basePromise, promise) => {\n  const suspensePromiseExtra = {\n    b: basePromise,\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise(resolve => {\n    suspensePromiseExtra.c = () => {\n      suspensePromiseExtra.c = null;\n      resolve();\n    };\n    promise.finally(suspensePromiseExtra.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;\n  return suspensePromise;\n};\nconst copySuspensePromise = suspensePromise => createSuspensePromise(suspensePromise[SUSPENSE_PROMISE].b, suspensePromise[SUSPENSE_PROMISE].o);\nconst promiseAbortMap = /* @__PURE__ */new WeakMap();\nconst registerPromiseAbort = (basePromise, abort) => {\n  promiseAbortMap.set(basePromise, abort);\n};\nconst hasInitialValue = atom => \"init\" in atom;\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = initialValues => {\n  const committedAtomStateMap = /* @__PURE__ */new WeakMap();\n  const mountedMap = /* @__PURE__ */new WeakMap();\n  const pendingMap = /* @__PURE__ */new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */new Set();\n    mountedAtoms = /* @__PURE__ */new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        y: true,\n        // not invalidated\n        d: /* @__PURE__ */new Map()\n      };\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\"Found initial value for derived atom which can cause unexpected behavior\", atom);\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = atom => {\n    const versionSet = /* @__PURE__ */new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */new WeakMap();\n  const getVersionedAtomStateMap = version => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState && \"p\" in atomState && isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          atomState = void 0;\n        }\n        if (atomState) {\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = function (version) {\n    let prevReadDependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /* @__PURE__ */new Map();\n    let dependencies = arguments.length > 2 ? arguments[2] : undefined;\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */new Map();\n    let changed = false;\n    dependencies.forEach(atom => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = !(atomState == null ? void 0 : atomState.y);\n    if (!atomState || !(\"v\" in atomState) ||\n    // new value, or\n    !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every(a => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      // set read error\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n        if (!atomState.y) {\n          return {\n            ...atomState,\n            y: true\n          };\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(promiseOrValue, promiseOrValue.then(value => {\n        setAtomValue(version, atom, value, dependencies, suspensePromise);\n      }).catch(e => {\n        if (e instanceof Promise) {\n          if (isSuspensePromise(e)) {\n            return e.then(() => {\n              readAtomState(version, atom, true);\n            });\n          }\n          return e;\n        }\n        setAtomReadError(version, atom, e, dependencies, suspensePromise);\n      }));\n      return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n    }\n    return setAtomValue(version, atom, promiseOrValue, dependencies);\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = {\n        ...atomState,\n        // copy everything\n        y: false\n        // invalidated\n      };\n\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.y &&\n        // not invalidated\n        \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && !aState.y) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(_ref => {\n          let [a, r] = _ref;\n          const aState = getAtomState(version, a);\n          return aState && !(\"p\" in aState) &&\n          // has no suspense promise\n          aState.r === r;\n        })) {\n          if (!atomState.y) {\n            return {\n              ...atomState,\n              y: true\n            };\n          }\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */new Set();\n    try {\n      const promiseOrValue = atom.read(a => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);\n        return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (version, addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (version, deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(dependent => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(() => {\n            const s = getAtomState(version, a);\n            if (s && \"p\" in s && s.p === aState.p) {\n              return new Promise(resolve => setTimeout(resolve)).then(() => writeGetter(a, options));\n            }\n            return writeGetter(a, options);\n          });\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\"Reading pending atom state in write operation. We throw a promise for now.\", a);\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] no value found while reading atom in write operation. This is probably a bug.\", a);\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach(cancelledVersion => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = atom => !!atom.write;\n  const mountAtom = (version, atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = update => writeAtom(atom, update, version);\n      const onUnmount = atom.onMount(setAtom);\n      version = void 0;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (version, atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (version, atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach(a => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  const flushPending = version => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach(listener => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(_ref2 => {\n        let [atom, prevAtomState] = _ref2;\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && (\n        // invalidated\n        atomState == null ? void 0 : atomState.y)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach(listener => listener());\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach(l => l());\n    }\n  };\n  const commitVersionedAtomStateMap = version => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback, version) => {\n    const mounted = addAtom(version, atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: l => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: a => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: a => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = initialValues => {\n  const store = createStore(initialValues);\n  const get = atom => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = atom => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return {\n    s: store\n  };\n};\nconst ScopeContextMap = /* @__PURE__ */new Map();\nconst getScopeContext = scope => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\nconst Provider = _ref3 => {\n  let {\n    children,\n    initialValues,\n    scope,\n    unstable_createStore,\n    unstable_enableVersionedWrite\n  } = _ref3;\n  const [version, setVersion] = useState({});\n  useEffect(() => {\n    const scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    const scopeContainer = createScopeContainer(initialValues, unstable_createStore);\n    if (unstable_enableVersionedWrite) {\n      let retrying = 0;\n      scopeContainer.w = write => {\n        setVersion(parentVersion => {\n          const nextVersion = retrying ? parentVersion : {\n            p: parentVersion\n          };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = fn => {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\nfunction atom(read, write) {\n  return atom$1(read, write);\n}\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const {\n    s: store,\n    v: versionFromProvider\n  } = scopeContainer;\n  const getAtomValue = version2 => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !atomState.y) {\n      throw new Error(\"should not be invalidated\");\n    }\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  };\n  const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] = useReducer((prev, nextVersion) => {\n    const nextValue = getAtomValue(nextVersion);\n    if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n      return prev;\n    }\n    return [nextVersion, nextValue, atom];\n  }, versionFromProvider, initialVersion => {\n    const initialValue = getAtomValue(initialVersion);\n    return [initialVersion, initialValue, atom];\n  });\n  let value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  useEffect(() => {\n    const {\n      v: versionFromProvider2\n    } = scopeContainer;\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom, versionFromProvider2);\n    }\n    const unsubscribe = store[SUBSCRIBE_ATOM](atom, rerenderIfChanged, versionFromProvider2);\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const {\n    s: store,\n    w: versionedWrite\n  } = useContext(ScopeContext);\n  const setAtom = useCallback(update => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n      throw new Error(\"not writable atom\");\n    }\n    const write = version => store[WRITE_ATOM](atom, update, version);\n    return versionedWrite ? versionedWrite(write) : write();\n  }, [store, versionedWrite, atom]);\n  return setAtom;\n}\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\");\n    scope = atom.scope;\n  }\n  return [useAtomValue(atom, scope),\n  // We do wrong type assertion here, which results in throwing an error.\n  useSetAtom(atom, scope)];\n}\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, registerPromiseAbort as SECRET_INTERNAL_registerPromiseAbort, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };","map":{"version":3,"names":["createContext","useState","useEffect","useRef","createElement","useContext","useReducer","useDebugValue","useCallback","atom","atom$1","SUSPENSE_PROMISE","Symbol","isSuspensePromise","promise","isSuspensePromiseAlreadyCancelled","suspensePromise","c","cancelSuspensePromise","_a","b","basePromise","cancelPromise","promiseAbortMap","get","isEqualSuspensePromise","oldSuspensePromise","newSuspensePromise","oldOriginalPromise","o","newOriginalPromise","createSuspensePromise","suspensePromiseExtra","Promise","resolve","finally","copySuspensePromise","WeakMap","registerPromiseAbort","abort","set","hasInitialValue","READ_ATOM","WRITE_ATOM","COMMIT_ATOM","SUBSCRIBE_ATOM","RESTORE_ATOMS","DEV_SUBSCRIBE_STATE","DEV_GET_MOUNTED_ATOMS","DEV_GET_ATOM_STATE","DEV_GET_MOUNTED","createStore","initialValues","committedAtomStateMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","import","meta","env","MODE","Set","value","atomState","v","r","y","d","Object","freeze","console","warn","suspensePromiseCacheMap","addSuspensePromiseToCache","version","cache","then","delete","size","cancelAllSuspensePromiseInCache","versionSet","forEach","add","versionedAtomStateMapMap","getVersionedAtomStateMap","versionedAtomStateMap","getAtomState","p","setAtomState","prevAtomState","has","createReadDependencies","prevReadDependencies","arguments","length","undefined","dependencies","readDependencies","changed","revision","setAtomValue","nextAtomState","is","Array","from","keys","every","a","flushPending","setAtomReadError","error","e","setAtomSuspensePromise","setAtomPromiseOrValue","promiseOrValue","catch","readAtomState","setAtomInvalidated","force","_","aState","_ref","read","init","Error","errorOrPromise","readAtom","readingAtom","addAtom","addingAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","deletingAtom","unmountAtom","invalidateDependents","dependent","writeAtomState","update","isSync","writeGetter","options","unstable_promise","s","setTimeout","info","setter","promiseOrVoid2","cancelledVersion","promiseOrVoid","write","writeAtom","writingAtom","isActuallyWritableAtom","initialDependent","aMounted","onMount","setAtom","onUnmount","u","mountDependencies","committedAtomState","listener","pending","clear","_ref2","commitVersionedAtomStateMap","commitAtom","_atom","subscribeAtom","callback","listeners","restoreAtoms","values","createStoreForExport","store","asyncGet","reject","sub","SECRET_INTERNAL_store","createScopeContainer","unstable_createStore","ScopeContextMap","getScopeContext","scope","Provider","_ref3","children","unstable_enableVersionedWrite","setVersion","scopeContainer","scopeContainerRef","current","w","retrying","parentVersion","nextVersion","fn","ScopeContainerContext","useAtomValue","ScopeContext","versionFromProvider","getAtomValue","version2","valueFromReducer","atomFromReducer","rerenderIfChanged","prev","nextValue","initialVersion","initialValue","versionFromProvider2","unsubscribe","useSetAtom","versionedWrite","useAtom","SECRET_INTERNAL_getScopeContext","SECRET_INTERNAL_registerPromiseAbort"],"sources":["D:/project/excalidraw-cn/node_modules/jotai/esm/index.mjs"],"sourcesContent":["import { createContext, useState, useEffect, useRef, createElement, useContext, useReducer, useDebugValue, useCallback } from 'react';\nimport { atom as atom$1 } from 'jotai/vanilla';\n\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = (suspensePromise) => {\n  var _a;\n  const { b: basePromise, c: cancelPromise } = suspensePromise[SUSPENSE_PROMISE];\n  if (cancelPromise) {\n    cancelPromise();\n    (_a = promiseAbortMap.get(basePromise)) == null ? void 0 : _a();\n  }\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (basePromise, promise) => {\n  const suspensePromiseExtra = {\n    b: basePromise,\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise((resolve) => {\n    suspensePromiseExtra.c = () => {\n      suspensePromiseExtra.c = null;\n      resolve();\n    };\n    promise.finally(suspensePromiseExtra.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;\n  return suspensePromise;\n};\nconst copySuspensePromise = (suspensePromise) => createSuspensePromise(\n  suspensePromise[SUSPENSE_PROMISE].b,\n  suspensePromise[SUSPENSE_PROMISE].o\n);\nconst promiseAbortMap = /* @__PURE__ */ new WeakMap();\nconst registerPromiseAbort = (basePromise, abort) => {\n  promiseAbortMap.set(basePromise, abort);\n};\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = (initialValues) => {\n  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        y: true,\n        // not invalidated\n        d: /* @__PURE__ */ new Map()\n      };\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\n            \"Found initial value for derived atom which can cause unexpected behavior\",\n            atom\n          );\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */ new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = (atom) => {\n    const versionSet = /* @__PURE__ */ new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();\n  const getVersionedAtomStateMap = (version) => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */ new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState && \"p\" in atomState && isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          atomState = void 0;\n        }\n        if (atomState) {\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    dependencies.forEach((atom) => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = !(atomState == null ? void 0 : atomState.y);\n    if (!atomState || !(\"v\" in atomState) || // new value, or\n    !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      // set read error\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n        if (!atomState.y) {\n          return { ...atomState, y: true };\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(\n        promiseOrValue,\n        promiseOrValue.then((value) => {\n          setAtomValue(version, atom, value, dependencies, suspensePromise);\n        }).catch((e) => {\n          if (e instanceof Promise) {\n            if (isSuspensePromise(e)) {\n              return e.then(() => {\n                readAtomState(version, atom, true);\n              });\n            }\n            return e;\n          }\n          setAtomReadError(version, atom, e, dependencies, suspensePromise);\n        })\n      );\n      return setAtomSuspensePromise(\n        version,\n        atom,\n        suspensePromise,\n        dependencies\n      );\n    }\n    return setAtomValue(\n      version,\n      atom,\n      promiseOrValue,\n      dependencies\n    );\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = {\n        ...atomState,\n        // copy everything\n        y: false\n        // invalidated\n      };\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.y && // not invalidated\n        \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && !aState.y) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(([a, r]) => {\n          const aState = getAtomState(version, a);\n          return aState && !(\"p\" in aState) && // has no suspense promise\n          aState.r === r;\n        })) {\n          if (!atomState.y) {\n            return { ...atomState, y: true };\n          }\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */ new Set();\n    try {\n      const promiseOrValue = atom.read((a) => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);\n        return setAtomSuspensePromise(\n          version,\n          atom,\n          suspensePromise,\n          dependencies\n        );\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (version, addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (version, deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(() => {\n            const s = getAtomState(version, a);\n            if (s && \"p\" in s && s.p === aState.p) {\n              return new Promise((resolve) => setTimeout(resolve)).then(\n                () => writeGetter(a, options)\n              );\n            }\n            return writeGetter(a, options);\n          });\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\n            \"Reading pending atom state in write operation. We throw a promise for now.\",\n            a\n          );\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\n          \"[Bug] no value found while reading atom in write operation. This is probably a bug.\",\n          a\n        );\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach((cancelledVersion) => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom) => !!atom.write;\n  const mountAtom = (version, atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = (update) => writeAtom(atom, update, version);\n      const onUnmount = atom.onMount(setAtom);\n      version = void 0;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (version, atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (version, atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  const flushPending = (version) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && // invalidated\n        (atomState == null ? void 0 : atomState.y)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const commitVersionedAtomStateMap = (version) => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback, version) => {\n    const mounted = addAtom(version, atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = (initialValues) => {\n  const store = createStore(initialValues);\n  const get = (atom) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = (atom) => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return { s: store };\n};\nconst ScopeContextMap = /* @__PURE__ */ new Map();\nconst getScopeContext = (scope) => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nconst Provider = ({\n  children,\n  initialValues,\n  scope,\n  unstable_createStore,\n  unstable_enableVersionedWrite\n}) => {\n  const [version, setVersion] = useState({});\n  useEffect(() => {\n    const scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    const scopeContainer = createScopeContainer(\n      initialValues,\n      unstable_createStore\n    );\n    if (unstable_enableVersionedWrite) {\n      let retrying = 0;\n      scopeContainer.w = (write) => {\n        setVersion((parentVersion) => {\n          const nextVersion = retrying ? parentVersion : { p: parentVersion };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = (fn) => {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(\n    ScopeContainerContext.Provider,\n    {\n      value: scopeContainerRef.current\n    },\n    children\n  );\n};\n\nfunction atom(read, write) {\n  return atom$1(read, write);\n}\n\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const { s: store, v: versionFromProvider } = scopeContainer;\n  const getAtomValue = (version2) => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !atomState.y) {\n      throw new Error(\"should not be invalidated\");\n    }\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  };\n  const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] = useReducer(\n    (prev, nextVersion) => {\n      const nextValue = getAtomValue(nextVersion);\n      if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n        return prev;\n      }\n      return [nextVersion, nextValue, atom];\n    },\n    versionFromProvider,\n    (initialVersion) => {\n      const initialValue = getAtomValue(initialVersion);\n      return [initialVersion, initialValue, atom];\n    }\n  );\n  let value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  useEffect(() => {\n    const { v: versionFromProvider2 } = scopeContainer;\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom, versionFromProvider2);\n    }\n    const unsubscribe = store[SUBSCRIBE_ATOM](\n      atom,\n      rerenderIfChanged,\n      versionFromProvider2\n    );\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store, w: versionedWrite } = useContext(ScopeContext);\n  const setAtom = useCallback(\n    (update) => {\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      const write = (version) => store[WRITE_ATOM](atom, update, version);\n      return versionedWrite ? versionedWrite(write) : write();\n    },\n    [store, versionedWrite, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\n      \"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\"\n    );\n    scope = atom.scope;\n  }\n  return [\n    useAtomValue(atom, scope),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, scope)\n  ];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, registerPromiseAbort as SECRET_INTERNAL_registerPromiseAbort, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}