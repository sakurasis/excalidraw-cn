{"ast":null,"code":"import { rotatePoints, rotateLines } from '../geometry';\nexport function polygonHachureLines(polygonList, o) {\n  const angle = o.hachureAngle + 90;\n  let gap = o.hachureGap;\n  if (gap < 0) {\n    gap = o.strokeWidth * 4;\n  }\n  gap = Math.max(gap, 0.1);\n  const rotationCenter = [0, 0];\n  if (angle) {\n    for (const polygon of polygonList) {\n      rotatePoints(polygon, rotationCenter, angle);\n    }\n  }\n  const lines = straightHachureLines(polygonList, gap);\n  if (angle) {\n    for (const polygon of polygonList) {\n      rotatePoints(polygon, rotationCenter, -angle);\n    }\n    rotateLines(lines, rotationCenter, -angle);\n  }\n  return lines;\n}\nfunction straightHachureLines(polygonList, gap) {\n  const vertexArray = [];\n  for (const polygon of polygonList) {\n    const vertices = [...polygon];\n    if (vertices[0].join(',') !== vertices[vertices.length - 1].join(',')) {\n      vertices.push([vertices[0][0], vertices[0][1]]);\n    }\n    if (vertices.length > 2) {\n      vertexArray.push(vertices);\n    }\n  }\n  const lines = [];\n  gap = Math.max(gap, 0.1);\n  // Create sorted edges table\n  const edges = [];\n  for (const vertices of vertexArray) {\n    for (let i = 0; i < vertices.length - 1; i++) {\n      const p1 = vertices[i];\n      const p2 = vertices[i + 1];\n      if (p1[1] !== p2[1]) {\n        const ymin = Math.min(p1[1], p2[1]);\n        edges.push({\n          ymin,\n          ymax: Math.max(p1[1], p2[1]),\n          x: ymin === p1[1] ? p1[0] : p2[0],\n          islope: (p2[0] - p1[0]) / (p2[1] - p1[1])\n        });\n      }\n    }\n  }\n  edges.sort((e1, e2) => {\n    if (e1.ymin < e2.ymin) {\n      return -1;\n    }\n    if (e1.ymin > e2.ymin) {\n      return 1;\n    }\n    if (e1.x < e2.x) {\n      return -1;\n    }\n    if (e1.x > e2.x) {\n      return 1;\n    }\n    if (e1.ymax === e2.ymax) {\n      return 0;\n    }\n    return (e1.ymax - e2.ymax) / Math.abs(e1.ymax - e2.ymax);\n  });\n  if (!edges.length) {\n    return lines;\n  }\n  // Start scanning\n  let activeEdges = [];\n  let y = edges[0].ymin;\n  while (activeEdges.length || edges.length) {\n    if (edges.length) {\n      let ix = -1;\n      for (let i = 0; i < edges.length; i++) {\n        if (edges[i].ymin > y) {\n          break;\n        }\n        ix = i;\n      }\n      const removed = edges.splice(0, ix + 1);\n      removed.forEach(edge => {\n        activeEdges.push({\n          s: y,\n          edge\n        });\n      });\n    }\n    activeEdges = activeEdges.filter(ae => {\n      if (ae.edge.ymax <= y) {\n        return false;\n      }\n      return true;\n    });\n    activeEdges.sort((ae1, ae2) => {\n      if (ae1.edge.x === ae2.edge.x) {\n        return 0;\n      }\n      return (ae1.edge.x - ae2.edge.x) / Math.abs(ae1.edge.x - ae2.edge.x);\n    });\n    // fill between the edges\n    if (activeEdges.length > 1) {\n      for (let i = 0; i < activeEdges.length; i = i + 2) {\n        const nexti = i + 1;\n        if (nexti >= activeEdges.length) {\n          break;\n        }\n        const ce = activeEdges[i].edge;\n        const ne = activeEdges[nexti].edge;\n        lines.push([[Math.round(ce.x), y], [Math.round(ne.x), y]]);\n      }\n    }\n    y += gap;\n    activeEdges.forEach(ae => {\n      ae.edge.x = ae.edge.x + gap * ae.edge.islope;\n    });\n  }\n  return lines;\n}","map":{"version":3,"names":["rotatePoints","rotateLines","polygonHachureLines","polygonList","o","angle","hachureAngle","gap","hachureGap","strokeWidth","Math","max","rotationCenter","polygon","lines","straightHachureLines","vertexArray","vertices","join","length","push","edges","i","p1","p2","ymin","min","ymax","x","islope","sort","e1","e2","abs","activeEdges","y","ix","removed","splice","forEach","edge","s","filter","ae","ae1","ae2","nexti","ce","ne","round"],"sources":["D:/project/excalidraw-cn/node_modules/roughjs/bin/fillers/scan-line-hachure.js"],"sourcesContent":["import { rotatePoints, rotateLines } from '../geometry';\nexport function polygonHachureLines(polygonList, o) {\n    const angle = o.hachureAngle + 90;\n    let gap = o.hachureGap;\n    if (gap < 0) {\n        gap = o.strokeWidth * 4;\n    }\n    gap = Math.max(gap, 0.1);\n    const rotationCenter = [0, 0];\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, angle);\n        }\n    }\n    const lines = straightHachureLines(polygonList, gap);\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, -angle);\n        }\n        rotateLines(lines, rotationCenter, -angle);\n    }\n    return lines;\n}\nfunction straightHachureLines(polygonList, gap) {\n    const vertexArray = [];\n    for (const polygon of polygonList) {\n        const vertices = [...polygon];\n        if (vertices[0].join(',') !== vertices[vertices.length - 1].join(',')) {\n            vertices.push([vertices[0][0], vertices[0][1]]);\n        }\n        if (vertices.length > 2) {\n            vertexArray.push(vertices);\n        }\n    }\n    const lines = [];\n    gap = Math.max(gap, 0.1);\n    // Create sorted edges table\n    const edges = [];\n    for (const vertices of vertexArray) {\n        for (let i = 0; i < vertices.length - 1; i++) {\n            const p1 = vertices[i];\n            const p2 = vertices[i + 1];\n            if (p1[1] !== p2[1]) {\n                const ymin = Math.min(p1[1], p2[1]);\n                edges.push({\n                    ymin,\n                    ymax: Math.max(p1[1], p2[1]),\n                    x: ymin === p1[1] ? p1[0] : p2[0],\n                    islope: (p2[0] - p1[0]) / (p2[1] - p1[1]),\n                });\n            }\n        }\n    }\n    edges.sort((e1, e2) => {\n        if (e1.ymin < e2.ymin) {\n            return -1;\n        }\n        if (e1.ymin > e2.ymin) {\n            return 1;\n        }\n        if (e1.x < e2.x) {\n            return -1;\n        }\n        if (e1.x > e2.x) {\n            return 1;\n        }\n        if (e1.ymax === e2.ymax) {\n            return 0;\n        }\n        return (e1.ymax - e2.ymax) / Math.abs((e1.ymax - e2.ymax));\n    });\n    if (!edges.length) {\n        return lines;\n    }\n    // Start scanning\n    let activeEdges = [];\n    let y = edges[0].ymin;\n    while (activeEdges.length || edges.length) {\n        if (edges.length) {\n            let ix = -1;\n            for (let i = 0; i < edges.length; i++) {\n                if (edges[i].ymin > y) {\n                    break;\n                }\n                ix = i;\n            }\n            const removed = edges.splice(0, ix + 1);\n            removed.forEach((edge) => {\n                activeEdges.push({ s: y, edge });\n            });\n        }\n        activeEdges = activeEdges.filter((ae) => {\n            if (ae.edge.ymax <= y) {\n                return false;\n            }\n            return true;\n        });\n        activeEdges.sort((ae1, ae2) => {\n            if (ae1.edge.x === ae2.edge.x) {\n                return 0;\n            }\n            return (ae1.edge.x - ae2.edge.x) / Math.abs((ae1.edge.x - ae2.edge.x));\n        });\n        // fill between the edges\n        if (activeEdges.length > 1) {\n            for (let i = 0; i < activeEdges.length; i = i + 2) {\n                const nexti = i + 1;\n                if (nexti >= activeEdges.length) {\n                    break;\n                }\n                const ce = activeEdges[i].edge;\n                const ne = activeEdges[nexti].edge;\n                lines.push([\n                    [Math.round(ce.x), y],\n                    [Math.round(ne.x), y],\n                ]);\n            }\n        }\n        y += gap;\n        activeEdges.forEach((ae) => {\n            ae.edge.x = ae.edge.x + (gap * ae.edge.islope);\n        });\n    }\n    return lines;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}