{"ast":null,"code":"import { distance2d, rotate, rotatePoint } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { getShapeForElement, generateRoughOptions } from \"../renderer/renderElement\";\nimport { isArrowElement, isFreeDrawElement, isLinearElement, isTextElement } from \"./typeChecks\";\nimport { rescalePoints } from \"../points\";\nimport { getBoundTextElement, getContainerElement } from \"./textElement\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\n\n// x and y position of top left corner, x and y position of bottom right corner\n\nexport class ElementBounds {\n  static getBounds(element) {\n    const cachedBounds = ElementBounds.boundsCache.get(element);\n    if (cachedBounds !== null && cachedBounds !== void 0 && cachedBounds.version && cachedBounds.version === element.version) {\n      return cachedBounds.bounds;\n    }\n    const bounds = ElementBounds.calculateBounds(element);\n    ElementBounds.boundsCache.set(element, {\n      version: element.version,\n      bounds\n    });\n    return bounds;\n  }\n  static calculateBounds(element) {\n    let bounds;\n    const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(element);\n    if (isFreeDrawElement(element)) {\n      const [minX, minY, maxX, maxY] = getBoundsFromPoints(element.points.map(_ref => {\n        let [x, y] = _ref;\n        return rotate(x, y, cx - element.x, cy - element.y, element.angle);\n      }));\n      return [minX + element.x, minY + element.y, maxX + element.x, maxY + element.y];\n    } else if (isLinearElement(element)) {\n      bounds = getLinearElementRotatedBounds(element, cx, cy);\n    } else if (element.type === \"diamond\") {\n      const [x11, y11] = rotate(cx, y1, cx, cy, element.angle);\n      const [x12, y12] = rotate(cx, y2, cx, cy, element.angle);\n      const [x22, y22] = rotate(x1, cy, cx, cy, element.angle);\n      const [x21, y21] = rotate(x2, cy, cx, cy, element.angle);\n      const minX = Math.min(x11, x12, x22, x21);\n      const minY = Math.min(y11, y12, y22, y21);\n      const maxX = Math.max(x11, x12, x22, x21);\n      const maxY = Math.max(y11, y12, y22, y21);\n      bounds = [minX, minY, maxX, maxY];\n    } else if (element.type === \"ellipse\") {\n      const w = (x2 - x1) / 2;\n      const h = (y2 - y1) / 2;\n      const cos = Math.cos(element.angle);\n      const sin = Math.sin(element.angle);\n      const ww = Math.hypot(w * cos, h * sin);\n      const hh = Math.hypot(h * cos, w * sin);\n      bounds = [cx - ww, cy - hh, cx + ww, cy + hh];\n    } else {\n      const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n      const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n      const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n      const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n      const minX = Math.min(x11, x12, x22, x21);\n      const minY = Math.min(y11, y12, y22, y21);\n      const maxX = Math.max(x11, x12, x22, x21);\n      const maxY = Math.max(y11, y12, y22, y21);\n      bounds = [minX, minY, maxX, maxY];\n    }\n    return bounds;\n  }\n}\n\n// Scene -> Scene coords, but in x1,x2,y1,y2 format.\n//\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nElementBounds.boundsCache = new WeakMap();\nexport const getElementAbsoluteCoords = function (element) {\n  let includeBoundText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (isFreeDrawElement(element)) {\n    return getFreeDrawElementAbsoluteCoords(element);\n  } else if (isLinearElement(element)) {\n    return LinearElementEditor.getElementAbsoluteCoords(element, includeBoundText);\n  } else if (isTextElement(element)) {\n    const container = getContainerElement(element);\n    if (isArrowElement(container)) {\n      const coords = LinearElementEditor.getBoundTextElementPosition(container, element);\n      return [coords.x, coords.y, coords.x + element.width, coords.y + element.height, coords.x + element.width / 2, coords.y + element.height / 2];\n    }\n  }\n  return [element.x, element.y, element.x + element.width, element.y + element.height, element.x + element.width / 2, element.y + element.height / 2];\n};\n\n/**\n * for a given element, `getElementLineSegments` returns line segments\n * that can be used for visual collision detection (useful for frames)\n * as opposed to bounding box collision detection\n */\nexport const getElementLineSegments = element => {\n  const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(element);\n  const center = [cx, cy];\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    const segments = [];\n    let i = 0;\n    while (i < element.points.length - 1) {\n      segments.push([rotatePoint([element.points[i][0] + element.x, element.points[i][1] + element.y], center, element.angle), rotatePoint([element.points[i + 1][0] + element.x, element.points[i + 1][1] + element.y], center, element.angle)]);\n      i++;\n    }\n    return segments;\n  }\n  const [nw, ne, sw, se, n, s, w, e] = [[x1, y1], [x2, y1], [x1, y2], [x2, y2], [cx, y1], [cx, y2], [x1, cy], [x2, cy]].map(point => rotatePoint(point, center, element.angle));\n  if (element.type === \"diamond\") {\n    return [[n, w], [n, e], [s, w], [s, e]];\n  }\n  if (element.type === \"ellipse\") {\n    return [[n, w], [n, e], [s, w], [s, e], [n, w], [n, e], [s, w], [s, e]];\n  }\n  return [[nw, ne], [sw, se], [nw, sw], [ne, se], [nw, e], [sw, e], [ne, w], [se, w]];\n};\n\n/**\n * Scene -> Scene coords, but in x1,x2,y1,y2 format.\n *\n * Rectangle here means any rectangular frame, not an excalidraw element.\n */\nexport const getRectangleBoxAbsoluteCoords = boxSceneCoords => {\n  return [boxSceneCoords.x, boxSceneCoords.y, boxSceneCoords.x + boxSceneCoords.width, boxSceneCoords.y + boxSceneCoords.height, boxSceneCoords.x + boxSceneCoords.width / 2, boxSceneCoords.y + boxSceneCoords.height / 2];\n};\nexport const pointRelativeTo = (element, absoluteCoords) => {\n  return [absoluteCoords[0] - element.x, absoluteCoords[1] - element.y];\n};\nexport const getDiamondPoints = element => {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = 0;\n  const leftY = rightY;\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n};\nexport const getCurvePathOps = shape => {\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n  return shape.sets[0].ops;\n};\n\n// reference: https://eliot-jones.com/2019/12/cubic-bezier-curve-bounding-boxes\nconst getBezierValueForT = (t, p0, p1, p2, p3) => {\n  const oneMinusT = 1 - t;\n  return Math.pow(oneMinusT, 3) * p0 + 3 * Math.pow(oneMinusT, 2) * t * p1 + 3 * oneMinusT * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;\n};\nconst solveQuadratic = (p0, p1, p2, p3) => {\n  const i = p1 - p0;\n  const j = p2 - p1;\n  const k = p3 - p2;\n  const a = 3 * i - 6 * j + 3 * k;\n  const b = 6 * j - 6 * i;\n  const c = 3 * i;\n  const sqrtPart = b * b - 4 * a * c;\n  const hasSolution = sqrtPart >= 0;\n  if (!hasSolution) {\n    return false;\n  }\n  let s1 = null;\n  let s2 = null;\n  let t1 = Infinity;\n  let t2 = Infinity;\n  if (a === 0) {\n    t1 = t2 = -c / b;\n  } else {\n    t1 = (-b + Math.sqrt(sqrtPart)) / (2 * a);\n    t2 = (-b - Math.sqrt(sqrtPart)) / (2 * a);\n  }\n  if (t1 >= 0 && t1 <= 1) {\n    s1 = getBezierValueForT(t1, p0, p1, p2, p3);\n  }\n  if (t2 >= 0 && t2 <= 1) {\n    s2 = getBezierValueForT(t2, p0, p1, p2, p3);\n  }\n  return [s1, s2];\n};\nconst getCubicBezierCurveBound = (p0, p1, p2, p3) => {\n  const solX = solveQuadratic(p0[0], p1[0], p2[0], p3[0]);\n  const solY = solveQuadratic(p0[1], p1[1], p2[1], p3[1]);\n  let minX = Math.min(p0[0], p3[0]);\n  let maxX = Math.max(p0[0], p3[0]);\n  if (solX) {\n    const xs = solX.filter(x => x !== null);\n    minX = Math.min(minX, ...xs);\n    maxX = Math.max(maxX, ...xs);\n  }\n  let minY = Math.min(p0[1], p3[1]);\n  let maxY = Math.max(p0[1], p3[1]);\n  if (solY) {\n    const ys = solY.filter(y => y !== null);\n    minY = Math.min(minY, ...ys);\n    maxY = Math.max(maxY, ...ys);\n  }\n  return [minX, minY, maxX, maxY];\n};\nexport const getMinMaxXYFromCurvePathOps = (ops, transformXY) => {\n  let currentP = [0, 0];\n  const {\n    minX,\n    minY,\n    maxX,\n    maxY\n  } = ops.reduce((limits, _ref2) => {\n    let {\n      op,\n      data\n    } = _ref2;\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = data;\n      // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      const _p1 = [data[0], data[1]];\n      const _p2 = [data[2], data[3]];\n      const _p3 = [data[4], data[5]];\n      const p1 = transformXY ? transformXY(..._p1) : _p1;\n      const p2 = transformXY ? transformXY(..._p2) : _p2;\n      const p3 = transformXY ? transformXY(..._p3) : _p3;\n      const p0 = transformXY ? transformXY(...currentP) : currentP;\n      currentP = _p3;\n      const [minX, minY, maxX, maxY] = getCubicBezierCurveBound(p0, p1, p2, p3);\n      limits.minX = Math.min(limits.minX, minX);\n      limits.minY = Math.min(limits.minY, minY);\n      limits.maxX = Math.max(limits.maxX, maxX);\n      limits.maxY = Math.max(limits.maxY, maxY);\n    } else if (op === \"lineTo\") {\n      // TODO: Implement this\n    } else if (op === \"qcurveTo\") {\n      // TODO: Implement this\n    }\n    return limits;\n  }, {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  });\n  return [minX, minY, maxX, maxY];\n};\nconst getBoundsFromPoints = points => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  for (const [x, y] of points) {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n  return [minX, minY, maxX, maxY];\n};\nconst getFreeDrawElementAbsoluteCoords = element => {\n  const [minX, minY, maxX, maxY] = getBoundsFromPoints(element.points);\n  const x1 = minX + element.x;\n  const y1 = minY + element.y;\n  const x2 = maxX + element.x;\n  const y2 = maxY + element.y;\n  return [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2];\n};\nexport const getArrowheadPoints = (element, shape, position, arrowhead) => {\n  const ops = getCurvePathOps(shape[0]);\n  if (ops.length < 1) {\n    return null;\n  }\n\n  // The index of the bCurve operation to examine.\n  const index = position === \"start\" ? 1 : ops.length - 1;\n  const data = ops[index].data;\n  const p3 = [data[4], data[5]];\n  const p2 = [data[2], data[3]];\n  const p1 = [data[0], data[1]];\n\n  // We need to find p0 of the bezier curve.\n  // It is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation.\n  const prevOp = ops[index - 1];\n  let p0 = [0, 0];\n  if (prevOp.op === \"move\") {\n    p0 = prevOp.data;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t, idx) => Math.pow(1 - t, 3) * p3[idx] + 3 * t * Math.pow(1 - t, 2) * p2[idx] + 3 * Math.pow(t, 2) * (1 - t) * p1[idx] + p0[idx] * Math.pow(t, 3);\n\n  // Ee know the last point of the arrow (or the first, if start arrowhead).\n  const [x2, y2] = position === \"start\" ? p0 : p3;\n\n  // By using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point.\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases.\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // Find the normalized direction vector based on the\n  // previously calculated points.\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n  const size = {\n    arrow: 30,\n    bar: 15,\n    dot: 15,\n    triangle: 15\n  }[arrowhead]; // pixels (will differ for each arrowhead)\n\n  let length = 0;\n  if (arrowhead === \"arrow\") {\n    // Length for -> arrows is based on the length of the last section\n    const [cx, cy] = element.points[element.points.length - 1];\n    const [px, py] = element.points.length > 1 ? element.points[element.points.length - 2] : [0, 0];\n    length = Math.hypot(cx - px, cy - py);\n  } else {\n    // Length for other arrowhead types is based on the total length of the line\n    for (let i = 0; i < element.points.length; i++) {\n      const [px, py] = element.points[i - 1] || [0, 0];\n      const [cx, cy] = element.points[i];\n      length += Math.hypot(cx - px, cy - py);\n    }\n  }\n\n  // Scale down the arrowhead until we hit a certain size so that it doesn't look weird.\n  // This value is selected by minimizing a minimum size with the last segment of the arrowhead\n  const minSize = Math.min(size, length / 2);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n  if (arrowhead === \"dot\") {\n    const r = Math.hypot(ys - y2, xs - x2) + element.strokeWidth;\n    return [x2, y2, r];\n  }\n  const angle = {\n    arrow: 20,\n    bar: 90,\n    triangle: 25\n  }[arrowhead]; // degrees\n\n  // Return points\n  const [x3, y3] = rotate(xs, ys, x2, y2, -angle * Math.PI / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, angle * Math.PI / 180);\n  return [x2, y2, x3, y3, x4, y4];\n};\nconst generateLinearElementShape = element => {\n  const generator = rough.generator();\n  const options = generateRoughOptions(element);\n  const method = (() => {\n    if (element.roundness) {\n      return \"curve\";\n    }\n    if (options.fill) {\n      return \"polygon\";\n    }\n    return \"linearPath\";\n  })();\n  return generator[method](element.points, options);\n};\nconst getLinearElementRotatedBounds = (element, cx, cy) => {\n  var _getShapeForElement;\n  if (element.points.length < 2) {\n    const [pointX, pointY] = element.points[0];\n    const [x, y] = rotate(element.x + pointX, element.y + pointY, cx, cy, element.angle);\n    let coords = [x, y, x, y];\n    const boundTextElement = getBoundTextElement(element);\n    if (boundTextElement) {\n      const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(element, [x, y, x, y], boundTextElement);\n      coords = [coordsWithBoundText[0], coordsWithBoundText[1], coordsWithBoundText[2], coordsWithBoundText[3]];\n    }\n    return coords;\n  }\n\n  // first element is always the curve\n  const cachedShape = (_getShapeForElement = getShapeForElement(element)) === null || _getShapeForElement === void 0 ? void 0 : _getShapeForElement[0];\n  const shape = cachedShape !== null && cachedShape !== void 0 ? cachedShape : generateLinearElementShape(element);\n  const ops = getCurvePathOps(shape);\n  const transformXY = (x, y) => rotate(element.x + x, element.y + y, cx, cy, element.angle);\n  const res = getMinMaxXYFromCurvePathOps(ops, transformXY);\n  let coords = [res[0], res[1], res[2], res[3]];\n  const boundTextElement = getBoundTextElement(element);\n  if (boundTextElement) {\n    const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(element, coords, boundTextElement);\n    coords = [coordsWithBoundText[0], coordsWithBoundText[1], coordsWithBoundText[2], coordsWithBoundText[3]];\n  }\n  return coords;\n};\nexport const getElementBounds = element => {\n  return ElementBounds.getBounds(element);\n};\nexport const getCommonBounds = elements => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n  elements.forEach(element => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n  return [minX, minY, maxX, maxY];\n};\nexport const getResizedElementAbsoluteCoords = (element, nextWidth, nextHeight, normalizePoints) => {\n  if (!(isLinearElement(element) || isFreeDrawElement(element))) {\n    return [element.x, element.y, element.x + nextWidth, element.y + nextHeight];\n  }\n  const points = rescalePoints(0, nextWidth, rescalePoints(1, nextHeight, element.points, normalizePoints), normalizePoints);\n  let bounds;\n  if (isFreeDrawElement(element)) {\n    // Free Draw\n    bounds = getBoundsFromPoints(points);\n  } else {\n    // Line\n    const gen = rough.generator();\n    const curve = !element.roundness ? gen.linearPath(points, generateRoughOptions(element)) : gen.curve(points, generateRoughOptions(element));\n    const ops = getCurvePathOps(curve);\n    bounds = getMinMaxXYFromCurvePathOps(ops);\n  }\n  const [minX, minY, maxX, maxY] = bounds;\n  return [minX + element.x, minY + element.y, maxX + element.x, maxY + element.y];\n};\nexport const getElementPointsCoords = (element, points) => {\n  // This might be computationally heavey\n  const gen = rough.generator();\n  const curve = element.roundness == null ? gen.linearPath(points, generateRoughOptions(element)) : gen.curve(points, generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [minX + element.x, minY + element.y, maxX + element.x, maxY + element.y];\n};\nexport const getClosestElementBounds = (elements, from) => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n  let minDistance = Infinity;\n  let closestElement = elements[0];\n  elements.forEach(element => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    const distance = distance2d((x1 + x2) / 2, (y1 + y2) / 2, from.x, from.y);\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElement = element;\n    }\n  });\n  return getElementBounds(closestElement);\n};\nexport const getCommonBoundingBox = elements => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n    midX: (minX + maxX) / 2,\n    midY: (minY + maxY) / 2\n  };\n};","map":{"version":3,"names":["distance2d","rotate","rotatePoint","rough","getShapeForElement","generateRoughOptions","isArrowElement","isFreeDrawElement","isLinearElement","isTextElement","rescalePoints","getBoundTextElement","getContainerElement","LinearElementEditor","ElementBounds","getBounds","element","cachedBounds","boundsCache","get","version","bounds","calculateBounds","set","x1","y1","x2","y2","cx","cy","getElementAbsoluteCoords","minX","minY","maxX","maxY","getBoundsFromPoints","points","map","_ref","x","y","angle","getLinearElementRotatedBounds","type","x11","y11","x12","y12","x22","y22","x21","y21","Math","min","max","w","h","cos","sin","ww","hypot","hh","WeakMap","includeBoundText","arguments","length","undefined","getFreeDrawElementAbsoluteCoords","container","coords","getBoundTextElementPosition","width","height","getElementLineSegments","center","segments","i","push","nw","ne","sw","se","n","s","e","point","getRectangleBoxAbsoluteCoords","boxSceneCoords","pointRelativeTo","absoluteCoords","getDiamondPoints","topX","floor","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","getCurvePathOps","shape","sets","ops","getBezierValueForT","t","p0","p1","p2","p3","oneMinusT","pow","solveQuadratic","j","k","a","b","c","sqrtPart","hasSolution","s1","s2","t1","Infinity","t2","sqrt","getCubicBezierCurveBound","solX","solY","xs","filter","ys","getMinMaxXYFromCurvePathOps","transformXY","currentP","reduce","limits","_ref2","op","data","_p1","_p2","_p3","getArrowheadPoints","position","arrowhead","index","prevOp","equation","idx","distance","nx","ny","size","arrow","bar","dot","triangle","px","py","minSize","r","strokeWidth","x3","y3","PI","x4","y4","generateLinearElementShape","generator","options","method","roundness","fill","_getShapeForElement","pointX","pointY","boundTextElement","coordsWithBoundText","getMinMaxXYWithBoundText","cachedShape","res","getElementBounds","getCommonBounds","elements","forEach","getResizedElementAbsoluteCoords","nextWidth","nextHeight","normalizePoints","gen","curve","linearPath","getElementPointsCoords","getClosestElementBounds","from","minDistance","closestElement","getCommonBoundingBox","midX","midY"],"sources":["D:/project/excalidraw-cn/src/element/bounds.ts"],"sourcesContent":["import {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  Arrowhead,\n  ExcalidrawFreeDrawElement,\n  NonDeleted,\n  ExcalidrawTextElementWithContainer,\n} from \"./types\";\nimport { distance2d, rotate, rotatePoint } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { Drawable, Op } from \"roughjs/bin/core\";\nimport { Point } from \"../types\";\nimport {\n  getShapeForElement,\n  generateRoughOptions,\n} from \"../renderer/renderElement\";\nimport {\n  isArrowElement,\n  isFreeDrawElement,\n  isLinearElement,\n  isTextElement,\n} from \"./typeChecks\";\nimport { rescalePoints } from \"../points\";\nimport { getBoundTextElement, getContainerElement } from \"./textElement\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { Mutable } from \"../utility-types\";\n\nexport type RectangleBox = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  angle: number;\n};\n\ntype MaybeQuadraticSolution = [number | null, number | null] | false;\n\n// x and y position of top left corner, x and y position of bottom right corner\nexport type Bounds = readonly [x1: number, y1: number, x2: number, y2: number];\n\nexport class ElementBounds {\n  private static boundsCache = new WeakMap<\n    ExcalidrawElement,\n    {\n      bounds: Bounds;\n      version: ExcalidrawElement[\"version\"];\n    }\n  >();\n\n  static getBounds(element: ExcalidrawElement) {\n    const cachedBounds = ElementBounds.boundsCache.get(element);\n\n    if (cachedBounds?.version && cachedBounds.version === element.version) {\n      return cachedBounds.bounds;\n    }\n\n    const bounds = ElementBounds.calculateBounds(element);\n\n    ElementBounds.boundsCache.set(element, {\n      version: element.version,\n      bounds,\n    });\n\n    return bounds;\n  }\n\n  private static calculateBounds(element: ExcalidrawElement): Bounds {\n    let bounds: [number, number, number, number];\n\n    const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(element);\n\n    if (isFreeDrawElement(element)) {\n      const [minX, minY, maxX, maxY] = getBoundsFromPoints(\n        element.points.map(([x, y]) =>\n          rotate(x, y, cx - element.x, cy - element.y, element.angle),\n        ),\n      );\n\n      return [\n        minX + element.x,\n        minY + element.y,\n        maxX + element.x,\n        maxY + element.y,\n      ];\n    } else if (isLinearElement(element)) {\n      bounds = getLinearElementRotatedBounds(element, cx, cy);\n    } else if (element.type === \"diamond\") {\n      const [x11, y11] = rotate(cx, y1, cx, cy, element.angle);\n      const [x12, y12] = rotate(cx, y2, cx, cy, element.angle);\n      const [x22, y22] = rotate(x1, cy, cx, cy, element.angle);\n      const [x21, y21] = rotate(x2, cy, cx, cy, element.angle);\n      const minX = Math.min(x11, x12, x22, x21);\n      const minY = Math.min(y11, y12, y22, y21);\n      const maxX = Math.max(x11, x12, x22, x21);\n      const maxY = Math.max(y11, y12, y22, y21);\n      bounds = [minX, minY, maxX, maxY];\n    } else if (element.type === \"ellipse\") {\n      const w = (x2 - x1) / 2;\n      const h = (y2 - y1) / 2;\n      const cos = Math.cos(element.angle);\n      const sin = Math.sin(element.angle);\n      const ww = Math.hypot(w * cos, h * sin);\n      const hh = Math.hypot(h * cos, w * sin);\n      bounds = [cx - ww, cy - hh, cx + ww, cy + hh];\n    } else {\n      const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n      const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n      const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n      const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n      const minX = Math.min(x11, x12, x22, x21);\n      const minY = Math.min(y11, y12, y22, y21);\n      const maxX = Math.max(x11, x12, x22, x21);\n      const maxY = Math.max(y11, y12, y22, y21);\n      bounds = [minX, minY, maxX, maxY];\n    }\n\n    return bounds;\n  }\n}\n\n// Scene -> Scene coords, but in x1,x2,y1,y2 format.\n//\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport const getElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  includeBoundText: boolean = false,\n): [number, number, number, number, number, number] => {\n  if (isFreeDrawElement(element)) {\n    return getFreeDrawElementAbsoluteCoords(element);\n  } else if (isLinearElement(element)) {\n    return LinearElementEditor.getElementAbsoluteCoords(\n      element,\n      includeBoundText,\n    );\n  } else if (isTextElement(element)) {\n    const container = getContainerElement(element);\n    if (isArrowElement(container)) {\n      const coords = LinearElementEditor.getBoundTextElementPosition(\n        container,\n        element as ExcalidrawTextElementWithContainer,\n      );\n      return [\n        coords.x,\n        coords.y,\n        coords.x + element.width,\n        coords.y + element.height,\n        coords.x + element.width / 2,\n        coords.y + element.height / 2,\n      ];\n    }\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n    element.x + element.width / 2,\n    element.y + element.height / 2,\n  ];\n};\n\n/**\n * for a given element, `getElementLineSegments` returns line segments\n * that can be used for visual collision detection (useful for frames)\n * as opposed to bounding box collision detection\n */\nexport const getElementLineSegments = (\n  element: ExcalidrawElement,\n): [Point, Point][] => {\n  const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(element);\n\n  const center: Point = [cx, cy];\n\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    const segments: [Point, Point][] = [];\n\n    let i = 0;\n\n    while (i < element.points.length - 1) {\n      segments.push([\n        rotatePoint(\n          [\n            element.points[i][0] + element.x,\n            element.points[i][1] + element.y,\n          ] as Point,\n          center,\n          element.angle,\n        ),\n        rotatePoint(\n          [\n            element.points[i + 1][0] + element.x,\n            element.points[i + 1][1] + element.y,\n          ] as Point,\n          center,\n          element.angle,\n        ),\n      ]);\n      i++;\n    }\n\n    return segments;\n  }\n\n  const [nw, ne, sw, se, n, s, w, e] = (\n    [\n      [x1, y1],\n      [x2, y1],\n      [x1, y2],\n      [x2, y2],\n      [cx, y1],\n      [cx, y2],\n      [x1, cy],\n      [x2, cy],\n    ] as Point[]\n  ).map((point) => rotatePoint(point, center, element.angle));\n\n  if (element.type === \"diamond\") {\n    return [\n      [n, w],\n      [n, e],\n      [s, w],\n      [s, e],\n    ];\n  }\n\n  if (element.type === \"ellipse\") {\n    return [\n      [n, w],\n      [n, e],\n      [s, w],\n      [s, e],\n      [n, w],\n      [n, e],\n      [s, w],\n      [s, e],\n    ];\n  }\n\n  return [\n    [nw, ne],\n    [sw, se],\n    [nw, sw],\n    [ne, se],\n    [nw, e],\n    [sw, e],\n    [ne, w],\n    [se, w],\n  ];\n};\n\n/**\n * Scene -> Scene coords, but in x1,x2,y1,y2 format.\n *\n * Rectangle here means any rectangular frame, not an excalidraw element.\n */\nexport const getRectangleBoxAbsoluteCoords = (boxSceneCoords: RectangleBox) => {\n  return [\n    boxSceneCoords.x,\n    boxSceneCoords.y,\n    boxSceneCoords.x + boxSceneCoords.width,\n    boxSceneCoords.y + boxSceneCoords.height,\n    boxSceneCoords.x + boxSceneCoords.width / 2,\n    boxSceneCoords.y + boxSceneCoords.height / 2,\n  ];\n};\n\nexport const pointRelativeTo = (\n  element: ExcalidrawElement,\n  absoluteCoords: Point,\n): Point => {\n  return [absoluteCoords[0] - element.x, absoluteCoords[1] - element.y];\n};\n\nexport const getDiamondPoints = (element: ExcalidrawElement) => {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = 0;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n};\n\nexport const getCurvePathOps = (shape: Drawable): Op[] => {\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n  return shape.sets[0].ops;\n};\n\n// reference: https://eliot-jones.com/2019/12/cubic-bezier-curve-bounding-boxes\nconst getBezierValueForT = (\n  t: number,\n  p0: number,\n  p1: number,\n  p2: number,\n  p3: number,\n) => {\n  const oneMinusT = 1 - t;\n  return (\n    Math.pow(oneMinusT, 3) * p0 +\n    3 * Math.pow(oneMinusT, 2) * t * p1 +\n    3 * oneMinusT * Math.pow(t, 2) * p2 +\n    Math.pow(t, 3) * p3\n  );\n};\n\nconst solveQuadratic = (\n  p0: number,\n  p1: number,\n  p2: number,\n  p3: number,\n): MaybeQuadraticSolution => {\n  const i = p1 - p0;\n  const j = p2 - p1;\n  const k = p3 - p2;\n\n  const a = 3 * i - 6 * j + 3 * k;\n  const b = 6 * j - 6 * i;\n  const c = 3 * i;\n\n  const sqrtPart = b * b - 4 * a * c;\n  const hasSolution = sqrtPart >= 0;\n\n  if (!hasSolution) {\n    return false;\n  }\n\n  let s1 = null;\n  let s2 = null;\n\n  let t1 = Infinity;\n  let t2 = Infinity;\n\n  if (a === 0) {\n    t1 = t2 = -c / b;\n  } else {\n    t1 = (-b + Math.sqrt(sqrtPart)) / (2 * a);\n    t2 = (-b - Math.sqrt(sqrtPart)) / (2 * a);\n  }\n\n  if (t1 >= 0 && t1 <= 1) {\n    s1 = getBezierValueForT(t1, p0, p1, p2, p3);\n  }\n\n  if (t2 >= 0 && t2 <= 1) {\n    s2 = getBezierValueForT(t2, p0, p1, p2, p3);\n  }\n\n  return [s1, s2];\n};\n\nconst getCubicBezierCurveBound = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  p3: Point,\n): Bounds => {\n  const solX = solveQuadratic(p0[0], p1[0], p2[0], p3[0]);\n  const solY = solveQuadratic(p0[1], p1[1], p2[1], p3[1]);\n\n  let minX = Math.min(p0[0], p3[0]);\n  let maxX = Math.max(p0[0], p3[0]);\n\n  if (solX) {\n    const xs = solX.filter((x) => x !== null) as number[];\n    minX = Math.min(minX, ...xs);\n    maxX = Math.max(maxX, ...xs);\n  }\n\n  let minY = Math.min(p0[1], p3[1]);\n  let maxY = Math.max(p0[1], p3[1]);\n  if (solY) {\n    const ys = solY.filter((y) => y !== null) as number[];\n    minY = Math.min(minY, ...ys);\n    maxY = Math.max(maxY, ...ys);\n  }\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getMinMaxXYFromCurvePathOps = (\n  ops: Op[],\n  transformXY?: (x: number, y: number) => [number, number],\n): [number, number, number, number] => {\n  let currentP: Point = [0, 0];\n\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        currentP = data as unknown as Point;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        const _p1 = [data[0], data[1]] as Point;\n        const _p2 = [data[2], data[3]] as Point;\n        const _p3 = [data[4], data[5]] as Point;\n\n        const p1 = transformXY ? transformXY(..._p1) : _p1;\n        const p2 = transformXY ? transformXY(..._p2) : _p2;\n        const p3 = transformXY ? transformXY(..._p3) : _p3;\n\n        const p0 = transformXY ? transformXY(...currentP) : currentP;\n        currentP = _p3;\n\n        const [minX, minY, maxX, maxY] = getCubicBezierCurveBound(\n          p0,\n          p1,\n          p2,\n          p3,\n        );\n\n        limits.minX = Math.min(limits.minX, minX);\n        limits.minY = Math.min(limits.minY, minY);\n\n        limits.maxX = Math.max(limits.maxX, maxX);\n        limits.maxY = Math.max(limits.maxY, maxY);\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n  return [minX, minY, maxX, maxY];\n};\n\nconst getBoundsFromPoints = (\n  points: ExcalidrawFreeDrawElement[\"points\"],\n): [number, number, number, number] => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (const [x, y] of points) {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getFreeDrawElementAbsoluteCoords = (\n  element: ExcalidrawFreeDrawElement,\n): [number, number, number, number, number, number] => {\n  const [minX, minY, maxX, maxY] = getBoundsFromPoints(element.points);\n  const x1 = minX + element.x;\n  const y1 = minY + element.y;\n  const x2 = maxX + element.x;\n  const y2 = maxY + element.y;\n  return [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2];\n};\n\nexport const getArrowheadPoints = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n  position: \"start\" | \"end\",\n  arrowhead: Arrowhead,\n) => {\n  const ops = getCurvePathOps(shape[0]);\n  if (ops.length < 1) {\n    return null;\n  }\n\n  // The index of the bCurve operation to examine.\n  const index = position === \"start\" ? 1 : ops.length - 1;\n\n  const data = ops[index].data;\n  const p3 = [data[4], data[5]] as Point;\n  const p2 = [data[2], data[3]] as Point;\n  const p1 = [data[0], data[1]] as Point;\n\n  // We need to find p0 of the bezier curve.\n  // It is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation.\n  const prevOp = ops[index - 1];\n  let p0: Point = [0, 0];\n  if (prevOp.op === \"move\") {\n    p0 = prevOp.data as unknown as Point;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // Ee know the last point of the arrow (or the first, if start arrowhead).\n  const [x2, y2] = position === \"start\" ? p0 : p3;\n\n  // By using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point.\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases.\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // Find the normalized direction vector based on the\n  // previously calculated points.\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n\n  const size = {\n    arrow: 30,\n    bar: 15,\n    dot: 15,\n    triangle: 15,\n  }[arrowhead]; // pixels (will differ for each arrowhead)\n\n  let length = 0;\n\n  if (arrowhead === \"arrow\") {\n    // Length for -> arrows is based on the length of the last section\n    const [cx, cy] = element.points[element.points.length - 1];\n    const [px, py] =\n      element.points.length > 1\n        ? element.points[element.points.length - 2]\n        : [0, 0];\n\n    length = Math.hypot(cx - px, cy - py);\n  } else {\n    // Length for other arrowhead types is based on the total length of the line\n    for (let i = 0; i < element.points.length; i++) {\n      const [px, py] = element.points[i - 1] || [0, 0];\n      const [cx, cy] = element.points[i];\n      length += Math.hypot(cx - px, cy - py);\n    }\n  }\n\n  // Scale down the arrowhead until we hit a certain size so that it doesn't look weird.\n  // This value is selected by minimizing a minimum size with the last segment of the arrowhead\n  const minSize = Math.min(size, length / 2);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  if (arrowhead === \"dot\") {\n    const r = Math.hypot(ys - y2, xs - x2) + element.strokeWidth;\n    return [x2, y2, r];\n  }\n\n  const angle = {\n    arrow: 20,\n    bar: 90,\n    triangle: 25,\n  }[arrowhead]; // degrees\n\n  // Return points\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n  return [x2, y2, x3, y3, x4, y4];\n};\n\nconst generateLinearElementShape = (\n  element: ExcalidrawLinearElement,\n): Drawable => {\n  const generator = rough.generator();\n  const options = generateRoughOptions(element);\n\n  const method = (() => {\n    if (element.roundness) {\n      return \"curve\";\n    }\n    if (options.fill) {\n      return \"polygon\";\n    }\n    return \"linearPath\";\n  })();\n\n  return generator[method](element.points as Mutable<Point>[], options);\n};\n\nconst getLinearElementRotatedBounds = (\n  element: ExcalidrawLinearElement,\n  cx: number,\n  cy: number,\n): [number, number, number, number] => {\n  if (element.points.length < 2) {\n    const [pointX, pointY] = element.points[0];\n    const [x, y] = rotate(\n      element.x + pointX,\n      element.y + pointY,\n      cx,\n      cy,\n      element.angle,\n    );\n\n    let coords: [number, number, number, number] = [x, y, x, y];\n    const boundTextElement = getBoundTextElement(element);\n    if (boundTextElement) {\n      const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(\n        element,\n        [x, y, x, y],\n        boundTextElement,\n      );\n      coords = [\n        coordsWithBoundText[0],\n        coordsWithBoundText[1],\n        coordsWithBoundText[2],\n        coordsWithBoundText[3],\n      ];\n    }\n    return coords;\n  }\n\n  // first element is always the curve\n  const cachedShape = getShapeForElement(element)?.[0];\n  const shape = cachedShape ?? generateLinearElementShape(element);\n  const ops = getCurvePathOps(shape);\n  const transformXY = (x: number, y: number) =>\n    rotate(element.x + x, element.y + y, cx, cy, element.angle);\n  const res = getMinMaxXYFromCurvePathOps(ops, transformXY);\n  let coords: [number, number, number, number] = [\n    res[0],\n    res[1],\n    res[2],\n    res[3],\n  ];\n  const boundTextElement = getBoundTextElement(element);\n  if (boundTextElement) {\n    const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(\n      element,\n      coords,\n      boundTextElement,\n    );\n    coords = [\n      coordsWithBoundText[0],\n      coordsWithBoundText[1],\n      coordsWithBoundText[2],\n      coordsWithBoundText[3],\n    ];\n  }\n  return coords;\n};\n\nexport const getElementBounds = (element: ExcalidrawElement): Bounds => {\n  return ElementBounds.getBounds(element);\n};\nexport const getCommonBounds = (\n  elements: readonly ExcalidrawElement[],\n): Bounds => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getResizedElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  nextWidth: number,\n  nextHeight: number,\n  normalizePoints: boolean,\n): [number, number, number, number] => {\n  if (!(isLinearElement(element) || isFreeDrawElement(element))) {\n    return [\n      element.x,\n      element.y,\n      element.x + nextWidth,\n      element.y + nextHeight,\n    ];\n  }\n\n  const points = rescalePoints(\n    0,\n    nextWidth,\n    rescalePoints(1, nextHeight, element.points, normalizePoints),\n    normalizePoints,\n  );\n\n  let bounds: [number, number, number, number];\n\n  if (isFreeDrawElement(element)) {\n    // Free Draw\n    bounds = getBoundsFromPoints(points);\n  } else {\n    // Line\n    const gen = rough.generator();\n    const curve = !element.roundness\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n\n    const ops = getCurvePathOps(curve);\n    bounds = getMinMaxXYFromCurvePathOps(ops);\n  }\n\n  const [minX, minY, maxX, maxY] = bounds;\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getElementPointsCoords = (\n  element: ExcalidrawLinearElement,\n  points: readonly (readonly [number, number])[],\n): [number, number, number, number] => {\n  // This might be computationally heavey\n  const gen = rough.generator();\n  const curve =\n    element.roundness == null\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getClosestElementBounds = (\n  elements: readonly ExcalidrawElement[],\n  from: { x: number; y: number },\n): Bounds => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minDistance = Infinity;\n  let closestElement = elements[0];\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    const distance = distance2d((x1 + x2) / 2, (y1 + y2) / 2, from.x, from.y);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElement = element;\n    }\n  });\n\n  return getElementBounds(closestElement);\n};\n\nexport interface BoundingBox {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n  midX: number;\n  midY: number;\n  width: number;\n  height: number;\n}\n\nexport const getCommonBoundingBox = (\n  elements: ExcalidrawElement[] | readonly NonDeleted<ExcalidrawElement>[],\n): BoundingBox => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n    midX: (minX + maxX) / 2,\n    midY: (minY + maxY) / 2,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}