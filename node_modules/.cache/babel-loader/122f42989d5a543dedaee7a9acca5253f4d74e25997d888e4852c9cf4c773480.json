{"ast":null,"code":"// libraries\n// -----------------------------------------------------------------------------\n/** @deprecated legacy: do not use outside of migration paths */ /** @deprecated legacy: do not use outside of migration paths */ /** v2 library item */ // -----------------------------------------------------------------------------\n// NOTE ready/readyPromise props are optional for host apps' sake (our own\n// implem guarantees existence)\nexport var UserIdleState=/*#__PURE__*/function(UserIdleState){UserIdleState[\"ACTIVE\"]=\"active\";UserIdleState[\"AWAY\"]=\"away\";UserIdleState[\"IDLE\"]=\"idle\";return UserIdleState;}({});// NOTE at the moment, if action name coressponds to canvasAction prop, its\n// truthiness value will determine whether the action is rendered or not\n// (see manager renderAction). We also override canvasAction values in\n// excalidraw package index.tsx.\n/** A subset of App class properties that we need to use elsewhere\n * in the app, eg Manager. Factored out into a separate type to keep DRY. */","map":{"version":3,"names":["UserIdleState"],"sources":["D:/project/excalidraw-cn/src/types.ts"],"sourcesContent":["import React from \"react\";\nimport {\n  PointerType,\n  ExcalidrawLinearElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  TextAlign,\n  ExcalidrawElement,\n  GroupId,\n  ExcalidrawBindableElement,\n  Arrowhead,\n  ChartType,\n  FontFamilyValues,\n  FileId,\n  ExcalidrawImageElement,\n  Theme,\n  StrokeRoundness,\n  ExcalidrawFrameElement,\n} from \"./element/types\";\nimport { SHAPES } from \"./shapes\";\nimport { Point as RoughPoint } from \"roughjs/bin/geometry\";\nimport { LinearElementEditor } from \"./element/linearElementEditor\";\nimport { SuggestedBinding } from \"./element/binding\";\nimport { ImportedDataState } from \"./data/types\";\nimport type App from \"./components/App\";\nimport type { ResolvablePromise, throttleRAF } from \"./utils\";\nimport { Spreadsheet } from \"./charts\";\nimport { Language } from \"./i18n\";\nimport { ClipboardData } from \"./clipboard\";\nimport { isOverScrollBars } from \"./scene\";\nimport { MaybeTransformHandleType } from \"./element/transformHandles\";\nimport Library from \"./data/library\";\nimport type { FileSystemHandle } from \"./data/filesystem\";\nimport type { IMAGE_MIME_TYPES, MIME_TYPES } from \"./constants\";\nimport { ContextMenuItems } from \"./components/ContextMenu\";\nimport { Merge, ForwardRef, ValueOf } from \"./utility-types\";\n\nexport type Point = Readonly<RoughPoint>;\n\nexport type Collaborator = {\n  pointer?: {\n    x: number;\n    y: number;\n  };\n  button?: \"up\" | \"down\";\n  selectedElementIds?: AppState[\"selectedElementIds\"];\n  username?: string | null;\n  userState?: UserIdleState;\n  color?: {\n    background: string;\n    stroke: string;\n  };\n  // The url of the collaborator's avatar, defaults to username intials\n  // if not present\n  avatarUrl?: string;\n  // user id. If supplied, we'll filter out duplicates when rendering user avatars.\n  id?: string;\n};\n\nexport type DataURL = string & { _brand: \"DataURL\" };\n\nexport type BinaryFileData = {\n  mimeType:\n    | ValueOf<typeof IMAGE_MIME_TYPES>\n    // future user or unknown file type\n    | typeof MIME_TYPES.binary;\n  id: FileId;\n  dataURL: DataURL;\n  /**\n   * Epoch timestamp in milliseconds\n   */\n  created: number;\n  /**\n   * Indicates when the file was last retrieved from storage to be loaded\n   * onto the scene. We use this flag to determine whether to delete unused\n   * files from storage.\n   *\n   * Epoch timestamp in milliseconds.\n   */\n  lastRetrieved?: number;\n};\n\nexport type BinaryFileMetadata = Omit<BinaryFileData, \"dataURL\">;\n\nexport type BinaryFiles = Record<ExcalidrawElement[\"id\"], BinaryFileData>;\n\nexport type LastActiveTool =\n  | {\n      type: typeof SHAPES[number][\"value\"] | \"eraser\" | \"hand\" | \"frame\";\n      customType: null;\n    }\n  | {\n      type: \"custom\";\n      customType: string;\n    }\n  | null;\n\nexport type SidebarName = string;\nexport type SidebarTabName = string;\n\nexport type AppState = {\n  contextMenu: {\n    items: ContextMenuItems;\n    top: number;\n    left: number;\n  } | null;\n  showWelcomeScreen: boolean;\n  isLoading: boolean;\n  errorMessage: React.ReactNode;\n  draggingElement: NonDeletedExcalidrawElement | null;\n  resizingElement: NonDeletedExcalidrawElement | null;\n  multiElement: NonDeleted<ExcalidrawLinearElement> | null;\n  selectionElement: NonDeletedExcalidrawElement | null;\n  isBindingEnabled: boolean;\n  startBoundElement: NonDeleted<ExcalidrawBindableElement> | null;\n  suggestedBindings: SuggestedBinding[];\n  frameToHighlight: NonDeleted<ExcalidrawFrameElement> | null;\n  frameRendering: {\n    enabled: boolean;\n    name: boolean;\n    outline: boolean;\n    clip: boolean;\n  };\n  editingFrame: string | null;\n  elementsToHighlight: NonDeleted<ExcalidrawElement>[] | null;\n  // element being edited, but not necessarily added to elements array yet\n  // (e.g. text element when typing into the input)\n  editingElement: NonDeletedExcalidrawElement | null;\n  editingLinearElement: LinearElementEditor | null;\n  activeTool: {\n    /**\n     * indicates a previous tool we should revert back to if we deselect the\n     * currently active tool. At the moment applies to `eraser` and `hand` tool.\n     */\n    lastActiveTool: LastActiveTool;\n    locked: boolean;\n  } & (\n    | {\n        type: typeof SHAPES[number][\"value\"] | \"eraser\" | \"hand\" | \"frame\";\n        customType: null;\n      }\n    | {\n        type: \"custom\";\n        customType: string;\n      }\n  );\n  penMode: boolean;\n  penDetected: boolean;\n  exportBackground: boolean;\n  exportEmbedScene: boolean;\n  exportWithDarkMode: boolean;\n  exportScale: number;\n  currentItemStrokeColor: string;\n  currentItemBackgroundColor: string;\n  currentItemFillStyle: ExcalidrawElement[\"fillStyle\"];\n  currentItemStrokeWidth: number;\n  currentItemStrokeStyle: ExcalidrawElement[\"strokeStyle\"];\n  currentItemRoughness: number;\n  currentItemOpacity: number;\n  currentItemFontFamily: FontFamilyValues;\n  currentItemFontSize: number;\n  currentItemTextAlign: TextAlign;\n  currentItemStartArrowhead: Arrowhead | null;\n  currentItemEndArrowhead: Arrowhead | null;\n  currentItemRoundness: StrokeRoundness;\n  viewBackgroundColor: string;\n  scrollX: number;\n  scrollY: number;\n  cursorButton: \"up\" | \"down\";\n  scrolledOutside: boolean;\n  name: string;\n  isResizing: boolean;\n  isRotating: boolean;\n  zoom: Zoom;\n  openMenu: \"canvas\" | \"shape\" | null;\n  openPopup: \"canvasBackground\" | \"elementBackground\" | \"elementStroke\" | null;\n  openSidebar: { name: SidebarName; tab?: SidebarTabName } | null;\n  openDialog: \"imageExport\" | \"help\" | \"jsonExport\" | null;\n  /**\n   * Reflects user preference for whether the default sidebar should be docked.\n   *\n   * NOTE this is only a user preference and does not reflect the actual docked\n   * state of the sidebar, because the host apps can override this through\n   * a DefaultSidebar prop, which is not reflected back to the appState.\n   */\n  defaultSidebarDockedPreference: boolean;\n\n  lastPointerDownWith: PointerType;\n  selectedElementIds: Readonly<{ [id: string]: true }>;\n  previousSelectedElementIds: { [id: string]: true };\n  selectedElementsAreBeingDragged: boolean;\n  shouldCacheIgnoreZoom: boolean;\n  toast: { message: string; closable?: boolean; duration?: number } | null;\n  zenModeEnabled: boolean;\n  theme: Theme;\n  gridSize: number | null;\n  viewModeEnabled: boolean;\n\n  /** top-most selected groups (i.e. does not include nested groups) */\n  selectedGroupIds: { [groupId: string]: boolean };\n  /** group being edited when you drill down to its constituent element\n    (e.g. when you double-click on a group's element) */\n  editingGroupId: GroupId | null;\n  width: number;\n  height: number;\n  offsetTop: number;\n  offsetLeft: number;\n\n  fileHandle: FileSystemHandle | null;\n  collaborators: Map<string, Collaborator>;\n  showStats: boolean;\n  currentChartType: ChartType;\n  pasteDialog:\n    | {\n        shown: false;\n        data: null;\n      }\n    | {\n        shown: true;\n        data: Spreadsheet;\n      };\n  /** imageElement waiting to be placed on canvas */\n  pendingImageElementId: ExcalidrawImageElement[\"id\"] | null;\n  showHyperlinkPopup: false | \"info\" | \"editor\";\n  selectedLinearElement: LinearElementEditor | null;\n};\n\nexport type UIAppState = Omit<\n  AppState,\n  | \"suggestedBindings\"\n  | \"startBoundElement\"\n  | \"cursorButton\"\n  | \"scrollX\"\n  | \"scrollY\"\n>;\n\nexport type NormalizedZoomValue = number & { _brand: \"normalizedZoom\" };\n\nexport type Zoom = Readonly<{\n  value: NormalizedZoomValue;\n}>;\n\nexport type PointerCoords = Readonly<{\n  x: number;\n  y: number;\n}>;\n\nexport type Gesture = {\n  pointers: Map<number, PointerCoords>;\n  lastCenter: { x: number; y: number } | null;\n  initialDistance: number | null;\n  initialScale: number | null;\n};\n\nexport declare class GestureEvent extends UIEvent {\n  readonly rotation: number;\n  readonly scale: number;\n}\n\n// libraries\n// -----------------------------------------------------------------------------\n/** @deprecated legacy: do not use outside of migration paths */\nexport type LibraryItem_v1 = readonly NonDeleted<ExcalidrawElement>[];\n/** @deprecated legacy: do not use outside of migration paths */\ntype LibraryItems_v1 = readonly LibraryItem_v1[];\n\n/** v2 library item */\nexport type LibraryItem = {\n  id: string;\n  status: \"published\" | \"unpublished\";\n  elements: readonly NonDeleted<ExcalidrawElement>[];\n  /** timestamp in epoch (ms) */\n  created: number;\n  name?: string;\n  error?: string;\n};\nexport type LibraryItems = readonly LibraryItem[];\nexport type LibraryItems_anyVersion = LibraryItems | LibraryItems_v1;\n\nexport type LibraryItemsSource =\n  | ((\n      currentLibraryItems: LibraryItems,\n    ) =>\n      | Blob\n      | LibraryItems_anyVersion\n      | Promise<LibraryItems_anyVersion | Blob>)\n  | Blob\n  | LibraryItems_anyVersion\n  | Promise<LibraryItems_anyVersion | Blob>;\n// -----------------------------------------------------------------------------\n\n// NOTE ready/readyPromise props are optional for host apps' sake (our own\n// implem guarantees existence)\nexport type ExcalidrawAPIRefValue =\n  | ExcalidrawImperativeAPI\n  | {\n      readyPromise?: ResolvablePromise<ExcalidrawImperativeAPI>;\n      ready?: false;\n    };\n\nexport type ExcalidrawInitialDataState = Merge<\n  ImportedDataState,\n  {\n    libraryItems?:\n      | Required<ImportedDataState>[\"libraryItems\"]\n      | Promise<Required<ImportedDataState>[\"libraryItems\"]>;\n  }\n>;\n\nexport interface ExcalidrawProps {\n  onChange?: (\n    elements: readonly ExcalidrawElement[],\n    appState: AppState,\n    files: BinaryFiles,\n  ) => void;\n  initialData?:\n    | ExcalidrawInitialDataState\n    | null\n    | Promise<ExcalidrawInitialDataState | null>;\n  excalidrawRef?: ForwardRef<ExcalidrawAPIRefValue>;\n  isCollaborating?: boolean;\n  onPointerUpdate?: (payload: {\n    pointer: { x: number; y: number };\n    button: \"down\" | \"up\";\n    pointersMap: Gesture[\"pointers\"];\n  }) => void;\n  onPaste?: (\n    data: ClipboardData,\n    event: ClipboardEvent | null,\n  ) => Promise<boolean> | boolean;\n  renderTopRightUI?: (\n    isMobile: boolean,\n    appState: UIAppState,\n  ) => JSX.Element | null;\n  langCode?: Language[\"code\"];\n  viewModeEnabled?: boolean;\n  zenModeEnabled?: boolean;\n  gridModeEnabled?: boolean;\n  libraryReturnUrl?: string;\n  theme?: Theme;\n  name?: string;\n  renderCustomStats?: (\n    elements: readonly NonDeletedExcalidrawElement[],\n    appState: UIAppState,\n  ) => JSX.Element;\n  UIOptions?: Partial<UIOptions>;\n  detectScroll?: boolean;\n  handleKeyboardGlobally?: boolean;\n  onLibraryChange?: (libraryItems: LibraryItems) => void | Promise<any>;\n  autoFocus?: boolean;\n  generateIdForFile?: (file: File) => string | Promise<string>;\n  onLinkOpen?: (\n    element: NonDeletedExcalidrawElement,\n    event: CustomEvent<{\n      nativeEvent: MouseEvent | React.PointerEvent<HTMLCanvasElement>;\n    }>,\n  ) => void;\n  onPointerDown?: (\n    activeTool: AppState[\"activeTool\"],\n    pointerDownState: PointerDownState,\n  ) => void;\n  onScrollChange?: (scrollX: number, scrollY: number) => void;\n  children?: React.ReactNode;\n}\n\nexport type SceneData = {\n  elements?: ImportedDataState[\"elements\"];\n  appState?: ImportedDataState[\"appState\"];\n  collaborators?: Map<string, Collaborator>;\n  commitToHistory?: boolean;\n};\n\nexport enum UserIdleState {\n  ACTIVE = \"active\",\n  AWAY = \"away\",\n  IDLE = \"idle\",\n}\n\nexport type ExportOpts = {\n  saveFileToDisk?: boolean;\n  onExportToBackend?: (\n    exportedElements: readonly NonDeletedExcalidrawElement[],\n    appState: UIAppState,\n    files: BinaryFiles,\n    canvas: HTMLCanvasElement | null,\n  ) => void;\n  renderCustomUI?: (\n    exportedElements: readonly NonDeletedExcalidrawElement[],\n    appState: UIAppState,\n    files: BinaryFiles,\n    canvas: HTMLCanvasElement | null,\n  ) => JSX.Element;\n};\n\n// NOTE at the moment, if action name coressponds to canvasAction prop, its\n// truthiness value will determine whether the action is rendered or not\n// (see manager renderAction). We also override canvasAction values in\n// excalidraw package index.tsx.\ntype CanvasActions = Partial<{\n  changeViewBackgroundColor: boolean;\n  clearCanvas: boolean;\n  export: false | ExportOpts;\n  loadScene: boolean;\n  saveToActiveFile: boolean;\n  toggleTheme: boolean | null;\n  saveAsImage: boolean;\n}>;\n\ntype UIOptions = Partial<{\n  dockedSidebarBreakpoint: number;\n  canvasActions: CanvasActions;\n  /** @deprecated does nothing. Will be removed in 0.15 */\n  welcomeScreen?: boolean;\n}>;\n\nexport type AppProps = Merge<\n  ExcalidrawProps,\n  {\n    UIOptions: Merge<\n      UIOptions,\n      {\n        canvasActions: Required<CanvasActions> & { export: ExportOpts };\n      }\n    >;\n    detectScroll: boolean;\n    handleKeyboardGlobally: boolean;\n    isCollaborating: boolean;\n    children?: React.ReactNode;\n  }\n>;\n\n/** A subset of App class properties that we need to use elsewhere\n * in the app, eg Manager. Factored out into a separate type to keep DRY. */\nexport type AppClassProperties = {\n  props: AppProps;\n  canvas: HTMLCanvasElement | null;\n  focusContainer(): void;\n  library: Library;\n  imageCache: Map<\n    FileId,\n    {\n      image: HTMLImageElement | Promise<HTMLImageElement>;\n      mimeType: ValueOf<typeof IMAGE_MIME_TYPES>;\n    }\n  >;\n  files: BinaryFiles;\n  device: App[\"device\"];\n  scene: App[\"scene\"];\n  pasteFromClipboard: App[\"pasteFromClipboard\"];\n  id: App[\"id\"];\n  onInsertElements: App[\"onInsertElements\"];\n  onExportImage: App[\"onExportImage\"];\n  lastViewportPosition: App[\"lastViewportPosition\"];\n};\n\nexport type PointerDownState = Readonly<{\n  // The first position at which pointerDown happened\n  origin: Readonly<{ x: number; y: number }>;\n  // Same as \"origin\" but snapped to the grid, if grid is on\n  originInGrid: Readonly<{ x: number; y: number }>;\n  // Scrollbar checks\n  scrollbars: ReturnType<typeof isOverScrollBars>;\n  // The previous pointer position\n  lastCoords: { x: number; y: number };\n  // map of original elements data\n  originalElements: Map<string, NonDeleted<ExcalidrawElement>>;\n  resize: {\n    // Handle when resizing, might change during the pointer interaction\n    handleType: MaybeTransformHandleType;\n    // This is determined on the initial pointer down event\n    isResizing: boolean;\n    // This is determined on the initial pointer down event\n    offset: { x: number; y: number };\n    // This is determined on the initial pointer down event\n    arrowDirection: \"origin\" | \"end\";\n    // This is a center point of selected elements determined on the initial pointer down event (for rotation only)\n    center: { x: number; y: number };\n  };\n  hit: {\n    // The element the pointer is \"hitting\", is determined on the initial\n    // pointer down event\n    element: NonDeleted<ExcalidrawElement> | null;\n    // The elements the pointer is \"hitting\", is determined on the initial\n    // pointer down event\n    allHitElements: NonDeleted<ExcalidrawElement>[];\n    // This is determined on the initial pointer down event\n    wasAddedToSelection: boolean;\n    // Whether selected element(s) were duplicated, might change during the\n    // pointer interaction\n    hasBeenDuplicated: boolean;\n    hasHitCommonBoundingBoxOfSelectedElements: boolean;\n  };\n  withCmdOrCtrl: boolean;\n  drag: {\n    // Might change during the pointer interaction\n    hasOccurred: boolean;\n    // Might change during the pointer interaction\n    offset: { x: number; y: number } | null;\n  };\n  // We need to have these in the state so that we can unsubscribe them\n  eventListeners: {\n    // It's defined on the initial pointer down event\n    onMove: null | ReturnType<typeof throttleRAF>;\n    // It's defined on the initial pointer down event\n    onUp: null | ((event: PointerEvent) => void);\n    // It's defined on the initial pointer down event\n    onKeyDown: null | ((event: KeyboardEvent) => void);\n    // It's defined on the initial pointer down event\n    onKeyUp: null | ((event: KeyboardEvent) => void);\n  };\n  boxSelection: {\n    hasOccurred: boolean;\n  };\n  elementIdsToErase: {\n    [key: ExcalidrawElement[\"id\"]]: {\n      opacity: ExcalidrawElement[\"opacity\"];\n      erase: boolean;\n    };\n  };\n}>;\n\nexport type ExcalidrawImperativeAPI = {\n  updateScene: InstanceType<typeof App>[\"updateScene\"];\n  updateLibrary: InstanceType<typeof Library>[\"updateLibrary\"];\n  resetScene: InstanceType<typeof App>[\"resetScene\"];\n  getSceneElementsIncludingDeleted: InstanceType<\n    typeof App\n  >[\"getSceneElementsIncludingDeleted\"];\n  history: {\n    clear: InstanceType<typeof App>[\"resetHistory\"];\n  };\n  scrollToContent: InstanceType<typeof App>[\"scrollToContent\"];\n  getSceneElements: InstanceType<typeof App>[\"getSceneElements\"];\n  getAppState: () => InstanceType<typeof App>[\"state\"];\n  getFiles: () => InstanceType<typeof App>[\"files\"];\n  refresh: InstanceType<typeof App>[\"refresh\"];\n  setToast: InstanceType<typeof App>[\"setToast\"];\n  addFiles: (data: BinaryFileData[]) => void;\n  readyPromise: ResolvablePromise<ExcalidrawImperativeAPI>;\n  ready: true;\n  id: string;\n  setActiveTool: InstanceType<typeof App>[\"setActiveTool\"];\n  setCursor: InstanceType<typeof App>[\"setCursor\"];\n  resetCursor: InstanceType<typeof App>[\"resetCursor\"];\n  toggleSidebar: InstanceType<typeof App>[\"toggleSidebar\"];\n  /**\n   * Disables rendering of frames (including element clipping), but currently\n   * the frames are still interactive in edit mode. As such, this API should be\n   * used in conjunction with view mode (props.viewModeEnabled).\n   */\n  updateFrameRendering: InstanceType<typeof App>[\"updateFrameRendering\"];\n};\n\nexport type Device = Readonly<{\n  isSmScreen: boolean;\n  isMobile: boolean;\n  isTouchScreen: boolean;\n  canDeviceFitSidebar: boolean;\n  isLandscape: boolean;\n}>;\n\ntype FrameNameBounds = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  angle: number;\n};\n\nexport type FrameNameBoundsCache = {\n  get: (frameElement: ExcalidrawFrameElement) => FrameNameBounds | null;\n  _cache: Map<\n    string,\n    FrameNameBounds & {\n      zoom: AppState[\"zoom\"][\"value\"];\n      versionNonce: ExcalidrawFrameElement[\"versionNonce\"];\n    }\n  >;\n};\n"],"mappings":"AAmQA;AACA;AACA,iEAEA,iEAGA,uBAuBA;AAEA;AACA;AAgFA,UAAY,CAAAA,aAAa,uBAAbA,aAAa,EAAbA,aAAa,oBAAbA,aAAa,gBAAbA,aAAa,sBAAb,CAAAA,aAAa,OAsBzB;AACA;AACA;AACA;AAkCA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}