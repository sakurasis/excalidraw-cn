{"ast":null,"code":"import decodePng from \"png-chunks-extract\";\nimport tEXt from \"png-chunk-text\";\nimport encodePng from \"png-chunks-encode\";\nimport { stringToBase64, encode, decode, base64ToString } from \"./encode\";\nimport { EXPORT_DATA_TYPES, MIME_TYPES } from \"../constants\";\nimport { blobToArrayBuffer } from \"./blob\";\n\n// -----------------------------------------------------------------------------\n// PNG\n// -----------------------------------------------------------------------------\n\nexport const getTEXtChunk = async blob => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n  const metadataChunk = chunks.find(chunk => chunk.name === \"tEXt\");\n  if (metadataChunk) {\n    return tEXt.decode(metadataChunk.data);\n  }\n  return null;\n};\nexport const encodePngMetadata = async _ref => {\n  let {\n    blob,\n    metadata\n  } = _ref;\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n  const metadataChunk = tEXt.encode(MIME_TYPES.excalidraw, JSON.stringify(await encode({\n    text: metadata,\n    compress: true\n  })));\n  // insert metadata before last chunk (iEND)\n  chunks.splice(-1, 0, metadataChunk);\n  return new Blob([encodePng(chunks)], {\n    type: MIME_TYPES.png\n  });\n};\nexport const decodePngMetadata = async blob => {\n  const metadata = await getTEXtChunk(blob);\n  if ((metadata === null || metadata === void 0 ? void 0 : metadata.keyword) === MIME_TYPES.excalidraw) {\n    try {\n      const encodedData = JSON.parse(metadata.text);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\"type\" in encodedData && encodedData.type === EXPORT_DATA_TYPES.excalidraw) {\n          return metadata.text;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return await decode(encodedData);\n    } catch (error) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};\n\n// -----------------------------------------------------------------------------\n// SVG\n// -----------------------------------------------------------------------------\n\nexport const encodeSvgMetadata = async _ref2 => {\n  let {\n    text\n  } = _ref2;\n  const base64 = await stringToBase64(JSON.stringify(await encode({\n    text\n  })), true /* is already byte string */);\n\n  let metadata = \"\";\n  metadata += `<!-- payload-type:${MIME_TYPES.excalidraw} -->`;\n  metadata += `<!-- payload-version:2 -->`;\n  metadata += \"<!-- payload-start -->\";\n  metadata += base64;\n  metadata += \"<!-- payload-end -->\";\n  return metadata;\n};\nexport const decodeSvgMetadata = async _ref3 => {\n  let {\n    svg\n  } = _ref3;\n  if (svg.includes(`payload-type:${MIME_TYPES.excalidraw}`)) {\n    const match = svg.match(/<!-- payload-start -->\\s*(.+?)\\s*<!-- payload-end -->/);\n    if (!match) {\n      throw new Error(\"INVALID\");\n    }\n    const versionMatch = svg.match(/<!-- payload-version:(\\d+) -->/);\n    const version = (versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch[1]) || \"1\";\n    const isByteString = version !== \"1\";\n    try {\n      const json = await base64ToString(match[1], isByteString);\n      const encodedData = JSON.parse(json);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\"type\" in encodedData && encodedData.type === EXPORT_DATA_TYPES.excalidraw) {\n          return json;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return await decode(encodedData);\n    } catch (error) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};","map":{"version":3,"names":["decodePng","tEXt","encodePng","stringToBase64","encode","decode","base64ToString","EXPORT_DATA_TYPES","MIME_TYPES","blobToArrayBuffer","getTEXtChunk","blob","chunks","Uint8Array","metadataChunk","find","chunk","name","data","encodePngMetadata","_ref","metadata","excalidraw","JSON","stringify","text","compress","splice","Blob","type","png","decodePngMetadata","keyword","encodedData","parse","Error","error","console","encodeSvgMetadata","_ref2","base64","decodeSvgMetadata","_ref3","svg","includes","match","versionMatch","version","isByteString","json"],"sources":["D:/project/excalidraw-cn/src/data/image.ts"],"sourcesContent":["import decodePng from \"png-chunks-extract\";\nimport tEXt from \"png-chunk-text\";\nimport encodePng from \"png-chunks-encode\";\nimport { stringToBase64, encode, decode, base64ToString } from \"./encode\";\nimport { EXPORT_DATA_TYPES, MIME_TYPES } from \"../constants\";\nimport { blobToArrayBuffer } from \"./blob\";\n\n// -----------------------------------------------------------------------------\n// PNG\n// -----------------------------------------------------------------------------\n\nexport const getTEXtChunk = async (\n  blob: Blob,\n): Promise<{ keyword: string; text: string } | null> => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n  const metadataChunk = chunks.find((chunk) => chunk.name === \"tEXt\");\n  if (metadataChunk) {\n    return tEXt.decode(metadataChunk.data);\n  }\n  return null;\n};\n\nexport const encodePngMetadata = async ({\n  blob,\n  metadata,\n}: {\n  blob: Blob;\n  metadata: string;\n}) => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n\n  const metadataChunk = tEXt.encode(\n    MIME_TYPES.excalidraw,\n    JSON.stringify(\n      await encode({\n        text: metadata,\n        compress: true,\n      }),\n    ),\n  );\n  // insert metadata before last chunk (iEND)\n  chunks.splice(-1, 0, metadataChunk);\n\n  return new Blob([encodePng(chunks)], { type: MIME_TYPES.png });\n};\n\nexport const decodePngMetadata = async (blob: Blob) => {\n  const metadata = await getTEXtChunk(blob);\n  if (metadata?.keyword === MIME_TYPES.excalidraw) {\n    try {\n      const encodedData = JSON.parse(metadata.text);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\n          \"type\" in encodedData &&\n          encodedData.type === EXPORT_DATA_TYPES.excalidraw\n        ) {\n          return metadata.text;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return await decode(encodedData);\n    } catch (error: any) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};\n\n// -----------------------------------------------------------------------------\n// SVG\n// -----------------------------------------------------------------------------\n\nexport const encodeSvgMetadata = async ({ text }: { text: string }) => {\n  const base64 = await stringToBase64(\n    JSON.stringify(await encode({ text })),\n    true /* is already byte string */,\n  );\n\n  let metadata = \"\";\n  metadata += `<!-- payload-type:${MIME_TYPES.excalidraw} -->`;\n  metadata += `<!-- payload-version:2 -->`;\n  metadata += \"<!-- payload-start -->\";\n  metadata += base64;\n  metadata += \"<!-- payload-end -->\";\n  return metadata;\n};\n\nexport const decodeSvgMetadata = async ({ svg }: { svg: string }) => {\n  if (svg.includes(`payload-type:${MIME_TYPES.excalidraw}`)) {\n    const match = svg.match(\n      /<!-- payload-start -->\\s*(.+?)\\s*<!-- payload-end -->/,\n    );\n    if (!match) {\n      throw new Error(\"INVALID\");\n    }\n    const versionMatch = svg.match(/<!-- payload-version:(\\d+) -->/);\n    const version = versionMatch?.[1] || \"1\";\n    const isByteString = version !== \"1\";\n\n    try {\n      const json = await base64ToString(match[1], isByteString);\n      const encodedData = JSON.parse(json);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\n          \"type\" in encodedData &&\n          encodedData.type === EXPORT_DATA_TYPES.excalidraw\n        ) {\n          return json;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return await decode(encodedData);\n    } catch (error: any) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}