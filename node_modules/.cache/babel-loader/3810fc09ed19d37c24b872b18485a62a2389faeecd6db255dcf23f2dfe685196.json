{"ast":null,"code":"import { PRECEDING_ELEMENT_KEY } from \"../../constants\";\nimport { arrayToMapWithIndex } from \"../../utils\";\nconst shouldDiscardRemoteElement = (localAppState, local, remote) => {\n  var _localAppState$editin, _localAppState$resizi, _localAppState$draggi;\n  if (local && (\n  // local element is being edited\n  local.id === ((_localAppState$editin = localAppState.editingElement) === null || _localAppState$editin === void 0 ? void 0 : _localAppState$editin.id) || local.id === ((_localAppState$resizi = localAppState.resizingElement) === null || _localAppState$resizi === void 0 ? void 0 : _localAppState$resizi.id) || local.id === ((_localAppState$draggi = localAppState.draggingElement) === null || _localAppState$draggi === void 0 ? void 0 : _localAppState$draggi.id) ||\n  // local element is newer\n  local.version > remote.version ||\n  // resolve conflicting edits deterministically by taking the one with\n  // the lowest versionNonce\n  local.version === remote.version && local.versionNonce < remote.versionNonce)) {\n    return true;\n  }\n  return false;\n};\nexport const reconcileElements = (localElements, remoteElements, localAppState) => {\n  const localElementsData = arrayToMapWithIndex(localElements);\n  const reconciledElements = localElements.slice();\n  const duplicates = new WeakMap();\n  let cursor = 0;\n  let offset = 0;\n  let remoteElementIdx = -1;\n  for (const remoteElement of remoteElements) {\n    var _remoteElements;\n    remoteElementIdx++;\n    const local = localElementsData.get(remoteElement.id);\n    if (shouldDiscardRemoteElement(localAppState, local === null || local === void 0 ? void 0 : local[0], remoteElement)) {\n      if (remoteElement[PRECEDING_ELEMENT_KEY]) {\n        delete remoteElement[PRECEDING_ELEMENT_KEY];\n      }\n      continue;\n    }\n\n    // Mark duplicate for removal as it'll be replaced with the remote element\n    if (local) {\n      // Unless the remote and local elements are the same element in which case\n      // we need to keep it as we'd otherwise discard it from the resulting\n      // array.\n      if (local[0] === remoteElement) {\n        continue;\n      }\n      duplicates.set(local[0], true);\n    }\n\n    // parent may not be defined in case the remote client is running an older\n    // excalidraw version\n    const parent = remoteElement[PRECEDING_ELEMENT_KEY] || ((_remoteElements = remoteElements[remoteElementIdx - 1]) === null || _remoteElements === void 0 ? void 0 : _remoteElements.id) || null;\n    if (parent != null) {\n      delete remoteElement[PRECEDING_ELEMENT_KEY];\n\n      // ^ indicates the element is the first in elements array\n      if (parent === \"^\") {\n        offset++;\n        if (cursor === 0) {\n          reconciledElements.unshift(remoteElement);\n          localElementsData.set(remoteElement.id, [remoteElement, cursor - offset]);\n        } else {\n          reconciledElements.splice(cursor + 1, 0, remoteElement);\n          localElementsData.set(remoteElement.id, [remoteElement, cursor + 1 - offset]);\n          cursor++;\n        }\n      } else {\n        let idx = localElementsData.has(parent) ? localElementsData.get(parent)[1] : null;\n        if (idx != null) {\n          idx += offset;\n        }\n        if (idx != null && idx >= cursor) {\n          reconciledElements.splice(idx + 1, 0, remoteElement);\n          offset++;\n          localElementsData.set(remoteElement.id, [remoteElement, idx + 1 - offset]);\n          cursor = idx + 1;\n        } else if (idx != null) {\n          reconciledElements.splice(cursor + 1, 0, remoteElement);\n          offset++;\n          localElementsData.set(remoteElement.id, [remoteElement, cursor + 1 - offset]);\n          cursor++;\n        } else {\n          reconciledElements.push(remoteElement);\n          localElementsData.set(remoteElement.id, [remoteElement, reconciledElements.length - 1 - offset]);\n        }\n      }\n      // no parent z-index information, local element exists → replace in place\n    } else if (local) {\n      reconciledElements[local[1]] = remoteElement;\n      localElementsData.set(remoteElement.id, [remoteElement, local[1]]);\n      // otherwise push to the end\n    } else {\n      reconciledElements.push(remoteElement);\n      localElementsData.set(remoteElement.id, [remoteElement, reconciledElements.length - 1 - offset]);\n    }\n  }\n  const ret = reconciledElements.filter(element => !duplicates.has(element));\n  return ret;\n};","map":{"version":3,"names":["PRECEDING_ELEMENT_KEY","arrayToMapWithIndex","shouldDiscardRemoteElement","localAppState","local","remote","_localAppState$editin","_localAppState$resizi","_localAppState$draggi","id","editingElement","resizingElement","draggingElement","version","versionNonce","reconcileElements","localElements","remoteElements","localElementsData","reconciledElements","slice","duplicates","WeakMap","cursor","offset","remoteElementIdx","remoteElement","_remoteElements","get","set","parent","unshift","splice","idx","has","push","length","ret","filter","element"],"sources":["D:/project/excalidraw-cn/src/excalidraw-app/collab/reconciliation.ts"],"sourcesContent":["import { PRECEDING_ELEMENT_KEY } from \"../../constants\";\nimport { ExcalidrawElement } from \"../../element/types\";\nimport { AppState } from \"../../types\";\nimport { arrayToMapWithIndex } from \"../../utils\";\n\nexport type ReconciledElements = readonly ExcalidrawElement[] & {\n  _brand: \"reconciledElements\";\n};\n\nexport type BroadcastedExcalidrawElement = ExcalidrawElement & {\n  [PRECEDING_ELEMENT_KEY]?: string;\n};\n\nconst shouldDiscardRemoteElement = (\n  localAppState: AppState,\n  local: ExcalidrawElement | undefined,\n  remote: BroadcastedExcalidrawElement,\n): boolean => {\n  if (\n    local &&\n    // local element is being edited\n    (local.id === localAppState.editingElement?.id ||\n      local.id === localAppState.resizingElement?.id ||\n      local.id === localAppState.draggingElement?.id ||\n      // local element is newer\n      local.version > remote.version ||\n      // resolve conflicting edits deterministically by taking the one with\n      // the lowest versionNonce\n      (local.version === remote.version &&\n        local.versionNonce < remote.versionNonce))\n  ) {\n    return true;\n  }\n  return false;\n};\n\nexport const reconcileElements = (\n  localElements: readonly ExcalidrawElement[],\n  remoteElements: readonly BroadcastedExcalidrawElement[],\n  localAppState: AppState,\n): ReconciledElements => {\n  const localElementsData =\n    arrayToMapWithIndex<ExcalidrawElement>(localElements);\n\n  const reconciledElements: ExcalidrawElement[] = localElements.slice();\n\n  const duplicates = new WeakMap<ExcalidrawElement, true>();\n\n  let cursor = 0;\n  let offset = 0;\n\n  let remoteElementIdx = -1;\n  for (const remoteElement of remoteElements) {\n    remoteElementIdx++;\n\n    const local = localElementsData.get(remoteElement.id);\n\n    if (shouldDiscardRemoteElement(localAppState, local?.[0], remoteElement)) {\n      if (remoteElement[PRECEDING_ELEMENT_KEY]) {\n        delete remoteElement[PRECEDING_ELEMENT_KEY];\n      }\n\n      continue;\n    }\n\n    // Mark duplicate for removal as it'll be replaced with the remote element\n    if (local) {\n      // Unless the remote and local elements are the same element in which case\n      // we need to keep it as we'd otherwise discard it from the resulting\n      // array.\n      if (local[0] === remoteElement) {\n        continue;\n      }\n      duplicates.set(local[0], true);\n    }\n\n    // parent may not be defined in case the remote client is running an older\n    // excalidraw version\n    const parent =\n      remoteElement[PRECEDING_ELEMENT_KEY] ||\n      remoteElements[remoteElementIdx - 1]?.id ||\n      null;\n\n    if (parent != null) {\n      delete remoteElement[PRECEDING_ELEMENT_KEY];\n\n      // ^ indicates the element is the first in elements array\n      if (parent === \"^\") {\n        offset++;\n        if (cursor === 0) {\n          reconciledElements.unshift(remoteElement);\n          localElementsData.set(remoteElement.id, [\n            remoteElement,\n            cursor - offset,\n          ]);\n        } else {\n          reconciledElements.splice(cursor + 1, 0, remoteElement);\n          localElementsData.set(remoteElement.id, [\n            remoteElement,\n            cursor + 1 - offset,\n          ]);\n          cursor++;\n        }\n      } else {\n        let idx = localElementsData.has(parent)\n          ? localElementsData.get(parent)![1]\n          : null;\n        if (idx != null) {\n          idx += offset;\n        }\n        if (idx != null && idx >= cursor) {\n          reconciledElements.splice(idx + 1, 0, remoteElement);\n          offset++;\n          localElementsData.set(remoteElement.id, [\n            remoteElement,\n            idx + 1 - offset,\n          ]);\n          cursor = idx + 1;\n        } else if (idx != null) {\n          reconciledElements.splice(cursor + 1, 0, remoteElement);\n          offset++;\n          localElementsData.set(remoteElement.id, [\n            remoteElement,\n            cursor + 1 - offset,\n          ]);\n          cursor++;\n        } else {\n          reconciledElements.push(remoteElement);\n          localElementsData.set(remoteElement.id, [\n            remoteElement,\n            reconciledElements.length - 1 - offset,\n          ]);\n        }\n      }\n      // no parent z-index information, local element exists → replace in place\n    } else if (local) {\n      reconciledElements[local[1]] = remoteElement;\n      localElementsData.set(remoteElement.id, [remoteElement, local[1]]);\n      // otherwise push to the end\n    } else {\n      reconciledElements.push(remoteElement);\n      localElementsData.set(remoteElement.id, [\n        remoteElement,\n        reconciledElements.length - 1 - offset,\n      ]);\n    }\n  }\n\n  const ret: readonly ExcalidrawElement[] = reconciledElements.filter(\n    (element) => !duplicates.has(element),\n  );\n\n  return ret as ReconciledElements;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}