{"ast":null,"code":"import _createForOfIteratorHelper from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import _slicedToArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import*as GA from\"../ga\";import*as GAPoint from\"../gapoints\";import*as GADirection from\"../gadirections\";import*as GALine from\"../galines\";import*as GATransform from\"../gatransforms\";import{distance2d,rotatePoint,isPathALoop,isPointInPolygon,rotate}from\"../math\";import{pointsOnBezierCurves}from\"points-on-curve\";import{getElementAbsoluteCoords,getCurvePathOps,getRectangleBoxAbsoluteCoords}from\"./bounds\";import{getShapeForElement}from\"../renderer/renderElement\";import{hasBoundTextElement,isImageElement}from\"./typeChecks\";import{isTextElement}from\".\";import{isTransparent}from\"../utils\";import{shouldShowBoundingBox}from\"./transformHandles\";import{getBoundTextElement}from\"./textElement\";var isElementDraggableFromInside=function isElementDraggableFromInside(element){if(element.type===\"arrow\"){return false;}if(element.type===\"freedraw\"){return true;}var isDraggableFromInside=!isTransparent(element.backgroundColor)||hasBoundTextElement(element);if(element.type===\"line\"){return isDraggableFromInside&&isPathALoop(element.points);}return isDraggableFromInside||isImageElement(element);};export var hitTest=function hitTest(element,appState,frameNameBoundsCache,x,y){// How many pixels off the shape boundary we still consider a hit\nvar threshold=10/appState.zoom.value;var point=[x,y];if(isElementSelected(appState,element)&&shouldShowBoundingBox([element],appState)){return isPointHittingElementBoundingBox(element,point,threshold,frameNameBoundsCache);}var boundTextElement=getBoundTextElement(element);if(boundTextElement){var isHittingBoundTextElement=hitTest(boundTextElement,appState,frameNameBoundsCache,x,y);if(isHittingBoundTextElement){return true;}}return isHittingElementNotConsideringBoundingBox(element,appState,frameNameBoundsCache,point);};export var isHittingElementBoundingBoxWithoutHittingElement=function isHittingElementBoundingBoxWithoutHittingElement(element,appState,frameNameBoundsCache,x,y){var threshold=10/appState.zoom.value;// So that bound text element hit is considered within bounding box of container even if its outside actual bounding box of element\n// eg for linear elements text can be outside the element bounding box\nvar boundTextElement=getBoundTextElement(element);if(boundTextElement&&hitTest(boundTextElement,appState,frameNameBoundsCache,x,y)){return false;}return!isHittingElementNotConsideringBoundingBox(element,appState,frameNameBoundsCache,[x,y])&&isPointHittingElementBoundingBox(element,[x,y],threshold,frameNameBoundsCache);};export var isHittingElementNotConsideringBoundingBox=function isHittingElementNotConsideringBoundingBox(element,appState,frameNameBoundsCache,point){var threshold=10/appState.zoom.value;var check=isTextElement(element)?isStrictlyInside:isElementDraggableFromInside(element)?isInsideCheck:isNearCheck;return hitTestPointAgainstElement({element:element,point:point,threshold:threshold,check:check,frameNameBoundsCache:frameNameBoundsCache});};var isElementSelected=function isElementSelected(appState,element){return appState.selectedElementIds[element.id];};export var isPointHittingElementBoundingBox=function isPointHittingElementBoundingBox(element,_ref,threshold,frameNameBoundsCache){var _ref2=_slicedToArray(_ref,2),x=_ref2[0],y=_ref2[1];// frames needs be checked differently so as to be able to drag it\n// by its frame, whether it has been selected or not\n// this logic here is not ideal\n// TODO: refactor it later...\nif(element.type===\"frame\"){return hitTestPointAgainstElement({element:element,point:[x,y],threshold:threshold,check:isInsideCheck,frameNameBoundsCache:frameNameBoundsCache});}var _getElementAbsoluteCo=getElementAbsoluteCoords(element),_getElementAbsoluteCo2=_slicedToArray(_getElementAbsoluteCo,4),x1=_getElementAbsoluteCo2[0],y1=_getElementAbsoluteCo2[1],x2=_getElementAbsoluteCo2[2],y2=_getElementAbsoluteCo2[3];var elementCenterX=(x1+x2)/2;var elementCenterY=(y1+y2)/2;// reverse rotate to take element's angle into account.\nvar _rotate=rotate(x,y,elementCenterX,elementCenterY,-element.angle),_rotate2=_slicedToArray(_rotate,2),rotatedX=_rotate2[0],rotatedY=_rotate2[1];return rotatedX>x1-threshold&&rotatedX<x2+threshold&&rotatedY>y1-threshold&&rotatedY<y2+threshold;};export var bindingBorderTest=function bindingBorderTest(element,_ref3){var x=_ref3.x,y=_ref3.y;var threshold=maxBindingGap(element,element.width,element.height);var check=isOutsideCheck;var point=[x,y];return hitTestPointAgainstElement({element:element,point:point,threshold:threshold,check:check,frameNameBoundsCache:null});};export var maxBindingGap=function maxBindingGap(element,elementWidth,elementHeight){// Aligns diamonds with rectangles\nvar shapeRatio=element.type===\"diamond\"?1/Math.sqrt(2):1;var smallerDimension=shapeRatio*Math.min(elementWidth,elementHeight);// We make the bindable boundary bigger for bigger elements\nreturn Math.max(16,Math.min(0.25*smallerDimension,32));};var hitTestPointAgainstElement=function hitTestPointAgainstElement(args){switch(args.element.type){case\"rectangle\":case\"image\":case\"text\":case\"diamond\":case\"ellipse\":var _distance=distanceToBindableElement(args.element,args.point);return args.check(_distance,args.threshold);case\"freedraw\":{if(!args.check(distanceToRectangle(args.element,args.point),args.threshold)){return false;}return hitTestFreeDrawElement(args.element,args.point,args.threshold);}case\"arrow\":case\"line\":return hitTestLinear(args);case\"selection\":console.warn(\"This should not happen, we need to investigate why it does.\");return false;case\"frame\":{var _args$frameNameBounds;// check distance to frame element first\nif(args.check(distanceToBindableElement(args.element,args.point),args.threshold)){return true;}var frameNameBounds=(_args$frameNameBounds=args.frameNameBoundsCache)===null||_args$frameNameBounds===void 0?void 0:_args$frameNameBounds.get(args.element);if(frameNameBounds){return args.check(distanceToRectangleBox(frameNameBounds,args.point),args.threshold);}return false;}}};export var distanceToBindableElement=function distanceToBindableElement(element,point){switch(element.type){case\"rectangle\":case\"image\":case\"text\":case\"frame\":return distanceToRectangle(element,point);case\"diamond\":return distanceToDiamond(element,point);case\"ellipse\":return distanceToEllipse(element,point);}};var isStrictlyInside=function isStrictlyInside(distance,threshold){return distance<0;};var isInsideCheck=function isInsideCheck(distance,threshold){return distance<threshold;};var isNearCheck=function isNearCheck(distance,threshold){return Math.abs(distance)<threshold;};var isOutsideCheck=function isOutsideCheck(distance,threshold){return 0<=distance&&distance<threshold;};var distanceToRectangle=function distanceToRectangle(element,point){var _pointRelativeToEleme=pointRelativeToElement(element,point),_pointRelativeToEleme2=_slicedToArray(_pointRelativeToEleme,4),pointRel=_pointRelativeToEleme2[1],hwidth=_pointRelativeToEleme2[2],hheight=_pointRelativeToEleme2[3];return Math.max(GAPoint.distanceToLine(pointRel,GALine.equation(0,1,-hheight)),GAPoint.distanceToLine(pointRel,GALine.equation(1,0,-hwidth)));};var distanceToRectangleBox=function distanceToRectangleBox(box,point){var _pointRelativeToDivEl=pointRelativeToDivElement(point,box),_pointRelativeToDivEl2=_slicedToArray(_pointRelativeToDivEl,4),pointRel=_pointRelativeToDivEl2[1],hwidth=_pointRelativeToDivEl2[2],hheight=_pointRelativeToDivEl2[3];return Math.max(GAPoint.distanceToLine(pointRel,GALine.equation(0,1,-hheight)),GAPoint.distanceToLine(pointRel,GALine.equation(1,0,-hwidth)));};var distanceToDiamond=function distanceToDiamond(element,point){var _pointRelativeToEleme3=pointRelativeToElement(element,point),_pointRelativeToEleme4=_slicedToArray(_pointRelativeToEleme3,4),pointRel=_pointRelativeToEleme4[1],hwidth=_pointRelativeToEleme4[2],hheight=_pointRelativeToEleme4[3];var side=GALine.equation(hheight,hwidth,-hheight*hwidth);return GAPoint.distanceToLine(pointRel,side);};var distanceToEllipse=function distanceToEllipse(element,point){var _ellipseParamsForTest=ellipseParamsForTest(element,point),_ellipseParamsForTest2=_slicedToArray(_ellipseParamsForTest,2),pointRel=_ellipseParamsForTest2[0],tangent=_ellipseParamsForTest2[1];return-GALine.sign(tangent)*GAPoint.distanceToLine(pointRel,tangent);};var ellipseParamsForTest=function ellipseParamsForTest(element,point){var _pointRelativeToEleme5=pointRelativeToElement(element,point),_pointRelativeToEleme6=_slicedToArray(_pointRelativeToEleme5,4),pointRel=_pointRelativeToEleme6[1],hwidth=_pointRelativeToEleme6[2],hheight=_pointRelativeToEleme6[3];var _GAPoint$toTuple=GAPoint.toTuple(pointRel),_GAPoint$toTuple2=_slicedToArray(_GAPoint$toTuple,2),px=_GAPoint$toTuple2[0],py=_GAPoint$toTuple2[1];// We're working in positive quadrant, so start with `t = 45deg`, `tx=cos(t)`\nvar tx=0.707;var ty=0.707;var a=hwidth;var b=hheight;// This is a numerical method to find the params tx, ty at which\n// the ellipse has the closest point to the given point\n[0,1,2,3].forEach(function(_){var xx=a*tx;var yy=b*ty;var ex=(a*a-b*b)*Math.pow(tx,3)/a;var ey=(b*b-a*a)*Math.pow(ty,3)/b;var rx=xx-ex;var ry=yy-ey;var qx=px-ex;var qy=py-ey;var r=Math.hypot(ry,rx);var q=Math.hypot(qy,qx);tx=Math.min(1,Math.max(0,(qx*r/q+ex)/a));ty=Math.min(1,Math.max(0,(qy*r/q+ey)/b));var t=Math.hypot(ty,tx);tx/=t;ty/=t;});var closestPoint=GA.point(a*tx,b*ty);var tangent=GALine.orthogonalThrough(pointRel,closestPoint);return[pointRel,tangent];};var hitTestFreeDrawElement=function hitTestFreeDrawElement(element,point,threshold){// Check point-distance-to-line-segment for every segment in the\n// element's points (its input points, not its outline points).\n// This is... okay? It's plenty fast, but the GA library may\n// have a faster option.\nvar x;var y;if(element.angle===0){x=point[0]-element.x;y=point[1]-element.y;}else{// Counter-rotate the point around center before testing\nvar _getElementAbsoluteCo3=getElementAbsoluteCoords(element),_getElementAbsoluteCo4=_slicedToArray(_getElementAbsoluteCo3,4),minX=_getElementAbsoluteCo4[0],minY=_getElementAbsoluteCo4[1],maxX=_getElementAbsoluteCo4[2],maxY=_getElementAbsoluteCo4[3];var rotatedPoint=rotatePoint(point,[minX+(maxX-minX)/2,minY+(maxY-minY)/2],-element.angle);x=rotatedPoint[0]-element.x;y=rotatedPoint[1]-element.y;}var _element$points=_slicedToArray(element.points,2),A=_element$points[0],B=_element$points[1];var P;// For freedraw dots\nif(distance2d(A[0],A[1],x,y)<threshold||distance2d(B[0],B[1],x,y)<threshold){return true;}// For freedraw lines\nfor(var i=0;i<element.points.length;i++){var delta=[B[0]-A[0],B[1]-A[1]];var length=Math.hypot(delta[1],delta[0]);var U=[delta[0]/length,delta[1]/length];var C=[x-A[0],y-A[1]];var d=(C[0]*U[0]+C[1]*U[1])/Math.hypot(U[1],U[0]);P=[A[0]+U[0]*d,A[1]+U[1]*d];var da=distance2d(P[0],P[1],A[0],A[1]);var db=distance2d(P[0],P[1],B[0],B[1]);P=db<da&&da>length?B:da<db&&db>length?A:P;if(Math.hypot(y-P[1],x-P[0])<threshold){return true;}A=B;B=element.points[i+1];}var shape=getShapeForElement(element);// for filled freedraw shapes, support\n// selecting from inside\nif(shape&&shape.sets.length){return hitTestRoughShape(shape,x,y,threshold);}return false;};var hitTestLinear=function hitTestLinear(args){var element=args.element,threshold=args.threshold;if(!getShapeForElement(element)){return false;}var _pointRelativeToEleme7=pointRelativeToElement(args.element,args.point),_pointRelativeToEleme8=_slicedToArray(_pointRelativeToEleme7,4),point=_pointRelativeToEleme8[0],pointAbs=_pointRelativeToEleme8[1],hwidth=_pointRelativeToEleme8[2],hheight=_pointRelativeToEleme8[3];var side1=GALine.equation(0,1,-hheight);var side2=GALine.equation(1,0,-hwidth);if(!isInsideCheck(GAPoint.distanceToLine(pointAbs,side1),threshold)||!isInsideCheck(GAPoint.distanceToLine(pointAbs,side2),threshold)){return false;}var _GAPoint$toTuple3=GAPoint.toTuple(point),_GAPoint$toTuple4=_slicedToArray(_GAPoint$toTuple3,2),relX=_GAPoint$toTuple4[0],relY=_GAPoint$toTuple4[1];var shape=getShapeForElement(element);if(!shape){return false;}if(args.check===isInsideCheck){var hit=shape.some(function(subshape){return hitTestCurveInside(subshape,relX,relY,element.roundness?\"round\":\"sharp\");});if(hit){return true;}}// hit test all \"subshapes\" of the linear element\nreturn shape.some(function(subshape){return hitTestRoughShape(subshape,relX,relY,threshold);});};// Returns:\n//   1. the point relative to the elements (x, y) position\n//   2. the point relative to the element's center with positive (x, y)\n//   3. half element width\n//   4. half element height\n//\n// Note that for linear elements the (x, y) position is not at the\n// top right corner of their boundary.\n//\n// Rectangles, diamonds and ellipses are symmetrical over axes,\n// and other elements have a rectangular boundary,\n// so we only need to perform hit tests for the positive quadrant.\nvar pointRelativeToElement=function pointRelativeToElement(element,pointTuple){var point=GAPoint.from(pointTuple);var _getElementAbsoluteCo5=getElementAbsoluteCoords(element),_getElementAbsoluteCo6=_slicedToArray(_getElementAbsoluteCo5,4),x1=_getElementAbsoluteCo6[0],y1=_getElementAbsoluteCo6[1],x2=_getElementAbsoluteCo6[2],y2=_getElementAbsoluteCo6[3];var center=coordsCenter(x1,y1,x2,y2);// GA has angle orientation opposite to `rotate`\nvar rotate=GATransform.rotation(center,element.angle);var pointRotated=GATransform.apply(rotate,point);var pointRelToCenter=GA.sub(pointRotated,GADirection.from(center));var pointRelToCenterAbs=GAPoint.abs(pointRelToCenter);var elementPos=GA.offset(element.x,element.y);var pointRelToPos=GA.sub(pointRotated,elementPos);var halfWidth=(x2-x1)/2;var halfHeight=(y2-y1)/2;return[pointRelToPos,pointRelToCenterAbs,halfWidth,halfHeight];};var pointRelativeToDivElement=function pointRelativeToDivElement(pointTuple,rectangle){var point=GAPoint.from(pointTuple);var _getRectangleBoxAbsol=getRectangleBoxAbsoluteCoords(rectangle),_getRectangleBoxAbsol2=_slicedToArray(_getRectangleBoxAbsol,4),x1=_getRectangleBoxAbsol2[0],y1=_getRectangleBoxAbsol2[1],x2=_getRectangleBoxAbsol2[2],y2=_getRectangleBoxAbsol2[3];var center=coordsCenter(x1,y1,x2,y2);var rotate=GATransform.rotation(center,rectangle.angle);var pointRotated=GATransform.apply(rotate,point);var pointRelToCenter=GA.sub(pointRotated,GADirection.from(center));var pointRelToCenterAbs=GAPoint.abs(pointRelToCenter);var elementPos=GA.offset(rectangle.x,rectangle.y);var pointRelToPos=GA.sub(pointRotated,elementPos);var halfWidth=(x2-x1)/2;var halfHeight=(y2-y1)/2;return[pointRelToPos,pointRelToCenterAbs,halfWidth,halfHeight];};// Returns point in absolute coordinates\nexport var pointInAbsoluteCoords=function pointInAbsoluteCoords(element,point){var _point=_slicedToArray(point,2),x=_point[0],y=_point[1];var _getElementAbsoluteCo7=getElementAbsoluteCoords(element),_getElementAbsoluteCo8=_slicedToArray(_getElementAbsoluteCo7,4),x1=_getElementAbsoluteCo8[0],y1=_getElementAbsoluteCo8[1],x2=_getElementAbsoluteCo8[2],y2=_getElementAbsoluteCo8[3];var cx=(x2-x1)/2;var cy=(y2-y1)/2;var _rotate3=rotate(x,y,cx,cy,element.angle),_rotate4=_slicedToArray(_rotate3,2),rotatedX=_rotate4[0],rotatedY=_rotate4[1];return[element.x+rotatedX,element.y+rotatedY];};var relativizationToElementCenter=function relativizationToElementCenter(element){var _getElementAbsoluteCo9=getElementAbsoluteCoords(element),_getElementAbsoluteCo10=_slicedToArray(_getElementAbsoluteCo9,4),x1=_getElementAbsoluteCo10[0],y1=_getElementAbsoluteCo10[1],x2=_getElementAbsoluteCo10[2],y2=_getElementAbsoluteCo10[3];var center=coordsCenter(x1,y1,x2,y2);// GA has angle orientation opposite to `rotate`\nvar rotate=GATransform.rotation(center,element.angle);var translate=GA.reverse(GATransform.translation(GADirection.from(center)));return GATransform.compose(rotate,translate);};var coordsCenter=function coordsCenter(x1,y1,x2,y2){return GA.point((x1+x2)/2,(y1+y2)/2);};// The focus distance is the oriented ratio between the size of\n// the `element` and the \"focus image\" of the element on which\n// all focus points lie, so it's a number between -1 and 1.\n// The line going through `a` and `b` is a tangent to the \"focus image\"\n// of the element.\nexport var determineFocusDistance=function determineFocusDistance(element,a,b){var relateToCenter=relativizationToElementCenter(element);var aRel=GATransform.apply(relateToCenter,GAPoint.from(a));var bRel=GATransform.apply(relateToCenter,GAPoint.from(b));var line=GALine.through(aRel,bRel);var q=element.height/element.width;var hwidth=element.width/2;var hheight=element.height/2;var n=line[2];var m=line[3];var c=line[1];var mabs=Math.abs(m);var nabs=Math.abs(n);switch(element.type){case\"rectangle\":case\"image\":case\"text\":case\"frame\":return c/(hwidth*(nabs+q*mabs));case\"diamond\":return mabs<nabs?c/(nabs*hwidth):c/(mabs*hheight);case\"ellipse\":return c/(hwidth*Math.sqrt(Math.pow(n,2)+Math.pow(q,2)*Math.pow(m,2)));}};export var determineFocusPoint=function determineFocusPoint(element,focus,adjecentPoint){if(focus===0){var _getElementAbsoluteCo11=getElementAbsoluteCoords(element),_getElementAbsoluteCo12=_slicedToArray(_getElementAbsoluteCo11,4),x1=_getElementAbsoluteCo12[0],y1=_getElementAbsoluteCo12[1],x2=_getElementAbsoluteCo12[2],y2=_getElementAbsoluteCo12[3];var center=coordsCenter(x1,y1,x2,y2);return GAPoint.toTuple(center);}var relateToCenter=relativizationToElementCenter(element);var adjecentPointRel=GATransform.apply(relateToCenter,GAPoint.from(adjecentPoint));var reverseRelateToCenter=GA.reverse(relateToCenter);var point;switch(element.type){case\"rectangle\":case\"image\":case\"text\":case\"diamond\":case\"frame\":point=findFocusPointForRectangulars(element,focus,adjecentPointRel);break;case\"ellipse\":point=findFocusPointForEllipse(element,focus,adjecentPointRel);break;}return GAPoint.toTuple(GATransform.apply(reverseRelateToCenter,point));};// Returns 2 or 0 intersection points between line going through `a` and `b`\n// and the `element`, in ascending order of distance from `a`.\nexport var intersectElementWithLine=function intersectElementWithLine(element,a,b){var gap=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;var relateToCenter=relativizationToElementCenter(element);var aRel=GATransform.apply(relateToCenter,GAPoint.from(a));var bRel=GATransform.apply(relateToCenter,GAPoint.from(b));var line=GALine.through(aRel,bRel);var reverseRelateToCenter=GA.reverse(relateToCenter);var intersections=getSortedElementLineIntersections(element,line,aRel,gap);return intersections.map(function(point){return GAPoint.toTuple(GATransform.apply(reverseRelateToCenter,point));});};var getSortedElementLineIntersections=function getSortedElementLineIntersections(element,line,nearPoint){var gap=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;var intersections;switch(element.type){case\"rectangle\":case\"image\":case\"text\":case\"diamond\":case\"frame\":var corners=getCorners(element);intersections=corners.flatMap(function(point,i){var edge=[point,corners[(i+1)%4]];return intersectSegment(line,offsetSegment(edge,gap));}).concat(corners.flatMap(function(point){return getCircleIntersections(point,gap,line);}));break;case\"ellipse\":intersections=getEllipseIntersections(element,gap,line);break;}if(intersections.length<2){// Ignore the \"edge\" case of only intersecting with a single corner\nreturn[];}var sortedIntersections=intersections.sort(function(i1,i2){return GAPoint.distance(i1,nearPoint)-GAPoint.distance(i2,nearPoint);});return[sortedIntersections[0],sortedIntersections[sortedIntersections.length-1]];};var getCorners=function getCorners(element){var scale=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var hx=scale*element.width/2;var hy=scale*element.height/2;switch(element.type){case\"rectangle\":case\"image\":case\"text\":case\"frame\":return[GA.point(hx,hy),GA.point(hx,-hy),GA.point(-hx,-hy),GA.point(-hx,hy)];case\"diamond\":return[GA.point(0,hy),GA.point(hx,0),GA.point(0,-hy),GA.point(-hx,0)];}};// Returns intersection of `line` with `segment`, with `segment` moved by\n// `gap` in its polar direction.\n// If intersection coincides with second segment point returns empty array.\nvar intersectSegment=function intersectSegment(line,segment){var _segment=_slicedToArray(segment,2),a=_segment[0],b=_segment[1];var aDist=GAPoint.distanceToLine(a,line);var bDist=GAPoint.distanceToLine(b,line);if(aDist*bDist>=0){// The intersection is outside segment `(a, b)`\nreturn[];}return[GAPoint.intersect(line,GALine.through(a,b))];};var offsetSegment=function offsetSegment(segment,distance){var _segment2=_slicedToArray(segment,2),a=_segment2[0],b=_segment2[1];var offset=GATransform.translationOrthogonal(GADirection.fromTo(a,b),distance);return[GATransform.apply(offset,a),GATransform.apply(offset,b)];};var getEllipseIntersections=function getEllipseIntersections(element,gap,line){var a=element.width/2+gap;var b=element.height/2+gap;var m=line[2];var n=line[3];var c=line[1];var squares=a*a*m*m+b*b*n*n;var discr=squares-c*c;if(squares===0||discr<=0){return[];}var discrRoot=Math.sqrt(discr);var xn=-a*a*m*c;var yn=-b*b*n*c;return[GA.point((xn+a*b*n*discrRoot)/squares,(yn-a*b*m*discrRoot)/squares),GA.point((xn-a*b*n*discrRoot)/squares,(yn+a*b*m*discrRoot)/squares)];};export var getCircleIntersections=function getCircleIntersections(center,radius,line){if(radius===0){return GAPoint.distanceToLine(line,center)===0?[center]:[];}var m=line[2];var n=line[3];var c=line[1];var _GAPoint$toTuple5=GAPoint.toTuple(center),_GAPoint$toTuple6=_slicedToArray(_GAPoint$toTuple5,2),a=_GAPoint$toTuple6[0],b=_GAPoint$toTuple6[1];var r=radius;var squares=m*m+n*n;var discr=r*r*squares-Math.pow(m*a+n*b+c,2);if(squares===0||discr<=0){return[];}var discrRoot=Math.sqrt(discr);var xn=a*n*n-b*m*n-m*c;var yn=b*m*m-a*m*n-n*c;return[GA.point((xn+n*discrRoot)/squares,(yn-m*discrRoot)/squares),GA.point((xn-n*discrRoot)/squares,(yn+m*discrRoot)/squares)];};// The focus point is the tangent point of the \"focus image\" of the\n// `element`, where the tangent goes through `point`.\nexport var findFocusPointForEllipse=function findFocusPointForEllipse(ellipse,relativeDistance,point){var relativeDistanceAbs=Math.abs(relativeDistance);var a=ellipse.width*relativeDistanceAbs/2;var b=ellipse.height*relativeDistanceAbs/2;var orientation=Math.sign(relativeDistance);var _GAPoint$toTuple7=GAPoint.toTuple(point),_GAPoint$toTuple8=_slicedToArray(_GAPoint$toTuple7,2),px=_GAPoint$toTuple8[0],pyo=_GAPoint$toTuple8[1];// The calculation below can't handle py = 0\nvar py=pyo===0?0.0001:pyo;var squares=Math.pow(px,2)*Math.pow(b,2)+Math.pow(py,2)*Math.pow(a,2);// Tangent mx + ny + 1 = 0\nvar m=(-px*Math.pow(b,2)+orientation*py*Math.sqrt(Math.max(0,squares-Math.pow(a,2)*Math.pow(b,2))))/squares;var n=(-m*px-1)/py;if(n===0){// if zero {-0, 0}, fall back to a same-sign value in the similar range\nn=(Object.is(n,-0)?-1:1)*0.01;}var x=-(Math.pow(a,2)*m)/(Math.pow(n,2)*Math.pow(b,2)+Math.pow(m,2)*Math.pow(a,2));return GA.point(x,(-m*x-1)/n);};export var findFocusPointForRectangulars=function findFocusPointForRectangulars(element,relativeDistance,point){var relativeDistanceAbs=Math.abs(relativeDistance);var orientation=Math.sign(relativeDistance);var corners=getCorners(element,relativeDistanceAbs);var maxDistance=0;var tangentPoint=null;corners.forEach(function(corner){var distance=orientation*GALine.through(point,corner)[1];if(distance>maxDistance){maxDistance=distance;tangentPoint=corner;}});return tangentPoint;};var pointInBezierEquation=function pointInBezierEquation(p0,p1,p2,p3,_ref4,lineThreshold){var _ref5=_slicedToArray(_ref4,2),mx=_ref5[0],my=_ref5[1];// B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\nvar equation=function equation(t,idx){return Math.pow(1-t,3)*p3[idx]+3*t*Math.pow(1-t,2)*p2[idx]+3*Math.pow(t,2)*(1-t)*p1[idx]+p0[idx]*Math.pow(t,3);};// go through t in increments of 0.01\nvar t=0;while(t<=1.0){var tx=equation(t,0);var ty=equation(t,1);var diff=Math.sqrt(Math.pow(tx-mx,2)+Math.pow(ty-my,2));if(diff<lineThreshold){return true;}t+=0.01;}return false;};var hitTestCurveInside=function hitTestCurveInside(drawable,x,y,roundness){var ops=getCurvePathOps(drawable);var points=[];var odd=false;// select one line out of double lines\nvar _iterator=_createForOfIteratorHelper(ops),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var operation=_step.value;if(operation.op===\"move\"){odd=!odd;if(odd){points.push([operation.data[0],operation.data[1]]);}}else if(operation.op===\"bcurveTo\"){if(odd){points.push([operation.data[0],operation.data[1]]);points.push([operation.data[2],operation.data[3]]);points.push([operation.data[4],operation.data[5]]);}}else if(operation.op===\"lineTo\"){if(odd){points.push([operation.data[0],operation.data[1]]);}}}}catch(err){_iterator.e(err);}finally{_iterator.f();}if(points.length>=4){if(roundness===\"sharp\"){return isPointInPolygon(points,x,y);}var polygonPoints=pointsOnBezierCurves(points,10,5);return isPointInPolygon(polygonPoints,x,y);}return false;};var hitTestRoughShape=function hitTestRoughShape(drawable,x,y,lineThreshold){// read operations from first opSet\nvar ops=getCurvePathOps(drawable);// set start position as (0,0) just in case\n// move operation does not exist (unlikely but it is worth safekeeping it)\nvar currentP=[0,0];return ops.some(function(_ref6,idx){var op=_ref6.op,data=_ref6.data;// There are only four operation types:\n// move, bcurveTo, lineTo, and curveTo\nif(op===\"move\"){// change starting point\ncurrentP=data;// move operation does not draw anything; so, it always\n// returns false\n}else if(op===\"bcurveTo\"){// create points from bezier curve\n// bezier curve stores data as a flattened array of three positions\n// [x1, y1, x2, y2, x3, y3]\nvar p1=[data[0],data[1]];var p2=[data[2],data[3]];var p3=[data[4],data[5]];var p0=currentP;currentP=p3;// check if points are on the curve\n// cubic bezier curves require four parameters\n// the first parameter is the last stored position (p0)\nvar retVal=pointInBezierEquation(p0,p1,p2,p3,[x,y],lineThreshold);// set end point of bezier curve as the new starting point for\n// upcoming operations as each operation is based on the last drawn\n// position of the previous operation\nreturn retVal;}else if(op===\"lineTo\"){return hitTestCurveInside(drawable,x,y,\"sharp\");}else if(op===\"qcurveTo\"){// TODO: Implement this\nconsole.warn(\"qcurveTo is not implemented yet\");}return false;});};","map":{"version":3,"names":["GA","GAPoint","GADirection","GALine","GATransform","distance2d","rotatePoint","isPathALoop","isPointInPolygon","rotate","pointsOnBezierCurves","getElementAbsoluteCoords","getCurvePathOps","getRectangleBoxAbsoluteCoords","getShapeForElement","hasBoundTextElement","isImageElement","isTextElement","isTransparent","shouldShowBoundingBox","getBoundTextElement","isElementDraggableFromInside","element","type","isDraggableFromInside","backgroundColor","points","hitTest","appState","frameNameBoundsCache","x","y","threshold","zoom","value","point","isElementSelected","isPointHittingElementBoundingBox","boundTextElement","isHittingBoundTextElement","isHittingElementNotConsideringBoundingBox","isHittingElementBoundingBoxWithoutHittingElement","check","isStrictlyInside","isInsideCheck","isNearCheck","hitTestPointAgainstElement","selectedElementIds","id","_ref","_ref2","_slicedToArray","_getElementAbsoluteCo","_getElementAbsoluteCo2","x1","y1","x2","y2","elementCenterX","elementCenterY","_rotate","angle","_rotate2","rotatedX","rotatedY","bindingBorderTest","_ref3","maxBindingGap","width","height","isOutsideCheck","elementWidth","elementHeight","shapeRatio","Math","sqrt","smallerDimension","min","max","args","distance","distanceToBindableElement","distanceToRectangle","hitTestFreeDrawElement","hitTestLinear","console","warn","_args$frameNameBounds","frameNameBounds","get","distanceToRectangleBox","distanceToDiamond","distanceToEllipse","abs","_pointRelativeToEleme","pointRelativeToElement","_pointRelativeToEleme2","pointRel","hwidth","hheight","distanceToLine","equation","box","_pointRelativeToDivEl","pointRelativeToDivElement","_pointRelativeToDivEl2","_pointRelativeToEleme3","_pointRelativeToEleme4","side","_ellipseParamsForTest","ellipseParamsForTest","_ellipseParamsForTest2","tangent","sign","_pointRelativeToEleme5","_pointRelativeToEleme6","_GAPoint$toTuple","toTuple","_GAPoint$toTuple2","px","py","tx","ty","a","b","forEach","_","xx","yy","ex","pow","ey","rx","ry","qx","qy","r","hypot","q","t","closestPoint","orthogonalThrough","_getElementAbsoluteCo3","_getElementAbsoluteCo4","minX","minY","maxX","maxY","rotatedPoint","_element$points","A","B","P","i","length","delta","U","C","d","da","db","shape","sets","hitTestRoughShape","_pointRelativeToEleme7","_pointRelativeToEleme8","pointAbs","side1","side2","_GAPoint$toTuple3","_GAPoint$toTuple4","relX","relY","hit","some","subshape","hitTestCurveInside","roundness","pointTuple","from","_getElementAbsoluteCo5","_getElementAbsoluteCo6","center","coordsCenter","rotation","pointRotated","apply","pointRelToCenter","sub","pointRelToCenterAbs","elementPos","offset","pointRelToPos","halfWidth","halfHeight","rectangle","_getRectangleBoxAbsol","_getRectangleBoxAbsol2","pointInAbsoluteCoords","_point","_getElementAbsoluteCo7","_getElementAbsoluteCo8","cx","cy","_rotate3","_rotate4","relativizationToElementCenter","_getElementAbsoluteCo9","_getElementAbsoluteCo10","translate","reverse","translation","compose","determineFocusDistance","relateToCenter","aRel","bRel","line","through","n","m","c","mabs","nabs","determineFocusPoint","focus","adjecentPoint","_getElementAbsoluteCo11","_getElementAbsoluteCo12","adjecentPointRel","reverseRelateToCenter","findFocusPointForRectangulars","findFocusPointForEllipse","intersectElementWithLine","gap","arguments","undefined","intersections","getSortedElementLineIntersections","map","nearPoint","corners","getCorners","flatMap","edge","intersectSegment","offsetSegment","concat","getCircleIntersections","getEllipseIntersections","sortedIntersections","sort","i1","i2","scale","hx","hy","segment","_segment","aDist","bDist","intersect","_segment2","translationOrthogonal","fromTo","squares","discr","discrRoot","xn","yn","radius","_GAPoint$toTuple5","_GAPoint$toTuple6","ellipse","relativeDistance","relativeDistanceAbs","orientation","_GAPoint$toTuple7","_GAPoint$toTuple8","pyo","Object","is","maxDistance","tangentPoint","corner","pointInBezierEquation","p0","p1","p2","p3","_ref4","lineThreshold","_ref5","mx","my","idx","diff","drawable","ops","odd","_iterator","_createForOfIteratorHelper","_step","s","done","operation","op","push","data","err","e","f","polygonPoints","currentP","_ref6","retVal"],"sources":["D:/project/excalidraw-cn/src/element/collision.ts"],"sourcesContent":["import * as GA from \"../ga\";\nimport * as GAPoint from \"../gapoints\";\nimport * as GADirection from \"../gadirections\";\nimport * as GALine from \"../galines\";\nimport * as GATransform from \"../gatransforms\";\n\nimport {\n  distance2d,\n  rotatePoint,\n  isPathALoop,\n  isPointInPolygon,\n  rotate,\n} from \"../math\";\nimport { pointsOnBezierCurves } from \"points-on-curve\";\n\nimport {\n  NonDeletedExcalidrawElement,\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawRectangleElement,\n  ExcalidrawDiamondElement,\n  ExcalidrawTextElement,\n  ExcalidrawEllipseElement,\n  NonDeleted,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawImageElement,\n  ExcalidrawLinearElement,\n  StrokeRoundness,\n  ExcalidrawFrameElement,\n} from \"./types\";\n\nimport {\n  getElementAbsoluteCoords,\n  getCurvePathOps,\n  getRectangleBoxAbsoluteCoords,\n  RectangleBox,\n} from \"./bounds\";\nimport { FrameNameBoundsCache, Point } from \"../types\";\nimport { Drawable } from \"roughjs/bin/core\";\nimport { AppState } from \"../types\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\nimport { hasBoundTextElement, isImageElement } from \"./typeChecks\";\nimport { isTextElement } from \".\";\nimport { isTransparent } from \"../utils\";\nimport { shouldShowBoundingBox } from \"./transformHandles\";\nimport { getBoundTextElement } from \"./textElement\";\nimport { Mutable } from \"../utility-types\";\n\nconst isElementDraggableFromInside = (\n  element: NonDeletedExcalidrawElement,\n): boolean => {\n  if (element.type === \"arrow\") {\n    return false;\n  }\n\n  if (element.type === \"freedraw\") {\n    return true;\n  }\n  const isDraggableFromInside =\n    !isTransparent(element.backgroundColor) || hasBoundTextElement(element);\n  if (element.type === \"line\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n  return isDraggableFromInside || isImageElement(element);\n};\n\nexport const hitTest = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  frameNameBoundsCache: FrameNameBoundsCache,\n  x: number,\n  y: number,\n): boolean => {\n  // How many pixels off the shape boundary we still consider a hit\n  const threshold = 10 / appState.zoom.value;\n  const point: Point = [x, y];\n\n  if (\n    isElementSelected(appState, element) &&\n    shouldShowBoundingBox([element], appState)\n  ) {\n    return isPointHittingElementBoundingBox(\n      element,\n      point,\n      threshold,\n      frameNameBoundsCache,\n    );\n  }\n\n  const boundTextElement = getBoundTextElement(element);\n  if (boundTextElement) {\n    const isHittingBoundTextElement = hitTest(\n      boundTextElement,\n      appState,\n      frameNameBoundsCache,\n      x,\n      y,\n    );\n    if (isHittingBoundTextElement) {\n      return true;\n    }\n  }\n  return isHittingElementNotConsideringBoundingBox(\n    element,\n    appState,\n    frameNameBoundsCache,\n    point,\n  );\n};\n\nexport const isHittingElementBoundingBoxWithoutHittingElement = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  frameNameBoundsCache: FrameNameBoundsCache,\n  x: number,\n  y: number,\n): boolean => {\n  const threshold = 10 / appState.zoom.value;\n\n  // So that bound text element hit is considered within bounding box of container even if its outside actual bounding box of element\n  // eg for linear elements text can be outside the element bounding box\n  const boundTextElement = getBoundTextElement(element);\n  if (\n    boundTextElement &&\n    hitTest(boundTextElement, appState, frameNameBoundsCache, x, y)\n  ) {\n    return false;\n  }\n\n  return (\n    !isHittingElementNotConsideringBoundingBox(\n      element,\n      appState,\n      frameNameBoundsCache,\n      [x, y],\n    ) &&\n    isPointHittingElementBoundingBox(\n      element,\n      [x, y],\n      threshold,\n      frameNameBoundsCache,\n    )\n  );\n};\n\nexport const isHittingElementNotConsideringBoundingBox = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  frameNameBoundsCache: FrameNameBoundsCache | null,\n  point: Point,\n): boolean => {\n  const threshold = 10 / appState.zoom.value;\n  const check = isTextElement(element)\n    ? isStrictlyInside\n    : isElementDraggableFromInside(element)\n    ? isInsideCheck\n    : isNearCheck;\n  return hitTestPointAgainstElement({\n    element,\n    point,\n    threshold,\n    check,\n    frameNameBoundsCache,\n  });\n};\n\nconst isElementSelected = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n) => appState.selectedElementIds[element.id];\n\nexport const isPointHittingElementBoundingBox = (\n  element: NonDeleted<ExcalidrawElement>,\n  [x, y]: Point,\n  threshold: number,\n  frameNameBoundsCache: FrameNameBoundsCache | null,\n) => {\n  // frames needs be checked differently so as to be able to drag it\n  // by its frame, whether it has been selected or not\n  // this logic here is not ideal\n  // TODO: refactor it later...\n  if (element.type === \"frame\") {\n    return hitTestPointAgainstElement({\n      element,\n      point: [x, y],\n      threshold,\n      check: isInsideCheck,\n      frameNameBoundsCache,\n    });\n  }\n\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const elementCenterX = (x1 + x2) / 2;\n  const elementCenterY = (y1 + y2) / 2;\n  // reverse rotate to take element's angle into account.\n  const [rotatedX, rotatedY] = rotate(\n    x,\n    y,\n    elementCenterX,\n    elementCenterY,\n    -element.angle,\n  );\n\n  return (\n    rotatedX > x1 - threshold &&\n    rotatedX < x2 + threshold &&\n    rotatedY > y1 - threshold &&\n    rotatedY < y2 + threshold\n  );\n};\n\nexport const bindingBorderTest = (\n  element: NonDeleted<ExcalidrawBindableElement>,\n  { x, y }: { x: number; y: number },\n): boolean => {\n  const threshold = maxBindingGap(element, element.width, element.height);\n  const check = isOutsideCheck;\n  const point: Point = [x, y];\n  return hitTestPointAgainstElement({\n    element,\n    point,\n    threshold,\n    check,\n    frameNameBoundsCache: null,\n  });\n};\n\nexport const maxBindingGap = (\n  element: ExcalidrawElement,\n  elementWidth: number,\n  elementHeight: number,\n): number => {\n  // Aligns diamonds with rectangles\n  const shapeRatio = element.type === \"diamond\" ? 1 / Math.sqrt(2) : 1;\n  const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight);\n  // We make the bindable boundary bigger for bigger elements\n  return Math.max(16, Math.min(0.25 * smallerDimension, 32));\n};\n\ntype HitTestArgs = {\n  element: NonDeletedExcalidrawElement;\n  point: Point;\n  threshold: number;\n  check: (distance: number, threshold: number) => boolean;\n  frameNameBoundsCache: FrameNameBoundsCache | null;\n};\n\nconst hitTestPointAgainstElement = (args: HitTestArgs): boolean => {\n  switch (args.element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"diamond\":\n    case \"ellipse\":\n      const distance = distanceToBindableElement(args.element, args.point);\n      return args.check(distance, args.threshold);\n    case \"freedraw\": {\n      if (\n        !args.check(\n          distanceToRectangle(args.element, args.point),\n          args.threshold,\n        )\n      ) {\n        return false;\n      }\n\n      return hitTestFreeDrawElement(args.element, args.point, args.threshold);\n    }\n    case \"arrow\":\n    case \"line\":\n      return hitTestLinear(args);\n    case \"selection\":\n      console.warn(\n        \"This should not happen, we need to investigate why it does.\",\n      );\n      return false;\n    case \"frame\": {\n      // check distance to frame element first\n      if (\n        args.check(\n          distanceToBindableElement(args.element, args.point),\n          args.threshold,\n        )\n      ) {\n        return true;\n      }\n\n      const frameNameBounds = args.frameNameBoundsCache?.get(args.element);\n\n      if (frameNameBounds) {\n        return args.check(\n          distanceToRectangleBox(frameNameBounds, args.point),\n          args.threshold,\n        );\n      }\n      return false;\n    }\n  }\n};\n\nexport const distanceToBindableElement = (\n  element: ExcalidrawBindableElement,\n  point: Point,\n): number => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"frame\":\n      return distanceToRectangle(element, point);\n    case \"diamond\":\n      return distanceToDiamond(element, point);\n    case \"ellipse\":\n      return distanceToEllipse(element, point);\n  }\n};\n\nconst isStrictlyInside = (distance: number, threshold: number): boolean => {\n  return distance < 0;\n};\n\nconst isInsideCheck = (distance: number, threshold: number): boolean => {\n  return distance < threshold;\n};\n\nconst isNearCheck = (distance: number, threshold: number): boolean => {\n  return Math.abs(distance) < threshold;\n};\n\nconst isOutsideCheck = (distance: number, threshold: number): boolean => {\n  return 0 <= distance && distance < threshold;\n};\n\nconst distanceToRectangle = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawTextElement\n    | ExcalidrawFreeDrawElement\n    | ExcalidrawImageElement\n    | ExcalidrawFrameElement,\n  point: Point,\n): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  return Math.max(\n    GAPoint.distanceToLine(pointRel, GALine.equation(0, 1, -hheight)),\n    GAPoint.distanceToLine(pointRel, GALine.equation(1, 0, -hwidth)),\n  );\n};\n\nconst distanceToRectangleBox = (box: RectangleBox, point: Point): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToDivElement(point, box);\n  return Math.max(\n    GAPoint.distanceToLine(pointRel, GALine.equation(0, 1, -hheight)),\n    GAPoint.distanceToLine(pointRel, GALine.equation(1, 0, -hwidth)),\n  );\n};\n\nconst distanceToDiamond = (\n  element: ExcalidrawDiamondElement,\n  point: Point,\n): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const side = GALine.equation(hheight, hwidth, -hheight * hwidth);\n  return GAPoint.distanceToLine(pointRel, side);\n};\n\nconst distanceToEllipse = (\n  element: ExcalidrawEllipseElement,\n  point: Point,\n): number => {\n  const [pointRel, tangent] = ellipseParamsForTest(element, point);\n  return -GALine.sign(tangent) * GAPoint.distanceToLine(pointRel, tangent);\n};\n\nconst ellipseParamsForTest = (\n  element: ExcalidrawEllipseElement,\n  point: Point,\n): [GA.Point, GA.Line] => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const [px, py] = GAPoint.toTuple(pointRel);\n\n  // We're working in positive quadrant, so start with `t = 45deg`, `tx=cos(t)`\n  let tx = 0.707;\n  let ty = 0.707;\n\n  const a = hwidth;\n  const b = hheight;\n\n  // This is a numerical method to find the params tx, ty at which\n  // the ellipse has the closest point to the given point\n  [0, 1, 2, 3].forEach((_) => {\n    const xx = a * tx;\n    const yy = b * ty;\n\n    const ex = ((a * a - b * b) * tx ** 3) / a;\n    const ey = ((b * b - a * a) * ty ** 3) / b;\n\n    const rx = xx - ex;\n    const ry = yy - ey;\n\n    const qx = px - ex;\n    const qy = py - ey;\n\n    const r = Math.hypot(ry, rx);\n    const q = Math.hypot(qy, qx);\n\n    tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n    ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n    const t = Math.hypot(ty, tx);\n    tx /= t;\n    ty /= t;\n  });\n\n  const closestPoint = GA.point(a * tx, b * ty);\n\n  const tangent = GALine.orthogonalThrough(pointRel, closestPoint);\n  return [pointRel, tangent];\n};\n\nconst hitTestFreeDrawElement = (\n  element: ExcalidrawFreeDrawElement,\n  point: Point,\n  threshold: number,\n): boolean => {\n  // Check point-distance-to-line-segment for every segment in the\n  // element's points (its input points, not its outline points).\n  // This is... okay? It's plenty fast, but the GA library may\n  // have a faster option.\n\n  let x: number;\n  let y: number;\n\n  if (element.angle === 0) {\n    x = point[0] - element.x;\n    y = point[1] - element.y;\n  } else {\n    // Counter-rotate the point around center before testing\n    const [minX, minY, maxX, maxY] = getElementAbsoluteCoords(element);\n    const rotatedPoint = rotatePoint(\n      point,\n      [minX + (maxX - minX) / 2, minY + (maxY - minY) / 2],\n      -element.angle,\n    );\n    x = rotatedPoint[0] - element.x;\n    y = rotatedPoint[1] - element.y;\n  }\n\n  let [A, B] = element.points;\n  let P: readonly [number, number];\n\n  // For freedraw dots\n  if (\n    distance2d(A[0], A[1], x, y) < threshold ||\n    distance2d(B[0], B[1], x, y) < threshold\n  ) {\n    return true;\n  }\n\n  // For freedraw lines\n  for (let i = 0; i < element.points.length; i++) {\n    const delta = [B[0] - A[0], B[1] - A[1]];\n    const length = Math.hypot(delta[1], delta[0]);\n\n    const U = [delta[0] / length, delta[1] / length];\n    const C = [x - A[0], y - A[1]];\n    const d = (C[0] * U[0] + C[1] * U[1]) / Math.hypot(U[1], U[0]);\n    P = [A[0] + U[0] * d, A[1] + U[1] * d];\n\n    const da = distance2d(P[0], P[1], A[0], A[1]);\n    const db = distance2d(P[0], P[1], B[0], B[1]);\n\n    P = db < da && da > length ? B : da < db && db > length ? A : P;\n\n    if (Math.hypot(y - P[1], x - P[0]) < threshold) {\n      return true;\n    }\n\n    A = B;\n    B = element.points[i + 1];\n  }\n\n  const shape = getShapeForElement(element);\n\n  // for filled freedraw shapes, support\n  // selecting from inside\n  if (shape && shape.sets.length) {\n    return hitTestRoughShape(shape, x, y, threshold);\n  }\n\n  return false;\n};\n\nconst hitTestLinear = (args: HitTestArgs): boolean => {\n  const { element, threshold } = args;\n  if (!getShapeForElement(element)) {\n    return false;\n  }\n\n  const [point, pointAbs, hwidth, hheight] = pointRelativeToElement(\n    args.element,\n    args.point,\n  );\n  const side1 = GALine.equation(0, 1, -hheight);\n  const side2 = GALine.equation(1, 0, -hwidth);\n  if (\n    !isInsideCheck(GAPoint.distanceToLine(pointAbs, side1), threshold) ||\n    !isInsideCheck(GAPoint.distanceToLine(pointAbs, side2), threshold)\n  ) {\n    return false;\n  }\n  const [relX, relY] = GAPoint.toTuple(point);\n\n  const shape = getShapeForElement(element as ExcalidrawLinearElement);\n\n  if (!shape) {\n    return false;\n  }\n\n  if (args.check === isInsideCheck) {\n    const hit = shape.some((subshape) =>\n      hitTestCurveInside(\n        subshape,\n        relX,\n        relY,\n        element.roundness ? \"round\" : \"sharp\",\n      ),\n    );\n    if (hit) {\n      return true;\n    }\n  }\n\n  // hit test all \"subshapes\" of the linear element\n  return shape.some((subshape) =>\n    hitTestRoughShape(subshape, relX, relY, threshold),\n  );\n};\n\n// Returns:\n//   1. the point relative to the elements (x, y) position\n//   2. the point relative to the element's center with positive (x, y)\n//   3. half element width\n//   4. half element height\n//\n// Note that for linear elements the (x, y) position is not at the\n// top right corner of their boundary.\n//\n// Rectangles, diamonds and ellipses are symmetrical over axes,\n// and other elements have a rectangular boundary,\n// so we only need to perform hit tests for the positive quadrant.\nconst pointRelativeToElement = (\n  element: ExcalidrawElement,\n  pointTuple: Point,\n): [GA.Point, GA.Point, number, number] => {\n  const point = GAPoint.from(pointTuple);\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const center = coordsCenter(x1, y1, x2, y2);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const pointRotated = GATransform.apply(rotate, point);\n  const pointRelToCenter = GA.sub(pointRotated, GADirection.from(center));\n  const pointRelToCenterAbs = GAPoint.abs(pointRelToCenter);\n  const elementPos = GA.offset(element.x, element.y);\n  const pointRelToPos = GA.sub(pointRotated, elementPos);\n  const halfWidth = (x2 - x1) / 2;\n  const halfHeight = (y2 - y1) / 2;\n  return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];\n};\n\nconst pointRelativeToDivElement = (\n  pointTuple: Point,\n  rectangle: RectangleBox,\n): [GA.Point, GA.Point, number, number] => {\n  const point = GAPoint.from(pointTuple);\n  const [x1, y1, x2, y2] = getRectangleBoxAbsoluteCoords(rectangle);\n  const center = coordsCenter(x1, y1, x2, y2);\n  const rotate = GATransform.rotation(center, rectangle.angle);\n  const pointRotated = GATransform.apply(rotate, point);\n  const pointRelToCenter = GA.sub(pointRotated, GADirection.from(center));\n  const pointRelToCenterAbs = GAPoint.abs(pointRelToCenter);\n  const elementPos = GA.offset(rectangle.x, rectangle.y);\n  const pointRelToPos = GA.sub(pointRotated, elementPos);\n  const halfWidth = (x2 - x1) / 2;\n  const halfHeight = (y2 - y1) / 2;\n  return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];\n};\n\n// Returns point in absolute coordinates\nexport const pointInAbsoluteCoords = (\n  element: ExcalidrawElement,\n  // Point relative to the element position\n  point: Point,\n): Point => {\n  const [x, y] = point;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2;\n  const cy = (y2 - y1) / 2;\n  const [rotatedX, rotatedY] = rotate(x, y, cx, cy, element.angle);\n  return [element.x + rotatedX, element.y + rotatedY];\n};\n\nconst relativizationToElementCenter = (\n  element: ExcalidrawElement,\n): GA.Transform => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const center = coordsCenter(x1, y1, x2, y2);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const translate = GA.reverse(\n    GATransform.translation(GADirection.from(center)),\n  );\n  return GATransform.compose(rotate, translate);\n};\n\nconst coordsCenter = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n): GA.Point => {\n  return GA.point((x1 + x2) / 2, (y1 + y2) / 2);\n};\n\n// The focus distance is the oriented ratio between the size of\n// the `element` and the \"focus image\" of the element on which\n// all focus points lie, so it's a number between -1 and 1.\n// The line going through `a` and `b` is a tangent to the \"focus image\"\n// of the element.\nexport const determineFocusDistance = (\n  element: ExcalidrawBindableElement,\n  // Point on the line, in absolute coordinates\n  a: Point,\n  // Another point on the line, in absolute coordinates (closer to element)\n  b: Point,\n): number => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const q = element.height / element.width;\n  const hwidth = element.width / 2;\n  const hheight = element.height / 2;\n  const n = line[2];\n  const m = line[3];\n  const c = line[1];\n  const mabs = Math.abs(m);\n  const nabs = Math.abs(n);\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"frame\":\n      return c / (hwidth * (nabs + q * mabs));\n    case \"diamond\":\n      return mabs < nabs ? c / (nabs * hwidth) : c / (mabs * hheight);\n    case \"ellipse\":\n      return c / (hwidth * Math.sqrt(n ** 2 + q ** 2 * m ** 2));\n  }\n};\n\nexport const determineFocusPoint = (\n  element: ExcalidrawBindableElement,\n  // The oriented, relative distance from the center of `element` of the\n  // returned focusPoint\n  focus: number,\n  adjecentPoint: Point,\n): Point => {\n  if (focus === 0) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const center = coordsCenter(x1, y1, x2, y2);\n    return GAPoint.toTuple(center);\n  }\n  const relateToCenter = relativizationToElementCenter(element);\n  const adjecentPointRel = GATransform.apply(\n    relateToCenter,\n    GAPoint.from(adjecentPoint),\n  );\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  let point;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"diamond\":\n    case \"frame\":\n      point = findFocusPointForRectangulars(element, focus, adjecentPointRel);\n      break;\n    case \"ellipse\":\n      point = findFocusPointForEllipse(element, focus, adjecentPointRel);\n      break;\n  }\n  return GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point));\n};\n\n// Returns 2 or 0 intersection points between line going through `a` and `b`\n// and the `element`, in ascending order of distance from `a`.\nexport const intersectElementWithLine = (\n  element: ExcalidrawBindableElement,\n  // Point on the line, in absolute coordinates\n  a: Point,\n  // Another point on the line, in absolute coordinates\n  b: Point,\n  // If given, the element is inflated by this value\n  gap: number = 0,\n): Point[] => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  const intersections = getSortedElementLineIntersections(\n    element,\n    line,\n    aRel,\n    gap,\n  );\n  return intersections.map((point) =>\n    GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point)),\n  );\n};\n\nconst getSortedElementLineIntersections = (\n  element: ExcalidrawBindableElement,\n  // Relative to element center\n  line: GA.Line,\n  // Relative to element center\n  nearPoint: GA.Point,\n  gap: number = 0,\n): GA.Point[] => {\n  let intersections: GA.Point[];\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"diamond\":\n    case \"frame\":\n      const corners = getCorners(element);\n      intersections = corners\n        .flatMap((point, i) => {\n          const edge: [GA.Point, GA.Point] = [point, corners[(i + 1) % 4]];\n          return intersectSegment(line, offsetSegment(edge, gap));\n        })\n        .concat(\n          corners.flatMap((point) => getCircleIntersections(point, gap, line)),\n        );\n      break;\n    case \"ellipse\":\n      intersections = getEllipseIntersections(element, gap, line);\n      break;\n  }\n  if (intersections.length < 2) {\n    // Ignore the \"edge\" case of only intersecting with a single corner\n    return [];\n  }\n  const sortedIntersections = intersections.sort(\n    (i1, i2) =>\n      GAPoint.distance(i1, nearPoint) - GAPoint.distance(i2, nearPoint),\n  );\n  return [\n    sortedIntersections[0],\n    sortedIntersections[sortedIntersections.length - 1],\n  ];\n};\n\nconst getCorners = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawImageElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawTextElement\n    | ExcalidrawFrameElement,\n  scale: number = 1,\n): GA.Point[] => {\n  const hx = (scale * element.width) / 2;\n  const hy = (scale * element.height) / 2;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"frame\":\n      return [\n        GA.point(hx, hy),\n        GA.point(hx, -hy),\n        GA.point(-hx, -hy),\n        GA.point(-hx, hy),\n      ];\n    case \"diamond\":\n      return [\n        GA.point(0, hy),\n        GA.point(hx, 0),\n        GA.point(0, -hy),\n        GA.point(-hx, 0),\n      ];\n  }\n};\n\n// Returns intersection of `line` with `segment`, with `segment` moved by\n// `gap` in its polar direction.\n// If intersection coincides with second segment point returns empty array.\nconst intersectSegment = (\n  line: GA.Line,\n  segment: [GA.Point, GA.Point],\n): GA.Point[] => {\n  const [a, b] = segment;\n  const aDist = GAPoint.distanceToLine(a, line);\n  const bDist = GAPoint.distanceToLine(b, line);\n  if (aDist * bDist >= 0) {\n    // The intersection is outside segment `(a, b)`\n    return [];\n  }\n  return [GAPoint.intersect(line, GALine.through(a, b))];\n};\n\nconst offsetSegment = (\n  segment: [GA.Point, GA.Point],\n  distance: number,\n): [GA.Point, GA.Point] => {\n  const [a, b] = segment;\n  const offset = GATransform.translationOrthogonal(\n    GADirection.fromTo(a, b),\n    distance,\n  );\n  return [GATransform.apply(offset, a), GATransform.apply(offset, b)];\n};\n\nconst getEllipseIntersections = (\n  element: ExcalidrawEllipseElement,\n  gap: number,\n  line: GA.Line,\n): GA.Point[] => {\n  const a = element.width / 2 + gap;\n  const b = element.height / 2 + gap;\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const squares = a * a * m * m + b * b * n * n;\n  const discr = squares - c * c;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = -a * a * m * c;\n  const yn = -b * b * n * c;\n  return [\n    GA.point(\n      (xn + a * b * n * discrRoot) / squares,\n      (yn - a * b * m * discrRoot) / squares,\n    ),\n    GA.point(\n      (xn - a * b * n * discrRoot) / squares,\n      (yn + a * b * m * discrRoot) / squares,\n    ),\n  ];\n};\n\nexport const getCircleIntersections = (\n  center: GA.Point,\n  radius: number,\n  line: GA.Line,\n): GA.Point[] => {\n  if (radius === 0) {\n    return GAPoint.distanceToLine(line, center) === 0 ? [center] : [];\n  }\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const [a, b] = GAPoint.toTuple(center);\n  const r = radius;\n  const squares = m * m + n * n;\n  const discr = r * r * squares - (m * a + n * b + c) ** 2;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = a * n * n - b * m * n - m * c;\n  const yn = b * m * m - a * m * n - n * c;\n\n  return [\n    GA.point((xn + n * discrRoot) / squares, (yn - m * discrRoot) / squares),\n    GA.point((xn - n * discrRoot) / squares, (yn + m * discrRoot) / squares),\n  ];\n};\n\n// The focus point is the tangent point of the \"focus image\" of the\n// `element`, where the tangent goes through `point`.\nexport const findFocusPointForEllipse = (\n  ellipse: ExcalidrawEllipseElement,\n  // Between -1 and 1 (not 0) the relative size of the \"focus image\" of\n  // the element on which the focus point lies\n  relativeDistance: number,\n  // The point for which we're trying to find the focus point, relative\n  // to the ellipse center.\n  point: GA.Point,\n): GA.Point => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const a = (ellipse.width * relativeDistanceAbs) / 2;\n  const b = (ellipse.height * relativeDistanceAbs) / 2;\n\n  const orientation = Math.sign(relativeDistance);\n  const [px, pyo] = GAPoint.toTuple(point);\n\n  // The calculation below can't handle py = 0\n  const py = pyo === 0 ? 0.0001 : pyo;\n\n  const squares = px ** 2 * b ** 2 + py ** 2 * a ** 2;\n  // Tangent mx + ny + 1 = 0\n  const m =\n    (-px * b ** 2 +\n      orientation * py * Math.sqrt(Math.max(0, squares - a ** 2 * b ** 2))) /\n    squares;\n\n  let n = (-m * px - 1) / py;\n\n  if (n === 0) {\n    // if zero {-0, 0}, fall back to a same-sign value in the similar range\n    n = (Object.is(n, -0) ? -1 : 1) * 0.01;\n  }\n\n  const x = -(a ** 2 * m) / (n ** 2 * b ** 2 + m ** 2 * a ** 2);\n  return GA.point(x, (-m * x - 1) / n);\n};\n\nexport const findFocusPointForRectangulars = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawImageElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawTextElement\n    | ExcalidrawFrameElement,\n  // Between -1 and 1 for how far away should the focus point be relative\n  // to the size of the element. Sign determines orientation.\n  relativeDistance: number,\n  // The point for which we're trying to find the focus point, relative\n  // to the element center.\n  point: GA.Point,\n): GA.Point => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const orientation = Math.sign(relativeDistance);\n  const corners = getCorners(element, relativeDistanceAbs);\n\n  let maxDistance = 0;\n  let tangentPoint: null | GA.Point = null;\n  corners.forEach((corner) => {\n    const distance = orientation * GALine.through(point, corner)[1];\n    if (distance > maxDistance) {\n      maxDistance = distance;\n      tangentPoint = corner;\n    }\n  });\n  return tangentPoint!;\n};\n\nconst pointInBezierEquation = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  p3: Point,\n  [mx, my]: Point,\n  lineThreshold: number,\n) => {\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // go through t in increments of 0.01\n  let t = 0;\n  while (t <= 1.0) {\n    const tx = equation(t, 0);\n    const ty = equation(t, 1);\n\n    const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));\n\n    if (diff < lineThreshold) {\n      return true;\n    }\n\n    t += 0.01;\n  }\n\n  return false;\n};\n\nconst hitTestCurveInside = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  roundness: StrokeRoundness,\n) => {\n  const ops = getCurvePathOps(drawable);\n  const points: Mutable<Point>[] = [];\n  let odd = false; // select one line out of double lines\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      odd = !odd;\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n      }\n    } else if (operation.op === \"bcurveTo\") {\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n        points.push([operation.data[2], operation.data[3]]);\n        points.push([operation.data[4], operation.data[5]]);\n      }\n    } else if (operation.op === \"lineTo\") {\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n      }\n    }\n  }\n  if (points.length >= 4) {\n    if (roundness === \"sharp\") {\n      return isPointInPolygon(points, x, y);\n    }\n    const polygonPoints = pointsOnBezierCurves(points, 10, 5);\n    return isPointInPolygon(polygonPoints, x, y);\n  }\n  return false;\n};\n\nconst hitTestRoughShape = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  lineThreshold: number,\n) => {\n  // read operations from first opSet\n  const ops = getCurvePathOps(drawable);\n\n  // set start position as (0,0) just in case\n  // move operation does not exist (unlikely but it is worth safekeeping it)\n  let currentP: Point = [0, 0];\n\n  return ops.some(({ op, data }, idx) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = data as unknown as Point;\n      // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]] as Point;\n      const p2 = [data[2], data[3]] as Point;\n      const p3 = [data[4], data[5]] as Point;\n\n      const p0 = currentP;\n      currentP = p3;\n\n      // check if points are on the curve\n      // cubic bezier curves require four parameters\n      // the first parameter is the last stored position (p0)\n      const retVal = pointInBezierEquation(\n        p0,\n        p1,\n        p2,\n        p3,\n        [x, y],\n        lineThreshold,\n      );\n\n      // set end point of bezier curve as the new starting point for\n      // upcoming operations as each operation is based on the last drawn\n      // position of the previous operation\n      return retVal;\n    } else if (op === \"lineTo\") {\n      return hitTestCurveInside(drawable, x, y, \"sharp\");\n    } else if (op === \"qcurveTo\") {\n      // TODO: Implement this\n      console.warn(\"qcurveTo is not implemented yet\");\n    }\n\n    return false;\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}