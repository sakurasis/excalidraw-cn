{"ast":null,"code":"import { CODES, KEYS } from \"../keys\";\nimport { isWritableElement, getFontString, getFontFamilyString, isTestEnv } from \"../utils\";\nimport Scene from \"../scene/Scene\";\nimport { isArrowElement, isBoundToContainer, isTextElement } from \"./typeChecks\";\nimport { CLASSES, isSafari } from \"../constants\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getBoundTextElementId, getContainerDims, getContainerElement, getTextElementAngle, getTextWidth, normalizeText, redrawTextBoundingBox, wrapText, getBoundTextMaxHeight, getBoundTextMaxWidth, computeContainerDimensionForBoundText, detectLineHeight, computeBoundTextPosition } from \"./textElement\";\nimport { actionDecreaseFontSize, actionIncreaseFontSize } from \"../actions/actionProperties\";\nimport { actionZoomIn, actionZoomOut } from \"../actions/actionCanvas\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { parseClipboard } from \"../clipboard\";\nconst getTransform = (width, height, angle, appState, maxWidth, maxHeight) => {\n  const {\n    zoom\n  } = appState;\n  const degree = 180 * angle / Math.PI;\n  let translateX = width * (zoom.value - 1) / 2;\n  let translateY = height * (zoom.value - 1) / 2;\n  if (width > maxWidth && zoom.value !== 1) {\n    translateX = maxWidth * (zoom.value - 1) / 2;\n  }\n  if (height > maxHeight && zoom.value !== 1) {\n    translateY = maxHeight * (zoom.value - 1) / 2;\n  }\n  return `translate(${translateX}px, ${translateY}px) scale(${zoom.value}) rotate(${degree}deg)`;\n};\nconst originalContainerCache = {};\nexport const updateOriginalContainerCache = (id, height) => {\n  const data = originalContainerCache[id] || (originalContainerCache[id] = {\n    height\n  });\n  data.height = height;\n  return data;\n};\nexport const resetOriginalContainerCache = id => {\n  if (originalContainerCache[id]) {\n    delete originalContainerCache[id];\n  }\n};\nexport const getOriginalContainerHeightFromCache = id => {\n  var _originalContainerCac, _originalContainerCac2;\n  return (_originalContainerCac = (_originalContainerCac2 = originalContainerCache[id]) === null || _originalContainerCac2 === void 0 ? void 0 : _originalContainerCac2.height) !== null && _originalContainerCac !== void 0 ? _originalContainerCac : null;\n};\nexport const textWysiwyg = _ref => {\n  let {\n    id,\n    onChange,\n    onSubmit,\n    getViewportCoords,\n    element,\n    canvas,\n    excalidrawContainer,\n    app\n  } = _ref;\n  const textPropertiesUpdated = (updatedTextElement, editable) => {\n    if (!editable.style.fontFamily || !editable.style.fontSize) {\n      return false;\n    }\n    const currentFont = editable.style.fontFamily.replace(/\"/g, \"\");\n    if (getFontFamilyString({\n      fontFamily: updatedTextElement.fontFamily\n    }) !== currentFont) {\n      return true;\n    }\n    if (`${updatedTextElement.fontSize}px` !== editable.style.fontSize) {\n      return true;\n    }\n    return false;\n  };\n  const updateWysiwygStyle = () => {\n    var _Scene$getScene;\n    const appState = app.state;\n    const updatedTextElement = (_Scene$getScene = Scene.getScene(element)) === null || _Scene$getScene === void 0 ? void 0 : _Scene$getScene.getElement(id);\n    if (!updatedTextElement) {\n      return;\n    }\n    const {\n      textAlign,\n      verticalAlign\n    } = updatedTextElement;\n    if (updatedTextElement && isTextElement(updatedTextElement)) {\n      let coordX = updatedTextElement.x;\n      let coordY = updatedTextElement.y;\n      const container = getContainerElement(updatedTextElement);\n      let maxWidth = updatedTextElement.width;\n      let maxHeight = updatedTextElement.height;\n      let textElementWidth = updatedTextElement.width;\n      // Set to element height by default since that's\n      // what is going to be used for unbounded text\n      const textElementHeight = updatedTextElement.height;\n      if (container && updatedTextElement.containerId) {\n        if (isArrowElement(container)) {\n          const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(container, updatedTextElement);\n          coordX = boundTextCoords.x;\n          coordY = boundTextCoords.y;\n        }\n        const propertiesUpdated = textPropertiesUpdated(updatedTextElement, editable);\n        const containerDims = getContainerDims(container);\n        let originalContainerData;\n        if (propertiesUpdated) {\n          originalContainerData = updateOriginalContainerCache(container.id, containerDims.height);\n        } else {\n          originalContainerData = originalContainerCache[container.id];\n          if (!originalContainerData) {\n            originalContainerData = updateOriginalContainerCache(container.id, containerDims.height);\n          }\n        }\n        maxWidth = getBoundTextMaxWidth(container);\n        maxHeight = getBoundTextMaxHeight(container, updatedTextElement);\n\n        // autogrow container height if text exceeds\n        if (!isArrowElement(container) && textElementHeight > maxHeight) {\n          const targetContainerHeight = computeContainerDimensionForBoundText(textElementHeight, container.type);\n          mutateElement(container, {\n            height: targetContainerHeight\n          });\n          return;\n        } else if (\n        // autoshrink container height until original container height\n        // is reached when text is removed\n        !isArrowElement(container) && containerDims.height > originalContainerData.height && textElementHeight < maxHeight) {\n          const targetContainerHeight = computeContainerDimensionForBoundText(textElementHeight, container.type);\n          mutateElement(container, {\n            height: targetContainerHeight\n          });\n        } else {\n          const {\n            y\n          } = computeBoundTextPosition(container, updatedTextElement);\n          coordY = y;\n        }\n      }\n      const [viewportX, viewportY] = getViewportCoords(coordX, coordY);\n      const initialSelectionStart = editable.selectionStart;\n      const initialSelectionEnd = editable.selectionEnd;\n      const initialLength = editable.value.length;\n\n      // restore cursor position after value updated so it doesn't\n      // go to the end of text when container auto expanded\n      if (initialSelectionStart === initialSelectionEnd && initialSelectionEnd !== initialLength) {\n        // get diff between length and selection end and shift\n        // the cursor by \"diff\" times to position correctly\n        const diff = initialLength - initialSelectionEnd;\n        editable.selectionStart = editable.value.length - diff;\n        editable.selectionEnd = editable.value.length - diff;\n      }\n      if (!container) {\n        maxWidth = (appState.width - 8 - viewportX) / appState.zoom.value;\n        textElementWidth = Math.min(textElementWidth, maxWidth);\n      } else {\n        textElementWidth += 0.5;\n      }\n      let lineHeight = updatedTextElement.lineHeight;\n\n      // In Safari the font size gets rounded off when rendering hence calculating the line height by rounding off font size\n      if (isSafari) {\n        lineHeight = detectLineHeight({\n          ...updatedTextElement,\n          fontSize: Math.round(updatedTextElement.fontSize)\n        });\n      }\n\n      // Make sure text editor height doesn't go beyond viewport\n      const editorMaxHeight = (appState.height - viewportY) / appState.zoom.value;\n      Object.assign(editable.style, {\n        font: getFontString(updatedTextElement),\n        // must be defined *after* font ¯\\_(ツ)_/¯\n        lineHeight,\n        width: `${textElementWidth}px`,\n        height: `${textElementHeight}px`,\n        left: `${viewportX}px`,\n        top: `${viewportY}px`,\n        transform: getTransform(textElementWidth, textElementHeight, getTextElementAngle(updatedTextElement), appState, maxWidth, editorMaxHeight),\n        textAlign,\n        verticalAlign,\n        color: updatedTextElement.strokeColor,\n        opacity: updatedTextElement.opacity / 100,\n        filter: \"var(--theme-filter)\",\n        maxHeight: `${editorMaxHeight}px`\n      });\n      editable.scrollTop = 0;\n      // For some reason updating font attribute doesn't set font family\n      // hence updating font family explicitly for test environment\n      if (isTestEnv()) {\n        editable.style.fontFamily = getFontFamilyString(updatedTextElement);\n      }\n      mutateElement(updatedTextElement, {\n        x: coordX,\n        y: coordY\n      });\n    }\n  };\n  const editable = document.createElement(\"textarea\");\n  editable.dir = \"auto\";\n  editable.tabIndex = 0;\n  editable.dataset.type = \"wysiwyg\";\n  // prevent line wrapping on Safari\n  editable.wrap = \"off\";\n  editable.classList.add(\"excalidraw-wysiwyg\");\n  let whiteSpace = \"pre\";\n  let wordBreak = \"normal\";\n  if (isBoundToContainer(element)) {\n    whiteSpace = \"pre-wrap\";\n    wordBreak = \"break-word\";\n  }\n  Object.assign(editable.style, {\n    position: \"absolute\",\n    display: \"inline-block\",\n    minHeight: \"1em\",\n    backfaceVisibility: \"hidden\",\n    margin: 0,\n    padding: 0,\n    border: 0,\n    outline: 0,\n    resize: \"none\",\n    background: \"transparent\",\n    overflow: \"hidden\",\n    // must be specified because in dark mode canvas creates a stacking context\n    zIndex: \"var(--zIndex-wysiwyg)\",\n    wordBreak,\n    // prevent line wrapping (`whitespace: nowrap` doesn't work on FF)\n    whiteSpace,\n    overflowWrap: \"break-word\",\n    boxSizing: \"content-box\"\n  });\n  editable.value = element.originalText;\n  updateWysiwygStyle();\n  if (onChange) {\n    editable.onpaste = async event => {\n      const clipboardData = await parseClipboard(event, true);\n      if (!clipboardData.text) {\n        return;\n      }\n      const data = normalizeText(clipboardData.text);\n      if (!data) {\n        return;\n      }\n      const container = getContainerElement(element);\n      const font = getFontString({\n        fontSize: app.state.currentItemFontSize,\n        fontFamily: app.state.currentItemFontFamily\n      });\n      if (container) {\n        const wrappedText = wrapText(`${editable.value}${data}`, font, getBoundTextMaxWidth(container));\n        const width = getTextWidth(wrappedText, font);\n        editable.style.width = `${width}px`;\n      }\n    };\n    editable.oninput = () => {\n      onChange(normalizeText(editable.value));\n    };\n  }\n  editable.onkeydown = event => {\n    if (!event.shiftKey && actionZoomIn.keyTest(event)) {\n      event.preventDefault();\n      app.actionManager.executeAction(actionZoomIn);\n      updateWysiwygStyle();\n    } else if (!event.shiftKey && actionZoomOut.keyTest(event)) {\n      event.preventDefault();\n      app.actionManager.executeAction(actionZoomOut);\n      updateWysiwygStyle();\n    } else if (actionDecreaseFontSize.keyTest(event)) {\n      app.actionManager.executeAction(actionDecreaseFontSize);\n    } else if (actionIncreaseFontSize.keyTest(event)) {\n      app.actionManager.executeAction(actionIncreaseFontSize);\n    } else if (event.key === KEYS.ESCAPE) {\n      event.preventDefault();\n      submittedViaKeyboard = true;\n      handleSubmit();\n    } else if (event.key === KEYS.ENTER && event[KEYS.CTRL_OR_CMD]) {\n      event.preventDefault();\n      if (event.isComposing || event.keyCode === 229) {\n        return;\n      }\n      submittedViaKeyboard = true;\n      handleSubmit();\n    } else if (event.key === KEYS.TAB || event[KEYS.CTRL_OR_CMD] && (event.code === CODES.BRACKET_LEFT || event.code === CODES.BRACKET_RIGHT)) {\n      event.preventDefault();\n      if (event.isComposing) {\n        return;\n      } else if (event.shiftKey || event.code === CODES.BRACKET_LEFT) {\n        outdent();\n      } else {\n        indent();\n      }\n      // We must send an input event to resize the element\n      editable.dispatchEvent(new Event(\"input\"));\n    }\n  };\n  const TAB_SIZE = 4;\n  const TAB = \" \".repeat(TAB_SIZE);\n  const RE_LEADING_TAB = new RegExp(`^ {1,${TAB_SIZE}}`);\n  const indent = () => {\n    const {\n      selectionStart,\n      selectionEnd\n    } = editable;\n    const linesStartIndices = getSelectedLinesStartIndices();\n    let value = editable.value;\n    linesStartIndices.forEach(startIndex => {\n      const startValue = value.slice(0, startIndex);\n      const endValue = value.slice(startIndex);\n      value = `${startValue}${TAB}${endValue}`;\n    });\n    editable.value = value;\n    editable.selectionStart = selectionStart + TAB_SIZE;\n    editable.selectionEnd = selectionEnd + TAB_SIZE * linesStartIndices.length;\n  };\n  const outdent = () => {\n    const {\n      selectionStart,\n      selectionEnd\n    } = editable;\n    const linesStartIndices = getSelectedLinesStartIndices();\n    const removedTabs = [];\n    let value = editable.value;\n    linesStartIndices.forEach(startIndex => {\n      const tabMatch = value.slice(startIndex, startIndex + TAB_SIZE).match(RE_LEADING_TAB);\n      if (tabMatch) {\n        const startValue = value.slice(0, startIndex);\n        const endValue = value.slice(startIndex + tabMatch[0].length);\n\n        // Delete a tab from the line\n        value = `${startValue}${endValue}`;\n        removedTabs.push(startIndex);\n      }\n    });\n    editable.value = value;\n    if (removedTabs.length) {\n      if (selectionStart > removedTabs[removedTabs.length - 1]) {\n        editable.selectionStart = Math.max(selectionStart - TAB_SIZE, removedTabs[removedTabs.length - 1]);\n      } else {\n        // If the cursor is before the first tab removed, ex:\n        // Line| #1\n        //     Line #2\n        // Lin|e #3\n        // we should reset the selectionStart to his initial value.\n        editable.selectionStart = selectionStart;\n      }\n      editable.selectionEnd = Math.max(editable.selectionStart, selectionEnd - TAB_SIZE * removedTabs.length);\n    }\n  };\n\n  /**\n   * @returns indices of start positions of selected lines, in reverse order\n   */\n  const getSelectedLinesStartIndices = () => {\n    let {\n      selectionStart,\n      selectionEnd,\n      value\n    } = editable;\n\n    // chars before selectionStart on the same line\n    const startOffset = value.slice(0, selectionStart).match(/[^\\n]*$/)[0].length;\n    // put caret at the start of the line\n    selectionStart = selectionStart - startOffset;\n    const selected = value.slice(selectionStart, selectionEnd);\n    return selected.split(\"\\n\").reduce((startIndices, line, idx, lines) => startIndices.concat(idx ?\n    // curr line index is prev line's start + prev line's length + \\n\n    startIndices[idx - 1] + lines[idx - 1].length + 1 :\n    // first selected line\n    selectionStart), []).reverse();\n  };\n  const stopEvent = event => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  // using a state variable instead of passing it to the handleSubmit callback\n  // so that we don't need to create separate a callback for event handlers\n  let submittedViaKeyboard = false;\n  const handleSubmit = () => {\n    var _Scene$getScene2;\n    // cleanup must be run before onSubmit otherwise when app blurs the wysiwyg\n    // it'd get stuck in an infinite loop of blur→onSubmit after we re-focus the\n    // wysiwyg on update\n    cleanup();\n    const updateElement = (_Scene$getScene2 = Scene.getScene(element)) === null || _Scene$getScene2 === void 0 ? void 0 : _Scene$getScene2.getElement(element.id);\n    if (!updateElement) {\n      return;\n    }\n    let text = editable.value;\n    const container = getContainerElement(updateElement);\n    if (container) {\n      text = updateElement.text;\n      if (editable.value.trim()) {\n        const boundTextElementId = getBoundTextElementId(container);\n        if (!boundTextElementId || boundTextElementId !== element.id) {\n          mutateElement(container, {\n            boundElements: (container.boundElements || []).concat({\n              type: \"text\",\n              id: element.id\n            })\n          });\n        }\n      } else {\n        var _container$boundEleme;\n        mutateElement(container, {\n          boundElements: (_container$boundEleme = container.boundElements) === null || _container$boundEleme === void 0 ? void 0 : _container$boundEleme.filter(ele => !isTextElement(ele))\n        });\n      }\n      redrawTextBoundingBox(updateElement, container);\n    }\n    onSubmit({\n      text,\n      viaKeyboard: submittedViaKeyboard,\n      originalText: editable.value\n    });\n  };\n  const cleanup = () => {\n    if (isDestroyed) {\n      return;\n    }\n    isDestroyed = true;\n    // remove events to ensure they don't late-fire\n    editable.onblur = null;\n    editable.oninput = null;\n    editable.onkeydown = null;\n    if (observer) {\n      observer.disconnect();\n    }\n    window.removeEventListener(\"resize\", updateWysiwygStyle);\n    window.removeEventListener(\"wheel\", stopEvent, true);\n    window.removeEventListener(\"pointerdown\", onPointerDown);\n    window.removeEventListener(\"pointerup\", bindBlurEvent);\n    window.removeEventListener(\"blur\", handleSubmit);\n    unbindUpdate();\n    editable.remove();\n  };\n  const bindBlurEvent = event => {\n    window.removeEventListener(\"pointerup\", bindBlurEvent);\n    // Deferred so that the pointerdown that initiates the wysiwyg doesn't\n    // trigger the blur on ensuing pointerup.\n    // Also to handle cases such as picking a color which would trigger a blur\n    // in that same tick.\n    const target = event === null || event === void 0 ? void 0 : event.target;\n    const isTargetPickerTrigger = target instanceof HTMLElement && target.classList.contains(\"active-color\");\n    setTimeout(() => {\n      editable.onblur = handleSubmit;\n      if (isTargetPickerTrigger) {\n        const callback = (mutationList, observer) => {\n          const radixIsRemoved = mutationList.find(mutation => {\n            var _dataset;\n            return mutation.removedNodes.length > 0 && ((_dataset = mutation.removedNodes[0].dataset) === null || _dataset === void 0 ? void 0 : _dataset.radixPopperContentWrapper) !== undefined;\n          });\n          if (radixIsRemoved) {\n            // should work without this in theory\n            // and i think it does actually but radix probably somewhere,\n            // somehow sets the focus elsewhere\n            setTimeout(() => {\n              editable.focus();\n            });\n            observer.disconnect();\n          }\n        };\n        const observer = new MutationObserver(callback);\n        observer.observe(document.querySelector(\".excalidraw-container\"), {\n          childList: true\n        });\n      }\n\n      // case: clicking on the same property → no change → no update → no focus\n      if (!isTargetPickerTrigger) {\n        editable.focus();\n      }\n    });\n  };\n\n  // prevent blur when changing properties from the menu\n  const onPointerDown = event => {\n    const isTargetPickerTrigger = event.target instanceof HTMLElement && event.target.classList.contains(\"active-color\");\n    if ((event.target instanceof HTMLElement || event.target instanceof SVGElement) && event.target.closest(`.${CLASSES.SHAPE_ACTIONS_MENU}`) && !isWritableElement(event.target) || isTargetPickerTrigger) {\n      editable.onblur = null;\n      window.addEventListener(\"pointerup\", bindBlurEvent);\n      // handle edge-case where pointerup doesn't fire e.g. due to user\n      // alt-tabbing away\n      window.addEventListener(\"blur\", handleSubmit);\n    }\n  };\n\n  // handle updates of textElement properties of editing element\n  const unbindUpdate = Scene.getScene(element).addCallback(() => {\n    var _document$activeEleme;\n    updateWysiwygStyle();\n    const isColorPickerActive = !!((_document$activeEleme = document.activeElement) !== null && _document$activeEleme !== void 0 && _document$activeEleme.closest(\".color-picker-content\"));\n    if (!isColorPickerActive) {\n      editable.focus();\n    }\n  });\n\n  // ---------------------------------------------------------------------------\n\n  let isDestroyed = false;\n\n  // select on init (focusing is done separately inside the bindBlurEvent()\n  // because we need it to happen *after* the blur event from `pointerdown`)\n  editable.select();\n  bindBlurEvent();\n\n  // reposition wysiwyg in case of canvas is resized. Using ResizeObserver\n  // is preferred so we catch changes from host, where window may not resize.\n  let observer = null;\n  if (canvas && \"ResizeObserver\" in window) {\n    observer = new window.ResizeObserver(() => {\n      updateWysiwygStyle();\n    });\n    observer.observe(canvas);\n  } else {\n    window.addEventListener(\"resize\", updateWysiwygStyle);\n  }\n  window.addEventListener(\"pointerdown\", onPointerDown);\n  window.addEventListener(\"wheel\", stopEvent, {\n    passive: false,\n    capture: true\n  });\n  excalidrawContainer === null || excalidrawContainer === void 0 ? void 0 : excalidrawContainer.querySelector(\".excalidraw-textEditorContainer\").appendChild(editable);\n};","map":{"version":3,"names":["CODES","KEYS","isWritableElement","getFontString","getFontFamilyString","isTestEnv","Scene","isArrowElement","isBoundToContainer","isTextElement","CLASSES","isSafari","mutateElement","getBoundTextElementId","getContainerDims","getContainerElement","getTextElementAngle","getTextWidth","normalizeText","redrawTextBoundingBox","wrapText","getBoundTextMaxHeight","getBoundTextMaxWidth","computeContainerDimensionForBoundText","detectLineHeight","computeBoundTextPosition","actionDecreaseFontSize","actionIncreaseFontSize","actionZoomIn","actionZoomOut","LinearElementEditor","parseClipboard","getTransform","width","height","angle","appState","maxWidth","maxHeight","zoom","degree","Math","PI","translateX","value","translateY","originalContainerCache","updateOriginalContainerCache","id","data","resetOriginalContainerCache","getOriginalContainerHeightFromCache","_originalContainerCac","_originalContainerCac2","textWysiwyg","_ref","onChange","onSubmit","getViewportCoords","element","canvas","excalidrawContainer","app","textPropertiesUpdated","updatedTextElement","editable","style","fontFamily","fontSize","currentFont","replace","updateWysiwygStyle","_Scene$getScene","state","getScene","getElement","textAlign","verticalAlign","coordX","x","coordY","y","container","textElementWidth","textElementHeight","containerId","boundTextCoords","getBoundTextElementPosition","propertiesUpdated","containerDims","originalContainerData","targetContainerHeight","type","viewportX","viewportY","initialSelectionStart","selectionStart","initialSelectionEnd","selectionEnd","initialLength","length","diff","min","lineHeight","round","editorMaxHeight","Object","assign","font","left","top","transform","color","strokeColor","opacity","filter","scrollTop","document","createElement","dir","tabIndex","dataset","wrap","classList","add","whiteSpace","wordBreak","position","display","minHeight","backfaceVisibility","margin","padding","border","outline","resize","background","overflow","zIndex","overflowWrap","boxSizing","originalText","onpaste","event","clipboardData","text","currentItemFontSize","currentItemFontFamily","wrappedText","oninput","onkeydown","shiftKey","keyTest","preventDefault","actionManager","executeAction","key","ESCAPE","submittedViaKeyboard","handleSubmit","ENTER","CTRL_OR_CMD","isComposing","keyCode","TAB","code","BRACKET_LEFT","BRACKET_RIGHT","outdent","indent","dispatchEvent","Event","TAB_SIZE","repeat","RE_LEADING_TAB","RegExp","linesStartIndices","getSelectedLinesStartIndices","forEach","startIndex","startValue","slice","endValue","removedTabs","tabMatch","match","push","max","startOffset","selected","split","reduce","startIndices","line","idx","lines","concat","reverse","stopEvent","stopPropagation","_Scene$getScene2","cleanup","updateElement","trim","boundTextElementId","boundElements","_container$boundEleme","ele","viaKeyboard","isDestroyed","onblur","observer","disconnect","window","removeEventListener","onPointerDown","bindBlurEvent","unbindUpdate","remove","target","isTargetPickerTrigger","HTMLElement","contains","setTimeout","callback","mutationList","radixIsRemoved","find","mutation","_dataset","removedNodes","radixPopperContentWrapper","undefined","focus","MutationObserver","observe","querySelector","childList","SVGElement","closest","SHAPE_ACTIONS_MENU","addEventListener","addCallback","_document$activeEleme","isColorPickerActive","activeElement","select","ResizeObserver","passive","capture","appendChild"],"sources":["D:/project/excalidraw-cn/src/element/textWysiwyg.tsx"],"sourcesContent":["import { CODES, KEYS } from \"../keys\";\nimport {\n  isWritableElement,\n  getFontString,\n  getFontFamilyString,\n  isTestEnv,\n} from \"../utils\";\nimport Scene from \"../scene/Scene\";\nimport {\n  isArrowElement,\n  isBoundToContainer,\n  isTextElement,\n} from \"./typeChecks\";\nimport { CLASSES, isSafari } from \"../constants\";\nimport {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElementWithContainer,\n  ExcalidrawTextElement,\n  ExcalidrawTextContainer,\n} from \"./types\";\nimport { AppState } from \"../types\";\nimport { mutateElement } from \"./mutateElement\";\nimport {\n  getBoundTextElementId,\n  getContainerDims,\n  getContainerElement,\n  getTextElementAngle,\n  getTextWidth,\n  normalizeText,\n  redrawTextBoundingBox,\n  wrapText,\n  getBoundTextMaxHeight,\n  getBoundTextMaxWidth,\n  computeContainerDimensionForBoundText,\n  detectLineHeight,\n  computeBoundTextPosition,\n} from \"./textElement\";\nimport {\n  actionDecreaseFontSize,\n  actionIncreaseFontSize,\n} from \"../actions/actionProperties\";\nimport { actionZoomIn, actionZoomOut } from \"../actions/actionCanvas\";\nimport App from \"../components/App\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { parseClipboard } from \"../clipboard\";\n\nconst getTransform = (\n  width: number,\n  height: number,\n  angle: number,\n  appState: AppState,\n  maxWidth: number,\n  maxHeight: number,\n) => {\n  const { zoom } = appState;\n  const degree = (180 * angle) / Math.PI;\n  let translateX = (width * (zoom.value - 1)) / 2;\n  let translateY = (height * (zoom.value - 1)) / 2;\n  if (width > maxWidth && zoom.value !== 1) {\n    translateX = (maxWidth * (zoom.value - 1)) / 2;\n  }\n  if (height > maxHeight && zoom.value !== 1) {\n    translateY = (maxHeight * (zoom.value - 1)) / 2;\n  }\n  return `translate(${translateX}px, ${translateY}px) scale(${zoom.value}) rotate(${degree}deg)`;\n};\n\nconst originalContainerCache: {\n  [id: ExcalidrawTextContainer[\"id\"]]:\n    | {\n        height: ExcalidrawTextContainer[\"height\"];\n      }\n    | undefined;\n} = {};\n\nexport const updateOriginalContainerCache = (\n  id: ExcalidrawTextContainer[\"id\"],\n  height: ExcalidrawTextContainer[\"height\"],\n) => {\n  const data =\n    originalContainerCache[id] || (originalContainerCache[id] = { height });\n  data.height = height;\n  return data;\n};\n\nexport const resetOriginalContainerCache = (\n  id: ExcalidrawTextContainer[\"id\"],\n) => {\n  if (originalContainerCache[id]) {\n    delete originalContainerCache[id];\n  }\n};\n\nexport const getOriginalContainerHeightFromCache = (\n  id: ExcalidrawTextContainer[\"id\"],\n) => {\n  return originalContainerCache[id]?.height ?? null;\n};\n\nexport const textWysiwyg = ({\n  id,\n  onChange,\n  onSubmit,\n  getViewportCoords,\n  element,\n  canvas,\n  excalidrawContainer,\n  app,\n}: {\n  id: ExcalidrawElement[\"id\"];\n  onChange?: (text: string) => void;\n  onSubmit: (data: {\n    text: string;\n    viaKeyboard: boolean;\n    originalText: string;\n  }) => void;\n  getViewportCoords: (x: number, y: number) => [number, number];\n  element: ExcalidrawTextElement;\n  canvas: HTMLCanvasElement | null;\n  excalidrawContainer: HTMLDivElement | null;\n  app: App;\n}) => {\n  const textPropertiesUpdated = (\n    updatedTextElement: ExcalidrawTextElement,\n    editable: HTMLTextAreaElement,\n  ) => {\n    if (!editable.style.fontFamily || !editable.style.fontSize) {\n      return false;\n    }\n    const currentFont = editable.style.fontFamily.replace(/\"/g, \"\");\n    if (\n      getFontFamilyString({ fontFamily: updatedTextElement.fontFamily }) !==\n      currentFont\n    ) {\n      return true;\n    }\n    if (`${updatedTextElement.fontSize}px` !== editable.style.fontSize) {\n      return true;\n    }\n    return false;\n  };\n\n  const updateWysiwygStyle = () => {\n    const appState = app.state;\n    const updatedTextElement =\n      Scene.getScene(element)?.getElement<ExcalidrawTextElement>(id);\n\n    if (!updatedTextElement) {\n      return;\n    }\n    const { textAlign, verticalAlign } = updatedTextElement;\n\n    if (updatedTextElement && isTextElement(updatedTextElement)) {\n      let coordX = updatedTextElement.x;\n      let coordY = updatedTextElement.y;\n      const container = getContainerElement(updatedTextElement);\n      let maxWidth = updatedTextElement.width;\n\n      let maxHeight = updatedTextElement.height;\n      let textElementWidth = updatedTextElement.width;\n      // Set to element height by default since that's\n      // what is going to be used for unbounded text\n      const textElementHeight = updatedTextElement.height;\n\n      if (container && updatedTextElement.containerId) {\n        if (isArrowElement(container)) {\n          const boundTextCoords =\n            LinearElementEditor.getBoundTextElementPosition(\n              container,\n              updatedTextElement as ExcalidrawTextElementWithContainer,\n            );\n          coordX = boundTextCoords.x;\n          coordY = boundTextCoords.y;\n        }\n        const propertiesUpdated = textPropertiesUpdated(\n          updatedTextElement,\n          editable,\n        );\n        const containerDims = getContainerDims(container);\n\n        let originalContainerData;\n        if (propertiesUpdated) {\n          originalContainerData = updateOriginalContainerCache(\n            container.id,\n            containerDims.height,\n          );\n        } else {\n          originalContainerData = originalContainerCache[container.id];\n          if (!originalContainerData) {\n            originalContainerData = updateOriginalContainerCache(\n              container.id,\n              containerDims.height,\n            );\n          }\n        }\n\n        maxWidth = getBoundTextMaxWidth(container);\n        maxHeight = getBoundTextMaxHeight(\n          container,\n          updatedTextElement as ExcalidrawTextElementWithContainer,\n        );\n\n        // autogrow container height if text exceeds\n        if (!isArrowElement(container) && textElementHeight > maxHeight) {\n          const targetContainerHeight = computeContainerDimensionForBoundText(\n            textElementHeight,\n            container.type,\n          );\n\n          mutateElement(container, { height: targetContainerHeight });\n          return;\n        } else if (\n          // autoshrink container height until original container height\n          // is reached when text is removed\n          !isArrowElement(container) &&\n          containerDims.height > originalContainerData.height &&\n          textElementHeight < maxHeight\n        ) {\n          const targetContainerHeight = computeContainerDimensionForBoundText(\n            textElementHeight,\n            container.type,\n          );\n          mutateElement(container, { height: targetContainerHeight });\n        } else {\n          const { y } = computeBoundTextPosition(\n            container,\n            updatedTextElement as ExcalidrawTextElementWithContainer,\n          );\n          coordY = y;\n        }\n      }\n      const [viewportX, viewportY] = getViewportCoords(coordX, coordY);\n      const initialSelectionStart = editable.selectionStart;\n      const initialSelectionEnd = editable.selectionEnd;\n      const initialLength = editable.value.length;\n\n      // restore cursor position after value updated so it doesn't\n      // go to the end of text when container auto expanded\n      if (\n        initialSelectionStart === initialSelectionEnd &&\n        initialSelectionEnd !== initialLength\n      ) {\n        // get diff between length and selection end and shift\n        // the cursor by \"diff\" times to position correctly\n        const diff = initialLength - initialSelectionEnd;\n        editable.selectionStart = editable.value.length - diff;\n        editable.selectionEnd = editable.value.length - diff;\n      }\n\n      if (!container) {\n        maxWidth = (appState.width - 8 - viewportX) / appState.zoom.value;\n        textElementWidth = Math.min(textElementWidth, maxWidth);\n      } else {\n        textElementWidth += 0.5;\n      }\n\n      let lineHeight = updatedTextElement.lineHeight;\n\n      // In Safari the font size gets rounded off when rendering hence calculating the line height by rounding off font size\n      if (isSafari) {\n        lineHeight = detectLineHeight({\n          ...updatedTextElement,\n          fontSize: Math.round(updatedTextElement.fontSize),\n        });\n      }\n\n      // Make sure text editor height doesn't go beyond viewport\n      const editorMaxHeight =\n        (appState.height - viewportY) / appState.zoom.value;\n      Object.assign(editable.style, {\n        font: getFontString(updatedTextElement),\n        // must be defined *after* font ¯\\_(ツ)_/¯\n        lineHeight,\n        width: `${textElementWidth}px`,\n        height: `${textElementHeight}px`,\n        left: `${viewportX}px`,\n        top: `${viewportY}px`,\n        transform: getTransform(\n          textElementWidth,\n          textElementHeight,\n          getTextElementAngle(updatedTextElement),\n          appState,\n          maxWidth,\n          editorMaxHeight,\n        ),\n        textAlign,\n        verticalAlign,\n        color: updatedTextElement.strokeColor,\n        opacity: updatedTextElement.opacity / 100,\n        filter: \"var(--theme-filter)\",\n        maxHeight: `${editorMaxHeight}px`,\n      });\n      editable.scrollTop = 0;\n      // For some reason updating font attribute doesn't set font family\n      // hence updating font family explicitly for test environment\n      if (isTestEnv()) {\n        editable.style.fontFamily = getFontFamilyString(updatedTextElement);\n      }\n      mutateElement(updatedTextElement, { x: coordX, y: coordY });\n    }\n  };\n\n  const editable = document.createElement(\"textarea\");\n\n  editable.dir = \"auto\";\n  editable.tabIndex = 0;\n  editable.dataset.type = \"wysiwyg\";\n  // prevent line wrapping on Safari\n  editable.wrap = \"off\";\n  editable.classList.add(\"excalidraw-wysiwyg\");\n\n  let whiteSpace = \"pre\";\n  let wordBreak = \"normal\";\n\n  if (isBoundToContainer(element)) {\n    whiteSpace = \"pre-wrap\";\n    wordBreak = \"break-word\";\n  }\n  Object.assign(editable.style, {\n    position: \"absolute\",\n    display: \"inline-block\",\n    minHeight: \"1em\",\n    backfaceVisibility: \"hidden\",\n    margin: 0,\n    padding: 0,\n    border: 0,\n    outline: 0,\n    resize: \"none\",\n    background: \"transparent\",\n    overflow: \"hidden\",\n    // must be specified because in dark mode canvas creates a stacking context\n    zIndex: \"var(--zIndex-wysiwyg)\",\n    wordBreak,\n    // prevent line wrapping (`whitespace: nowrap` doesn't work on FF)\n    whiteSpace,\n    overflowWrap: \"break-word\",\n    boxSizing: \"content-box\",\n  });\n  editable.value = element.originalText;\n  updateWysiwygStyle();\n\n  if (onChange) {\n    editable.onpaste = async (event) => {\n      const clipboardData = await parseClipboard(event, true);\n      if (!clipboardData.text) {\n        return;\n      }\n      const data = normalizeText(clipboardData.text);\n      if (!data) {\n        return;\n      }\n      const container = getContainerElement(element);\n\n      const font = getFontString({\n        fontSize: app.state.currentItemFontSize,\n        fontFamily: app.state.currentItemFontFamily,\n      });\n      if (container) {\n        const wrappedText = wrapText(\n          `${editable.value}${data}`,\n          font,\n          getBoundTextMaxWidth(container),\n        );\n        const width = getTextWidth(wrappedText, font);\n        editable.style.width = `${width}px`;\n      }\n    };\n\n    editable.oninput = () => {\n      onChange(normalizeText(editable.value));\n    };\n  }\n\n  editable.onkeydown = (event) => {\n    if (!event.shiftKey && actionZoomIn.keyTest(event)) {\n      event.preventDefault();\n      app.actionManager.executeAction(actionZoomIn);\n      updateWysiwygStyle();\n    } else if (!event.shiftKey && actionZoomOut.keyTest(event)) {\n      event.preventDefault();\n      app.actionManager.executeAction(actionZoomOut);\n      updateWysiwygStyle();\n    } else if (actionDecreaseFontSize.keyTest(event)) {\n      app.actionManager.executeAction(actionDecreaseFontSize);\n    } else if (actionIncreaseFontSize.keyTest(event)) {\n      app.actionManager.executeAction(actionIncreaseFontSize);\n    } else if (event.key === KEYS.ESCAPE) {\n      event.preventDefault();\n      submittedViaKeyboard = true;\n      handleSubmit();\n    } else if (event.key === KEYS.ENTER && event[KEYS.CTRL_OR_CMD]) {\n      event.preventDefault();\n      if (event.isComposing || event.keyCode === 229) {\n        return;\n      }\n      submittedViaKeyboard = true;\n      handleSubmit();\n    } else if (\n      event.key === KEYS.TAB ||\n      (event[KEYS.CTRL_OR_CMD] &&\n        (event.code === CODES.BRACKET_LEFT ||\n          event.code === CODES.BRACKET_RIGHT))\n    ) {\n      event.preventDefault();\n      if (event.isComposing) {\n        return;\n      } else if (event.shiftKey || event.code === CODES.BRACKET_LEFT) {\n        outdent();\n      } else {\n        indent();\n      }\n      // We must send an input event to resize the element\n      editable.dispatchEvent(new Event(\"input\"));\n    }\n  };\n\n  const TAB_SIZE = 4;\n  const TAB = \" \".repeat(TAB_SIZE);\n  const RE_LEADING_TAB = new RegExp(`^ {1,${TAB_SIZE}}`);\n  const indent = () => {\n    const { selectionStart, selectionEnd } = editable;\n    const linesStartIndices = getSelectedLinesStartIndices();\n\n    let value = editable.value;\n    linesStartIndices.forEach((startIndex: number) => {\n      const startValue = value.slice(0, startIndex);\n      const endValue = value.slice(startIndex);\n\n      value = `${startValue}${TAB}${endValue}`;\n    });\n\n    editable.value = value;\n\n    editable.selectionStart = selectionStart + TAB_SIZE;\n    editable.selectionEnd = selectionEnd + TAB_SIZE * linesStartIndices.length;\n  };\n\n  const outdent = () => {\n    const { selectionStart, selectionEnd } = editable;\n    const linesStartIndices = getSelectedLinesStartIndices();\n    const removedTabs: number[] = [];\n\n    let value = editable.value;\n    linesStartIndices.forEach((startIndex) => {\n      const tabMatch = value\n        .slice(startIndex, startIndex + TAB_SIZE)\n        .match(RE_LEADING_TAB);\n\n      if (tabMatch) {\n        const startValue = value.slice(0, startIndex);\n        const endValue = value.slice(startIndex + tabMatch[0].length);\n\n        // Delete a tab from the line\n        value = `${startValue}${endValue}`;\n        removedTabs.push(startIndex);\n      }\n    });\n\n    editable.value = value;\n\n    if (removedTabs.length) {\n      if (selectionStart > removedTabs[removedTabs.length - 1]) {\n        editable.selectionStart = Math.max(\n          selectionStart - TAB_SIZE,\n          removedTabs[removedTabs.length - 1],\n        );\n      } else {\n        // If the cursor is before the first tab removed, ex:\n        // Line| #1\n        //     Line #2\n        // Lin|e #3\n        // we should reset the selectionStart to his initial value.\n        editable.selectionStart = selectionStart;\n      }\n      editable.selectionEnd = Math.max(\n        editable.selectionStart,\n        selectionEnd - TAB_SIZE * removedTabs.length,\n      );\n    }\n  };\n\n  /**\n   * @returns indices of start positions of selected lines, in reverse order\n   */\n  const getSelectedLinesStartIndices = () => {\n    let { selectionStart, selectionEnd, value } = editable;\n\n    // chars before selectionStart on the same line\n    const startOffset = value.slice(0, selectionStart).match(/[^\\n]*$/)![0]\n      .length;\n    // put caret at the start of the line\n    selectionStart = selectionStart - startOffset;\n\n    const selected = value.slice(selectionStart, selectionEnd);\n\n    return selected\n      .split(\"\\n\")\n      .reduce(\n        (startIndices, line, idx, lines) =>\n          startIndices.concat(\n            idx\n              ? // curr line index is prev line's start + prev line's length + \\n\n                startIndices[idx - 1] + lines[idx - 1].length + 1\n              : // first selected line\n                selectionStart,\n          ),\n        [] as number[],\n      )\n      .reverse();\n  };\n\n  const stopEvent = (event: Event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  // using a state variable instead of passing it to the handleSubmit callback\n  // so that we don't need to create separate a callback for event handlers\n  let submittedViaKeyboard = false;\n  const handleSubmit = () => {\n    // cleanup must be run before onSubmit otherwise when app blurs the wysiwyg\n    // it'd get stuck in an infinite loop of blur→onSubmit after we re-focus the\n    // wysiwyg on update\n    cleanup();\n    const updateElement = Scene.getScene(element)?.getElement(\n      element.id,\n    ) as ExcalidrawTextElement;\n    if (!updateElement) {\n      return;\n    }\n    let text = editable.value;\n    const container = getContainerElement(updateElement);\n\n    if (container) {\n      text = updateElement.text;\n      if (editable.value.trim()) {\n        const boundTextElementId = getBoundTextElementId(container);\n        if (!boundTextElementId || boundTextElementId !== element.id) {\n          mutateElement(container, {\n            boundElements: (container.boundElements || []).concat({\n              type: \"text\",\n              id: element.id,\n            }),\n          });\n        }\n      } else {\n        mutateElement(container, {\n          boundElements: container.boundElements?.filter(\n            (ele) =>\n              !isTextElement(\n                ele as ExcalidrawTextElement | ExcalidrawLinearElement,\n              ),\n          ),\n        });\n      }\n      redrawTextBoundingBox(updateElement, container);\n    }\n\n    onSubmit({\n      text,\n      viaKeyboard: submittedViaKeyboard,\n      originalText: editable.value,\n    });\n  };\n\n  const cleanup = () => {\n    if (isDestroyed) {\n      return;\n    }\n    isDestroyed = true;\n    // remove events to ensure they don't late-fire\n    editable.onblur = null;\n    editable.oninput = null;\n    editable.onkeydown = null;\n\n    if (observer) {\n      observer.disconnect();\n    }\n\n    window.removeEventListener(\"resize\", updateWysiwygStyle);\n    window.removeEventListener(\"wheel\", stopEvent, true);\n    window.removeEventListener(\"pointerdown\", onPointerDown);\n    window.removeEventListener(\"pointerup\", bindBlurEvent);\n    window.removeEventListener(\"blur\", handleSubmit);\n\n    unbindUpdate();\n\n    editable.remove();\n  };\n\n  const bindBlurEvent = (event?: MouseEvent) => {\n    window.removeEventListener(\"pointerup\", bindBlurEvent);\n    // Deferred so that the pointerdown that initiates the wysiwyg doesn't\n    // trigger the blur on ensuing pointerup.\n    // Also to handle cases such as picking a color which would trigger a blur\n    // in that same tick.\n    const target = event?.target;\n\n    const isTargetPickerTrigger =\n      target instanceof HTMLElement &&\n      target.classList.contains(\"active-color\");\n\n    setTimeout(() => {\n      editable.onblur = handleSubmit;\n\n      if (isTargetPickerTrigger) {\n        const callback = (\n          mutationList: MutationRecord[],\n          observer: MutationObserver,\n        ) => {\n          const radixIsRemoved = mutationList.find(\n            (mutation) =>\n              mutation.removedNodes.length > 0 &&\n              (mutation.removedNodes[0] as HTMLElement).dataset\n                ?.radixPopperContentWrapper !== undefined,\n          );\n\n          if (radixIsRemoved) {\n            // should work without this in theory\n            // and i think it does actually but radix probably somewhere,\n            // somehow sets the focus elsewhere\n            setTimeout(() => {\n              editable.focus();\n            });\n\n            observer.disconnect();\n          }\n        };\n\n        const observer = new MutationObserver(callback);\n\n        observer.observe(document.querySelector(\".excalidraw-container\")!, {\n          childList: true,\n        });\n      }\n\n      // case: clicking on the same property → no change → no update → no focus\n      if (!isTargetPickerTrigger) {\n        editable.focus();\n      }\n    });\n  };\n\n  // prevent blur when changing properties from the menu\n  const onPointerDown = (event: MouseEvent) => {\n    const isTargetPickerTrigger =\n      event.target instanceof HTMLElement &&\n      event.target.classList.contains(\"active-color\");\n\n    if (\n      ((event.target instanceof HTMLElement ||\n        event.target instanceof SVGElement) &&\n        event.target.closest(`.${CLASSES.SHAPE_ACTIONS_MENU}`) &&\n        !isWritableElement(event.target)) ||\n      isTargetPickerTrigger\n    ) {\n      editable.onblur = null;\n      window.addEventListener(\"pointerup\", bindBlurEvent);\n      // handle edge-case where pointerup doesn't fire e.g. due to user\n      // alt-tabbing away\n      window.addEventListener(\"blur\", handleSubmit);\n    }\n  };\n\n  // handle updates of textElement properties of editing element\n  const unbindUpdate = Scene.getScene(element)!.addCallback(() => {\n    updateWysiwygStyle();\n    const isColorPickerActive = !!document.activeElement?.closest(\n      \".color-picker-content\",\n    );\n    if (!isColorPickerActive) {\n      editable.focus();\n    }\n  });\n\n  // ---------------------------------------------------------------------------\n\n  let isDestroyed = false;\n\n  // select on init (focusing is done separately inside the bindBlurEvent()\n  // because we need it to happen *after* the blur event from `pointerdown`)\n  editable.select();\n  bindBlurEvent();\n\n  // reposition wysiwyg in case of canvas is resized. Using ResizeObserver\n  // is preferred so we catch changes from host, where window may not resize.\n  let observer: ResizeObserver | null = null;\n  if (canvas && \"ResizeObserver\" in window) {\n    observer = new window.ResizeObserver(() => {\n      updateWysiwygStyle();\n    });\n    observer.observe(canvas);\n  } else {\n    window.addEventListener(\"resize\", updateWysiwygStyle);\n  }\n\n  window.addEventListener(\"pointerdown\", onPointerDown);\n  window.addEventListener(\"wheel\", stopEvent, {\n    passive: false,\n    capture: true,\n  });\n  excalidrawContainer\n    ?.querySelector(\".excalidraw-textEditorContainer\")!\n    .appendChild(editable);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}