{"ast":null,"code":"import { DEFAULT_ADAPTIVE_RADIUS, LINE_CONFIRM_THRESHOLD, DEFAULT_PROPORTIONAL_RADIUS, ROUNDNESS } from \"./constants\";\nimport { getShapeForElement } from \"./renderer/renderElement\";\nimport { getCurvePathOps } from \"./element/bounds\";\nexport const rotate = (x1, y1, x2, y2, angle) =>\n// ð‘Žâ€²ð‘¥=(ð‘Žð‘¥âˆ’ð‘ð‘¥)cosðœƒâˆ’(ð‘Žð‘¦âˆ’ð‘ð‘¦)sinðœƒ+ð‘ð‘¥\n// ð‘Žâ€²ð‘¦=(ð‘Žð‘¥âˆ’ð‘ð‘¥)sinðœƒ+(ð‘Žð‘¦âˆ’ð‘ð‘¦)cosðœƒ+ð‘ð‘¦.\n// https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n[(x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2, (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2];\nexport const rotatePoint = (point, center, angle) => rotate(point[0], point[1], center[0], center[1], angle);\nexport const adjustXYWithRotation = (sides, x, y, angle, deltaX1, deltaY1, deltaX2, deltaY2) => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  if (sides.e && sides.w) {\n    x += deltaX1 + deltaX2;\n  } else if (sides.e) {\n    x += deltaX1 * (1 + cos);\n    y += deltaX1 * sin;\n    x += deltaX2 * (1 - cos);\n    y += deltaX2 * -sin;\n  } else if (sides.w) {\n    x += deltaX1 * (1 - cos);\n    y += deltaX1 * -sin;\n    x += deltaX2 * (1 + cos);\n    y += deltaX2 * sin;\n  }\n  if (sides.n && sides.s) {\n    y += deltaY1 + deltaY2;\n  } else if (sides.n) {\n    x += deltaY1 * sin;\n    y += deltaY1 * (1 - cos);\n    x += deltaY2 * -sin;\n    y += deltaY2 * (1 + cos);\n  } else if (sides.s) {\n    x += deltaY1 * -sin;\n    y += deltaY1 * (1 + cos);\n    x += deltaY2 * sin;\n    y += deltaY2 * (1 - cos);\n  }\n  return [x, y];\n};\nexport const getPointOnAPath = (point, path) => {\n  const [px, py] = point;\n  const [start, ...other] = path;\n  let [lastX, lastY] = start;\n  let kLine = 0;\n  let idx = 0;\n\n  // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n  const retVal = other.some((_ref, i) => {\n    let [x2, y2] = _ref;\n    // we always take a line when dealing with line segments\n    const x1 = lastX;\n    const y1 = lastY;\n    lastX = x2;\n    lastY = y2;\n\n    // if a point is not within the domain of the line segment\n    // it is not on the line segment\n    if (px < x1 || px > x2) {\n      return false;\n    }\n\n    // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n\n    // coefficient for the line (p0, p1)\n    const kL = (y2 - y1) / (x2 - x1);\n\n    // coefficient for the line segment (p0, point)\n    const kP1 = (py - y1) / (px - x1);\n\n    // coefficient for the line segment (point, p1)\n    const kP2 = (py - y2) / (px - x2);\n\n    // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n\n    // using it for floating point comparisons\n    const epsilon = 0.3;\n\n    // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    }\n\n    // store the coefficient because we are goint to need it\n    kLine = kL;\n    idx = i;\n    return true;\n  });\n\n  // Return a coordinate that is always on the line segment\n  if (retVal === true) {\n    return {\n      x: point[0],\n      y: kLine * point[0],\n      segment: idx\n    };\n  }\n  return null;\n};\nexport const distance2d = (x1, y1, x2, y2) => {\n  const xd = x2 - x1;\n  const yd = y2 - y1;\n  return Math.hypot(xd, yd);\n};\nexport const centerPoint = (a, b) => {\n  return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n};\n\n// Checks if the first and last point are close enough\n// to be considered a loop\nexport const isPathALoop = function (points) {\n  let zoomValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (points.length >= 3) {\n    const [first, last] = [points[0], points[points.length - 1]];\n    const distance = distance2d(first[0], first[1], last[0], last[1]);\n\n    // Adjusting LINE_CONFIRM_THRESHOLD to current zoom so that when zoomed in\n    // really close we make the threshold smaller, and vice versa.\n    return distance <= LINE_CONFIRM_THRESHOLD / zoomValue;\n  }\n  return false;\n};\n\n// Draw a line from the point to the right till infiinty\n// Check how many lines of the polygon does this infinite line intersects with\n// If the number of intersections is odd, point is in the polygon\nexport const isPointInPolygon = (points, x, y) => {\n  const vertices = points.length;\n\n  // There must be at least 3 vertices in polygon\n  if (vertices < 3) {\n    return false;\n  }\n  const extreme = [Number.MAX_SAFE_INTEGER, y];\n  const p = [x, y];\n  let count = 0;\n  for (let i = 0; i < vertices; i++) {\n    const current = points[i];\n    const next = points[(i + 1) % vertices];\n    if (doSegmentsIntersect(current, next, p, extreme)) {\n      if (orderedColinearOrientation(current, p, next) === 0) {\n        return isPointWithinBounds(current, p, next);\n      }\n      count++;\n    }\n  }\n  // true if count is off\n  return count % 2 === 1;\n};\n\n// Returns whether `q` lies inside the segment/rectangle defined by `p` and `r`.\n// This is an approximation to \"does `q` lie on a segment `pr`\" check.\nexport const isPointWithinBounds = (p, q, r) => {\n  return q[0] <= Math.max(p[0], r[0]) && q[0] >= Math.min(p[0], r[0]) && q[1] <= Math.max(p[1], r[1]) && q[1] >= Math.min(p[1], r[1]);\n};\n\n// For the ordered points p, q, r, return\n// 0 if p, q, r are colinear\n// 1 if Clockwise\n// 2 if counterclickwise\nconst orderedColinearOrientation = (p, q, r) => {\n  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n  if (val === 0) {\n    return 0;\n  }\n  return val > 0 ? 1 : 2;\n};\n\n// Check is p1q1 intersects with p2q2\nconst doSegmentsIntersect = (p1, q1, p2, q2) => {\n  const o1 = orderedColinearOrientation(p1, q1, p2);\n  const o2 = orderedColinearOrientation(p1, q1, q2);\n  const o3 = orderedColinearOrientation(p2, q2, p1);\n  const o4 = orderedColinearOrientation(p2, q2, q1);\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n  if (o1 === 0 && isPointWithinBounds(p1, p2, q1)) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n  if (o2 === 0 && isPointWithinBounds(p1, q2, q1)) {\n    return true;\n  }\n\n  // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n  if (o3 === 0 && isPointWithinBounds(p2, p1, q2)) {\n    return true;\n  }\n\n  // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n  if (o4 === 0 && isPointWithinBounds(p2, q1, q2)) {\n    return true;\n  }\n  return false;\n};\n\n// TODO: Rounding this point causes some shake when free drawing\nexport const getGridPoint = (x, y, gridSize) => {\n  if (gridSize) {\n    return [Math.round(x / gridSize) * gridSize, Math.round(y / gridSize) * gridSize];\n  }\n  return [x, y];\n};\nexport const getCornerRadius = (x, element) => {\n  var _element$roundness, _element$roundness2, _element$roundness3;\n  if (((_element$roundness = element.roundness) === null || _element$roundness === void 0 ? void 0 : _element$roundness.type) === ROUNDNESS.PROPORTIONAL_RADIUS || ((_element$roundness2 = element.roundness) === null || _element$roundness2 === void 0 ? void 0 : _element$roundness2.type) === ROUNDNESS.LEGACY) {\n    return x * DEFAULT_PROPORTIONAL_RADIUS;\n  }\n  if (((_element$roundness3 = element.roundness) === null || _element$roundness3 === void 0 ? void 0 : _element$roundness3.type) === ROUNDNESS.ADAPTIVE_RADIUS) {\n    var _element$roundness$va, _element$roundness4;\n    const fixedRadiusSize = (_element$roundness$va = (_element$roundness4 = element.roundness) === null || _element$roundness4 === void 0 ? void 0 : _element$roundness4.value) !== null && _element$roundness$va !== void 0 ? _element$roundness$va : DEFAULT_ADAPTIVE_RADIUS;\n    const CUTOFF_SIZE = fixedRadiusSize / DEFAULT_PROPORTIONAL_RADIUS;\n    if (x <= CUTOFF_SIZE) {\n      return x * DEFAULT_PROPORTIONAL_RADIUS;\n    }\n    return fixedRadiusSize;\n  }\n  return 0;\n};\nexport const getControlPointsForBezierCurve = (element, endPoint) => {\n  const shape = getShapeForElement(element);\n  if (!shape) {\n    return null;\n  }\n  const ops = getCurvePathOps(shape[0]);\n  let currentP = [0, 0];\n  let index = 0;\n  let minDistance = Infinity;\n  let controlPoints = null;\n  while (index < ops.length) {\n    const {\n      op,\n      data\n    } = ops[index];\n    if (op === \"move\") {\n      currentP = data;\n    }\n    if (op === \"bcurveTo\") {\n      const p0 = currentP;\n      const p1 = [data[0], data[1]];\n      const p2 = [data[2], data[3]];\n      const p3 = [data[4], data[5]];\n      const distance = distance2d(p3[0], p3[1], endPoint[0], endPoint[1]);\n      if (distance < minDistance) {\n        minDistance = distance;\n        controlPoints = [p0, p1, p2, p3];\n      }\n      currentP = p3;\n    }\n    index++;\n  }\n  return controlPoints;\n};\nexport const getBezierXY = (p0, p1, p2, p3, t) => {\n  const equation = (t, idx) => Math.pow(1 - t, 3) * p3[idx] + 3 * t * Math.pow(1 - t, 2) * p2[idx] + 3 * Math.pow(t, 2) * (1 - t) * p1[idx] + p0[idx] * Math.pow(t, 3);\n  const tx = equation(t, 0);\n  const ty = equation(t, 1);\n  return [tx, ty];\n};\nexport const getPointsInBezierCurve = (element, endPoint) => {\n  const controlPoints = getControlPointsForBezierCurve(element, endPoint);\n  if (!controlPoints) {\n    return [];\n  }\n  const pointsOnCurve = [];\n  let t = 1;\n  // Take 20 points on curve for better accuracy\n  while (t > 0) {\n    const point = getBezierXY(controlPoints[0], controlPoints[1], controlPoints[2], controlPoints[3], t);\n    pointsOnCurve.push([point[0], point[1]]);\n    t -= 0.05;\n  }\n  if (pointsOnCurve.length) {\n    if (arePointsEqual(pointsOnCurve.at(-1), endPoint)) {\n      pointsOnCurve.push([endPoint[0], endPoint[1]]);\n    }\n  }\n  return pointsOnCurve;\n};\nexport const getBezierCurveArcLengths = (element, endPoint) => {\n  const arcLengths = [];\n  arcLengths[0] = 0;\n  const points = getPointsInBezierCurve(element, endPoint);\n  let index = 0;\n  let distance = 0;\n  while (index < points.length - 1) {\n    const segmentDistance = distance2d(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1]);\n    distance += segmentDistance;\n    arcLengths.push(distance);\n    index++;\n  }\n  return arcLengths;\n};\nexport const getBezierCurveLength = (element, endPoint) => {\n  const arcLengths = getBezierCurveArcLengths(element, endPoint);\n  return arcLengths.at(-1);\n};\n\n// This maps interval to actual interval t on the curve so that when t = 0.5, its actually the point at 50% of the length\nexport const mapIntervalToBezierT = (element, endPoint, interval // The interval between 0 to 1 for which you want to find the point on the curve,\n) => {\n  const arcLengths = getBezierCurveArcLengths(element, endPoint);\n  const pointsCount = arcLengths.length - 1;\n  const curveLength = arcLengths.at(-1);\n  const targetLength = interval * curveLength;\n  let low = 0;\n  let high = pointsCount;\n  let index = 0;\n  // Doing a binary search to find the largest length that is less than the target length\n  while (low < high) {\n    index = Math.floor(low + (high - low) / 2);\n    if (arcLengths[index] < targetLength) {\n      low = index + 1;\n    } else {\n      high = index;\n    }\n  }\n  if (arcLengths[index] > targetLength) {\n    index--;\n  }\n  if (arcLengths[index] === targetLength) {\n    return index / pointsCount;\n  }\n  return 1 - (index + (targetLength - arcLengths[index]) / (arcLengths[index + 1] - arcLengths[index])) / pointsCount;\n};\nexport const arePointsEqual = (p1, p2) => {\n  return p1[0] === p2[0] && p1[1] === p2[1];\n};\nexport const isRightAngle = angle => {\n  // if our angles were mathematically accurate, we could just check\n  //\n  //    angle % (Math.PI / 2) === 0\n  //\n  // but since we're in floating point land, we need to round.\n  //\n  // Below, after dividing by Math.PI, a multiple of 0.5 indicates a right\n  // angle, which we can check with modulo after rounding.\n  return Math.round(angle / Math.PI * 10000) % 5000 === 0;\n};","map":{"version":3,"names":["DEFAULT_ADAPTIVE_RADIUS","LINE_CONFIRM_THRESHOLD","DEFAULT_PROPORTIONAL_RADIUS","ROUNDNESS","getShapeForElement","getCurvePathOps","rotate","x1","y1","x2","y2","angle","Math","cos","sin","rotatePoint","point","center","adjustXYWithRotation","sides","x","y","deltaX1","deltaY1","deltaX2","deltaY2","e","w","n","s","getPointOnAPath","path","px","py","start","other","lastX","lastY","kLine","idx","retVal","some","_ref","i","kL","kP1","kP2","epsilon","abs","segment","distance2d","xd","yd","hypot","centerPoint","a","b","isPathALoop","points","zoomValue","arguments","length","undefined","first","last","distance","isPointInPolygon","vertices","extreme","Number","MAX_SAFE_INTEGER","p","count","current","next","doSegmentsIntersect","orderedColinearOrientation","isPointWithinBounds","q","r","max","min","val","p1","q1","p2","q2","o1","o2","o3","o4","getGridPoint","gridSize","round","getCornerRadius","element","_element$roundness","_element$roundness2","_element$roundness3","roundness","type","PROPORTIONAL_RADIUS","LEGACY","ADAPTIVE_RADIUS","_element$roundness$va","_element$roundness4","fixedRadiusSize","value","CUTOFF_SIZE","getControlPointsForBezierCurve","endPoint","shape","ops","currentP","index","minDistance","Infinity","controlPoints","op","data","p0","p3","getBezierXY","t","equation","pow","tx","ty","getPointsInBezierCurve","pointsOnCurve","push","arePointsEqual","at","getBezierCurveArcLengths","arcLengths","segmentDistance","getBezierCurveLength","mapIntervalToBezierT","interval","pointsCount","curveLength","targetLength","low","high","floor","isRightAngle","PI"],"sources":["D:/project/excalidraw-cn/src/math.ts"],"sourcesContent":["import { NormalizedZoomValue, Point, Zoom } from \"./types\";\nimport {\n  DEFAULT_ADAPTIVE_RADIUS,\n  LINE_CONFIRM_THRESHOLD,\n  DEFAULT_PROPORTIONAL_RADIUS,\n  ROUNDNESS,\n} from \"./constants\";\nimport {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  NonDeleted,\n} from \"./element/types\";\nimport { getShapeForElement } from \"./renderer/renderElement\";\nimport { getCurvePathOps } from \"./element/bounds\";\nimport { Mutable } from \"./utility-types\";\n\nexport const rotate = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  angle: number,\n): [number, number] =>\n  // ð‘Žâ€²ð‘¥=(ð‘Žð‘¥âˆ’ð‘ð‘¥)cosðœƒâˆ’(ð‘Žð‘¦âˆ’ð‘ð‘¦)sinðœƒ+ð‘ð‘¥\n  // ð‘Žâ€²ð‘¦=(ð‘Žð‘¥âˆ’ð‘ð‘¥)sinðœƒ+(ð‘Žð‘¦âˆ’ð‘ð‘¦)cosðœƒ+ð‘ð‘¦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2,\n  ];\n\nexport const rotatePoint = (\n  point: Point,\n  center: Point,\n  angle: number,\n): [number, number] => rotate(point[0], point[1], center[0], center[1], angle);\n\nexport const adjustXYWithRotation = (\n  sides: {\n    n?: boolean;\n    e?: boolean;\n    s?: boolean;\n    w?: boolean;\n  },\n  x: number,\n  y: number,\n  angle: number,\n  deltaX1: number,\n  deltaY1: number,\n  deltaX2: number,\n  deltaY2: number,\n): [number, number] => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  if (sides.e && sides.w) {\n    x += deltaX1 + deltaX2;\n  } else if (sides.e) {\n    x += deltaX1 * (1 + cos);\n    y += deltaX1 * sin;\n    x += deltaX2 * (1 - cos);\n    y += deltaX2 * -sin;\n  } else if (sides.w) {\n    x += deltaX1 * (1 - cos);\n    y += deltaX1 * -sin;\n    x += deltaX2 * (1 + cos);\n    y += deltaX2 * sin;\n  }\n\n  if (sides.n && sides.s) {\n    y += deltaY1 + deltaY2;\n  } else if (sides.n) {\n    x += deltaY1 * sin;\n    y += deltaY1 * (1 - cos);\n    x += deltaY2 * -sin;\n    y += deltaY2 * (1 + cos);\n  } else if (sides.s) {\n    x += deltaY1 * -sin;\n    y += deltaY1 * (1 + cos);\n    x += deltaY2 * sin;\n    y += deltaY2 * (1 - cos);\n  }\n  return [x, y];\n};\n\nexport const getPointOnAPath = (point: Point, path: Point[]) => {\n  const [px, py] = point;\n  const [start, ...other] = path;\n  let [lastX, lastY] = start;\n  let kLine: number = 0;\n  let idx: number = 0;\n\n  // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n  const retVal = other.some(([x2, y2], i) => {\n    // we always take a line when dealing with line segments\n    const x1 = lastX;\n    const y1 = lastY;\n\n    lastX = x2;\n    lastY = y2;\n\n    // if a point is not within the domain of the line segment\n    // it is not on the line segment\n    if (px < x1 || px > x2) {\n      return false;\n    }\n\n    // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n\n    // coefficient for the line (p0, p1)\n    const kL = (y2 - y1) / (x2 - x1);\n\n    // coefficient for the line segment (p0, point)\n    const kP1 = (py - y1) / (px - x1);\n\n    // coefficient for the line segment (point, p1)\n    const kP2 = (py - y2) / (px - x2);\n\n    // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n\n    // using it for floating point comparisons\n    const epsilon = 0.3;\n\n    // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    }\n\n    // store the coefficient because we are goint to need it\n    kLine = kL;\n    idx = i;\n\n    return true;\n  });\n\n  // Return a coordinate that is always on the line segment\n  if (retVal === true) {\n    return { x: point[0], y: kLine * point[0], segment: idx };\n  }\n\n  return null;\n};\n\nexport const distance2d = (x1: number, y1: number, x2: number, y2: number) => {\n  const xd = x2 - x1;\n  const yd = y2 - y1;\n  return Math.hypot(xd, yd);\n};\n\nexport const centerPoint = (a: Point, b: Point): Point => {\n  return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n};\n\n// Checks if the first and last point are close enough\n// to be considered a loop\nexport const isPathALoop = (\n  points: ExcalidrawLinearElement[\"points\"],\n  /** supply if you want the loop detection to account for current zoom */\n  zoomValue: Zoom[\"value\"] = 1 as NormalizedZoomValue,\n): boolean => {\n  if (points.length >= 3) {\n    const [first, last] = [points[0], points[points.length - 1]];\n    const distance = distance2d(first[0], first[1], last[0], last[1]);\n\n    // Adjusting LINE_CONFIRM_THRESHOLD to current zoom so that when zoomed in\n    // really close we make the threshold smaller, and vice versa.\n    return distance <= LINE_CONFIRM_THRESHOLD / zoomValue;\n  }\n  return false;\n};\n\n// Draw a line from the point to the right till infiinty\n// Check how many lines of the polygon does this infinite line intersects with\n// If the number of intersections is odd, point is in the polygon\nexport const isPointInPolygon = (\n  points: Point[],\n  x: number,\n  y: number,\n): boolean => {\n  const vertices = points.length;\n\n  // There must be at least 3 vertices in polygon\n  if (vertices < 3) {\n    return false;\n  }\n  const extreme: Point = [Number.MAX_SAFE_INTEGER, y];\n  const p: Point = [x, y];\n  let count = 0;\n  for (let i = 0; i < vertices; i++) {\n    const current = points[i];\n    const next = points[(i + 1) % vertices];\n    if (doSegmentsIntersect(current, next, p, extreme)) {\n      if (orderedColinearOrientation(current, p, next) === 0) {\n        return isPointWithinBounds(current, p, next);\n      }\n      count++;\n    }\n  }\n  // true if count is off\n  return count % 2 === 1;\n};\n\n// Returns whether `q` lies inside the segment/rectangle defined by `p` and `r`.\n// This is an approximation to \"does `q` lie on a segment `pr`\" check.\nexport const isPointWithinBounds = (p: Point, q: Point, r: Point) => {\n  return (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  );\n};\n\n// For the ordered points p, q, r, return\n// 0 if p, q, r are colinear\n// 1 if Clockwise\n// 2 if counterclickwise\nconst orderedColinearOrientation = (p: Point, q: Point, r: Point) => {\n  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n  if (val === 0) {\n    return 0;\n  }\n  return val > 0 ? 1 : 2;\n};\n\n// Check is p1q1 intersects with p2q2\nconst doSegmentsIntersect = (p1: Point, q1: Point, p2: Point, q2: Point) => {\n  const o1 = orderedColinearOrientation(p1, q1, p2);\n  const o2 = orderedColinearOrientation(p1, q1, q2);\n  const o3 = orderedColinearOrientation(p2, q2, p1);\n  const o4 = orderedColinearOrientation(p2, q2, q1);\n\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n  if (o1 === 0 && isPointWithinBounds(p1, p2, q1)) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n  if (o2 === 0 && isPointWithinBounds(p1, q2, q1)) {\n    return true;\n  }\n\n  // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n  if (o3 === 0 && isPointWithinBounds(p2, p1, q2)) {\n    return true;\n  }\n\n  // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n  if (o4 === 0 && isPointWithinBounds(p2, q1, q2)) {\n    return true;\n  }\n\n  return false;\n};\n\n// TODO: Rounding this point causes some shake when free drawing\nexport const getGridPoint = (\n  x: number,\n  y: number,\n  gridSize: number | null,\n): [number, number] => {\n  if (gridSize) {\n    return [\n      Math.round(x / gridSize) * gridSize,\n      Math.round(y / gridSize) * gridSize,\n    ];\n  }\n  return [x, y];\n};\n\nexport const getCornerRadius = (x: number, element: ExcalidrawElement) => {\n  if (\n    element.roundness?.type === ROUNDNESS.PROPORTIONAL_RADIUS ||\n    element.roundness?.type === ROUNDNESS.LEGACY\n  ) {\n    return x * DEFAULT_PROPORTIONAL_RADIUS;\n  }\n\n  if (element.roundness?.type === ROUNDNESS.ADAPTIVE_RADIUS) {\n    const fixedRadiusSize = element.roundness?.value ?? DEFAULT_ADAPTIVE_RADIUS;\n\n    const CUTOFF_SIZE = fixedRadiusSize / DEFAULT_PROPORTIONAL_RADIUS;\n\n    if (x <= CUTOFF_SIZE) {\n      return x * DEFAULT_PROPORTIONAL_RADIUS;\n    }\n\n    return fixedRadiusSize;\n  }\n\n  return 0;\n};\n\nexport const getControlPointsForBezierCurve = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  endPoint: Point,\n) => {\n  const shape = getShapeForElement(element as ExcalidrawLinearElement);\n  if (!shape) {\n    return null;\n  }\n\n  const ops = getCurvePathOps(shape[0]);\n  let currentP: Mutable<Point> = [0, 0];\n  let index = 0;\n  let minDistance = Infinity;\n  let controlPoints: Mutable<Point>[] | null = null;\n\n  while (index < ops.length) {\n    const { op, data } = ops[index];\n    if (op === \"move\") {\n      currentP = data as unknown as Mutable<Point>;\n    }\n    if (op === \"bcurveTo\") {\n      const p0 = currentP;\n      const p1 = [data[0], data[1]] as Mutable<Point>;\n      const p2 = [data[2], data[3]] as Mutable<Point>;\n      const p3 = [data[4], data[5]] as Mutable<Point>;\n      const distance = distance2d(p3[0], p3[1], endPoint[0], endPoint[1]);\n      if (distance < minDistance) {\n        minDistance = distance;\n        controlPoints = [p0, p1, p2, p3];\n      }\n      currentP = p3;\n    }\n    index++;\n  }\n\n  return controlPoints;\n};\n\nexport const getBezierXY = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  p3: Point,\n  t: number,\n) => {\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n  const tx = equation(t, 0);\n  const ty = equation(t, 1);\n  return [tx, ty];\n};\n\nexport const getPointsInBezierCurve = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  endPoint: Point,\n) => {\n  const controlPoints: Mutable<Point>[] = getControlPointsForBezierCurve(\n    element,\n    endPoint,\n  )!;\n  if (!controlPoints) {\n    return [];\n  }\n  const pointsOnCurve: Mutable<Point>[] = [];\n  let t = 1;\n  // Take 20 points on curve for better accuracy\n  while (t > 0) {\n    const point = getBezierXY(\n      controlPoints[0],\n      controlPoints[1],\n      controlPoints[2],\n      controlPoints[3],\n      t,\n    );\n    pointsOnCurve.push([point[0], point[1]]);\n    t -= 0.05;\n  }\n  if (pointsOnCurve.length) {\n    if (arePointsEqual(pointsOnCurve.at(-1)!, endPoint)) {\n      pointsOnCurve.push([endPoint[0], endPoint[1]]);\n    }\n  }\n  return pointsOnCurve;\n};\n\nexport const getBezierCurveArcLengths = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  endPoint: Point,\n) => {\n  const arcLengths: number[] = [];\n  arcLengths[0] = 0;\n  const points = getPointsInBezierCurve(element, endPoint);\n  let index = 0;\n  let distance = 0;\n  while (index < points.length - 1) {\n    const segmentDistance = distance2d(\n      points[index][0],\n      points[index][1],\n      points[index + 1][0],\n      points[index + 1][1],\n    );\n    distance += segmentDistance;\n    arcLengths.push(distance);\n    index++;\n  }\n\n  return arcLengths;\n};\n\nexport const getBezierCurveLength = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  endPoint: Point,\n) => {\n  const arcLengths = getBezierCurveArcLengths(element, endPoint);\n  return arcLengths.at(-1) as number;\n};\n\n// This maps interval to actual interval t on the curve so that when t = 0.5, its actually the point at 50% of the length\nexport const mapIntervalToBezierT = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  endPoint: Point,\n  interval: number, // The interval between 0 to 1 for which you want to find the point on the curve,\n) => {\n  const arcLengths = getBezierCurveArcLengths(element, endPoint);\n  const pointsCount = arcLengths.length - 1;\n  const curveLength = arcLengths.at(-1) as number;\n  const targetLength = interval * curveLength;\n  let low = 0;\n  let high = pointsCount;\n  let index = 0;\n  // Doing a binary search to find the largest length that is less than the target length\n  while (low < high) {\n    index = Math.floor(low + (high - low) / 2);\n    if (arcLengths[index] < targetLength) {\n      low = index + 1;\n    } else {\n      high = index;\n    }\n  }\n  if (arcLengths[index] > targetLength) {\n    index--;\n  }\n  if (arcLengths[index] === targetLength) {\n    return index / pointsCount;\n  }\n\n  return (\n    1 -\n    (index +\n      (targetLength - arcLengths[index]) /\n        (arcLengths[index + 1] - arcLengths[index])) /\n      pointsCount\n  );\n};\n\nexport const arePointsEqual = (p1: Point, p2: Point) => {\n  return p1[0] === p2[0] && p1[1] === p2[1];\n};\n\nexport const isRightAngle = (angle: number) => {\n  // if our angles were mathematically accurate, we could just check\n  //\n  //    angle % (Math.PI / 2) === 0\n  //\n  // but since we're in floating point land, we need to round.\n  //\n  // Below, after dividing by Math.PI, a multiple of 0.5 indicates a right\n  // angle, which we can check with modulo after rounding.\n  return Math.round((angle / Math.PI) * 10000) % 5000 === 0;\n};\n"],"mappings":"AACA,SACEA,uBAAuB,EACvBC,sBAAsB,EACtBC,2BAA2B,EAC3BC,SAAS,QACJ,aAAa;AAMpB,SAASC,kBAAkB,QAAQ,0BAA0B;AAC7D,SAASC,eAAe,QAAQ,kBAAkB;AAGlD,OAAO,MAAMC,MAAM,GAAGA,CACpBC,EAAU,EACVC,EAAU,EACVC,EAAU,EACVC,EAAU,EACVC,KAAa;AAEb;AACA;AACA;AACA,CACE,CAACJ,EAAE,GAAGE,EAAE,IAAIG,IAAI,CAACC,GAAG,CAACF,KAAK,CAAC,GAAG,CAACH,EAAE,GAAGE,EAAE,IAAIE,IAAI,CAACE,GAAG,CAACH,KAAK,CAAC,GAAGF,EAAE,EAC9D,CAACF,EAAE,GAAGE,EAAE,IAAIG,IAAI,CAACE,GAAG,CAACH,KAAK,CAAC,GAAG,CAACH,EAAE,GAAGE,EAAE,IAAIE,IAAI,CAACC,GAAG,CAACF,KAAK,CAAC,GAAGD,EAAE,CAC/D;AAEH,OAAO,MAAMK,WAAW,GAAGA,CACzBC,KAAY,EACZC,MAAa,EACbN,KAAa,KACQL,MAAM,CAACU,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,EAAEC,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,EAAEN,KAAK,CAAC;AAE9E,OAAO,MAAMO,oBAAoB,GAAGA,CAClCC,KAKC,EACDC,CAAS,EACTC,CAAS,EACTV,KAAa,EACbW,OAAe,EACfC,OAAe,EACfC,OAAe,EACfC,OAAe,KACM;EACrB,MAAMZ,GAAG,GAAGD,IAAI,CAACC,GAAG,CAACF,KAAK,CAAC;EAC3B,MAAMG,GAAG,GAAGF,IAAI,CAACE,GAAG,CAACH,KAAK,CAAC;EAC3B,IAAIQ,KAAK,CAACO,CAAC,IAAIP,KAAK,CAACQ,CAAC,EAAE;IACtBP,CAAC,IAAIE,OAAO,GAAGE,OAAO;EACxB,CAAC,MAAM,IAAIL,KAAK,CAACO,CAAC,EAAE;IAClBN,CAAC,IAAIE,OAAO,IAAI,CAAC,GAAGT,GAAG,CAAC;IACxBQ,CAAC,IAAIC,OAAO,GAAGR,GAAG;IAClBM,CAAC,IAAII,OAAO,IAAI,CAAC,GAAGX,GAAG,CAAC;IACxBQ,CAAC,IAAIG,OAAO,GAAG,CAACV,GAAG;EACrB,CAAC,MAAM,IAAIK,KAAK,CAACQ,CAAC,EAAE;IAClBP,CAAC,IAAIE,OAAO,IAAI,CAAC,GAAGT,GAAG,CAAC;IACxBQ,CAAC,IAAIC,OAAO,GAAG,CAACR,GAAG;IACnBM,CAAC,IAAII,OAAO,IAAI,CAAC,GAAGX,GAAG,CAAC;IACxBQ,CAAC,IAAIG,OAAO,GAAGV,GAAG;EACpB;EAEA,IAAIK,KAAK,CAACS,CAAC,IAAIT,KAAK,CAACU,CAAC,EAAE;IACtBR,CAAC,IAAIE,OAAO,GAAGE,OAAO;EACxB,CAAC,MAAM,IAAIN,KAAK,CAACS,CAAC,EAAE;IAClBR,CAAC,IAAIG,OAAO,GAAGT,GAAG;IAClBO,CAAC,IAAIE,OAAO,IAAI,CAAC,GAAGV,GAAG,CAAC;IACxBO,CAAC,IAAIK,OAAO,GAAG,CAACX,GAAG;IACnBO,CAAC,IAAII,OAAO,IAAI,CAAC,GAAGZ,GAAG,CAAC;EAC1B,CAAC,MAAM,IAAIM,KAAK,CAACU,CAAC,EAAE;IAClBT,CAAC,IAAIG,OAAO,GAAG,CAACT,GAAG;IACnBO,CAAC,IAAIE,OAAO,IAAI,CAAC,GAAGV,GAAG,CAAC;IACxBO,CAAC,IAAIK,OAAO,GAAGX,GAAG;IAClBO,CAAC,IAAII,OAAO,IAAI,CAAC,GAAGZ,GAAG,CAAC;EAC1B;EACA,OAAO,CAACO,CAAC,EAAEC,CAAC,CAAC;AACf,CAAC;AAED,OAAO,MAAMS,eAAe,GAAGA,CAACd,KAAY,EAAEe,IAAa,KAAK;EAC9D,MAAM,CAACC,EAAE,EAAEC,EAAE,CAAC,GAAGjB,KAAK;EACtB,MAAM,CAACkB,KAAK,EAAE,GAAGC,KAAK,CAAC,GAAGJ,IAAI;EAC9B,IAAI,CAACK,KAAK,EAAEC,KAAK,CAAC,GAAGH,KAAK;EAC1B,IAAII,KAAa,GAAG,CAAC;EACrB,IAAIC,GAAW,GAAG,CAAC;;EAEnB;EACA;EACA,MAAMC,MAAM,GAAGL,KAAK,CAACM,IAAI,CAAC,CAAAC,IAAA,EAAWC,CAAC,KAAK;IAAA,IAAhB,CAAClC,EAAE,EAAEC,EAAE,CAAC,GAAAgC,IAAA;IACjC;IACA,MAAMnC,EAAE,GAAG6B,KAAK;IAChB,MAAM5B,EAAE,GAAG6B,KAAK;IAEhBD,KAAK,GAAG3B,EAAE;IACV4B,KAAK,GAAG3B,EAAE;;IAEV;IACA;IACA,IAAIsB,EAAE,GAAGzB,EAAE,IAAIyB,EAAE,GAAGvB,EAAE,EAAE;MACtB,OAAO,KAAK;IACd;;IAEA;IACA;IACA;;IAEA;IACA,MAAMmC,EAAE,GAAG,CAAClC,EAAE,GAAGF,EAAE,KAAKC,EAAE,GAAGF,EAAE,CAAC;;IAEhC;IACA,MAAMsC,GAAG,GAAG,CAACZ,EAAE,GAAGzB,EAAE,KAAKwB,EAAE,GAAGzB,EAAE,CAAC;;IAEjC;IACA,MAAMuC,GAAG,GAAG,CAACb,EAAE,GAAGvB,EAAE,KAAKsB,EAAE,GAAGvB,EAAE,CAAC;;IAEjC;IACA;;IAEA;IACA,MAAMsC,OAAO,GAAG,GAAG;;IAEnB;IACA;IACA,IAAInC,IAAI,CAACoC,GAAG,CAACH,GAAG,GAAGD,EAAE,CAAC,GAAGG,OAAO,IAAInC,IAAI,CAACoC,GAAG,CAACF,GAAG,GAAGF,EAAE,CAAC,GAAGG,OAAO,EAAE;MAChE,OAAO,KAAK;IACd;;IAEA;IACAT,KAAK,GAAGM,EAAE;IACVL,GAAG,GAAGI,CAAC;IAEP,OAAO,IAAI;EACb,CAAC,CAAC;;EAEF;EACA,IAAIH,MAAM,KAAK,IAAI,EAAE;IACnB,OAAO;MAAEpB,CAAC,EAAEJ,KAAK,CAAC,CAAC,CAAC;MAAEK,CAAC,EAAEiB,KAAK,GAAGtB,KAAK,CAAC,CAAC,CAAC;MAAEiC,OAAO,EAAEV;IAAI,CAAC;EAC3D;EAEA,OAAO,IAAI;AACb,CAAC;AAED,OAAO,MAAMW,UAAU,GAAGA,CAAC3C,EAAU,EAAEC,EAAU,EAAEC,EAAU,EAAEC,EAAU,KAAK;EAC5E,MAAMyC,EAAE,GAAG1C,EAAE,GAAGF,EAAE;EAClB,MAAM6C,EAAE,GAAG1C,EAAE,GAAGF,EAAE;EAClB,OAAOI,IAAI,CAACyC,KAAK,CAACF,EAAE,EAAEC,EAAE,CAAC;AAC3B,CAAC;AAED,OAAO,MAAME,WAAW,GAAGA,CAACC,CAAQ,EAAEC,CAAQ,KAAY;EACxD,OAAO,CAAC,CAACD,CAAC,CAAC,CAAC,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAACD,CAAC,CAAC,CAAC,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;AAC/C,CAAC;;AAED;AACA;AACA,OAAO,MAAMC,WAAW,GAAG,SAAAA,CACzBC,MAAyC,EAG7B;EAAA,IADZC,SAAwB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAE5B,IAAIF,MAAM,CAACG,MAAM,IAAI,CAAC,EAAE;IACtB,MAAM,CAACE,KAAK,EAAEC,IAAI,CAAC,GAAG,CAACN,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAACA,MAAM,CAACG,MAAM,GAAG,CAAC,CAAC,CAAC;IAC5D,MAAMI,QAAQ,GAAGf,UAAU,CAACa,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,EAAEC,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;;IAEjE;IACA;IACA,OAAOC,QAAQ,IAAIhE,sBAAsB,GAAG0D,SAAS;EACvD;EACA,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMO,gBAAgB,GAAGA,CAC9BR,MAAe,EACftC,CAAS,EACTC,CAAS,KACG;EACZ,MAAM8C,QAAQ,GAAGT,MAAM,CAACG,MAAM;;EAE9B;EACA,IAAIM,QAAQ,GAAG,CAAC,EAAE;IAChB,OAAO,KAAK;EACd;EACA,MAAMC,OAAc,GAAG,CAACC,MAAM,CAACC,gBAAgB,EAAEjD,CAAC,CAAC;EACnD,MAAMkD,CAAQ,GAAG,CAACnD,CAAC,EAAEC,CAAC,CAAC;EACvB,IAAImD,KAAK,GAAG,CAAC;EACb,KAAK,IAAI7B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwB,QAAQ,EAAExB,CAAC,EAAE,EAAE;IACjC,MAAM8B,OAAO,GAAGf,MAAM,CAACf,CAAC,CAAC;IACzB,MAAM+B,IAAI,GAAGhB,MAAM,CAAC,CAACf,CAAC,GAAG,CAAC,IAAIwB,QAAQ,CAAC;IACvC,IAAIQ,mBAAmB,CAACF,OAAO,EAAEC,IAAI,EAAEH,CAAC,EAAEH,OAAO,CAAC,EAAE;MAClD,IAAIQ,0BAA0B,CAACH,OAAO,EAAEF,CAAC,EAAEG,IAAI,CAAC,KAAK,CAAC,EAAE;QACtD,OAAOG,mBAAmB,CAACJ,OAAO,EAAEF,CAAC,EAAEG,IAAI,CAAC;MAC9C;MACAF,KAAK,EAAE;IACT;EACF;EACA;EACA,OAAOA,KAAK,GAAG,CAAC,KAAK,CAAC;AACxB,CAAC;;AAED;AACA;AACA,OAAO,MAAMK,mBAAmB,GAAGA,CAACN,CAAQ,EAAEO,CAAQ,EAAEC,CAAQ,KAAK;EACnE,OACED,CAAC,CAAC,CAAC,CAAC,IAAIlE,IAAI,CAACoE,GAAG,CAACT,CAAC,CAAC,CAAC,CAAC,EAAEQ,CAAC,CAAC,CAAC,CAAC,CAAC,IAC5BD,CAAC,CAAC,CAAC,CAAC,IAAIlE,IAAI,CAACqE,GAAG,CAACV,CAAC,CAAC,CAAC,CAAC,EAAEQ,CAAC,CAAC,CAAC,CAAC,CAAC,IAC5BD,CAAC,CAAC,CAAC,CAAC,IAAIlE,IAAI,CAACoE,GAAG,CAACT,CAAC,CAAC,CAAC,CAAC,EAAEQ,CAAC,CAAC,CAAC,CAAC,CAAC,IAC5BD,CAAC,CAAC,CAAC,CAAC,IAAIlE,IAAI,CAACqE,GAAG,CAACV,CAAC,CAAC,CAAC,CAAC,EAAEQ,CAAC,CAAC,CAAC,CAAC,CAAC;AAEhC,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMH,0BAA0B,GAAGA,CAACL,CAAQ,EAAEO,CAAQ,EAAEC,CAAQ,KAAK;EACnE,MAAMG,GAAG,GAAG,CAACJ,CAAC,CAAC,CAAC,CAAC,GAAGP,CAAC,CAAC,CAAC,CAAC,KAAKQ,CAAC,CAAC,CAAC,CAAC,GAAGD,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAACA,CAAC,CAAC,CAAC,CAAC,GAAGP,CAAC,CAAC,CAAC,CAAC,KAAKQ,CAAC,CAAC,CAAC,CAAC,GAAGD,CAAC,CAAC,CAAC,CAAC,CAAC;EACzE,IAAII,GAAG,KAAK,CAAC,EAAE;IACb,OAAO,CAAC;EACV;EACA,OAAOA,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;AACxB,CAAC;;AAED;AACA,MAAMP,mBAAmB,GAAGA,CAACQ,EAAS,EAAEC,EAAS,EAAEC,EAAS,EAAEC,EAAS,KAAK;EAC1E,MAAMC,EAAE,GAAGX,0BAA0B,CAACO,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;EACjD,MAAMG,EAAE,GAAGZ,0BAA0B,CAACO,EAAE,EAAEC,EAAE,EAAEE,EAAE,CAAC;EACjD,MAAMG,EAAE,GAAGb,0BAA0B,CAACS,EAAE,EAAEC,EAAE,EAAEH,EAAE,CAAC;EACjD,MAAMO,EAAE,GAAGd,0BAA0B,CAACS,EAAE,EAAEC,EAAE,EAAEF,EAAE,CAAC;EAEjD,IAAIG,EAAE,KAAKC,EAAE,IAAIC,EAAE,KAAKC,EAAE,EAAE;IAC1B,OAAO,IAAI;EACb;;EAEA;EACA,IAAIH,EAAE,KAAK,CAAC,IAAIV,mBAAmB,CAACM,EAAE,EAAEE,EAAE,EAAED,EAAE,CAAC,EAAE;IAC/C,OAAO,IAAI;EACb;;EAEA;EACA,IAAII,EAAE,KAAK,CAAC,IAAIX,mBAAmB,CAACM,EAAE,EAAEG,EAAE,EAAEF,EAAE,CAAC,EAAE;IAC/C,OAAO,IAAI;EACb;;EAEA;EACA,IAAIK,EAAE,KAAK,CAAC,IAAIZ,mBAAmB,CAACQ,EAAE,EAAEF,EAAE,EAAEG,EAAE,CAAC,EAAE;IAC/C,OAAO,IAAI;EACb;;EAEA;EACA,IAAII,EAAE,KAAK,CAAC,IAAIb,mBAAmB,CAACQ,EAAE,EAAED,EAAE,EAAEE,EAAE,CAAC,EAAE;IAC/C,OAAO,IAAI;EACb;EAEA,OAAO,KAAK;AACd,CAAC;;AAED;AACA,OAAO,MAAMK,YAAY,GAAGA,CAC1BvE,CAAS,EACTC,CAAS,EACTuE,QAAuB,KACF;EACrB,IAAIA,QAAQ,EAAE;IACZ,OAAO,CACLhF,IAAI,CAACiF,KAAK,CAACzE,CAAC,GAAGwE,QAAQ,CAAC,GAAGA,QAAQ,EACnChF,IAAI,CAACiF,KAAK,CAACxE,CAAC,GAAGuE,QAAQ,CAAC,GAAGA,QAAQ,CACpC;EACH;EACA,OAAO,CAACxE,CAAC,EAAEC,CAAC,CAAC;AACf,CAAC;AAED,OAAO,MAAMyE,eAAe,GAAGA,CAAC1E,CAAS,EAAE2E,OAA0B,KAAK;EAAA,IAAAC,kBAAA,EAAAC,mBAAA,EAAAC,mBAAA;EACxE,IACE,EAAAF,kBAAA,GAAAD,OAAO,CAACI,SAAS,cAAAH,kBAAA,uBAAjBA,kBAAA,CAAmBI,IAAI,MAAKjG,SAAS,CAACkG,mBAAmB,IACzD,EAAAJ,mBAAA,GAAAF,OAAO,CAACI,SAAS,cAAAF,mBAAA,uBAAjBA,mBAAA,CAAmBG,IAAI,MAAKjG,SAAS,CAACmG,MAAM,EAC5C;IACA,OAAOlF,CAAC,GAAGlB,2BAA2B;EACxC;EAEA,IAAI,EAAAgG,mBAAA,GAAAH,OAAO,CAACI,SAAS,cAAAD,mBAAA,uBAAjBA,mBAAA,CAAmBE,IAAI,MAAKjG,SAAS,CAACoG,eAAe,EAAE;IAAA,IAAAC,qBAAA,EAAAC,mBAAA;IACzD,MAAMC,eAAe,IAAAF,qBAAA,IAAAC,mBAAA,GAAGV,OAAO,CAACI,SAAS,cAAAM,mBAAA,uBAAjBA,mBAAA,CAAmBE,KAAK,cAAAH,qBAAA,cAAAA,qBAAA,GAAIxG,uBAAuB;IAE3E,MAAM4G,WAAW,GAAGF,eAAe,GAAGxG,2BAA2B;IAEjE,IAAIkB,CAAC,IAAIwF,WAAW,EAAE;MACpB,OAAOxF,CAAC,GAAGlB,2BAA2B;IACxC;IAEA,OAAOwG,eAAe;EACxB;EAEA,OAAO,CAAC;AACV,CAAC;AAED,OAAO,MAAMG,8BAA8B,GAAGA,CAC5Cd,OAA4C,EAC5Ce,QAAe,KACZ;EACH,MAAMC,KAAK,GAAG3G,kBAAkB,CAAC2F,OAAO,CAA4B;EACpE,IAAI,CAACgB,KAAK,EAAE;IACV,OAAO,IAAI;EACb;EAEA,MAAMC,GAAG,GAAG3G,eAAe,CAAC0G,KAAK,CAAC,CAAC,CAAC,CAAC;EACrC,IAAIE,QAAwB,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;EACrC,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,WAAW,GAAGC,QAAQ;EAC1B,IAAIC,aAAsC,GAAG,IAAI;EAEjD,OAAOH,KAAK,GAAGF,GAAG,CAACnD,MAAM,EAAE;IACzB,MAAM;MAAEyD,EAAE;MAAEC;IAAK,CAAC,GAAGP,GAAG,CAACE,KAAK,CAAC;IAC/B,IAAII,EAAE,KAAK,MAAM,EAAE;MACjBL,QAAQ,GAAGM,IAAiC;IAC9C;IACA,IAAID,EAAE,KAAK,UAAU,EAAE;MACrB,MAAME,EAAE,GAAGP,QAAQ;MACnB,MAAM9B,EAAE,GAAG,CAACoC,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAmB;MAC/C,MAAMlC,EAAE,GAAG,CAACkC,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAmB;MAC/C,MAAME,EAAE,GAAG,CAACF,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAmB;MAC/C,MAAMtD,QAAQ,GAAGf,UAAU,CAACuE,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,EAAEX,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAC;MACnE,IAAI7C,QAAQ,GAAGkD,WAAW,EAAE;QAC1BA,WAAW,GAAGlD,QAAQ;QACtBoD,aAAa,GAAG,CAACG,EAAE,EAAErC,EAAE,EAAEE,EAAE,EAAEoC,EAAE,CAAC;MAClC;MACAR,QAAQ,GAAGQ,EAAE;IACf;IACAP,KAAK,EAAE;EACT;EAEA,OAAOG,aAAa;AACtB,CAAC;AAED,OAAO,MAAMK,WAAW,GAAGA,CACzBF,EAAS,EACTrC,EAAS,EACTE,EAAS,EACToC,EAAS,EACTE,CAAS,KACN;EACH,MAAMC,QAAQ,GAAGA,CAACD,CAAS,EAAEpF,GAAW,KACtC3B,IAAI,CAACiH,GAAG,CAAC,CAAC,GAAGF,CAAC,EAAE,CAAC,CAAC,GAAGF,EAAE,CAAClF,GAAG,CAAC,GAC5B,CAAC,GAAGoF,CAAC,GAAG/G,IAAI,CAACiH,GAAG,CAAC,CAAC,GAAGF,CAAC,EAAE,CAAC,CAAC,GAAGtC,EAAE,CAAC9C,GAAG,CAAC,GACpC,CAAC,GAAG3B,IAAI,CAACiH,GAAG,CAACF,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,GAAGA,CAAC,CAAC,GAAGxC,EAAE,CAAC5C,GAAG,CAAC,GACtCiF,EAAE,CAACjF,GAAG,CAAC,GAAG3B,IAAI,CAACiH,GAAG,CAACF,CAAC,EAAE,CAAC,CAAC;EAC1B,MAAMG,EAAE,GAAGF,QAAQ,CAACD,CAAC,EAAE,CAAC,CAAC;EACzB,MAAMI,EAAE,GAAGH,QAAQ,CAACD,CAAC,EAAE,CAAC,CAAC;EACzB,OAAO,CAACG,EAAE,EAAEC,EAAE,CAAC;AACjB,CAAC;AAED,OAAO,MAAMC,sBAAsB,GAAGA,CACpCjC,OAA4C,EAC5Ce,QAAe,KACZ;EACH,MAAMO,aAA+B,GAAGR,8BAA8B,CACpEd,OAAO,EACPe,QAAQ,CACR;EACF,IAAI,CAACO,aAAa,EAAE;IAClB,OAAO,EAAE;EACX;EACA,MAAMY,aAA+B,GAAG,EAAE;EAC1C,IAAIN,CAAC,GAAG,CAAC;EACT;EACA,OAAOA,CAAC,GAAG,CAAC,EAAE;IACZ,MAAM3G,KAAK,GAAG0G,WAAW,CACvBL,aAAa,CAAC,CAAC,CAAC,EAChBA,aAAa,CAAC,CAAC,CAAC,EAChBA,aAAa,CAAC,CAAC,CAAC,EAChBA,aAAa,CAAC,CAAC,CAAC,EAChBM,CAAC,CACF;IACDM,aAAa,CAACC,IAAI,CAAC,CAAClH,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IACxC2G,CAAC,IAAI,IAAI;EACX;EACA,IAAIM,aAAa,CAACpE,MAAM,EAAE;IACxB,IAAIsE,cAAc,CAACF,aAAa,CAACG,EAAE,CAAC,CAAC,CAAC,CAAC,EAAGtB,QAAQ,CAAC,EAAE;MACnDmB,aAAa,CAACC,IAAI,CAAC,CAACpB,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAChD;EACF;EACA,OAAOmB,aAAa;AACtB,CAAC;AAED,OAAO,MAAMI,wBAAwB,GAAGA,CACtCtC,OAA4C,EAC5Ce,QAAe,KACZ;EACH,MAAMwB,UAAoB,GAAG,EAAE;EAC/BA,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC;EACjB,MAAM5E,MAAM,GAAGsE,sBAAsB,CAACjC,OAAO,EAAEe,QAAQ,CAAC;EACxD,IAAII,KAAK,GAAG,CAAC;EACb,IAAIjD,QAAQ,GAAG,CAAC;EAChB,OAAOiD,KAAK,GAAGxD,MAAM,CAACG,MAAM,GAAG,CAAC,EAAE;IAChC,MAAM0E,eAAe,GAAGrF,UAAU,CAChCQ,MAAM,CAACwD,KAAK,CAAC,CAAC,CAAC,CAAC,EAChBxD,MAAM,CAACwD,KAAK,CAAC,CAAC,CAAC,CAAC,EAChBxD,MAAM,CAACwD,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EACpBxD,MAAM,CAACwD,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CACrB;IACDjD,QAAQ,IAAIsE,eAAe;IAC3BD,UAAU,CAACJ,IAAI,CAACjE,QAAQ,CAAC;IACzBiD,KAAK,EAAE;EACT;EAEA,OAAOoB,UAAU;AACnB,CAAC;AAED,OAAO,MAAME,oBAAoB,GAAGA,CAClCzC,OAA4C,EAC5Ce,QAAe,KACZ;EACH,MAAMwB,UAAU,GAAGD,wBAAwB,CAACtC,OAAO,EAAEe,QAAQ,CAAC;EAC9D,OAAOwB,UAAU,CAACF,EAAE,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC;;AAED;AACA,OAAO,MAAMK,oBAAoB,GAAGA,CAClC1C,OAA4C,EAC5Ce,QAAe,EACf4B,QAAgB,CAAE;AAAA,KACf;EACH,MAAMJ,UAAU,GAAGD,wBAAwB,CAACtC,OAAO,EAAEe,QAAQ,CAAC;EAC9D,MAAM6B,WAAW,GAAGL,UAAU,CAACzE,MAAM,GAAG,CAAC;EACzC,MAAM+E,WAAW,GAAGN,UAAU,CAACF,EAAE,CAAC,CAAC,CAAC,CAAW;EAC/C,MAAMS,YAAY,GAAGH,QAAQ,GAAGE,WAAW;EAC3C,IAAIE,GAAG,GAAG,CAAC;EACX,IAAIC,IAAI,GAAGJ,WAAW;EACtB,IAAIzB,KAAK,GAAG,CAAC;EACb;EACA,OAAO4B,GAAG,GAAGC,IAAI,EAAE;IACjB7B,KAAK,GAAGtG,IAAI,CAACoI,KAAK,CAACF,GAAG,GAAG,CAACC,IAAI,GAAGD,GAAG,IAAI,CAAC,CAAC;IAC1C,IAAIR,UAAU,CAACpB,KAAK,CAAC,GAAG2B,YAAY,EAAE;MACpCC,GAAG,GAAG5B,KAAK,GAAG,CAAC;IACjB,CAAC,MAAM;MACL6B,IAAI,GAAG7B,KAAK;IACd;EACF;EACA,IAAIoB,UAAU,CAACpB,KAAK,CAAC,GAAG2B,YAAY,EAAE;IACpC3B,KAAK,EAAE;EACT;EACA,IAAIoB,UAAU,CAACpB,KAAK,CAAC,KAAK2B,YAAY,EAAE;IACtC,OAAO3B,KAAK,GAAGyB,WAAW;EAC5B;EAEA,OACE,CAAC,GACD,CAACzB,KAAK,GACJ,CAAC2B,YAAY,GAAGP,UAAU,CAACpB,KAAK,CAAC,KAC9BoB,UAAU,CAACpB,KAAK,GAAG,CAAC,CAAC,GAAGoB,UAAU,CAACpB,KAAK,CAAC,CAAC,IAC7CyB,WAAW;AAEjB,CAAC;AAED,OAAO,MAAMR,cAAc,GAAGA,CAAChD,EAAS,EAAEE,EAAS,KAAK;EACtD,OAAOF,EAAE,CAAC,CAAC,CAAC,KAAKE,EAAE,CAAC,CAAC,CAAC,IAAIF,EAAE,CAAC,CAAC,CAAC,KAAKE,EAAE,CAAC,CAAC,CAAC;AAC3C,CAAC;AAED,OAAO,MAAM4D,YAAY,GAAItI,KAAa,IAAK;EAC7C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,OAAOC,IAAI,CAACiF,KAAK,CAAElF,KAAK,GAAGC,IAAI,CAACsI,EAAE,GAAI,KAAK,CAAC,GAAG,IAAI,KAAK,CAAC;AAC3D,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}