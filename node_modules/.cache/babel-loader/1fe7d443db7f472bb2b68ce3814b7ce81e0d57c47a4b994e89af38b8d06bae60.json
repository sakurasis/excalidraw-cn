{"ast":null,"code":"import { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nimport { parsePath, normalize, absolutize } from 'path-data-parser';\nconst helper = {\n  randOffset,\n  randOffsetWithRange,\n  ellipse,\n  doubleLineOps: doubleLineFillOps\n};\nexport function line(x1, y1, x2, y2, o) {\n  return {\n    type: 'path',\n    ops: _doubleLine(x1, y1, x2, y2, o)\n  };\n}\nexport function linearPath(points, close, o) {\n  const len = (points || []).length;\n  if (len > 2) {\n    const ops = [];\n    for (let i = 0; i < len - 1; i++) {\n      ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n    }\n    if (close) {\n      ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n    }\n    return {\n      type: 'path',\n      ops\n    };\n  } else if (len === 2) {\n    return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n  }\n  return {\n    type: 'path',\n    ops: []\n  };\n}\nexport function polygon(points, o) {\n  return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n  const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n  return polygon(points, o);\n}\nexport function curve(points, o) {\n  let o1 = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n  if (!o.disableMultiStroke) {\n    const o2 = _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n    o1 = o1.concat(o2);\n  }\n  return {\n    type: 'path',\n    ops: o1\n  };\n}\nexport function ellipse(x, y, width, height, o) {\n  const params = generateEllipseParams(width, height, o);\n  return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n  const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n  const stepCount = Math.ceil(Math.max(o.curveStepCount, o.curveStepCount / Math.sqrt(200) * psq));\n  const increment = Math.PI * 2 / stepCount;\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  const curveFitRandomness = 1 - o.curveFitting;\n  rx += _offsetOpt(rx * curveFitRandomness, o);\n  ry += _offsetOpt(ry * curveFitRandomness, o);\n  return {\n    increment,\n    rx,\n    ry\n  };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n  const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n  let o1 = _curve(ap1, null, o);\n  if (!o.disableMultiStroke && o.roughness !== 0) {\n    const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n    const o2 = _curve(ap2, null, o);\n    o1 = o1.concat(o2);\n  }\n  return {\n    estimatedPoints: cp1,\n    opset: {\n      type: 'path',\n      ops: o1\n    }\n  };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n  const cx = x;\n  const cy = y;\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  rx += _offsetOpt(rx * 0.01, o);\n  ry += _offsetOpt(ry * 0.01, o);\n  let strt = start;\n  let stp = stop;\n  while (strt < 0) {\n    strt += Math.PI * 2;\n    stp += Math.PI * 2;\n  }\n  if (stp - strt > Math.PI * 2) {\n    strt = 0;\n    stp = Math.PI * 2;\n  }\n  const ellipseInc = Math.PI * 2 / o.curveStepCount;\n  const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n  const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n  if (!o.disableMultiStroke) {\n    const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n    ops.push(...o2);\n  }\n  if (closed) {\n    if (roughClosure) {\n      ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n    } else {\n      ops.push({\n        op: 'lineTo',\n        data: [cx, cy]\n      }, {\n        op: 'lineTo',\n        data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)]\n      });\n    }\n  }\n  return {\n    type: 'path',\n    ops\n  };\n}\nexport function svgPath(path, o) {\n  const segments = normalize(absolutize(parsePath(path)));\n  const ops = [];\n  let first = [0, 0];\n  let current = [0, 0];\n  for (const {\n    key,\n    data\n  } of segments) {\n    switch (key) {\n      case 'M':\n        {\n          const ro = 1 * (o.maxRandomnessOffset || 0);\n          const pv = o.preserveVertices;\n          ops.push({\n            op: 'move',\n            data: data.map(d => d + (pv ? 0 : _offsetOpt(ro, o)))\n          });\n          current = [data[0], data[1]];\n          first = [data[0], data[1]];\n          break;\n        }\n      case 'L':\n        ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n        current = [data[0], data[1]];\n        break;\n      case 'C':\n        {\n          const [x1, y1, x2, y2, x, y] = data;\n          ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n          current = [x, y];\n          break;\n        }\n      case 'Z':\n        ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n        current = [first[0], first[1]];\n        break;\n    }\n  }\n  return {\n    type: 'path',\n    ops\n  };\n}\n// Fills\nexport function solidFillPolygon(polygonList, o) {\n  const ops = [];\n  for (const points of polygonList) {\n    if (points.length) {\n      const offset = o.maxRandomnessOffset || 0;\n      const len = points.length;\n      if (len > 2) {\n        ops.push({\n          op: 'move',\n          data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]\n        });\n        for (let i = 1; i < len; i++) {\n          ops.push({\n            op: 'lineTo',\n            data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]\n          });\n        }\n      }\n    }\n  }\n  return {\n    type: 'fillPath',\n    ops\n  };\n}\nexport function patternFillPolygons(polygonList, o) {\n  return getFiller(o, helper).fillPolygons(polygonList, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n  const cx = x;\n  const cy = y;\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  rx += _offsetOpt(rx * 0.01, o);\n  ry += _offsetOpt(ry * 0.01, o);\n  let strt = start;\n  let stp = stop;\n  while (strt < 0) {\n    strt += Math.PI * 2;\n    stp += Math.PI * 2;\n  }\n  if (stp - strt > Math.PI * 2) {\n    strt = 0;\n    stp = Math.PI * 2;\n  }\n  const increment = (stp - strt) / o.curveStepCount;\n  const points = [];\n  for (let angle = strt; angle <= stp; angle = angle + increment) {\n    points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n  }\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  points.push([cx, cy]);\n  return patternFillPolygons([points], o);\n}\nexport function randOffset(x, o) {\n  return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n  return _offset(min, max, o);\n}\nexport function doubleLineFillOps(x1, y1, x2, y2, o) {\n  return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n  const result = Object.assign({}, ops);\n  result.randomizer = undefined;\n  if (ops.seed) {\n    result.seed = ops.seed + 1;\n  }\n  return result;\n}\nfunction random(ops) {\n  if (!ops.randomizer) {\n    ops.randomizer = new Random(ops.seed || 0);\n  }\n  return ops.randomizer.next();\n}\nfunction _offset(min, max, ops) {\n  let roughnessGain = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  return ops.roughness * roughnessGain * (random(ops) * (max - min) + min);\n}\nfunction _offsetOpt(x, ops) {\n  let roughnessGain = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o) {\n  let filling = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n  const o1 = _line(x1, y1, x2, y2, o, true, false);\n  if (singleStroke) {\n    return o1;\n  }\n  const o2 = _line(x1, y1, x2, y2, o, true, true);\n  return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n  const lengthSq = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\n  const length = Math.sqrt(lengthSq);\n  let roughnessGain = 1;\n  if (length < 200) {\n    roughnessGain = 1;\n  } else if (length > 500) {\n    roughnessGain = 0.4;\n  } else {\n    roughnessGain = -0.0016668 * length + 1.233334;\n  }\n  let offset = o.maxRandomnessOffset || 0;\n  if (offset * offset * 100 > lengthSq) {\n    offset = length / 10;\n  }\n  const halfOffset = offset / 2;\n  const divergePoint = 0.2 + random(o) * 0.2;\n  let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n  let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n  midDispX = _offsetOpt(midDispX, o, roughnessGain);\n  midDispY = _offsetOpt(midDispY, o, roughnessGain);\n  const ops = [];\n  const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n  const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n  const preserveVertices = o.preserveVertices;\n  if (move) {\n    if (overlay) {\n      ops.push({\n        op: 'move',\n        data: [x1 + (preserveVertices ? 0 : randomHalf()), y1 + (preserveVertices ? 0 : randomHalf())]\n      });\n    } else {\n      ops.push({\n        op: 'move',\n        data: [x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)), y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain))]\n      });\n    }\n  }\n  if (overlay) {\n    ops.push({\n      op: 'bcurveTo',\n      data: [midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(), midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(), midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(), midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(), x2 + (preserveVertices ? 0 : randomHalf()), y2 + (preserveVertices ? 0 : randomHalf())]\n    });\n  } else {\n    ops.push({\n      op: 'bcurveTo',\n      data: [midDispX + x1 + (x2 - x1) * divergePoint + randomFull(), midDispY + y1 + (y2 - y1) * divergePoint + randomFull(), midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(), midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(), x2 + (preserveVertices ? 0 : randomFull()), y2 + (preserveVertices ? 0 : randomFull())]\n    });\n  }\n  return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n  const ps = [];\n  ps.push([points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]);\n  ps.push([points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]);\n  for (let i = 1; i < points.length; i++) {\n    ps.push([points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]);\n    if (i === points.length - 1) {\n      ps.push([points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]);\n    }\n  }\n  return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n  const len = points.length;\n  const ops = [];\n  if (len > 3) {\n    const b = [];\n    const s = 1 - o.curveTightness;\n    ops.push({\n      op: 'move',\n      data: [points[1][0], points[1][1]]\n    });\n    for (let i = 1; i + 2 < len; i++) {\n      const cachedVertArray = points[i];\n      b[0] = [cachedVertArray[0], cachedVertArray[1]];\n      b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n      b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n      b[3] = [points[i + 1][0], points[i + 1][1]];\n      ops.push({\n        op: 'bcurveTo',\n        data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]]\n      });\n    }\n    if (closePoint && closePoint.length === 2) {\n      const ro = o.maxRandomnessOffset;\n      ops.push({\n        op: 'lineTo',\n        data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)]\n      });\n    }\n  } else if (len === 3) {\n    ops.push({\n      op: 'move',\n      data: [points[1][0], points[1][1]]\n    });\n    ops.push({\n      op: 'bcurveTo',\n      data: [points[1][0], points[1][1], points[2][0], points[2][1], points[2][0], points[2][1]]\n    });\n  } else if (len === 2) {\n    ops.push(..._doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n  }\n  return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n  const coreOnly = o.roughness === 0;\n  const corePoints = [];\n  const allPoints = [];\n  if (coreOnly) {\n    increment = increment / 4;\n    allPoints.push([cx + rx * Math.cos(-increment), cy + ry * Math.sin(-increment)]);\n    for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {\n      const p = [cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)];\n      corePoints.push(p);\n      allPoints.push(p);\n    }\n    allPoints.push([cx + rx * Math.cos(0), cy + ry * Math.sin(0)]);\n    allPoints.push([cx + rx * Math.cos(increment), cy + ry * Math.sin(increment)]);\n  } else {\n    const radOffset = _offsetOpt(0.5, o) - Math.PI / 2;\n    allPoints.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)]);\n    const endAngle = Math.PI * 2 + radOffset - 0.01;\n    for (let angle = radOffset; angle < endAngle; angle = angle + increment) {\n      const p = [_offsetOpt(offset, o) + cx + rx * Math.cos(angle), _offsetOpt(offset, o) + cy + ry * Math.sin(angle)];\n      corePoints.push(p);\n      allPoints.push(p);\n    }\n    allPoints.push([_offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5), _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)]);\n    allPoints.push([_offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap), _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)]);\n    allPoints.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)]);\n  }\n  return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n  const radOffset = strt + _offsetOpt(0.1, o);\n  const points = [];\n  points.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)]);\n  for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n    points.push([_offsetOpt(offset, o) + cx + rx * Math.cos(angle), _offsetOpt(offset, o) + cy + ry * Math.sin(angle)]);\n  }\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n  const ops = [];\n  const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n  let f = [0, 0];\n  const iterations = o.disableMultiStroke ? 1 : 2;\n  const preserveVertices = o.preserveVertices;\n  for (let i = 0; i < iterations; i++) {\n    if (i === 0) {\n      ops.push({\n        op: 'move',\n        data: [current[0], current[1]]\n      });\n    } else {\n      ops.push({\n        op: 'move',\n        data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))]\n      });\n    }\n    f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n    ops.push({\n      op: 'bcurveTo',\n      data: [x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o), x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o), f[0], f[1]]\n    });\n  }\n  return ops;\n}","map":{"version":3,"names":["getFiller","Random","parsePath","normalize","absolutize","helper","randOffset","randOffsetWithRange","ellipse","doubleLineOps","doubleLineFillOps","line","x1","y1","x2","y2","o","type","ops","_doubleLine","linearPath","points","close","len","length","i","push","polygon","rectangle","x","y","width","height","curve","o1","_curveWithOffset","roughness","disableMultiStroke","o2","cloneOptionsAlterSeed","concat","params","generateEllipseParams","ellipseWithParams","opset","psq","Math","sqrt","PI","pow","stepCount","ceil","max","curveStepCount","increment","rx","abs","ry","curveFitRandomness","curveFitting","_offsetOpt","ellipseParams","ap1","cp1","_computeEllipsePoints","_offset","_curve","ap2","estimatedPoints","arc","start","stop","closed","roughClosure","cx","cy","strt","stp","ellipseInc","arcInc","min","_arc","cos","sin","op","data","svgPath","path","segments","first","current","key","ro","maxRandomnessOffset","pv","preserveVertices","map","d","_bezierTo","solidFillPolygon","polygonList","offset","patternFillPolygons","fillPolygons","patternFillArc","angle","result","Object","assign","randomizer","undefined","seed","random","next","roughnessGain","arguments","filling","singleStroke","disableMultiStrokeFill","_line","move","overlay","lengthSq","halfOffset","divergePoint","midDispX","bowing","midDispY","randomHalf","randomFull","ps","closePoint","b","s","curveTightness","cachedVertArray","overlap","coreOnly","corePoints","allPoints","p","radOffset","endAngle","ros","f","iterations"],"sources":["D:/project/excalidraw-cn/node_modules/roughjs/bin/renderer.js"],"sourcesContent":["import { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nimport { parsePath, normalize, absolutize } from 'path-data-parser';\nconst helper = {\n    randOffset,\n    randOffsetWithRange,\n    ellipse,\n    doubleLineOps: doubleLineFillOps,\n};\nexport function line(x1, y1, x2, y2, o) {\n    return { type: 'path', ops: _doubleLine(x1, y1, x2, y2, o) };\n}\nexport function linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n        const ops = [];\n        for (let i = 0; i < (len - 1); i++) {\n            ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n        }\n        if (close) {\n            ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n        }\n        return { type: 'path', ops };\n    }\n    else if (len === 2) {\n        return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n    return { type: 'path', ops: [] };\n}\nexport function polygon(points, o) {\n    return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n    const points = [\n        [x, y],\n        [x + width, y],\n        [x + width, y + height],\n        [x, y + height],\n    ];\n    return polygon(points, o);\n}\nexport function curve(points, o) {\n    let o1 = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n    if (!o.disableMultiStroke) {\n        const o2 = _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n        o1 = o1.concat(o2);\n    }\n    return { type: 'path', ops: o1 };\n}\nexport function ellipse(x, y, width, height, o) {\n    const params = generateEllipseParams(width, height, o);\n    return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n    const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n    const stepCount = Math.ceil(Math.max(o.curveStepCount, (o.curveStepCount / Math.sqrt(200)) * psq));\n    const increment = (Math.PI * 2) / stepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    const curveFitRandomness = 1 - o.curveFitting;\n    rx += _offsetOpt(rx * curveFitRandomness, o);\n    ry += _offsetOpt(ry * curveFitRandomness, o);\n    return { increment, rx, ry };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n    const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n    let o1 = _curve(ap1, null, o);\n    if ((!o.disableMultiStroke) && (o.roughness !== 0)) {\n        const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n        const o2 = _curve(ap2, null, o);\n        o1 = o1.concat(o2);\n    }\n    return {\n        estimatedPoints: cp1,\n        opset: { type: 'path', ops: o1 },\n    };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    if (!o.disableMultiStroke) {\n        const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        ops.push(...o2);\n    }\n    if (closed) {\n        if (roughClosure) {\n            ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n        }\n        else {\n            ops.push({ op: 'lineTo', data: [cx, cy] }, { op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n        }\n    }\n    return { type: 'path', ops };\n}\nexport function svgPath(path, o) {\n    const segments = normalize(absolutize(parsePath(path)));\n    const ops = [];\n    let first = [0, 0];\n    let current = [0, 0];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M': {\n                const ro = 1 * (o.maxRandomnessOffset || 0);\n                const pv = o.preserveVertices;\n                ops.push({ op: 'move', data: data.map((d) => d + (pv ? 0 : _offsetOpt(ro, o))) });\n                current = [data[0], data[1]];\n                first = [data[0], data[1]];\n                break;\n            }\n            case 'L':\n                ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n                current = [data[0], data[1]];\n                break;\n            case 'C': {\n                const [x1, y1, x2, y2, x, y] = data;\n                ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n                current = [x, y];\n                break;\n            }\n            case 'Z':\n                ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n                current = [first[0], first[1]];\n                break;\n        }\n    }\n    return { type: 'path', ops };\n}\n// Fills\nexport function solidFillPolygon(polygonList, o) {\n    const ops = [];\n    for (const points of polygonList) {\n        if (points.length) {\n            const offset = o.maxRandomnessOffset || 0;\n            const len = points.length;\n            if (len > 2) {\n                ops.push({ op: 'move', data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)] });\n                for (let i = 1; i < len; i++) {\n                    ops.push({ op: 'lineTo', data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)] });\n                }\n            }\n        }\n    }\n    return { type: 'fillPath', ops };\n}\nexport function patternFillPolygons(polygonList, o) {\n    return getFiller(o, helper).fillPolygons(polygonList, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const increment = (stp - strt) / o.curveStepCount;\n    const points = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n        points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n    }\n    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n    points.push([cx, cy]);\n    return patternFillPolygons([points], o);\n}\nexport function randOffset(x, o) {\n    return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n    return _offset(min, max, o);\n}\nexport function doubleLineFillOps(x1, y1, x2, y2, o) {\n    return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n    const result = Object.assign({}, ops);\n    result.randomizer = undefined;\n    if (ops.seed) {\n        result.seed = ops.seed + 1;\n    }\n    return result;\n}\nfunction random(ops) {\n    if (!ops.randomizer) {\n        ops.randomizer = new Random(ops.seed || 0);\n    }\n    return ops.randomizer.next();\n}\nfunction _offset(min, max, ops, roughnessGain = 1) {\n    return ops.roughness * roughnessGain * ((random(ops) * (max - min)) + min);\n}\nfunction _offsetOpt(x, ops, roughnessGain = 1) {\n    return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o, filling = false) {\n    const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n    const o1 = _line(x1, y1, x2, y2, o, true, false);\n    if (singleStroke) {\n        return o1;\n    }\n    const o2 = _line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    const length = Math.sqrt(lengthSq);\n    let roughnessGain = 1;\n    if (length < 200) {\n        roughnessGain = 1;\n    }\n    else if (length > 500) {\n        roughnessGain = 0.4;\n    }\n    else {\n        roughnessGain = (-0.0016668) * length + 1.233334;\n    }\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n        offset = length / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + random(o) * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = _offsetOpt(midDispX, o, roughnessGain);\n    midDispY = _offsetOpt(midDispY, o, roughnessGain);\n    const ops = [];\n    const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n    const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n    const preserveVertices = o.preserveVertices;\n    if (move) {\n        if (overlay) {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : randomHalf()),\n                    y1 + (preserveVertices ? 0 : randomHalf()),\n                ],\n            });\n        }\n        else {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                    y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                ],\n            });\n        }\n    }\n    if (overlay) {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),\n                x2 + (preserveVertices ? 0 : randomHalf()),\n                y2 + (preserveVertices ? 0 : randomHalf()),\n            ],\n        });\n    }\n    else {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),\n                x2 + (preserveVertices ? 0 : randomFull()),\n                y2 + (preserveVertices ? 0 : randomFull()),\n            ],\n        });\n    }\n    return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n    const ps = [];\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n        ps.push([\n            points[i][0] + _offsetOpt(offset, o),\n            points[i][1] + _offsetOpt(offset, o),\n        ]);\n        if (i === (points.length - 1)) {\n            ps.push([\n                points[i][0] + _offsetOpt(offset, o),\n                points[i][1] + _offsetOpt(offset, o),\n            ]);\n        }\n    }\n    return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n    const len = points.length;\n    const ops = [];\n    if (len > 3) {\n        const b = [];\n        const s = 1 - o.curveTightness;\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        for (let i = 1; (i + 2) < len; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n        }\n        if (closePoint && closePoint.length === 2) {\n            const ro = o.maxRandomnessOffset;\n            ops.push({ op: 'lineTo', data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });\n        }\n    }\n    else if (len === 3) {\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                points[1][0], points[1][1],\n                points[2][0], points[2][1],\n                points[2][0], points[2][1],\n            ],\n        });\n    }\n    else if (len === 2) {\n        ops.push(..._doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n    }\n    return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const coreOnly = o.roughness === 0;\n    const corePoints = [];\n    const allPoints = [];\n    if (coreOnly) {\n        increment = increment / 4;\n        allPoints.push([\n            cx + rx * Math.cos(-increment),\n            cy + ry * Math.sin(-increment),\n        ]);\n        for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {\n            const p = [\n                cx + rx * Math.cos(angle),\n                cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            cx + rx * Math.cos(0),\n            cy + ry * Math.sin(0),\n        ]);\n        allPoints.push([\n            cx + rx * Math.cos(increment),\n            cy + ry * Math.sin(increment),\n        ]);\n    }\n    else {\n        const radOffset = _offsetOpt(0.5, o) - (Math.PI / 2);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n        ]);\n        const endAngle = Math.PI * 2 + radOffset - 0.01;\n        for (let angle = radOffset; angle < endAngle; angle = angle + increment) {\n            const p = [\n                _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n                _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n            _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5),\n        ]);\n    }\n    return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + _offsetOpt(0.1, o);\n    const points = [];\n    points.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n        points.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n        ]);\n    }\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n    const ops = [];\n    const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n    let f = [0, 0];\n    const iterations = o.disableMultiStroke ? 1 : 2;\n    const preserveVertices = o.preserveVertices;\n    for (let i = 0; i < iterations; i++) {\n        if (i === 0) {\n            ops.push({ op: 'move', data: [current[0], current[1]] });\n        }\n        else {\n            ops.push({ op: 'move', data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))] });\n        }\n        f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o),\n                x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o),\n                f[0], f[1],\n            ],\n        });\n    }\n    return ops;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}