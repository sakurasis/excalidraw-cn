{"ast":null,"code":"import { newElementWith } from \"../element/mutateElement\";\nimport { KEYS } from \"../keys\";\nimport { arrayToMap } from \"../utils\";\nimport { register } from \"./register\";\nconst shouldLock = elements => elements.every(el => !el.locked);\nexport const actionToggleElementLock = register({\n  name: \"toggleElementLock\",\n  trackEvent: {\n    category: \"element\"\n  },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    return !selectedElements.some(element => element.locked && element.frameId);\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n      includeElementsInFrames: true\n    });\n    if (!selectedElements.length) {\n      return false;\n    }\n    const nextLockState = shouldLock(selectedElements);\n    const selectedElementsMap = arrayToMap(selectedElements);\n    return {\n      elements: elements.map(element => {\n        if (!selectedElementsMap.has(element.id)) {\n          return element;\n        }\n        return newElementWith(element, {\n          locked: nextLockState\n        });\n      }),\n      appState: {\n        ...appState,\n        selectedLinearElement: nextLockState ? null : appState.selectedLinearElement\n      },\n      commitToHistory: true\n    };\n  },\n  contextItemLabel: (elements, appState, app) => {\n    const selected = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: false\n    });\n    if (selected.length === 1 && selected[0].type !== \"frame\") {\n      return selected[0].locked ? \"labels.elementLock.unlock\" : \"labels.elementLock.lock\";\n    }\n    return shouldLock(selected) ? \"labels.elementLock.lockAll\" : \"labels.elementLock.unlockAll\";\n  },\n  keyTest: (event, appState, elements, app) => {\n    return event.key.toLocaleLowerCase() === KEYS.L && event[KEYS.CTRL_OR_CMD] && event.shiftKey && app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: false\n    }).length > 0;\n  }\n});\nexport const actionUnlockAllElements = register({\n  name: \"unlockAllElements\",\n  trackEvent: {\n    category: \"canvas\"\n  },\n  viewMode: false,\n  predicate: elements => {\n    return elements.some(element => element.locked);\n  },\n  perform: (elements, appState) => {\n    const lockedElements = elements.filter(el => el.locked);\n    return {\n      elements: elements.map(element => {\n        if (element.locked) {\n          return newElementWith(element, {\n            locked: false\n          });\n        }\n        return element;\n      }),\n      appState: {\n        ...appState,\n        selectedElementIds: Object.fromEntries(lockedElements.map(el => [el.id, true]))\n      },\n      commitToHistory: true\n    };\n  },\n  contextItemLabel: \"labels.elementLock.unlockAll\"\n});","map":{"version":3,"names":["newElementWith","KEYS","arrayToMap","register","shouldLock","elements","every","el","locked","actionToggleElementLock","name","trackEvent","category","predicate","appState","_","app","selectedElements","scene","getSelectedElements","some","element","frameId","perform","selectedElementIds","includeBoundTextElement","includeElementsInFrames","length","nextLockState","selectedElementsMap","map","has","id","selectedLinearElement","commitToHistory","contextItemLabel","selected","type","keyTest","event","key","toLocaleLowerCase","L","CTRL_OR_CMD","shiftKey","actionUnlockAllElements","viewMode","lockedElements","filter","Object","fromEntries"],"sources":["D:/project/excalidraw-cn/src/actions/actionElementLock.ts"],"sourcesContent":["import { newElementWith } from \"../element/mutateElement\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { KEYS } from \"../keys\";\nimport { arrayToMap } from \"../utils\";\nimport { register } from \"./register\";\n\nconst shouldLock = (elements: readonly ExcalidrawElement[]) =>\n  elements.every((el) => !el.locked);\n\nexport const actionToggleElementLock = register({\n  name: \"toggleElementLock\",\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    return !selectedElements.some(\n      (element) => element.locked && element.frameId,\n    );\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n      includeElementsInFrames: true,\n    });\n\n    if (!selectedElements.length) {\n      return false;\n    }\n\n    const nextLockState = shouldLock(selectedElements);\n    const selectedElementsMap = arrayToMap(selectedElements);\n    return {\n      elements: elements.map((element) => {\n        if (!selectedElementsMap.has(element.id)) {\n          return element;\n        }\n\n        return newElementWith(element, { locked: nextLockState });\n      }),\n      appState: {\n        ...appState,\n        selectedLinearElement: nextLockState\n          ? null\n          : appState.selectedLinearElement,\n      },\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: (elements, appState, app) => {\n    const selected = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: false,\n    });\n    if (selected.length === 1 && selected[0].type !== \"frame\") {\n      return selected[0].locked\n        ? \"labels.elementLock.unlock\"\n        : \"labels.elementLock.lock\";\n    }\n\n    return shouldLock(selected)\n      ? \"labels.elementLock.lockAll\"\n      : \"labels.elementLock.unlockAll\";\n  },\n  keyTest: (event, appState, elements, app) => {\n    return (\n      event.key.toLocaleLowerCase() === KEYS.L &&\n      event[KEYS.CTRL_OR_CMD] &&\n      event.shiftKey &&\n      app.scene.getSelectedElements({\n        selectedElementIds: appState.selectedElementIds,\n        includeBoundTextElement: false,\n      }).length > 0\n    );\n  },\n});\n\nexport const actionUnlockAllElements = register({\n  name: \"unlockAllElements\",\n  trackEvent: { category: \"canvas\" },\n  viewMode: false,\n  predicate: (elements) => {\n    return elements.some((element) => element.locked);\n  },\n  perform: (elements, appState) => {\n    const lockedElements = elements.filter((el) => el.locked);\n\n    return {\n      elements: elements.map((element) => {\n        if (element.locked) {\n          return newElementWith(element, { locked: false });\n        }\n        return element;\n      }),\n      appState: {\n        ...appState,\n        selectedElementIds: Object.fromEntries(\n          lockedElements.map((el) => [el.id, true]),\n        ),\n      },\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.elementLock.unlockAll\",\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}