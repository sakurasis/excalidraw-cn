{"ast":null,"code":"var _jsxFileName = \"D:\\\\project\\\\excalidraw-cn\\\\src\\\\components\\\\App.tsx\";\nimport React, { useContext } from \"react\";\nimport { flushSync } from \"react-dom\";\nimport rough from \"roughjs/bin/rough\";\nimport clsx from \"clsx\";\nimport { nanoid } from \"nanoid\";\nimport { actionAddToLibrary, actionBringForward, actionBringToFront, actionCopy, actionCopyAsPng, actionCopyAsSvg, copyText, actionCopyStyles, actionCut, actionDeleteSelected, actionDuplicateSelection, actionFinalize, actionFlipHorizontal, actionFlipVertical, actionGroup, actionPasteStyles, actionSelectAll, actionSendBackward, actionSendToBack, actionToggleGridMode, actionToggleStats, actionToggleZenMode, actionUnbindText, actionBindText, actionUngroup, actionLink, actionToggleElementLock, actionToggleLinearEditor } from \"../actions\";\nimport { createRedoAction, createUndoAction } from \"../actions/actionHistory\";\nimport { ActionManager } from \"../actions/manager\";\nimport { actions } from \"../actions/register\";\nimport { trackEvent } from \"../analytics\";\nimport { getDefaultAppState, isEraserActive, isHandToolActive } from \"../appState\";\nimport { parseClipboard } from \"../clipboard\";\nimport { APP_NAME, CURSOR_TYPE, DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT, DEFAULT_UI_OPTIONS, DEFAULT_VERTICAL_ALIGN, DRAGGING_THRESHOLD, ELEMENT_READY_TO_ERASE_OPACITY, ELEMENT_SHIFT_TRANSLATE_AMOUNT, ELEMENT_TRANSLATE_AMOUNT, ENV, EVENT, FRAME_STYLE, GRID_SIZE, IMAGE_MIME_TYPES, IMAGE_RENDER_TIMEOUT, isAndroid, isBrave, LINE_CONFIRM_THRESHOLD, MAX_ALLOWED_FILE_BYTES, MIME_TYPES, MQ_MAX_HEIGHT_LANDSCAPE, MQ_MAX_WIDTH_LANDSCAPE, MQ_MAX_WIDTH_PORTRAIT, MQ_RIGHT_SIDEBAR_MIN_WIDTH, MQ_SM_MAX_WIDTH, POINTER_BUTTON, ROUNDNESS, SCROLL_TIMEOUT, TAP_TWICE_TIMEOUT, TEXT_TO_CENTER_SNAP_THRESHOLD, THEME, THEME_FILTER, TOUCH_CTX_MENU_TIMEOUT, VERTICAL_ALIGN, ZOOM_STEP } from \"../constants\";\nimport { exportCanvas, loadFromBlob } from \"../data\";\nimport Library, { distributeLibraryItemsOnSquareGrid } from \"../data/library\";\nimport { restore, restoreElements } from \"../data/restore\";\nimport { dragNewElement, dragSelectedElements, duplicateElement, getCommonBounds, getCursorForResizingElement, getDragOffsetXY, getElementWithTransformHandleType, getNormalizedDimensions, getResizeArrowDirection, getResizeOffsetXY, getLockedLinearCursorAlignSize, getTransformHandleTypeFromCoords, hitTest, isHittingElementBoundingBoxWithoutHittingElement, isInvisiblySmallElement, isNonDeletedElement, isTextElement, newElement, newLinearElement, newTextElement, newImageElement, textWysiwyg, transformElements, updateTextElement, redrawTextBoundingBox } from \"../element\";\nimport { bindOrUnbindLinearElement, bindOrUnbindSelectedElements, fixBindingsAfterDeletion, fixBindingsAfterDuplication, getEligibleElementsForBinding, getHoveredElementForBinding, isBindingEnabled, isLinearElementSimpleAndAlreadyBound, maybeBindLinearElement, shouldEnableBindingForPointerEvent, unbindLinearElements, updateBoundElements } from \"../element/binding\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { mutateElement, newElementWith } from \"../element/mutateElement\";\nimport { deepCopyElement, duplicateElements, newFrameElement, newFreeDrawElement } from \"../element/newElement\";\nimport { hasBoundTextElement, isArrowElement, isBindingElement, isBindingElementType, isBoundToContainer, isFrameElement, isImageElement, isInitializedImageElement, isLinearElement, isLinearElementType, isUsingAdaptiveRadius } from \"../element/typeChecks\";\nimport { getCenter, getDistance } from \"../gesture\";\nimport { editGroupForSelectedElement, getElementsInGroup, getSelectedGroupIdForElement, getSelectedGroupIds, isElementInGroup, isSelectedViaGroup, selectGroupsForSelectedElements } from \"../groups\";\nimport History from \"../history\";\nimport { defaultLang, getLanguage, languages, setLanguage, t } from \"../i18n\";\nimport { CODES, shouldResizeFromCenter, shouldMaintainAspectRatio, shouldRotateWithDiscreteAngle, isArrowKey, KEYS } from \"../keys\";\nimport { distance2d, getGridPoint, isPathALoop } from \"../math\";\nimport { isVisibleElement, renderScene } from \"../renderer/renderScene\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport { calculateScrollCenter, getElementsAtPosition, getElementsWithinSelection, getNormalizedZoom, getSelectedElements, hasBackground, isOverScrollBars, isSomeElementSelected } from \"../scene\";\nimport Scene from \"../scene/Scene\";\nimport { getStateForZoom } from \"../scene/zoom\";\nimport { findShapeByKey } from \"../shapes\";\nimport { debounce, distance, getFontString, getNearestScrollableContainer, isInputLike, isToolIcon, isWritableElement, resetCursor, resolvablePromise, sceneCoordsToViewportCoords, setCursor, setCursorForShape, tupleToCoors, viewportCoordsToSceneCoords, withBatchedUpdates, wrapEvent, withBatchedUpdatesThrottled, updateObject, setEraserCursor, updateActiveTool, getShortcutKey, isTransparent, easeToValuesRAF, muteFSAbortError, easeOut } from \"../utils\";\nimport { ContextMenu, CONTEXT_MENU_SEPARATOR } from \"./ContextMenu\";\nimport LayerUI from \"./LayerUI\";\nimport { Toast } from \"./Toast\";\nimport { actionToggleViewMode } from \"../actions/actionToggleViewMode\";\nimport { dataURLToFile, generateIdFromFile, getDataURL, getFileFromEvent, isImageFileHandle, isSupportedImageFile, loadSceneOrLibraryFromBlob, normalizeFile, parseLibraryJSON, resizeImageFile, SVGStringToFile } from \"../data/blob\";\nimport { getInitializedImageElements, loadHTMLImageElement, normalizeSVG, updateImageCache as _updateImageCache } from \"../element/image\";\nimport throttle from \"lodash.throttle\";\nimport { fileOpen } from \"../data/filesystem\";\nimport { bindTextToShapeAfterDuplication, getApproxMinLineHeight, getApproxMinLineWidth, getBoundTextElement, getContainerCenter, getContainerDims, getContainerElement, getDefaultLineHeight, getLineHeightInPx, getTextBindableContainerAtPosition, isMeasureTextSupported, isValidTextContainer } from \"../element/textElement\";\nimport { isHittingElementNotConsideringBoundingBox } from \"../element/collision\";\nimport { showHyperlinkTooltip, hideHyperlinkToolip, Hyperlink, isPointHittingLinkIcon } from \"../element/Hyperlink\";\nimport { isLocalLink, normalizeLink } from \"../data/url\";\nimport { shouldShowBoundingBox } from \"../element/transformHandles\";\nimport { actionUnlockAllElements } from \"../actions/actionElementLock\";\nimport { Fonts } from \"../scene/Fonts\";\nimport { getFrameElements, isCursorInFrame, bindElementsToFramesAfterDuplication, addElementsToFrame, replaceAllElementsInFrame, removeElementsFromFrame, getElementsInResizingFrame, getElementsInNewFrame, getContainingFrame, elementOverlapsWithFrame, updateFrameMembershipOfSelectedElements, isElementInFrame } from \"../frame\";\nimport { excludeElementsInFramesFromSelection, makeNextSelectedElementIds } from \"../scene/selection\";\nimport { actionPaste } from \"../actions/actionClipboard\";\nimport { actionRemoveAllElementsFromFrame, actionSelectAllElementsInFrame } from \"../actions/actionFrame\";\nimport { actionToggleHandTool, zoomToFit } from \"../actions/actionCanvas\";\nimport { jotaiStore } from \"../jotai\";\nimport { activeConfirmDialogAtom } from \"./ActiveConfirmDialog\";\nimport { actionWrapTextInContainer } from \"../actions/actionBoundText\";\nimport BraveMeasureTextError from \"./BraveMeasureTextError\";\nimport { activeEyeDropperAtom } from \"./EyeDropper\";\nimport { isSidebarDockedAtom } from \"./Sidebar/Sidebar\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AppContext = /*#__PURE__*/React.createContext(null);\nconst AppPropsContext = /*#__PURE__*/React.createContext(null);\nconst deviceContextInitialValue = {\n  isSmScreen: false,\n  isMobile: false,\n  isTouchScreen: false,\n  canDeviceFitSidebar: false,\n  isLandscape: false\n};\nconst DeviceContext = /*#__PURE__*/React.createContext(deviceContextInitialValue);\nDeviceContext.displayName = \"DeviceContext\";\nexport const ExcalidrawContainerContext = /*#__PURE__*/React.createContext({\n  container: null,\n  id: null\n});\nExcalidrawContainerContext.displayName = \"ExcalidrawContainerContext\";\nconst ExcalidrawElementsContext = /*#__PURE__*/React.createContext([]);\nExcalidrawElementsContext.displayName = \"ExcalidrawElementsContext\";\nconst ExcalidrawAppStateContext = /*#__PURE__*/React.createContext({\n  ...getDefaultAppState(),\n  width: 0,\n  height: 0,\n  offsetLeft: 0,\n  offsetTop: 0\n});\nExcalidrawAppStateContext.displayName = \"ExcalidrawAppStateContext\";\nconst ExcalidrawSetAppStateContext = /*#__PURE__*/React.createContext(() => {\n  console.warn(\"unitialized ExcalidrawSetAppStateContext context!\");\n});\nExcalidrawSetAppStateContext.displayName = \"ExcalidrawSetAppStateContext\";\nconst ExcalidrawActionManagerContext = /*#__PURE__*/React.createContext(null);\nExcalidrawActionManagerContext.displayName = \"ExcalidrawActionManagerContext\";\nexport const useApp = () => useContext(AppContext);\nexport const useAppProps = () => useContext(AppPropsContext);\nexport const useDevice = () => useContext(DeviceContext);\nexport const useExcalidrawContainer = () => useContext(ExcalidrawContainerContext);\nexport const useExcalidrawElements = () => useContext(ExcalidrawElementsContext);\nexport const useExcalidrawAppState = () => useContext(ExcalidrawAppStateContext);\nexport const useExcalidrawSetAppState = () => useContext(ExcalidrawSetAppStateContext);\nexport const useExcalidrawActionManager = () => useContext(ExcalidrawActionManagerContext);\nlet didTapTwice = false;\nlet tappedTwiceTimer = 0;\nlet isHoldingSpace = false;\nlet isPanning = false;\nlet isDraggingScrollBar = false;\nlet currentScrollBars = {\n  horizontal: null,\n  vertical: null\n};\nlet touchTimeout = 0;\nlet invalidateContextMenu = false;\n\n// remove this hack when we can sync render & resizeObserver (state update)\n// to rAF. See #5439\nlet THROTTLE_NEXT_RENDER = true;\nlet IS_PLAIN_PASTE = false;\nlet IS_PLAIN_PASTE_TIMER = 0;\nlet PLAIN_PASTE_TOAST_SHOWN = false;\nlet lastPointerUp = null;\nconst gesture = {\n  pointers: new Map(),\n  lastCenter: null,\n  initialDistance: null,\n  initialScale: null\n};\nclass App extends React.Component {\n  constructor(props) {\n    var _this;\n    super(props);\n    _this = this;\n    this.canvas = null;\n    this.rc = null;\n    this.unmounted = false;\n    this.actionManager = void 0;\n    this.device = deviceContextInitialValue;\n    this.detachIsMobileMqHandler = void 0;\n    this.excalidrawContainerRef = /*#__PURE__*/React.createRef();\n    this.scene = void 0;\n    this.fonts = void 0;\n    this.resizeObserver = void 0;\n    this.nearestScrollableContainer = void 0;\n    this.library = void 0;\n    this.libraryItemsFromStorage = void 0;\n    this.id = void 0;\n    this.history = void 0;\n    this.excalidrawContainerValue = void 0;\n    this.files = {};\n    this.imageCache = new Map();\n    this.hitLinkElement = void 0;\n    this.lastPointerDown = null;\n    this.lastPointerUp = null;\n    this.lastViewportPosition = {\n      x: 0,\n      y: 0\n    };\n    this.getFrameNameDOMId = frameElement => {\n      return `${this.id}-frame-name-${frameElement.id}`;\n    };\n    this.frameNameBoundsCache = {\n      get: frameElement => {\n        let bounds = this.frameNameBoundsCache._cache.get(frameElement.id);\n        if (!bounds || bounds.zoom !== this.state.zoom.value || bounds.versionNonce !== frameElement.versionNonce) {\n          const frameNameDiv = document.getElementById(this.getFrameNameDOMId(frameElement));\n          if (frameNameDiv) {\n            const box = frameNameDiv.getBoundingClientRect();\n            const boxSceneTopLeft = viewportCoordsToSceneCoords({\n              clientX: box.x,\n              clientY: box.y\n            }, this.state);\n            const boxSceneBottomRight = viewportCoordsToSceneCoords({\n              clientX: box.right,\n              clientY: box.bottom\n            }, this.state);\n            bounds = {\n              x: boxSceneTopLeft.x,\n              y: boxSceneTopLeft.y,\n              width: boxSceneBottomRight.x - boxSceneTopLeft.x,\n              height: boxSceneBottomRight.y - boxSceneTopLeft.y,\n              angle: 0,\n              zoom: this.state.zoom.value,\n              versionNonce: frameElement.versionNonce\n            };\n            this.frameNameBoundsCache._cache.set(frameElement.id, bounds);\n            return bounds;\n          }\n          return null;\n        }\n        return bounds;\n      },\n      /**\n       * @private\n       */\n      _cache: new Map()\n    };\n    this.renderFrameNames = () => {\n      if (!this.state.frameRendering.enabled || !this.state.frameRendering.name) {\n        return null;\n      }\n      const isDarkTheme = this.state.theme === \"dark\";\n      return this.scene.getNonDeletedFrames().map((f, index) => {\n        if (!this.canvas || !isVisibleElement(f, this.canvas.width / window.devicePixelRatio, this.canvas.height / window.devicePixelRatio, {\n          offsetLeft: this.state.offsetLeft,\n          offsetTop: this.state.offsetTop,\n          scrollX: this.state.scrollX,\n          scrollY: this.state.scrollY,\n          zoom: this.state.zoom\n        })) {\n          // if frame not visible, don't render its name\n          return null;\n        }\n        const {\n          x: x1,\n          y: y1\n        } = sceneCoordsToViewportCoords({\n          sceneX: f.x,\n          sceneY: f.y\n        }, this.state);\n        const {\n          x: x2\n        } = sceneCoordsToViewportCoords({\n          sceneX: f.x + f.width,\n          sceneY: f.y + f.height\n        }, this.state);\n        const FRAME_NAME_GAP = 20;\n        const FRAME_NAME_EDIT_PADDING = 6;\n        const reset = () => {\n          var _f$name;\n          if (((_f$name = f.name) === null || _f$name === void 0 ? void 0 : _f$name.trim()) === \"\") {\n            mutateElement(f, {\n              name: null\n            });\n          }\n          this.setState({\n            editingFrame: null\n          });\n        };\n        let frameNameJSX;\n        if (f.id === this.state.editingFrame) {\n          const frameNameInEdit = f.name == null ? `Frame ${index + 1}` : f.name;\n          frameNameJSX = /*#__PURE__*/_jsxDEV(\"input\", {\n            autoFocus: true,\n            value: frameNameInEdit,\n            onChange: e => {\n              mutateElement(f, {\n                name: e.target.value\n              });\n            },\n            onBlur: () => reset(),\n            onKeyDown: event => {\n              // for some inexplicable reason, `onBlur` triggered on ESC\n              // does not reset `state.editingFrame` despite being called,\n              // and we need to reset it here as well\n              if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {\n                reset();\n              }\n            },\n            style: {\n              background: this.state.viewBackgroundColor,\n              filter: isDarkTheme ? THEME_FILTER : \"none\",\n              zIndex: 2,\n              border: \"none\",\n              display: \"block\",\n              padding: `${FRAME_NAME_EDIT_PADDING}px`,\n              borderRadius: 4,\n              boxShadow: \"inset 0 0 0 1px var(--color-primary)\",\n              fontFamily: \"Assistant\",\n              fontSize: \"14px\",\n              transform: `translateY(-${FRAME_NAME_EDIT_PADDING}px)`,\n              color: \"var(--color-gray-80)\",\n              overflow: \"hidden\",\n              maxWidth: `${Math.min(x2 - x1 - FRAME_NAME_EDIT_PADDING, document.body.clientWidth - x1 - FRAME_NAME_EDIT_PADDING)}px`\n            },\n            size: frameNameInEdit.length + 1 || 1,\n            dir: \"auto\",\n            autoComplete: \"off\",\n            autoCapitalize: \"off\",\n            autoCorrect: \"off\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 706,\n            columnNumber: 11\n          }, this);\n        } else {\n          frameNameJSX = f.name == null || f.name.trim() === \"\" ? `Frame ${index + 1}` : f.name.trim();\n        }\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          id: this.getFrameNameDOMId(f),\n          style: {\n            position: \"absolute\",\n            top: `${y1 - FRAME_NAME_GAP - this.state.offsetTop}px`,\n            left: `${x1 - this.state.offsetLeft - (this.state.editingFrame === f.id ? FRAME_NAME_EDIT_PADDING : 0)}px`,\n            zIndex: 2,\n            fontSize: \"14px\",\n            color: isDarkTheme ? \"var(--color-gray-60)\" : \"var(--color-gray-50)\",\n            width: \"max-content\",\n            maxWidth: `${x2 - x1 + FRAME_NAME_EDIT_PADDING * 2}px`,\n            overflow: f.id === this.state.editingFrame ? \"visible\" : \"hidden\",\n            whiteSpace: \"nowrap\",\n            textOverflow: \"ellipsis\",\n            cursor: CURSOR_TYPE.MOVE,\n            // disable all interaction (e.g. cursor change) when in view\n            // mode\n            pointerEvents: this.state.viewModeEnabled ? \"none\" : \"all\"\n          },\n          onPointerDown: event => this.handleCanvasPointerDown(event),\n          onWheel: event => this.handleWheel(event),\n          onContextMenu: event => {\n            this.handleCanvasContextMenu(event);\n          },\n          onDoubleClick: () => {\n            this.setState({\n              editingFrame: f.id\n            });\n          },\n          children: frameNameJSX\n        }, f.id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 757,\n          columnNumber: 9\n        }, this);\n      });\n    };\n    this.focusContainer = () => {\n      var _this$excalidrawConta;\n      (_this$excalidrawConta = this.excalidrawContainerRef.current) === null || _this$excalidrawConta === void 0 ? void 0 : _this$excalidrawConta.focus();\n    };\n    this.getSceneElementsIncludingDeleted = () => {\n      return this.scene.getElementsIncludingDeleted();\n    };\n    this.getSceneElements = () => {\n      return this.scene.getNonDeletedElements();\n    };\n    this.onInsertElements = elements => {\n      this.addElementsFromPasteOrLibrary({\n        elements,\n        position: \"center\",\n        files: null\n      });\n    };\n    this.onExportImage = async (type, elements) => {\n      trackEvent(\"export\", type, \"ui\");\n      const fileHandle = await exportCanvas(type, elements, this.state, this.files, {\n        exportBackground: this.state.exportBackground,\n        name: this.state.name,\n        viewBackgroundColor: this.state.viewBackgroundColor\n      }).catch(muteFSAbortError).catch(error => {\n        console.error(error);\n        this.setState({\n          errorMessage: error.message\n        });\n      });\n      if (this.state.exportEmbedScene && fileHandle && isImageFileHandle(fileHandle)) {\n        this.setState({\n          fileHandle\n        });\n      }\n    };\n    this.openEyeDropper = _ref => {\n      let {\n        type\n      } = _ref;\n      jotaiStore.set(activeEyeDropperAtom, {\n        swapPreviewOnAlt: true,\n        previewType: type === \"stroke\" ? \"strokeColor\" : \"backgroundColor\",\n        onSelect: (color, event) => {\n          const shouldUpdateStrokeColor = type === \"background\" && event.altKey || type === \"stroke\" && !event.altKey;\n          const selectedElements = this.scene.getSelectedElements(this.state);\n          if (!selectedElements.length || this.state.activeTool.type !== \"selection\") {\n            if (shouldUpdateStrokeColor) {\n              this.setState({\n                currentItemStrokeColor: color\n              });\n            } else {\n              this.setState({\n                currentItemBackgroundColor: color\n              });\n            }\n          } else {\n            this.updateScene({\n              elements: this.scene.getElementsIncludingDeleted().map(el => {\n                if (this.state.selectedElementIds[el.id]) {\n                  return newElementWith(el, {\n                    [shouldUpdateStrokeColor ? \"strokeColor\" : \"backgroundColor\"]: color\n                  });\n                }\n                return el;\n              })\n            });\n          }\n        },\n        keepOpenOnAlt: false\n      });\n    };\n    this.syncActionResult = withBatchedUpdates(actionResult => {\n      if (this.unmounted || actionResult === false) {\n        return;\n      }\n      let editingElement = null;\n      if (actionResult.elements) {\n        actionResult.elements.forEach(element => {\n          var _this$state$editingEl;\n          if (((_this$state$editingEl = this.state.editingElement) === null || _this$state$editingEl === void 0 ? void 0 : _this$state$editingEl.id) === element.id && this.state.editingElement !== element && isNonDeletedElement(element)) {\n            editingElement = element;\n          }\n        });\n        this.scene.replaceAllElements(actionResult.elements);\n        if (actionResult.commitToHistory) {\n          this.history.resumeRecording();\n        }\n      }\n      if (actionResult.files) {\n        this.files = actionResult.replaceFiles ? actionResult.files : {\n          ...this.files,\n          ...actionResult.files\n        };\n        this.addNewImagesToImageCache();\n      }\n      if (actionResult.appState || editingElement || this.state.contextMenu) {\n        var _actionResult$appStat, _actionResult$appStat2, _actionResult$appStat3, _actionResult$appStat4, _actionResult$appStat5, _actionResult$appStat6, _actionResult$appStat7, _actionResult$appStat8, _actionResult$appStat9, _editingElement;\n        if (actionResult.commitToHistory) {\n          this.history.resumeRecording();\n        }\n        let viewModeEnabled = (actionResult === null || actionResult === void 0 ? void 0 : (_actionResult$appStat = actionResult.appState) === null || _actionResult$appStat === void 0 ? void 0 : _actionResult$appStat.viewModeEnabled) || false;\n        let zenModeEnabled = (actionResult === null || actionResult === void 0 ? void 0 : (_actionResult$appStat2 = actionResult.appState) === null || _actionResult$appStat2 === void 0 ? void 0 : _actionResult$appStat2.zenModeEnabled) || false;\n        let gridSize = (actionResult === null || actionResult === void 0 ? void 0 : (_actionResult$appStat3 = actionResult.appState) === null || _actionResult$appStat3 === void 0 ? void 0 : _actionResult$appStat3.gridSize) || null;\n        const theme = (actionResult === null || actionResult === void 0 ? void 0 : (_actionResult$appStat4 = actionResult.appState) === null || _actionResult$appStat4 === void 0 ? void 0 : _actionResult$appStat4.theme) || this.props.theme || THEME.LIGHT;\n        let name = (_actionResult$appStat5 = actionResult === null || actionResult === void 0 ? void 0 : (_actionResult$appStat6 = actionResult.appState) === null || _actionResult$appStat6 === void 0 ? void 0 : _actionResult$appStat6.name) !== null && _actionResult$appStat5 !== void 0 ? _actionResult$appStat5 : this.state.name;\n        const errorMessage = (_actionResult$appStat7 = actionResult === null || actionResult === void 0 ? void 0 : (_actionResult$appStat8 = actionResult.appState) === null || _actionResult$appStat8 === void 0 ? void 0 : _actionResult$appStat8.errorMessage) !== null && _actionResult$appStat7 !== void 0 ? _actionResult$appStat7 : this.state.errorMessage;\n        if (typeof this.props.viewModeEnabled !== \"undefined\") {\n          viewModeEnabled = this.props.viewModeEnabled;\n        }\n        if (typeof this.props.zenModeEnabled !== \"undefined\") {\n          zenModeEnabled = this.props.zenModeEnabled;\n        }\n        if (typeof this.props.gridModeEnabled !== \"undefined\") {\n          gridSize = this.props.gridModeEnabled ? GRID_SIZE : null;\n        }\n        if (typeof this.props.name !== \"undefined\") {\n          name = this.props.name;\n        }\n        editingElement = editingElement || ((_actionResult$appStat9 = actionResult.appState) === null || _actionResult$appStat9 === void 0 ? void 0 : _actionResult$appStat9.editingElement) || null;\n        if ((_editingElement = editingElement) !== null && _editingElement !== void 0 && _editingElement.isDeleted) {\n          editingElement = null;\n        }\n        this.setState(state => {\n          // using Object.assign instead of spread to fool TS 4.2.2+ into\n          // regarding the resulting type as not containing undefined\n          // (which the following expression will never contain)\n          return Object.assign(actionResult.appState || {}, {\n            // NOTE this will prevent opening context menu using an action\n            // or programmatically from the host, so it will need to be\n            // rewritten later\n            contextMenu: null,\n            editingElement,\n            viewModeEnabled,\n            zenModeEnabled,\n            gridSize,\n            theme,\n            name,\n            errorMessage\n          });\n        }, () => {\n          if (actionResult.syncHistory) {\n            this.history.setCurrentState(this.state, this.scene.getElementsIncludingDeleted());\n          }\n        });\n      }\n    });\n    // Lifecycle\n    this.onBlur = withBatchedUpdates(() => {\n      isHoldingSpace = false;\n      this.setState({\n        isBindingEnabled: true\n      });\n    });\n    this.onUnload = () => {\n      this.onBlur();\n    };\n    this.disableEvent = event => {\n      event.preventDefault();\n    };\n    this.resetHistory = () => {\n      this.history.clear();\n    };\n    /**\n     * Resets scene & history.\n     * ! Do not use to clear scene user action !\n     */\n    this.resetScene = withBatchedUpdates(opts => {\n      this.scene.replaceAllElements([]);\n      this.setState(state => ({\n        ...getDefaultAppState(),\n        isLoading: opts !== null && opts !== void 0 && opts.resetLoadingState ? false : state.isLoading,\n        theme: this.state.theme\n      }));\n      this.resetHistory();\n    });\n    this.initializeScene = async () => {\n      var _scene$appState, _initialData2;\n      if (\"launchQueue\" in window && \"LaunchParams\" in window) {\n        window.launchQueue.setConsumer(async launchParams => {\n          if (!launchParams.files.length) {\n            return;\n          }\n          const fileHandle = launchParams.files[0];\n          const blob = await fileHandle.getFile();\n          this.loadFileToCanvas(new File([blob], blob.name || \"\", {\n            type: blob.type\n          }), fileHandle);\n        });\n      }\n      if (this.props.theme) {\n        this.setState({\n          theme: this.props.theme\n        });\n      }\n      if (!this.state.isLoading) {\n        this.setState({\n          isLoading: true\n        });\n      }\n      let initialData = null;\n      try {\n        var _initialData;\n        initialData = (await this.props.initialData) || null;\n        if ((_initialData = initialData) !== null && _initialData !== void 0 && _initialData.libraryItems) {\n          this.library.updateLibrary({\n            libraryItems: initialData.libraryItems,\n            merge: true\n          }).catch(error => {\n            console.error(error);\n          });\n        }\n      } catch (error) {\n        console.error(error);\n        initialData = {\n          appState: {\n            errorMessage: error.message || \"Encountered an error during importing or restoring scene data\"\n          }\n        };\n      }\n      const scene = restore(initialData, null, null, {\n        repairBindings: true\n      });\n      scene.appState = {\n        ...scene.appState,\n        theme: this.props.theme || scene.appState.theme,\n        // we're falling back to current (pre-init) state when deciding\n        // whether to open the library, to handle a case where we\n        // update the state outside of initialData (e.g. when loading the app\n        // with a library install link, which should auto-open the library)\n        openSidebar: ((_scene$appState = scene.appState) === null || _scene$appState === void 0 ? void 0 : _scene$appState.openSidebar) || this.state.openSidebar,\n        activeTool: scene.appState.activeTool.type === \"image\" ? {\n          ...scene.appState.activeTool,\n          type: \"selection\"\n        } : scene.appState.activeTool,\n        isLoading: false,\n        toast: this.state.toast\n      };\n      if ((_initialData2 = initialData) !== null && _initialData2 !== void 0 && _initialData2.scrollToContent) {\n        scene.appState = {\n          ...scene.appState,\n          ...calculateScrollCenter(scene.elements, {\n            ...scene.appState,\n            width: this.state.width,\n            height: this.state.height,\n            offsetTop: this.state.offsetTop,\n            offsetLeft: this.state.offsetLeft\n          }, null)\n        };\n      }\n      // FontFaceSet loadingdone event we listen on may not always fire\n      // (looking at you Safari), so on init we manually load fonts for current\n      // text elements on canvas, and rerender them once done. This also\n      // seems faster even in browsers that do fire the loadingdone event.\n      this.fonts.loadFontsForElements(scene.elements);\n      this.resetHistory();\n      this.syncActionResult({\n        ...scene,\n        commitToHistory: true\n      });\n    };\n    this.refreshDeviceState = container => {\n      const {\n        width,\n        height\n      } = container.getBoundingClientRect();\n      const sidebarBreakpoint = this.props.UIOptions.dockedSidebarBreakpoint != null ? this.props.UIOptions.dockedSidebarBreakpoint : MQ_RIGHT_SIDEBAR_MIN_WIDTH;\n      this.device = updateObject(this.device, {\n        isLandscape: width > height,\n        isSmScreen: width < MQ_SM_MAX_WIDTH,\n        isMobile: width < MQ_MAX_WIDTH_PORTRAIT || height < MQ_MAX_HEIGHT_LANDSCAPE && width < MQ_MAX_WIDTH_LANDSCAPE,\n        canDeviceFitSidebar: width > sidebarBreakpoint\n      });\n    };\n    this.onResize = withBatchedUpdates(() => {\n      this.scene.getElementsIncludingDeleted().forEach(element => invalidateShapeForElement(element));\n      this.setState({});\n    });\n    this.renderScene = () => {\n      const cursorButton = {};\n      const pointerViewportCoords = {};\n      const remoteSelectedElementIds = {};\n      const pointerUsernames = {};\n      const pointerUserStates = {};\n      this.state.collaborators.forEach((user, socketId) => {\n        if (user.selectedElementIds) {\n          for (const id of Object.keys(user.selectedElementIds)) {\n            if (!(id in remoteSelectedElementIds)) {\n              remoteSelectedElementIds[id] = [];\n            }\n            remoteSelectedElementIds[id].push(socketId);\n          }\n        }\n        if (!user.pointer) {\n          return;\n        }\n        if (user.username) {\n          pointerUsernames[socketId] = user.username;\n        }\n        if (user.userState) {\n          pointerUserStates[socketId] = user.userState;\n        }\n        pointerViewportCoords[socketId] = sceneCoordsToViewportCoords({\n          sceneX: user.pointer.x,\n          sceneY: user.pointer.y\n        }, this.state);\n        cursorButton[socketId] = user.button;\n      });\n      const renderingElements = this.scene.getNonDeletedElements().filter(element => {\n        if (isImageElement(element)) {\n          if (\n          // not placed on canvas yet (but in elements array)\n          this.state.pendingImageElementId === element.id) {\n            return false;\n          }\n        }\n        // don't render text element that's being currently edited (it's\n        // rendered on remote only)\n        return !this.state.editingElement || this.state.editingElement.type !== \"text\" || element.id !== this.state.editingElement.id;\n      });\n      const selectionColor = getComputedStyle(document.querySelector(\".excalidraw\")).getPropertyValue(\"--color-selection\");\n      renderScene({\n        elements: renderingElements,\n        appState: this.state,\n        scale: window.devicePixelRatio,\n        rc: this.rc,\n        canvas: this.canvas,\n        renderConfig: {\n          selectionColor,\n          scrollX: this.state.scrollX,\n          scrollY: this.state.scrollY,\n          viewBackgroundColor: this.state.viewBackgroundColor,\n          zoom: this.state.zoom,\n          remotePointerViewportCoords: pointerViewportCoords,\n          remotePointerButton: cursorButton,\n          remoteSelectedElementIds,\n          remotePointerUsernames: pointerUsernames,\n          remotePointerUserStates: pointerUserStates,\n          shouldCacheIgnoreZoom: this.state.shouldCacheIgnoreZoom,\n          theme: this.state.theme,\n          imageCache: this.imageCache,\n          isExporting: false,\n          renderScrollbars: false\n        },\n        callback: _ref2 => {\n          let {\n            atLeastOneVisibleElement,\n            scrollBars\n          } = _ref2;\n          if (scrollBars) {\n            currentScrollBars = scrollBars;\n          }\n          const scrolledOutside =\n          // hide when editing text\n          isTextElement(this.state.editingElement) ? false : !atLeastOneVisibleElement && renderingElements.length > 0;\n          if (this.state.scrolledOutside !== scrolledOutside) {\n            this.setState({\n              scrolledOutside\n            });\n          }\n          this.scheduleImageRefresh();\n        }\n      }, THROTTLE_NEXT_RENDER && window.EXCALIDRAW_THROTTLE_RENDER === true);\n      if (!THROTTLE_NEXT_RENDER) {\n        THROTTLE_NEXT_RENDER = true;\n      }\n    };\n    this.onScroll = debounce(() => {\n      const {\n        offsetTop,\n        offsetLeft\n      } = this.getCanvasOffsets();\n      this.setState(state => {\n        if (state.offsetLeft === offsetLeft && state.offsetTop === offsetTop) {\n          return null;\n        }\n        return {\n          offsetTop,\n          offsetLeft\n        };\n      });\n    }, SCROLL_TIMEOUT);\n    // Copy/paste\n    this.onCut = withBatchedUpdates(event => {\n      var _this$excalidrawConta2;\n      const isExcalidrawActive = (_this$excalidrawConta2 = this.excalidrawContainerRef.current) === null || _this$excalidrawConta2 === void 0 ? void 0 : _this$excalidrawConta2.contains(document.activeElement);\n      if (!isExcalidrawActive || isWritableElement(event.target)) {\n        return;\n      }\n      this.cutAll();\n      event.preventDefault();\n      event.stopPropagation();\n    });\n    this.onCopy = withBatchedUpdates(event => {\n      var _this$excalidrawConta3;\n      const isExcalidrawActive = (_this$excalidrawConta3 = this.excalidrawContainerRef.current) === null || _this$excalidrawConta3 === void 0 ? void 0 : _this$excalidrawConta3.contains(document.activeElement);\n      if (!isExcalidrawActive || isWritableElement(event.target)) {\n        return;\n      }\n      this.copyAll();\n      event.preventDefault();\n      event.stopPropagation();\n    });\n    this.cutAll = () => {\n      this.actionManager.executeAction(actionCut, \"keyboard\");\n    };\n    this.copyAll = () => {\n      this.actionManager.executeAction(actionCopy, \"keyboard\");\n    };\n    this.onTapStart = event => {\n      // fix for Apple Pencil Scribble\n      // On Android, preventing the event would disable contextMenu on tap-hold\n      if (!isAndroid) {\n        event.preventDefault();\n      }\n      if (!didTapTwice) {\n        didTapTwice = true;\n        clearTimeout(tappedTwiceTimer);\n        tappedTwiceTimer = window.setTimeout(App.resetTapTwice, TAP_TWICE_TIMEOUT);\n        return;\n      }\n      // insert text only if we tapped twice with a single finger\n      // event.touches.length === 1 will also prevent inserting text when user's zooming\n      if (didTapTwice && event.touches.length === 1) {\n        const [touch] = event.touches;\n        // @ts-ignore\n        this.handleCanvasDoubleClick({\n          clientX: touch.clientX,\n          clientY: touch.clientY\n        });\n        didTapTwice = false;\n        clearTimeout(tappedTwiceTimer);\n      }\n      if (isAndroid) {\n        event.preventDefault();\n      }\n      if (event.touches.length === 2) {\n        this.setState({\n          selectedElementIds: makeNextSelectedElementIds({}, this.state)\n        });\n      }\n    };\n    this.onTapEnd = event => {\n      this.resetContextMenuTimer();\n      if (event.touches.length > 0) {\n        this.setState({\n          previousSelectedElementIds: {},\n          selectedElementIds: makeNextSelectedElementIds(this.state.previousSelectedElementIds, this.state)\n        });\n      } else {\n        gesture.pointers.clear();\n      }\n    };\n    this.pasteFromClipboard = withBatchedUpdates(async event => {\n      var _this$excalidrawConta4, _event$clipboardData;\n      const isPlainPaste = !!(IS_PLAIN_PASTE && event);\n\n      // #686\n      const target = document.activeElement;\n      const isExcalidrawActive = (_this$excalidrawConta4 = this.excalidrawContainerRef.current) === null || _this$excalidrawConta4 === void 0 ? void 0 : _this$excalidrawConta4.contains(target);\n      if (event && !isExcalidrawActive) {\n        return;\n      }\n      const elementUnderCursor = document.elementFromPoint(this.lastViewportPosition.x, this.lastViewportPosition.y);\n      if (event && (!(elementUnderCursor instanceof HTMLCanvasElement) || isWritableElement(target))) {\n        return;\n      }\n\n      // must be called in the same frame (thus before any awaits) as the paste\n      // event else some browsers (FF...) will clear the clipboardData\n      // (something something security)\n      let file = event === null || event === void 0 ? void 0 : (_event$clipboardData = event.clipboardData) === null || _event$clipboardData === void 0 ? void 0 : _event$clipboardData.files[0];\n      const data = await parseClipboard(event, isPlainPaste);\n      if (!file && data.text && !isPlainPaste) {\n        const string = data.text.trim();\n        if (string.startsWith(\"<svg\") && string.endsWith(\"</svg>\")) {\n          // ignore SVG validation/normalization which will be done during image\n          // initialization\n          file = SVGStringToFile(string);\n        }\n      }\n\n      // prefer spreadsheet data over image file (MS Office/Libre Office)\n      if (isSupportedImageFile(file) && !data.spreadsheet) {\n        const {\n          x: sceneX,\n          y: sceneY\n        } = viewportCoordsToSceneCoords({\n          clientX: this.lastViewportPosition.x,\n          clientY: this.lastViewportPosition.y\n        }, this.state);\n        const imageElement = this.createImageElement({\n          sceneX,\n          sceneY\n        });\n        this.insertImageElement(imageElement, file);\n        this.initializeImageDimensions(imageElement);\n        this.setState({\n          selectedElementIds: makeNextSelectedElementIds({\n            [imageElement.id]: true\n          }, this.state)\n        });\n        return;\n      }\n      if (this.props.onPaste) {\n        try {\n          if ((await this.props.onPaste(data, event)) === false) {\n            return;\n          }\n        } catch (error) {\n          console.error(error);\n        }\n      }\n      if (data.errorMessage) {\n        this.setState({\n          errorMessage: data.errorMessage\n        });\n      } else if (data.spreadsheet && !isPlainPaste) {\n        this.setState({\n          pasteDialog: {\n            data: data.spreadsheet,\n            shown: true\n          }\n        });\n      } else if (data.elements) {\n        // TODO remove formatting from elements if isPlainPaste\n        this.addElementsFromPasteOrLibrary({\n          elements: data.elements,\n          files: data.files || null,\n          position: \"cursor\",\n          retainSeed: isPlainPaste\n        });\n      } else if (data.text) {\n        this.addTextFromPaste(data.text, isPlainPaste);\n      }\n      this.setActiveTool({\n        type: \"selection\"\n      });\n      event === null || event === void 0 ? void 0 : event.preventDefault();\n    });\n    this.addElementsFromPasteOrLibrary = opts => {\n      const elements = restoreElements(opts.elements, null);\n      const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n      const elementsCenterX = distance(minX, maxX) / 2;\n      const elementsCenterY = distance(minY, maxY) / 2;\n      const clientX = typeof opts.position === \"object\" ? opts.position.clientX : opts.position === \"cursor\" ? this.lastViewportPosition.x : this.state.width / 2 + this.state.offsetLeft;\n      const clientY = typeof opts.position === \"object\" ? opts.position.clientY : opts.position === \"cursor\" ? this.lastViewportPosition.y : this.state.height / 2 + this.state.offsetTop;\n      const {\n        x,\n        y\n      } = viewportCoordsToSceneCoords({\n        clientX,\n        clientY\n      }, this.state);\n      const dx = x - elementsCenterX;\n      const dy = y - elementsCenterY;\n      const [gridX, gridY] = getGridPoint(dx, dy, this.state.gridSize);\n      const newElements = duplicateElements(elements.map(element => {\n        return newElementWith(element, {\n          x: element.x + gridX - minX,\n          y: element.y + gridY - minY\n        });\n      }), {\n        randomizeSeed: !opts.retainSeed\n      });\n      const nextElements = [...this.scene.getElementsIncludingDeleted(), ...newElements];\n      this.scene.replaceAllElements(nextElements);\n      newElements.forEach(newElement => {\n        if (isTextElement(newElement) && isBoundToContainer(newElement)) {\n          const container = getContainerElement(newElement);\n          redrawTextBoundingBox(newElement, container);\n        }\n      });\n      if (opts.files) {\n        this.files = {\n          ...this.files,\n          ...opts.files\n        };\n      }\n      this.history.resumeRecording();\n      const nextElementsToSelect = excludeElementsInFramesFromSelection(newElements);\n      this.setState(selectGroupsForSelectedElements({\n        ...this.state,\n        // keep sidebar (presumably the library) open if it's docked and\n        // can fit.\n        //\n        // Note, we should close the sidebar only if we're dropping items\n        // from library, not when pasting from clipboard. Alas.\n        openSidebar: this.state.openSidebar && this.device.canDeviceFitSidebar && jotaiStore.get(isSidebarDockedAtom) ? this.state.openSidebar : null,\n        selectedElementIds: nextElementsToSelect.reduce((acc, element) => {\n          if (!isBoundToContainer(element)) {\n            acc[element.id] = true;\n          }\n          return acc;\n        }, {}),\n        selectedGroupIds: {}\n      }, this.scene.getNonDeletedElements(), this.state, this), () => {\n        if (opts.files) {\n          this.addNewImagesToImageCache();\n        }\n      });\n      this.setActiveTool({\n        type: \"selection\"\n      });\n    };\n    this.setAppState = (state, callback) => {\n      this.setState(state, callback);\n    };\n    this.removePointer = event => {\n      if (touchTimeout) {\n        this.resetContextMenuTimer();\n      }\n      gesture.pointers.delete(event.pointerId);\n    };\n    this.toggleLock = function () {\n      let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"ui\";\n      if (!_this.state.activeTool.locked) {\n        trackEvent(\"toolbar\", \"toggleLock\", `${source} (${_this.device.isMobile ? \"mobile\" : \"desktop\"})`);\n      }\n      _this.setState(prevState => {\n        return {\n          activeTool: {\n            ...prevState.activeTool,\n            ...updateActiveTool(_this.state, prevState.activeTool.locked ? {\n              type: \"selection\"\n            } : prevState.activeTool),\n            locked: !prevState.activeTool.locked\n          }\n        };\n      });\n    };\n    this.updateFrameRendering = opts => {\n      this.setState(prevState => {\n        var _next$enabled, _next$clip, _next$name, _next$outline;\n        const next = typeof opts === \"function\" ? opts(prevState.frameRendering) : opts;\n        return {\n          frameRendering: {\n            enabled: (_next$enabled = next === null || next === void 0 ? void 0 : next.enabled) !== null && _next$enabled !== void 0 ? _next$enabled : prevState.frameRendering.enabled,\n            clip: (_next$clip = next === null || next === void 0 ? void 0 : next.clip) !== null && _next$clip !== void 0 ? _next$clip : prevState.frameRendering.clip,\n            name: (_next$name = next === null || next === void 0 ? void 0 : next.name) !== null && _next$name !== void 0 ? _next$name : prevState.frameRendering.name,\n            outline: (_next$outline = next === null || next === void 0 ? void 0 : next.outline) !== null && _next$outline !== void 0 ? _next$outline : prevState.frameRendering.outline\n          }\n        };\n      });\n    };\n    this.togglePenMode = () => {\n      this.setState(prevState => {\n        return {\n          penMode: !prevState.penMode\n        };\n      });\n    };\n    this.onHandToolToggle = () => {\n      this.actionManager.executeAction(actionToggleHandTool);\n    };\n    /**\n     * Zooms on canvas viewport center\n     */\n    this.zoomCanvas = value => {\n      this.setState({\n        ...getStateForZoom({\n          viewportX: this.state.width / 2 + this.state.offsetLeft,\n          viewportY: this.state.height / 2 + this.state.offsetTop,\n          nextZoom: getNormalizedZoom(value)\n        }, this.state)\n      });\n    };\n    this.cancelInProgresAnimation = null;\n    this.scrollToContent = function () {\n      var _this$cancelInProgres;\n      let target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.scene.getNonDeletedElements();\n      let opts = arguments.length > 1 ? arguments[1] : undefined;\n      (_this$cancelInProgres = _this.cancelInProgresAnimation) === null || _this$cancelInProgres === void 0 ? void 0 : _this$cancelInProgres.call(_this);\n\n      // convert provided target into ExcalidrawElement[] if necessary\n      const targetElements = Array.isArray(target) ? target : [target];\n      let zoom = _this.state.zoom;\n      let scrollX = _this.state.scrollX;\n      let scrollY = _this.state.scrollY;\n      if (opts !== null && opts !== void 0 && opts.fitToContent || opts !== null && opts !== void 0 && opts.fitToViewport) {\n        const {\n          appState\n        } = zoomToFit({\n          targetElements,\n          appState: _this.state,\n          fitToViewport: !!(opts !== null && opts !== void 0 && opts.fitToViewport),\n          viewportZoomFactor: opts === null || opts === void 0 ? void 0 : opts.viewportZoomFactor\n        });\n        zoom = appState.zoom;\n        scrollX = appState.scrollX;\n        scrollY = appState.scrollY;\n      } else {\n        // compute only the viewport location, without any zoom adjustment\n        const scroll = calculateScrollCenter(targetElements, _this.state, _this.canvas);\n        scrollX = scroll.scrollX;\n        scrollY = scroll.scrollY;\n      }\n\n      // when animating, we use RequestAnimationFrame to prevent the animation\n      // from slowing down other processes\n      if (opts !== null && opts !== void 0 && opts.animate) {\n        var _opts$duration;\n        const origScrollX = _this.state.scrollX;\n        const origScrollY = _this.state.scrollY;\n        const origZoom = _this.state.zoom.value;\n        const cancel = easeToValuesRAF({\n          fromValues: {\n            scrollX: origScrollX,\n            scrollY: origScrollY,\n            zoom: origZoom\n          },\n          toValues: {\n            scrollX,\n            scrollY,\n            zoom: zoom.value\n          },\n          interpolateValue: (from, to, progress, key) => {\n            // for zoom, use different easing\n            if (key === \"zoom\") {\n              return from * Math.pow(to / from, easeOut(progress));\n            }\n            // handle using default\n            return undefined;\n          },\n          onStep: _ref3 => {\n            let {\n              scrollX,\n              scrollY,\n              zoom\n            } = _ref3;\n            _this.setState({\n              scrollX,\n              scrollY,\n              zoom: {\n                value: zoom\n              }\n            });\n          },\n          onStart: () => {\n            _this.setState({\n              shouldCacheIgnoreZoom: true\n            });\n          },\n          onEnd: () => {\n            _this.setState({\n              shouldCacheIgnoreZoom: false\n            });\n          },\n          onCancel: () => {\n            _this.setState({\n              shouldCacheIgnoreZoom: false\n            });\n          },\n          duration: (_opts$duration = opts === null || opts === void 0 ? void 0 : opts.duration) !== null && _opts$duration !== void 0 ? _opts$duration : 500\n        });\n        _this.cancelInProgresAnimation = () => {\n          cancel();\n          _this.cancelInProgresAnimation = null;\n        };\n      } else {\n        _this.setState({\n          scrollX,\n          scrollY,\n          zoom\n        });\n      }\n    };\n    /** use when changing scrollX/scrollY/zoom based on user interaction */\n    this.translateCanvas = state => {\n      var _this$cancelInProgres2;\n      (_this$cancelInProgres2 = this.cancelInProgresAnimation) === null || _this$cancelInProgres2 === void 0 ? void 0 : _this$cancelInProgres2.call(this);\n      this.setState(state);\n    };\n    this.setToast = toast => {\n      this.setState({\n        toast\n      });\n    };\n    this.restoreFileFromShare = async () => {\n      try {\n        const webShareTargetCache = await caches.open(\"web-share-target\");\n        const response = await webShareTargetCache.match(\"shared-file\");\n        if (response) {\n          const blob = await response.blob();\n          const file = new File([blob], blob.name || \"\", {\n            type: blob.type\n          });\n          this.loadFileToCanvas(file, null);\n          await webShareTargetCache.delete(\"shared-file\");\n          window.history.replaceState(null, APP_NAME, window.location.pathname);\n        }\n      } catch (error) {\n        this.setState({\n          errorMessage: error.message\n        });\n      }\n    };\n    /** adds supplied files to existing files in the appState */\n    this.addFiles = withBatchedUpdates(files => {\n      const filesMap = files.reduce((acc, fileData) => {\n        acc.set(fileData.id, fileData);\n        return acc;\n      }, new Map());\n      this.files = {\n        ...this.files,\n        ...Object.fromEntries(filesMap)\n      };\n      this.scene.getNonDeletedElements().forEach(element => {\n        if (isInitializedImageElement(element) && filesMap.has(element.fileId)) {\n          this.imageCache.delete(element.fileId);\n          invalidateShapeForElement(element);\n        }\n      });\n      this.scene.informMutation();\n      this.addNewImagesToImageCache();\n    });\n    this.updateScene = withBatchedUpdates(sceneData => {\n      if (sceneData.commitToHistory) {\n        this.history.resumeRecording();\n      }\n      if (sceneData.appState) {\n        this.setState(sceneData.appState);\n      }\n      if (sceneData.elements) {\n        this.scene.replaceAllElements(sceneData.elements);\n      }\n      if (sceneData.collaborators) {\n        this.setState({\n          collaborators: sceneData.collaborators\n        });\n      }\n    });\n    this.onSceneUpdated = () => {\n      this.setState({});\n    };\n    /**\n     * @returns whether the menu was toggled on or off\n     */\n    this.toggleSidebar = _ref4 => {\n      let {\n        name,\n        tab,\n        force\n      } = _ref4;\n      let nextName;\n      if (force === undefined) {\n        var _this$state$openSideb;\n        nextName = ((_this$state$openSideb = this.state.openSidebar) === null || _this$state$openSideb === void 0 ? void 0 : _this$state$openSideb.name) === name ? null : name;\n      } else {\n        nextName = force ? name : null;\n      }\n      this.setState({\n        openSidebar: nextName ? {\n          name: nextName,\n          tab\n        } : null\n      });\n      return !!nextName;\n    };\n    this.updateCurrentCursorPosition = withBatchedUpdates(event => {\n      this.lastViewportPosition.x = event.clientX;\n      this.lastViewportPosition.y = event.clientY;\n    });\n    // Input handling\n    this.onKeyDown = withBatchedUpdates(event => {\n      // normalize `event.key` when CapsLock is pressed #2372\n\n      if (\"Proxy\" in window && (!event.shiftKey && /^[A-Z]$/.test(event.key) || event.shiftKey && /^[a-z]$/.test(event.key))) {\n        event = new Proxy(event, {\n          get(ev, prop) {\n            const value = ev[prop];\n            if (typeof value === \"function\") {\n              // fix for Proxies hijacking `this`\n              return value.bind(ev);\n            }\n            return prop === \"key\" ?\n            // CapsLock inverts capitalization based on ShiftKey, so invert\n            // it back\n            event.shiftKey ? ev.key.toUpperCase() : ev.key.toLowerCase() : value;\n          }\n        });\n      }\n      if (event[KEYS.CTRL_OR_CMD] && event.key.toLowerCase() === KEYS.V) {\n        IS_PLAIN_PASTE = event.shiftKey;\n        clearTimeout(IS_PLAIN_PASTE_TIMER);\n        // reset (100ms to be safe that we it runs after the ensuing\n        // paste event). Though, technically unnecessary to reset since we\n        // (re)set the flag before each paste event.\n        IS_PLAIN_PASTE_TIMER = window.setTimeout(() => {\n          IS_PLAIN_PASTE = false;\n        }, 100);\n      }\n\n      // prevent browser zoom in input fields\n      if (event[KEYS.CTRL_OR_CMD] && isWritableElement(event.target)) {\n        if (event.code === CODES.MINUS || event.code === CODES.EQUAL) {\n          event.preventDefault();\n          return;\n        }\n      }\n\n      // bail if\n      if (\n      // inside an input\n      isWritableElement(event.target) &&\n      // unless pressing escape (finalize action)\n      event.key !== KEYS.ESCAPE ||\n      // or unless using arrows (to move between buttons)\n      isArrowKey(event.key) && isInputLike(event.target)) {\n        return;\n      }\n      if (event.key === KEYS.QUESTION_MARK) {\n        this.setState({\n          openDialog: \"help\"\n        });\n        return;\n      } else if (event.key.toLowerCase() === KEYS.E && event.shiftKey && event[KEYS.CTRL_OR_CMD]) {\n        event.preventDefault();\n        this.setState({\n          openDialog: \"imageExport\"\n        });\n        return;\n      }\n      if (event.key === KEYS.PAGE_UP || event.key === KEYS.PAGE_DOWN) {\n        let offset = (event.shiftKey ? this.state.width : this.state.height) / this.state.zoom.value;\n        if (event.key === KEYS.PAGE_DOWN) {\n          offset = -offset;\n        }\n        if (event.shiftKey) {\n          this.translateCanvas(state => ({\n            scrollX: state.scrollX + offset\n          }));\n        } else {\n          this.translateCanvas(state => ({\n            scrollY: state.scrollY + offset\n          }));\n        }\n      }\n      if (this.actionManager.handleKeyDown(event)) {\n        return;\n      }\n      if (this.state.viewModeEnabled) {\n        return;\n      }\n      if (event[KEYS.CTRL_OR_CMD] && this.state.isBindingEnabled) {\n        this.setState({\n          isBindingEnabled: false\n        });\n      }\n      if (isArrowKey(event.key)) {\n        const step = this.state.gridSize && (event.shiftKey ? ELEMENT_TRANSLATE_AMOUNT : this.state.gridSize) || (event.shiftKey ? ELEMENT_SHIFT_TRANSLATE_AMOUNT : ELEMENT_TRANSLATE_AMOUNT);\n        let offsetX = 0;\n        let offsetY = 0;\n        if (event.key === KEYS.ARROW_LEFT) {\n          offsetX = -step;\n        } else if (event.key === KEYS.ARROW_RIGHT) {\n          offsetX = step;\n        } else if (event.key === KEYS.ARROW_UP) {\n          offsetY = -step;\n        } else if (event.key === KEYS.ARROW_DOWN) {\n          offsetY = step;\n        }\n        const selectedElements = this.scene.getSelectedElements({\n          selectedElementIds: this.state.selectedElementIds,\n          includeBoundTextElement: true,\n          includeElementsInFrames: true\n        });\n        selectedElements.forEach(element => {\n          mutateElement(element, {\n            x: element.x + offsetX,\n            y: element.y + offsetY\n          });\n          updateBoundElements(element, {\n            simultaneouslyUpdated: selectedElements\n          });\n        });\n        this.maybeSuggestBindingForAll(selectedElements);\n        event.preventDefault();\n      } else if (event.key === KEYS.ENTER) {\n        const selectedElements = this.scene.getSelectedElements(this.state);\n        if (selectedElements.length === 1) {\n          const selectedElement = selectedElements[0];\n          if (event[KEYS.CTRL_OR_CMD]) {\n            if (isLinearElement(selectedElement)) {\n              if (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== selectedElements[0].id) {\n                this.history.resumeRecording();\n                this.setState({\n                  editingLinearElement: new LinearElementEditor(selectedElement, this.scene)\n                });\n              }\n            }\n          } else if (isTextElement(selectedElement) || isValidTextContainer(selectedElement)) {\n            let container;\n            if (!isTextElement(selectedElement)) {\n              container = selectedElement;\n            }\n            const midPoint = getContainerCenter(selectedElement, this.state);\n            const sceneX = midPoint.x;\n            const sceneY = midPoint.y;\n            this.startTextEditing({\n              sceneX,\n              sceneY,\n              container\n            });\n            event.preventDefault();\n            return;\n          } else if (isFrameElement(selectedElement)) {\n            this.setState({\n              editingFrame: selectedElement.id\n            });\n          }\n        }\n      } else if (!event.ctrlKey && !event.altKey && !event.metaKey && this.state.draggingElement === null) {\n        const shape = findShapeByKey(event.key);\n        if (shape) {\n          if (this.state.activeTool.type !== shape) {\n            trackEvent(\"toolbar\", shape, `keyboard (${this.device.isMobile ? \"mobile\" : \"desktop\"})`);\n          }\n          this.setActiveTool({\n            type: shape\n          });\n          event.stopPropagation();\n        } else if (event.key === KEYS.Q) {\n          this.toggleLock(\"keyboard\");\n          event.stopPropagation();\n        }\n      }\n      if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {\n        isHoldingSpace = true;\n        setCursor(this.canvas, CURSOR_TYPE.GRAB);\n        event.preventDefault();\n      }\n      if ((event.key === KEYS.G || event.key === KEYS.S) && !event.altKey && !event[KEYS.CTRL_OR_CMD]) {\n        const selectedElements = this.scene.getSelectedElements(this.state);\n        if (this.state.activeTool.type === \"selection\" && !selectedElements.length) {\n          return;\n        }\n        if (event.key === KEYS.G && (hasBackground(this.state.activeTool.type) || selectedElements.some(element => hasBackground(element.type)))) {\n          this.setState({\n            openPopup: \"elementBackground\"\n          });\n          event.stopPropagation();\n        }\n        if (event.key === KEYS.S) {\n          this.setState({\n            openPopup: \"elementStroke\"\n          });\n          event.stopPropagation();\n        }\n      }\n      if (event[KEYS.CTRL_OR_CMD] && (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE)) {\n        jotaiStore.set(activeConfirmDialogAtom, \"clearCanvas\");\n      }\n\n      // eye dropper\n      // -----------------------------------------------------------------------\n      const lowerCased = event.key.toLocaleLowerCase();\n      const isPickingStroke = lowerCased === KEYS.S && event.shiftKey;\n      const isPickingBackground = event.key === KEYS.I || lowerCased === KEYS.G && event.shiftKey;\n      if (isPickingStroke || isPickingBackground) {\n        this.openEyeDropper({\n          type: isPickingStroke ? \"stroke\" : \"background\"\n        });\n      }\n      // -----------------------------------------------------------------------\n    });\n    this.onWheel = withBatchedUpdates(event => {\n      // prevent browser pinch zoom on DOM elements\n      if (!(event.target instanceof HTMLCanvasElement) && event.ctrlKey) {\n        event.preventDefault();\n      }\n    });\n    this.onKeyUp = withBatchedUpdates(event => {\n      if (event.key === KEYS.SPACE) {\n        if (this.state.viewModeEnabled) {\n          setCursor(this.canvas, CURSOR_TYPE.GRAB);\n        } else if (this.state.activeTool.type === \"selection\") {\n          resetCursor(this.canvas);\n        } else {\n          setCursorForShape(this.canvas, this.state);\n          this.setState({\n            selectedElementIds: makeNextSelectedElementIds({}, this.state),\n            selectedGroupIds: {},\n            editingGroupId: null\n          });\n        }\n        isHoldingSpace = false;\n      }\n      if (!event[KEYS.CTRL_OR_CMD] && !this.state.isBindingEnabled) {\n        this.setState({\n          isBindingEnabled: true\n        });\n      }\n      if (isArrowKey(event.key)) {\n        const selectedElements = this.scene.getSelectedElements(this.state);\n        isBindingEnabled(this.state) ? bindOrUnbindSelectedElements(selectedElements) : unbindLinearElements(selectedElements);\n        this.setState({\n          suggestedBindings: []\n        });\n      }\n    });\n    this.setActiveTool = tool => {\n      const nextActiveTool = updateActiveTool(this.state, tool);\n      if (nextActiveTool.type === \"hand\") {\n        setCursor(this.canvas, CURSOR_TYPE.GRAB);\n      } else if (!isHoldingSpace) {\n        setCursorForShape(this.canvas, this.state);\n      }\n      if (isToolIcon(document.activeElement)) {\n        this.focusContainer();\n      }\n      if (!isLinearElementType(nextActiveTool.type)) {\n        this.setState({\n          suggestedBindings: []\n        });\n      }\n      if (nextActiveTool.type === \"image\") {\n        this.onImageAction();\n      }\n      if (nextActiveTool.type !== \"selection\") {\n        this.setState({\n          activeTool: nextActiveTool,\n          selectedElementIds: makeNextSelectedElementIds({}, this.state),\n          selectedGroupIds: {},\n          editingGroupId: null\n        });\n      } else {\n        this.setState({\n          activeTool: nextActiveTool\n        });\n      }\n    };\n    this.setCursor = cursor => {\n      setCursor(this.canvas, cursor);\n    };\n    this.resetCursor = () => {\n      resetCursor(this.canvas);\n    };\n    /**\n     * returns whether user is making a gesture with >= 2 fingers (points)\n     * on o touch screen (not on a trackpad). Currently only relates to Darwin\n     * (iOS/iPadOS,MacOS), but may work on other devices in the future if\n     * GestureEvent is standardized.\n     */\n    this.isTouchScreenMultiTouchGesture = () => {\n      // we don't want to deselect when using trackpad, and multi-point gestures\n      // only work on touch screens, so checking for >= pointers means we're on a\n      // touchscreen\n      return gesture.pointers.size >= 2;\n    };\n    // fires only on Safari\n    this.onGestureStart = withBatchedUpdates(event => {\n      event.preventDefault();\n\n      // we only want to deselect on touch screens because user may have selected\n      // elements by mistake while zooming\n      if (this.isTouchScreenMultiTouchGesture()) {\n        this.setState({\n          selectedElementIds: makeNextSelectedElementIds({}, this.state)\n        });\n      }\n      gesture.initialScale = this.state.zoom.value;\n    });\n    // fires only on Safari\n    this.onGestureChange = withBatchedUpdates(event => {\n      event.preventDefault();\n\n      // onGestureChange only has zoom factor but not the center.\n      // If we're on iPad or iPhone, then we recognize multi-touch and will\n      // zoom in at the right location in the touchmove handler\n      // (handleCanvasPointerMove).\n      //\n      // On Macbook trackpad, we don't have those events so will zoom in at the\n      // current location instead.\n      //\n      // As such, bail from this handler on touch devices.\n      if (this.isTouchScreenMultiTouchGesture()) {\n        return;\n      }\n      const initialScale = gesture.initialScale;\n      if (initialScale) {\n        this.setState(state => ({\n          ...getStateForZoom({\n            viewportX: this.lastViewportPosition.x,\n            viewportY: this.lastViewportPosition.y,\n            nextZoom: getNormalizedZoom(initialScale * event.scale)\n          }, state)\n        }));\n      }\n    });\n    // fires only on Safari\n    this.onGestureEnd = withBatchedUpdates(event => {\n      event.preventDefault();\n      // reselect elements only on touch screens (see onGestureStart)\n      if (this.isTouchScreenMultiTouchGesture()) {\n        this.setState({\n          previousSelectedElementIds: {},\n          selectedElementIds: makeNextSelectedElementIds(this.state.previousSelectedElementIds, this.state)\n        });\n      }\n      gesture.initialScale = null;\n    });\n    this.startTextEditing = _ref5 => {\n      var _existingTextElement, _existingTextElement2, _container$groupIds, _container$angle;\n      let {\n        sceneX,\n        sceneY,\n        insertAtParentCenter = true,\n        container\n      } = _ref5;\n      let shouldBindToContainer = false;\n      let parentCenterPosition = insertAtParentCenter && this.getTextWysiwygSnappedToCenterPosition(sceneX, sceneY, this.state, container);\n      if (container && parentCenterPosition) {\n        const boundTextElementToContainer = getBoundTextElement(container);\n        if (!boundTextElementToContainer) {\n          shouldBindToContainer = true;\n        }\n      }\n      let existingTextElement = null;\n      const selectedElements = this.scene.getSelectedElements(this.state);\n      if (selectedElements.length === 1) {\n        if (isTextElement(selectedElements[0])) {\n          existingTextElement = selectedElements[0];\n        } else if (container) {\n          existingTextElement = getBoundTextElement(selectedElements[0]);\n        } else {\n          existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);\n        }\n      } else {\n        existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);\n      }\n      const fontFamily = ((_existingTextElement = existingTextElement) === null || _existingTextElement === void 0 ? void 0 : _existingTextElement.fontFamily) || this.state.currentItemFontFamily;\n      const lineHeight = ((_existingTextElement2 = existingTextElement) === null || _existingTextElement2 === void 0 ? void 0 : _existingTextElement2.lineHeight) || getDefaultLineHeight(fontFamily);\n      const fontSize = this.state.currentItemFontSize;\n      if (!existingTextElement && shouldBindToContainer && container && !isArrowElement(container)) {\n        const fontString = {\n          fontSize,\n          fontFamily\n        };\n        const minWidth = getApproxMinLineWidth(getFontString(fontString), lineHeight);\n        const minHeight = getApproxMinLineHeight(fontSize, lineHeight);\n        const containerDims = getContainerDims(container);\n        const newHeight = Math.max(containerDims.height, minHeight);\n        const newWidth = Math.max(containerDims.width, minWidth);\n        mutateElement(container, {\n          height: newHeight,\n          width: newWidth\n        });\n        sceneX = container.x + newWidth / 2;\n        sceneY = container.y + newHeight / 2;\n        if (parentCenterPosition) {\n          parentCenterPosition = this.getTextWysiwygSnappedToCenterPosition(sceneX, sceneY, this.state, container);\n        }\n      }\n      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n        x: sceneX,\n        y: sceneY\n      });\n      const element = existingTextElement ? existingTextElement : newTextElement({\n        x: parentCenterPosition ? parentCenterPosition.elementCenterX : sceneX,\n        y: parentCenterPosition ? parentCenterPosition.elementCenterY : sceneY,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        strokeStyle: this.state.currentItemStrokeStyle,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n        text: \"\",\n        fontSize,\n        fontFamily,\n        textAlign: parentCenterPosition ? \"center\" : this.state.currentItemTextAlign,\n        verticalAlign: parentCenterPosition ? VERTICAL_ALIGN.MIDDLE : DEFAULT_VERTICAL_ALIGN,\n        containerId: shouldBindToContainer ? container === null || container === void 0 ? void 0 : container.id : undefined,\n        groupIds: (_container$groupIds = container === null || container === void 0 ? void 0 : container.groupIds) !== null && _container$groupIds !== void 0 ? _container$groupIds : [],\n        lineHeight,\n        angle: (_container$angle = container === null || container === void 0 ? void 0 : container.angle) !== null && _container$angle !== void 0 ? _container$angle : 0,\n        frameId: topLayerFrame ? topLayerFrame.id : null\n      });\n      if (!existingTextElement && shouldBindToContainer && container) {\n        mutateElement(container, {\n          boundElements: (container.boundElements || []).concat({\n            type: \"text\",\n            id: element.id\n          })\n        });\n      }\n      this.setState({\n        editingElement: element\n      });\n      if (!existingTextElement) {\n        if (container && shouldBindToContainer) {\n          const containerIndex = this.scene.getElementIndex(container.id);\n          this.scene.insertElementAtIndex(element, containerIndex + 1);\n        } else {\n          this.scene.addNewElement(element);\n        }\n      }\n      this.setState({\n        editingElement: element\n      });\n      this.handleTextWysiwyg(element, {\n        isExistingElement: !!existingTextElement\n      });\n    };\n    this.handleCanvasDoubleClick = event => {\n      // case: double-clicking with arrow/line tool selected would both create\n      // text and enter multiElement mode\n      if (this.state.multiElement) {\n        return;\n      }\n      // we should only be able to double click when mode is selection\n      if (this.state.activeTool.type !== \"selection\") {\n        return;\n      }\n      const selectedElements = this.scene.getSelectedElements(this.state);\n      if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n        if (event[KEYS.CTRL_OR_CMD] && (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== selectedElements[0].id)) {\n          this.history.resumeRecording();\n          this.setState({\n            editingLinearElement: new LinearElementEditor(selectedElements[0], this.scene)\n          });\n          return;\n        } else if (this.state.editingLinearElement && this.state.editingLinearElement.elementId === selectedElements[0].id) {\n          return;\n        }\n      }\n      resetCursor(this.canvas);\n      let {\n        x: sceneX,\n        y: sceneY\n      } = viewportCoordsToSceneCoords(event, this.state);\n      const selectedGroupIds = getSelectedGroupIds(this.state);\n      if (selectedGroupIds.length > 0) {\n        const hitElement = this.getElementAtPosition(sceneX, sceneY);\n        const selectedGroupId = hitElement && getSelectedGroupIdForElement(hitElement, this.state.selectedGroupIds);\n        if (selectedGroupId) {\n          this.setState(prevState => selectGroupsForSelectedElements({\n            ...prevState,\n            editingGroupId: selectedGroupId,\n            selectedElementIds: {\n              [hitElement.id]: true\n            },\n            selectedGroupIds: {}\n          }, this.scene.getNonDeletedElements(), prevState, this));\n          return;\n        }\n      }\n      resetCursor(this.canvas);\n      if (!event[KEYS.CTRL_OR_CMD] && !this.state.viewModeEnabled) {\n        const container = getTextBindableContainerAtPosition(this.scene.getNonDeletedElements(), this.state, sceneX, sceneY);\n        if (container) {\n          if (hasBoundTextElement(container) || !isTransparent(container.backgroundColor) || isHittingElementNotConsideringBoundingBox(container, this.state, this.frameNameBoundsCache, [sceneX, sceneY])) {\n            const midPoint = getContainerCenter(container, this.state);\n            sceneX = midPoint.x;\n            sceneY = midPoint.y;\n          }\n        }\n        this.startTextEditing({\n          sceneX,\n          sceneY,\n          insertAtParentCenter: !event.altKey,\n          container\n        });\n      }\n    };\n    this.getElementLinkAtPosition = (scenePointer, hitElement) => {\n      // Reversing so we traverse the elements in decreasing order\n      // of z-index\n      const elements = this.scene.getNonDeletedElements().slice().reverse();\n      let hitElementIndex = Infinity;\n      return elements.find((element, index) => {\n        if (hitElement && element.id === hitElement.id) {\n          hitElementIndex = index;\n        }\n        return element.link && index <= hitElementIndex && isPointHittingLinkIcon(element, this.state, [scenePointer.x, scenePointer.y], this.device.isMobile);\n      });\n    };\n    this.redirectToLink = (event, isTouchScreen) => {\n      const draggedDistance = distance2d(this.lastPointerDown.clientX, this.lastPointerDown.clientY, this.lastPointerUp.clientX, this.lastPointerUp.clientY);\n      if (!this.hitLinkElement ||\n      // For touch screen allow dragging threshold else strict check\n      isTouchScreen && draggedDistance > DRAGGING_THRESHOLD || !isTouchScreen && draggedDistance !== 0) {\n        return;\n      }\n      const lastPointerDownCoords = viewportCoordsToSceneCoords(this.lastPointerDown, this.state);\n      const lastPointerDownHittingLinkIcon = isPointHittingLinkIcon(this.hitLinkElement, this.state, [lastPointerDownCoords.x, lastPointerDownCoords.y], this.device.isMobile);\n      const lastPointerUpCoords = viewportCoordsToSceneCoords(this.lastPointerUp, this.state);\n      const lastPointerUpHittingLinkIcon = isPointHittingLinkIcon(this.hitLinkElement, this.state, [lastPointerUpCoords.x, lastPointerUpCoords.y], this.device.isMobile);\n      if (lastPointerDownHittingLinkIcon && lastPointerUpHittingLinkIcon) {\n        let url = this.hitLinkElement.link;\n        if (url) {\n          var _customEvent;\n          url = normalizeLink(url);\n          let customEvent;\n          if (this.props.onLinkOpen) {\n            customEvent = wrapEvent(EVENT.EXCALIDRAW_LINK, event.nativeEvent);\n            this.props.onLinkOpen({\n              ...this.hitLinkElement,\n              link: url\n            }, customEvent);\n          }\n          if (!((_customEvent = customEvent) !== null && _customEvent !== void 0 && _customEvent.defaultPrevented)) {\n            const target = isLocalLink(url) ? \"_self\" : \"_blank\";\n            const newWindow = window.open(undefined, target);\n            // https://mathiasbynens.github.io/rel-noopener/\n            if (newWindow) {\n              newWindow.opener = null;\n              newWindow.location = url;\n            }\n          }\n        }\n      }\n    };\n    this.getTopLayerFrameAtSceneCoords = sceneCoords => {\n      const frames = this.scene.getNonDeletedFrames().filter(frame => isCursorInFrame(sceneCoords, frame));\n      return frames.length ? frames[frames.length - 1] : null;\n    };\n    this.handleCanvasPointerMove = event => {\n      this.savePointer(event.clientX, event.clientY, this.state.cursorButton);\n      if (gesture.pointers.has(event.pointerId)) {\n        gesture.pointers.set(event.pointerId, {\n          x: event.clientX,\n          y: event.clientY\n        });\n      }\n      const initialScale = gesture.initialScale;\n      if (gesture.pointers.size === 2 && gesture.lastCenter && initialScale && gesture.initialDistance) {\n        const center = getCenter(gesture.pointers);\n        const deltaX = center.x - gesture.lastCenter.x;\n        const deltaY = center.y - gesture.lastCenter.y;\n        gesture.lastCenter = center;\n        const distance = getDistance(Array.from(gesture.pointers.values()));\n        const scaleFactor = this.state.activeTool.type === \"freedraw\" && this.state.penMode ? 1 : distance / gesture.initialDistance;\n        const nextZoom = scaleFactor ? getNormalizedZoom(initialScale * scaleFactor) : this.state.zoom.value;\n        this.setState(state => {\n          const zoomState = getStateForZoom({\n            viewportX: center.x,\n            viewportY: center.y,\n            nextZoom\n          }, state);\n          this.translateCanvas({\n            zoom: zoomState.zoom,\n            scrollX: zoomState.scrollX + deltaX / nextZoom,\n            scrollY: zoomState.scrollY + deltaY / nextZoom,\n            shouldCacheIgnoreZoom: true\n          });\n        });\n        this.resetShouldCacheIgnoreZoomDebounced();\n      } else {\n        gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;\n      }\n      if (isHoldingSpace || isPanning || isDraggingScrollBar || isHandToolActive(this.state)) {\n        return;\n      }\n      const isPointerOverScrollBars = isOverScrollBars(currentScrollBars, event.clientX - this.state.offsetLeft, event.clientY - this.state.offsetTop);\n      const isOverScrollBar = isPointerOverScrollBars.isOverEither;\n      if (!this.state.draggingElement && !this.state.multiElement) {\n        if (isOverScrollBar) {\n          resetCursor(this.canvas);\n        } else {\n          setCursorForShape(this.canvas, this.state);\n        }\n      }\n      const scenePointer = viewportCoordsToSceneCoords(event, this.state);\n      const {\n        x: scenePointerX,\n        y: scenePointerY\n      } = scenePointer;\n      if (this.state.editingLinearElement && !this.state.editingLinearElement.isDragging) {\n        const editingLinearElement = LinearElementEditor.handlePointerMove(event, scenePointerX, scenePointerY, this.state);\n        if (editingLinearElement && editingLinearElement !== this.state.editingLinearElement) {\n          // Since we are reading from previous state which is not possible with\n          // automatic batching in React 18 hence using flush sync to synchronously\n          // update the state. Check https://github.com/excalidraw/excalidraw/pull/5508 for more details.\n          flushSync(() => {\n            this.setState({\n              editingLinearElement\n            });\n          });\n        }\n        if ((editingLinearElement === null || editingLinearElement === void 0 ? void 0 : editingLinearElement.lastUncommittedPoint) != null) {\n          this.maybeSuggestBindingAtCursor(scenePointer);\n        } else {\n          // causes stack overflow if not sync\n          flushSync(() => {\n            this.setState({\n              suggestedBindings: []\n            });\n          });\n        }\n      }\n      if (isBindingElementType(this.state.activeTool.type)) {\n        // Hovering with a selected tool or creating new linear element via click\n        // and point\n        const {\n          draggingElement\n        } = this.state;\n        if (isBindingElement(draggingElement, false)) {\n          this.maybeSuggestBindingsForLinearElementAtCoords(draggingElement, [scenePointer], this.state.startBoundElement);\n        } else {\n          this.maybeSuggestBindingAtCursor(scenePointer);\n        }\n      }\n      if (this.state.multiElement) {\n        const {\n          multiElement\n        } = this.state;\n        const {\n          x: rx,\n          y: ry\n        } = multiElement;\n        const {\n          points,\n          lastCommittedPoint\n        } = multiElement;\n        const lastPoint = points[points.length - 1];\n        setCursorForShape(this.canvas, this.state);\n        if (lastPoint === lastCommittedPoint) {\n          // if we haven't yet created a temp point and we're beyond commit-zone\n          // threshold, add a point\n          if (distance2d(scenePointerX - rx, scenePointerY - ry, lastPoint[0], lastPoint[1]) >= LINE_CONFIRM_THRESHOLD) {\n            mutateElement(multiElement, {\n              points: [...points, [scenePointerX - rx, scenePointerY - ry]]\n            });\n          } else {\n            setCursor(this.canvas, CURSOR_TYPE.POINTER);\n            // in this branch, we're inside the commit zone, and no uncommitted\n            // point exists. Thus do nothing (don't add/remove points).\n          }\n        } else if (points.length > 2 && lastCommittedPoint && distance2d(scenePointerX - rx, scenePointerY - ry, lastCommittedPoint[0], lastCommittedPoint[1]) < LINE_CONFIRM_THRESHOLD) {\n          setCursor(this.canvas, CURSOR_TYPE.POINTER);\n          mutateElement(multiElement, {\n            points: points.slice(0, -1)\n          });\n        } else {\n          var _multiElement$lastCom;\n          const [gridX, gridY] = getGridPoint(scenePointerX, scenePointerY, this.state.gridSize);\n          const [lastCommittedX, lastCommittedY] = (_multiElement$lastCom = multiElement === null || multiElement === void 0 ? void 0 : multiElement.lastCommittedPoint) !== null && _multiElement$lastCom !== void 0 ? _multiElement$lastCom : [0, 0];\n          let dxFromLastCommitted = gridX - rx - lastCommittedX;\n          let dyFromLastCommitted = gridY - ry - lastCommittedY;\n          if (shouldRotateWithDiscreteAngle(event)) {\n            ({\n              width: dxFromLastCommitted,\n              height: dyFromLastCommitted\n            } = getLockedLinearCursorAlignSize(\n            // actual coordinate of the last committed point\n            lastCommittedX + rx, lastCommittedY + ry,\n            // cursor-grid coordinate\n            gridX, gridY));\n          }\n          if (isPathALoop(points, this.state.zoom.value)) {\n            setCursor(this.canvas, CURSOR_TYPE.POINTER);\n          }\n          // update last uncommitted point\n          mutateElement(multiElement, {\n            points: [...points.slice(0, -1), [lastCommittedX + dxFromLastCommitted, lastCommittedY + dyFromLastCommitted]]\n          });\n        }\n        return;\n      }\n      const hasDeselectedButton = Boolean(event.buttons);\n      if (hasDeselectedButton || this.state.activeTool.type !== \"selection\" && this.state.activeTool.type !== \"text\" && this.state.activeTool.type !== \"eraser\") {\n        return;\n      }\n      const elements = this.scene.getNonDeletedElements();\n      const selectedElements = this.scene.getSelectedElements(this.state);\n      if (selectedElements.length === 1 && !isOverScrollBar && !this.state.editingLinearElement) {\n        const elementWithTransformHandleType = getElementWithTransformHandleType(elements, this.state, scenePointerX, scenePointerY, this.state.zoom, event.pointerType);\n        if (elementWithTransformHandleType && elementWithTransformHandleType.transformHandleType) {\n          setCursor(this.canvas, getCursorForResizingElement(elementWithTransformHandleType));\n          return;\n        }\n      } else if (selectedElements.length > 1 && !isOverScrollBar) {\n        const transformHandleType = getTransformHandleTypeFromCoords(getCommonBounds(selectedElements), scenePointerX, scenePointerY, this.state.zoom, event.pointerType);\n        if (transformHandleType) {\n          setCursor(this.canvas, getCursorForResizingElement({\n            transformHandleType\n          }));\n          return;\n        }\n      }\n      const hitElement = this.getElementAtPosition(scenePointer.x, scenePointer.y);\n      this.hitLinkElement = this.getElementLinkAtPosition(scenePointer, hitElement);\n      if (isEraserActive(this.state)) {\n        return;\n      }\n      if (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id]) {\n        setCursor(this.canvas, CURSOR_TYPE.POINTER);\n        showHyperlinkTooltip(this.hitLinkElement, this.state);\n      } else {\n        hideHyperlinkToolip();\n        if (hitElement && hitElement.link && this.state.selectedElementIds[hitElement.id] && !this.state.contextMenu && !this.state.showHyperlinkPopup) {\n          this.setState({\n            showHyperlinkPopup: \"info\"\n          });\n        } else if (this.state.activeTool.type === \"text\") {\n          setCursor(this.canvas, isTextElement(hitElement) ? CURSOR_TYPE.TEXT : CURSOR_TYPE.CROSSHAIR);\n        } else if (this.state.viewModeEnabled) {\n          setCursor(this.canvas, CURSOR_TYPE.GRAB);\n        } else if (isOverScrollBar) {\n          setCursor(this.canvas, CURSOR_TYPE.AUTO);\n        } else if (this.state.selectedLinearElement) {\n          this.handleHoverSelectedLinearElement(this.state.selectedLinearElement, scenePointerX, scenePointerY);\n        } else if (\n        // if using cmd/ctrl, we're not dragging\n        !event[KEYS.CTRL_OR_CMD]) {\n          if ((hitElement || this.isHittingCommonBoundingBoxOfSelectedElements(scenePointer, selectedElements)) && !(hitElement !== null && hitElement !== void 0 && hitElement.locked)) {\n            setCursor(this.canvas, CURSOR_TYPE.MOVE);\n          }\n        } else {\n          setCursor(this.canvas, CURSOR_TYPE.AUTO);\n        }\n      }\n    };\n    this.handleEraser = (event, pointerDownState, scenePointer) => {\n      const updateElementIds = elements => {\n        elements.forEach(element => {\n          if (element.locked) {\n            return;\n          }\n          idsToUpdate.push(element.id);\n          if (event.altKey) {\n            if (pointerDownState.elementIdsToErase[element.id] && pointerDownState.elementIdsToErase[element.id].erase) {\n              pointerDownState.elementIdsToErase[element.id].erase = false;\n            }\n          } else if (!pointerDownState.elementIdsToErase[element.id]) {\n            pointerDownState.elementIdsToErase[element.id] = {\n              erase: true,\n              opacity: element.opacity\n            };\n          }\n        });\n      };\n      const idsToUpdate = [];\n      const distance = distance2d(pointerDownState.lastCoords.x, pointerDownState.lastCoords.y, scenePointer.x, scenePointer.y);\n      const threshold = 10 / this.state.zoom.value;\n      const point = {\n        ...pointerDownState.lastCoords\n      };\n      let samplingInterval = 0;\n      while (samplingInterval <= distance) {\n        const hitElements = this.getElementsAtPosition(point.x, point.y);\n        updateElementIds(hitElements);\n\n        // Exit since we reached current point\n        if (samplingInterval === distance) {\n          break;\n        }\n\n        // Calculate next point in the line at a distance of sampling interval\n        samplingInterval = Math.min(samplingInterval + threshold, distance);\n        const distanceRatio = samplingInterval / distance;\n        const nextX = (1 - distanceRatio) * point.x + distanceRatio * scenePointer.x;\n        const nextY = (1 - distanceRatio) * point.y + distanceRatio * scenePointer.y;\n        point.x = nextX;\n        point.y = nextY;\n      }\n      const elements = this.scene.getElementsIncludingDeleted().map(ele => {\n        const id = isBoundToContainer(ele) && idsToUpdate.includes(ele.containerId) ? ele.containerId : ele.id;\n        if (idsToUpdate.includes(id)) {\n          if (event.altKey) {\n            if (pointerDownState.elementIdsToErase[id] && pointerDownState.elementIdsToErase[id].erase === false) {\n              return newElementWith(ele, {\n                opacity: pointerDownState.elementIdsToErase[id].opacity\n              });\n            }\n          } else {\n            return newElementWith(ele, {\n              opacity: ELEMENT_READY_TO_ERASE_OPACITY\n            });\n          }\n        }\n        return ele;\n      });\n      this.scene.replaceAllElements(elements);\n      pointerDownState.lastCoords.x = scenePointer.x;\n      pointerDownState.lastCoords.y = scenePointer.y;\n    };\n    // set touch moving for mobile context menu\n    this.handleTouchMove = event => {\n      invalidateContextMenu = true;\n    };\n    this.handleCanvasPointerDown = event => {\n      var _this$props, _this$props$onPointer;\n      // since contextMenu options are potentially evaluated on each render,\n      // and an contextMenu action may depend on selection state, we must\n      // close the contextMenu before we update the selection on pointerDown\n      // (e.g. resetting selection)\n      if (this.state.contextMenu) {\n        this.setState({\n          contextMenu: null\n        });\n      }\n      this.updateGestureOnPointerDown(event);\n\n      // if dragging element is freedraw and another pointerdown event occurs\n      // a second finger is on the screen\n      // discard the freedraw element if it is very short because it is likely\n      // just a spike, otherwise finalize the freedraw element when the second\n      // finger is lifted\n      if (event.pointerType === \"touch\" && this.state.draggingElement && this.state.draggingElement.type === \"freedraw\") {\n        const element = this.state.draggingElement;\n        this.updateScene({\n          ...(element.points.length < 10 ? {\n            elements: this.scene.getElementsIncludingDeleted().filter(el => el.id !== element.id)\n          } : {}),\n          appState: {\n            draggingElement: null,\n            editingElement: null,\n            startBoundElement: null,\n            suggestedBindings: [],\n            selectedElementIds: makeNextSelectedElementIds(Object.keys(this.state.selectedElementIds).filter(key => key !== element.id).reduce((obj, key) => {\n              obj[key] = this.state.selectedElementIds[key];\n              return obj;\n            }, {}), this.state)\n          }\n        });\n        return;\n      }\n\n      // remove any active selection when we start to interact with canvas\n      // (mainly, we care about removing selection outside the component which\n      //  would prevent our copy handling otherwise)\n      const selection = document.getSelection();\n      if (selection !== null && selection !== void 0 && selection.anchorNode) {\n        selection.removeAllRanges();\n      }\n      this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(event);\n      this.maybeCleanupAfterMissingPointerUp(event);\n\n      //fires only once, if pen is detected, penMode is enabled\n      //the user can disable this by toggling the penMode button\n      if (!this.state.penDetected && event.pointerType === \"pen\") {\n        this.setState(prevState => {\n          return {\n            penMode: true,\n            penDetected: true\n          };\n        });\n      }\n      if (!this.device.isTouchScreen && [\"pen\", \"touch\"].includes(event.pointerType)) {\n        this.device = updateObject(this.device, {\n          isTouchScreen: true\n        });\n      }\n      if (isPanning) {\n        return;\n      }\n      this.lastPointerDown = event;\n      this.setState({\n        lastPointerDownWith: event.pointerType,\n        cursorButton: \"down\"\n      });\n      this.savePointer(event.clientX, event.clientY, \"down\");\n      if (this.handleCanvasPanUsingWheelOrSpaceDrag(event)) {\n        return;\n      }\n\n      // only handle left mouse button or touch\n      if (event.button !== POINTER_BUTTON.MAIN && event.button !== POINTER_BUTTON.TOUCH) {\n        return;\n      }\n\n      // don't select while panning\n      if (gesture.pointers.size > 1) {\n        return;\n      }\n\n      // State for the duration of a pointer interaction, which starts with a\n      // pointerDown event, ends with a pointerUp event (or another pointerDown)\n      const pointerDownState = this.initialPointerDownState(event);\n      this.setState({\n        selectedElementsAreBeingDragged: false\n      });\n      if (this.handleDraggingScrollBar(event, pointerDownState)) {\n        return;\n      }\n      this.clearSelectionIfNotUsingSelection();\n      this.updateBindingEnabledOnPointerMove(event);\n      if (this.handleSelectionOnPointerDown(event, pointerDownState)) {\n        return;\n      }\n      const allowOnPointerDown = !this.state.penMode || event.pointerType !== \"touch\" || this.state.activeTool.type === \"selection\" || this.state.activeTool.type === \"text\" || this.state.activeTool.type === \"image\";\n      if (!allowOnPointerDown) {\n        return;\n      }\n      if (this.state.activeTool.type === \"text\") {\n        this.handleTextOnPointerDown(event, pointerDownState);\n        return;\n      } else if (this.state.activeTool.type === \"arrow\" || this.state.activeTool.type === \"line\") {\n        this.handleLinearElementOnPointerDown(event, this.state.activeTool.type, pointerDownState);\n      } else if (this.state.activeTool.type === \"image\") {\n        // reset image preview on pointerdown\n        setCursor(this.canvas, CURSOR_TYPE.CROSSHAIR);\n\n        // retrieve the latest element as the state may be stale\n        const pendingImageElement = this.state.pendingImageElementId && this.scene.getElement(this.state.pendingImageElementId);\n        if (!pendingImageElement) {\n          return;\n        }\n        this.setState({\n          draggingElement: pendingImageElement,\n          editingElement: pendingImageElement,\n          pendingImageElementId: null,\n          multiElement: null\n        });\n        const {\n          x,\n          y\n        } = viewportCoordsToSceneCoords(event, this.state);\n        mutateElement(pendingImageElement, {\n          x,\n          y\n        });\n      } else if (this.state.activeTool.type === \"freedraw\") {\n        this.handleFreeDrawElementOnPointerDown(event, this.state.activeTool.type, pointerDownState);\n      } else if (this.state.activeTool.type === \"custom\") {\n        setCursor(this.canvas, CURSOR_TYPE.AUTO);\n      } else if (this.state.activeTool.type === \"frame\") {\n        this.createFrameElementOnPointerDown(pointerDownState);\n      } else if (this.state.activeTool.type !== \"eraser\" && this.state.activeTool.type !== \"hand\") {\n        this.createGenericElementOnPointerDown(this.state.activeTool.type, pointerDownState);\n      }\n      (_this$props = this.props) === null || _this$props === void 0 ? void 0 : (_this$props$onPointer = _this$props.onPointerDown) === null || _this$props$onPointer === void 0 ? void 0 : _this$props$onPointer.call(_this$props, this.state.activeTool, pointerDownState);\n      const onPointerMove = this.onPointerMoveFromPointerDownHandler(pointerDownState);\n      const onPointerUp = this.onPointerUpFromPointerDownHandler(pointerDownState);\n      const onKeyDown = this.onKeyDownFromPointerDownHandler(pointerDownState);\n      const onKeyUp = this.onKeyUpFromPointerDownHandler(pointerDownState);\n      lastPointerUp = onPointerUp;\n      if (!this.state.viewModeEnabled) {\n        window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n        window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n        window.addEventListener(EVENT.KEYDOWN, onKeyDown);\n        window.addEventListener(EVENT.KEYUP, onKeyUp);\n        pointerDownState.eventListeners.onMove = onPointerMove;\n        pointerDownState.eventListeners.onUp = onPointerUp;\n        pointerDownState.eventListeners.onKeyUp = onKeyUp;\n        pointerDownState.eventListeners.onKeyDown = onKeyDown;\n      }\n    };\n    this.handleCanvasPointerUp = event => {\n      this.lastPointerUp = event;\n      if (this.device.isTouchScreen) {\n        const scenePointer = viewportCoordsToSceneCoords({\n          clientX: event.clientX,\n          clientY: event.clientY\n        }, this.state);\n        const hitElement = this.getElementAtPosition(scenePointer.x, scenePointer.y);\n        this.hitLinkElement = this.getElementLinkAtPosition(scenePointer, hitElement);\n      }\n      if (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id]) {\n        this.redirectToLink(event, this.device.isTouchScreen);\n      }\n      this.removePointer(event);\n    };\n    this.maybeOpenContextMenuAfterPointerDownOnTouchDevices = event => {\n      // deal with opening context menu on touch devices\n      if (event.pointerType === \"touch\") {\n        invalidateContextMenu = false;\n        if (touchTimeout) {\n          // If there's already a touchTimeout, this means that there's another\n          // touch down and we are doing another touch, so we shouldn't open the\n          // context menu.\n          invalidateContextMenu = true;\n        } else {\n          // open the context menu with the first touch's clientX and clientY\n          // if the touch is not moving\n          touchTimeout = window.setTimeout(() => {\n            touchTimeout = 0;\n            if (!invalidateContextMenu) {\n              this.handleCanvasContextMenu(event);\n            }\n          }, TOUCH_CTX_MENU_TIMEOUT);\n        }\n      }\n    };\n    this.resetContextMenuTimer = () => {\n      clearTimeout(touchTimeout);\n      touchTimeout = 0;\n      invalidateContextMenu = false;\n    };\n    // Returns whether the event is a panning\n    this.handleCanvasPanUsingWheelOrSpaceDrag = event => {\n      if (!(gesture.pointers.size <= 1 && (event.button === POINTER_BUTTON.WHEEL || event.button === POINTER_BUTTON.MAIN && isHoldingSpace || isHandToolActive(this.state) || this.state.viewModeEnabled)) || isTextElement(this.state.editingElement)) {\n        return false;\n      }\n      isPanning = true;\n      event.preventDefault();\n      let nextPastePrevented = false;\n      const isLinux = /Linux/.test(window.navigator.platform);\n      setCursor(this.canvas, CURSOR_TYPE.GRABBING);\n      let {\n        clientX: lastX,\n        clientY: lastY\n      } = event;\n      const onPointerMove = withBatchedUpdatesThrottled(event => {\n        const deltaX = lastX - event.clientX;\n        const deltaY = lastY - event.clientY;\n        lastX = event.clientX;\n        lastY = event.clientY;\n\n        /*\n         * Prevent paste event if we move while middle clicking on Linux.\n         * See issue #1383.\n         */\n        if (isLinux && !nextPastePrevented && (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1)) {\n          nextPastePrevented = true;\n\n          /* Prevent the next paste event */\n          const preventNextPaste = event => {\n            document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n            event.stopPropagation();\n          };\n\n          /*\n           * Reenable next paste in case of disabled middle click paste for\n           * any reason:\n           * - right click paste\n           * - empty clipboard\n           */\n          const enableNextPaste = () => {\n            setTimeout(() => {\n              document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n              window.removeEventListener(EVENT.POINTER_UP, enableNextPaste);\n            }, 100);\n          };\n          document.body.addEventListener(EVENT.PASTE, preventNextPaste);\n          window.addEventListener(EVENT.POINTER_UP, enableNextPaste);\n        }\n        this.translateCanvas({\n          scrollX: this.state.scrollX - deltaX / this.state.zoom.value,\n          scrollY: this.state.scrollY - deltaY / this.state.zoom.value\n        });\n      });\n      const teardown = withBatchedUpdates(lastPointerUp = () => {\n        lastPointerUp = null;\n        isPanning = false;\n        if (!isHoldingSpace) {\n          if (this.state.viewModeEnabled) {\n            setCursor(this.canvas, CURSOR_TYPE.GRAB);\n          } else {\n            setCursorForShape(this.canvas, this.state);\n          }\n        }\n        this.setState({\n          cursorButton: \"up\"\n        });\n        this.savePointer(event.clientX, event.clientY, \"up\");\n        window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n        window.removeEventListener(EVENT.POINTER_UP, teardown);\n        window.removeEventListener(EVENT.BLUR, teardown);\n        onPointerMove.flush();\n      });\n      window.addEventListener(EVENT.BLUR, teardown);\n      window.addEventListener(EVENT.POINTER_MOVE, onPointerMove, {\n        passive: true\n      });\n      window.addEventListener(EVENT.POINTER_UP, teardown);\n      return true;\n    };\n    this.clearSelectionIfNotUsingSelection = () => {\n      if (this.state.activeTool.type !== \"selection\") {\n        this.setState({\n          selectedElementIds: makeNextSelectedElementIds({}, this.state),\n          selectedGroupIds: {},\n          editingGroupId: null\n        });\n      }\n    };\n    /**\n     * @returns whether the pointer event has been completely handled\n     */\n    this.handleSelectionOnPointerDown = (event, pointerDownState) => {\n      if (this.state.activeTool.type === \"selection\") {\n        const elements = this.scene.getNonDeletedElements();\n        const selectedElements = this.scene.getSelectedElements(this.state);\n        if (selectedElements.length === 1 && !this.state.editingLinearElement) {\n          const elementWithTransformHandleType = getElementWithTransformHandleType(elements, this.state, pointerDownState.origin.x, pointerDownState.origin.y, this.state.zoom, event.pointerType);\n          if (elementWithTransformHandleType != null) {\n            this.setState({\n              resizingElement: elementWithTransformHandleType.element\n            });\n            pointerDownState.resize.handleType = elementWithTransformHandleType.transformHandleType;\n          }\n        } else if (selectedElements.length > 1) {\n          pointerDownState.resize.handleType = getTransformHandleTypeFromCoords(getCommonBounds(selectedElements), pointerDownState.origin.x, pointerDownState.origin.y, this.state.zoom, event.pointerType);\n        }\n        if (pointerDownState.resize.handleType) {\n          pointerDownState.resize.isResizing = true;\n          pointerDownState.resize.offset = tupleToCoors(getResizeOffsetXY(pointerDownState.resize.handleType, selectedElements, pointerDownState.origin.x, pointerDownState.origin.y));\n          if (selectedElements.length === 1 && isLinearElement(selectedElements[0]) && selectedElements[0].points.length === 2) {\n            pointerDownState.resize.arrowDirection = getResizeArrowDirection(pointerDownState.resize.handleType, selectedElements[0]);\n          }\n        } else {\n          var _pointerDownState$hit;\n          if (this.state.selectedLinearElement) {\n            const linearElementEditor = this.state.editingLinearElement || this.state.selectedLinearElement;\n            const ret = LinearElementEditor.handlePointerDown(event, this.state, this.history, pointerDownState.origin, linearElementEditor);\n            if (ret.hitElement) {\n              pointerDownState.hit.element = ret.hitElement;\n            }\n            if (ret.linearElementEditor) {\n              this.setState({\n                selectedLinearElement: ret.linearElementEditor\n              });\n              if (this.state.editingLinearElement) {\n                this.setState({\n                  editingLinearElement: ret.linearElementEditor\n                });\n              }\n            }\n            if (ret.didAddPoint) {\n              return true;\n            }\n          }\n          // hitElement may already be set above, so check first\n          pointerDownState.hit.element = (_pointerDownState$hit = pointerDownState.hit.element) !== null && _pointerDownState$hit !== void 0 ? _pointerDownState$hit : this.getElementAtPosition(pointerDownState.origin.x, pointerDownState.origin.y);\n          if (pointerDownState.hit.element) {\n            // Early return if pointer is hitting link icon\n            const hitLinkElement = this.getElementLinkAtPosition({\n              x: pointerDownState.origin.x,\n              y: pointerDownState.origin.y\n            }, pointerDownState.hit.element);\n            if (hitLinkElement) {\n              return false;\n            }\n          }\n\n          // For overlapped elements one position may hit\n          // multiple elements\n          pointerDownState.hit.allHitElements = this.getElementsAtPosition(pointerDownState.origin.x, pointerDownState.origin.y);\n          const hitElement = pointerDownState.hit.element;\n          const someHitElementIsSelected = pointerDownState.hit.allHitElements.some(element => this.isASelectedElement(element));\n          if ((hitElement === null || !someHitElementIsSelected) && !event.shiftKey && !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) {\n            this.clearSelection(hitElement);\n          }\n          if (this.state.editingLinearElement) {\n            this.setState({\n              selectedElementIds: makeNextSelectedElementIds({\n                [this.state.editingLinearElement.elementId]: true\n              }, this.state)\n            });\n            // If we click on something\n          } else if (hitElement != null) {\n            // on CMD/CTRL, drill down to hit element regardless of groups etc.\n            if (event[KEYS.CTRL_OR_CMD]) {\n              if (!this.state.selectedElementIds[hitElement.id]) {\n                pointerDownState.hit.wasAddedToSelection = true;\n              }\n              this.setState(prevState => ({\n                ...editGroupForSelectedElement(prevState, hitElement),\n                previousSelectedElementIds: this.state.selectedElementIds\n              }));\n              // mark as not completely handled so as to allow dragging etc.\n              return false;\n            }\n\n            // deselect if item is selected\n            // if shift is not clicked, this will always return true\n            // otherwise, it will trigger selection based on current\n            // state of the box\n            if (!this.state.selectedElementIds[hitElement.id]) {\n              // if we are currently editing a group, exiting editing mode and deselect the group.\n              if (this.state.editingGroupId && !isElementInGroup(hitElement, this.state.editingGroupId)) {\n                this.setState({\n                  selectedElementIds: makeNextSelectedElementIds({}, this.state),\n                  selectedGroupIds: {},\n                  editingGroupId: null\n                });\n              }\n\n              // Add hit element to selection. At this point if we're not holding\n              // SHIFT the previously selected element(s) were deselected above\n              // (make sure you use setState updater to use latest state)\n              // With shift-selection, we want to make sure that frames and their containing\n              // elements are not selected at the same time.\n              if (!someHitElementIsSelected && !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) {\n                this.setState(prevState => {\n                  const nextSelectedElementIds = {\n                    ...prevState.selectedElementIds,\n                    [hitElement.id]: true\n                  };\n                  const previouslySelectedElements = [];\n                  Object.keys(prevState.selectedElementIds).forEach(id => {\n                    const element = this.scene.getElement(id);\n                    element && previouslySelectedElements.push(element);\n                  });\n\n                  // if hitElement is frame, deselect all of its elements if they are selected\n                  if (hitElement.type === \"frame\") {\n                    getFrameElements(previouslySelectedElements, hitElement.id).forEach(element => {\n                      delete nextSelectedElementIds[element.id];\n                    });\n                  } else if (hitElement.frameId) {\n                    // if hitElement is in a frame and its frame has been selected\n                    // disable selection for the given element\n                    if (nextSelectedElementIds[hitElement.frameId]) {\n                      delete nextSelectedElementIds[hitElement.id];\n                    }\n                  } else {\n                    // hitElement is neither a frame nor an element in a frame\n                    // but since hitElement could be in a group with some frames\n                    // this means selecting hitElement will have the frames selected as well\n                    // because we want to keep the invariant:\n                    // - frames and their elements are not selected at the same time\n                    // we deselect elements in those frames that were previously selected\n\n                    const groupIds = hitElement.groupIds;\n                    const framesInGroups = new Set(groupIds.flatMap(gid => getElementsInGroup(this.scene.getNonDeletedElements(), gid)).filter(element => element.type === \"frame\").map(frame => frame.id));\n                    if (framesInGroups.size > 0) {\n                      previouslySelectedElements.forEach(element => {\n                        if (element.frameId && framesInGroups.has(element.frameId)) {\n                          // deselect element and groups containing the element\n                          delete nextSelectedElementIds[element.id];\n                          element.groupIds.flatMap(gid => getElementsInGroup(this.scene.getNonDeletedElements(), gid)).forEach(element => {\n                            delete nextSelectedElementIds[element.id];\n                          });\n                        }\n                      });\n                    }\n                  }\n                  return selectGroupsForSelectedElements({\n                    ...prevState,\n                    selectedElementIds: nextSelectedElementIds,\n                    showHyperlinkPopup: hitElement.link ? \"info\" : false\n                  }, this.scene.getNonDeletedElements(), prevState, this);\n                });\n                pointerDownState.hit.wasAddedToSelection = true;\n              }\n            }\n          }\n          this.setState({\n            previousSelectedElementIds: this.state.selectedElementIds\n          });\n        }\n      }\n      return false;\n    };\n    this.handleTextOnPointerDown = (event, pointerDownState) => {\n      // if we're currently still editing text, clicking outside\n      // should only finalize it, not create another (irrespective\n      // of state.activeTool.locked)\n      if (isTextElement(this.state.editingElement)) {\n        return;\n      }\n      let sceneX = pointerDownState.origin.x;\n      let sceneY = pointerDownState.origin.y;\n      const element = this.getElementAtPosition(sceneX, sceneY, {\n        includeBoundTextElement: true\n      });\n      let container = getTextBindableContainerAtPosition(this.scene.getNonDeletedElements(), this.state, sceneX, sceneY);\n      if (hasBoundTextElement(element)) {\n        container = element;\n        sceneX = element.x + element.width / 2;\n        sceneY = element.y + element.height / 2;\n      }\n      this.startTextEditing({\n        sceneX,\n        sceneY,\n        insertAtParentCenter: !event.altKey,\n        container\n      });\n      resetCursor(this.canvas);\n      if (!this.state.activeTool.locked) {\n        this.setState({\n          activeTool: updateActiveTool(this.state, {\n            type: \"selection\"\n          })\n        });\n      }\n    };\n    this.handleFreeDrawElementOnPointerDown = (event, elementType, pointerDownState) => {\n      // Begin a mark capture. This does not have to update state yet.\n      const [gridX, gridY] = getGridPoint(pointerDownState.origin.x, pointerDownState.origin.y, null);\n      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n        x: gridX,\n        y: gridY\n      });\n      const element = newFreeDrawElement({\n        type: elementType,\n        x: gridX,\n        y: gridY,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        strokeStyle: this.state.currentItemStrokeStyle,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n        roundness: null,\n        simulatePressure: event.pressure === 0.5,\n        locked: false,\n        frameId: topLayerFrame ? topLayerFrame.id : null\n      });\n      this.setState(prevState => {\n        const nextSelectedElementIds = {\n          ...prevState.selectedElementIds\n        };\n        delete nextSelectedElementIds[element.id];\n        return {\n          selectedElementIds: makeNextSelectedElementIds(nextSelectedElementIds, prevState)\n        };\n      });\n      const pressures = element.simulatePressure ? element.pressures : [...element.pressures, event.pressure];\n      mutateElement(element, {\n        points: [[0, 0]],\n        pressures\n      });\n      const boundElement = getHoveredElementForBinding(pointerDownState.origin, this.scene);\n      this.scene.addNewElement(element);\n      this.setState({\n        draggingElement: element,\n        editingElement: element,\n        startBoundElement: boundElement,\n        suggestedBindings: []\n      });\n    };\n    this.createImageElement = _ref6 => {\n      let {\n        sceneX,\n        sceneY\n      } = _ref6;\n      const [gridX, gridY] = getGridPoint(sceneX, sceneY, this.state.gridSize);\n      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n        x: gridX,\n        y: gridY\n      });\n      const element = newImageElement({\n        type: \"image\",\n        x: gridX,\n        y: gridY,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        strokeStyle: this.state.currentItemStrokeStyle,\n        roughness: this.state.currentItemRoughness,\n        roundness: null,\n        opacity: this.state.currentItemOpacity,\n        locked: false,\n        frameId: topLayerFrame ? topLayerFrame.id : null\n      });\n      return element;\n    };\n    this.handleLinearElementOnPointerDown = (event, elementType, pointerDownState) => {\n      if (this.state.multiElement) {\n        const {\n          multiElement\n        } = this.state;\n\n        // finalize if completing a loop\n        if (multiElement.type === \"line\" && isPathALoop(multiElement.points, this.state.zoom.value)) {\n          mutateElement(multiElement, {\n            lastCommittedPoint: multiElement.points[multiElement.points.length - 1]\n          });\n          this.actionManager.executeAction(actionFinalize);\n          return;\n        }\n        const {\n          x: rx,\n          y: ry,\n          lastCommittedPoint\n        } = multiElement;\n\n        // clicking inside commit zone  finalize arrow\n        if (multiElement.points.length > 1 && lastCommittedPoint && distance2d(pointerDownState.origin.x - rx, pointerDownState.origin.y - ry, lastCommittedPoint[0], lastCommittedPoint[1]) < LINE_CONFIRM_THRESHOLD) {\n          this.actionManager.executeAction(actionFinalize);\n          return;\n        }\n        this.setState(prevState => ({\n          selectedElementIds: makeNextSelectedElementIds({\n            ...prevState.selectedElementIds,\n            [multiElement.id]: true\n          }, prevState)\n        }));\n        // clicking outside commit zone  update reference for last committed\n        // point\n        mutateElement(multiElement, {\n          lastCommittedPoint: multiElement.points[multiElement.points.length - 1]\n        });\n        setCursor(this.canvas, CURSOR_TYPE.POINTER);\n      } else {\n        const [gridX, gridY] = getGridPoint(pointerDownState.origin.x, pointerDownState.origin.y, this.state.gridSize);\n        const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n          x: gridX,\n          y: gridY\n        });\n\n        /* If arrow is pre-arrowheads, it will have undefined for both start and end arrowheads.\n        If so, we want it to be null for start and \"arrow\" for end. If the linear item is not\n        an arrow, we want it to be null for both. Otherwise, we want it to use the\n        values from appState. */\n\n        const {\n          currentItemStartArrowhead,\n          currentItemEndArrowhead\n        } = this.state;\n        const [startArrowhead, endArrowhead] = elementType === \"arrow\" ? [currentItemStartArrowhead, currentItemEndArrowhead] : [null, null];\n        const element = newLinearElement({\n          type: elementType,\n          x: gridX,\n          y: gridY,\n          strokeColor: this.state.currentItemStrokeColor,\n          backgroundColor: this.state.currentItemBackgroundColor,\n          fillStyle: this.state.currentItemFillStyle,\n          strokeWidth: this.state.currentItemStrokeWidth,\n          strokeStyle: this.state.currentItemStrokeStyle,\n          roughness: this.state.currentItemRoughness,\n          opacity: this.state.currentItemOpacity,\n          roundness: this.state.currentItemRoundness === \"round\" ? {\n            type: ROUNDNESS.PROPORTIONAL_RADIUS\n          } : null,\n          startArrowhead,\n          endArrowhead,\n          locked: false,\n          frameId: topLayerFrame ? topLayerFrame.id : null\n        });\n        this.setState(prevState => {\n          const nextSelectedElementIds = {\n            ...prevState.selectedElementIds\n          };\n          delete nextSelectedElementIds[element.id];\n          return {\n            selectedElementIds: makeNextSelectedElementIds(nextSelectedElementIds, prevState)\n          };\n        });\n        mutateElement(element, {\n          points: [...element.points, [0, 0]]\n        });\n        const boundElement = getHoveredElementForBinding(pointerDownState.origin, this.scene);\n        this.scene.addNewElement(element);\n        this.setState({\n          draggingElement: element,\n          editingElement: element,\n          startBoundElement: boundElement,\n          suggestedBindings: []\n        });\n      }\n    };\n    this.createGenericElementOnPointerDown = (elementType, pointerDownState) => {\n      const [gridX, gridY] = getGridPoint(pointerDownState.origin.x, pointerDownState.origin.y, this.state.gridSize);\n      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n        x: gridX,\n        y: gridY\n      });\n      const element = newElement({\n        type: elementType,\n        x: gridX,\n        y: gridY,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        strokeStyle: this.state.currentItemStrokeStyle,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n        roundness: this.state.currentItemRoundness === \"round\" ? {\n          type: isUsingAdaptiveRadius(elementType) ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS\n        } : null,\n        locked: false,\n        frameId: topLayerFrame ? topLayerFrame.id : null\n      });\n      if (element.type === \"selection\") {\n        this.setState({\n          selectionElement: element,\n          draggingElement: element\n        });\n      } else {\n        this.scene.addNewElement(element);\n        this.setState({\n          multiElement: null,\n          draggingElement: element,\n          editingElement: element\n        });\n      }\n    };\n    this.createFrameElementOnPointerDown = pointerDownState => {\n      const [gridX, gridY] = getGridPoint(pointerDownState.origin.x, pointerDownState.origin.y, this.state.gridSize);\n      const frame = newFrameElement({\n        x: gridX,\n        y: gridY,\n        opacity: this.state.currentItemOpacity,\n        locked: false,\n        ...FRAME_STYLE\n      });\n      this.scene.replaceAllElements([...this.scene.getElementsIncludingDeleted(), frame]);\n      this.setState({\n        multiElement: null,\n        draggingElement: frame,\n        editingElement: frame\n      });\n    };\n    this.restoreReadyToEraseElements = pointerDownState => {\n      const elements = this.scene.getElementsIncludingDeleted().map(ele => {\n        if (pointerDownState.elementIdsToErase[ele.id] && pointerDownState.elementIdsToErase[ele.id].erase) {\n          return newElementWith(ele, {\n            opacity: pointerDownState.elementIdsToErase[ele.id].opacity\n          });\n        } else if (isBoundToContainer(ele) && pointerDownState.elementIdsToErase[ele.containerId] && pointerDownState.elementIdsToErase[ele.containerId].erase) {\n          return newElementWith(ele, {\n            opacity: pointerDownState.elementIdsToErase[ele.containerId].opacity\n          });\n        } else if (ele.frameId && pointerDownState.elementIdsToErase[ele.frameId] && pointerDownState.elementIdsToErase[ele.frameId].erase) {\n          return newElementWith(ele, {\n            opacity: pointerDownState.elementIdsToErase[ele.frameId].opacity\n          });\n        }\n        return ele;\n      });\n      this.scene.replaceAllElements(elements);\n    };\n    this.eraseElements = pointerDownState => {\n      const elements = this.scene.getElementsIncludingDeleted().map(ele => {\n        if (pointerDownState.elementIdsToErase[ele.id] && pointerDownState.elementIdsToErase[ele.id].erase) {\n          return newElementWith(ele, {\n            isDeleted: true\n          });\n        } else if (isBoundToContainer(ele) && pointerDownState.elementIdsToErase[ele.containerId] && pointerDownState.elementIdsToErase[ele.containerId].erase) {\n          return newElementWith(ele, {\n            isDeleted: true\n          });\n        } else if (ele.frameId && pointerDownState.elementIdsToErase[ele.frameId] && pointerDownState.elementIdsToErase[ele.frameId].erase) {\n          return newElementWith(ele, {\n            isDeleted: true\n          });\n        }\n        return ele;\n      });\n      this.history.resumeRecording();\n      this.scene.replaceAllElements(elements);\n    };\n    this.initializeImage = async _ref7 => {\n      var _this$props$generateI, _this$props2, _this$files$fileId2;\n      let {\n        imageFile,\n        imageElement: _imageElement,\n        showCursorImagePreview = false\n      } = _ref7;\n      // at this point this should be guaranteed image file, but we do this check\n      // to satisfy TS down the line\n      if (!isSupportedImageFile(imageFile)) {\n        throw new Error(t(\"errors.unsupportedFileType\"));\n      }\n      const mimeType = imageFile.type;\n      setCursor(this.canvas, \"wait\");\n      if (mimeType === MIME_TYPES.svg) {\n        try {\n          imageFile = SVGStringToFile(await normalizeSVG(await imageFile.text()), imageFile.name);\n        } catch (error) {\n          console.warn(error);\n          throw new Error(t(\"errors.svgImageInsertError\"));\n        }\n      }\n\n      // generate image id (by default the file digest) before any\n      // resizing/compression takes place to keep it more portable\n      const fileId = await (((_this$props$generateI = (_this$props2 = this.props).generateIdForFile) === null || _this$props$generateI === void 0 ? void 0 : _this$props$generateI.call(_this$props2, imageFile)) || generateIdFromFile(imageFile));\n      if (!fileId) {\n        console.warn(\"Couldn't generate file id or the supplied `generateIdForFile` didn't resolve to one.\");\n        throw new Error(t(\"errors.imageInsertError\"));\n      }\n      const existingFileData = this.files[fileId];\n      if (!(existingFileData !== null && existingFileData !== void 0 && existingFileData.dataURL)) {\n        try {\n          imageFile = await resizeImageFile(imageFile, {\n            maxWidthOrHeight: DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT\n          });\n        } catch (error) {\n          console.error(\"error trying to resing image file on insertion\", error);\n        }\n        if (imageFile.size > MAX_ALLOWED_FILE_BYTES) {\n          throw new Error(t(\"errors.fileTooBig\", {\n            maxSize: `${Math.trunc(MAX_ALLOWED_FILE_BYTES / 1024 / 1024)}MB`\n          }));\n        }\n      }\n      if (showCursorImagePreview) {\n        var _this$files$fileId;\n        const dataURL = (_this$files$fileId = this.files[fileId]) === null || _this$files$fileId === void 0 ? void 0 : _this$files$fileId.dataURL;\n        // optimization so that we don't unnecessarily resize the original\n        // full-size file for cursor preview\n        // (it's much faster to convert the resized dataURL to File)\n        const resizedFile = dataURL && dataURLToFile(dataURL);\n        this.setImagePreviewCursor(resizedFile || imageFile);\n      }\n      const dataURL = ((_this$files$fileId2 = this.files[fileId]) === null || _this$files$fileId2 === void 0 ? void 0 : _this$files$fileId2.dataURL) || (await getDataURL(imageFile));\n      const imageElement = mutateElement(_imageElement, {\n        fileId\n      }, false);\n      return new Promise(async (resolve, reject) => {\n        try {\n          var _this$state$draggingE;\n          this.files = {\n            ...this.files,\n            [fileId]: {\n              mimeType,\n              id: fileId,\n              dataURL,\n              created: Date.now(),\n              lastRetrieved: Date.now()\n            }\n          };\n          const cachedImageData = this.imageCache.get(fileId);\n          if (!cachedImageData) {\n            this.addNewImagesToImageCache();\n            await this.updateImageCache([imageElement]);\n          }\n          if ((cachedImageData === null || cachedImageData === void 0 ? void 0 : cachedImageData.image) instanceof Promise) {\n            await cachedImageData.image;\n          }\n          if (this.state.pendingImageElementId !== imageElement.id && ((_this$state$draggingE = this.state.draggingElement) === null || _this$state$draggingE === void 0 ? void 0 : _this$state$draggingE.id) !== imageElement.id) {\n            this.initializeImageDimensions(imageElement, true);\n          }\n          resolve(imageElement);\n        } catch (error) {\n          console.error(error);\n          reject(new Error(t(\"errors.imageInsertError\")));\n        } finally {\n          if (!showCursorImagePreview) {\n            resetCursor(this.canvas);\n          }\n        }\n      });\n    };\n    /**\n     * inserts image into elements array and rerenders\n     */\n    this.insertImageElement = async (imageElement, imageFile, showCursorImagePreview) => {\n      this.scene.addNewElement(imageElement);\n      try {\n        await this.initializeImage({\n          imageFile,\n          imageElement,\n          showCursorImagePreview\n        });\n      } catch (error) {\n        mutateElement(imageElement, {\n          isDeleted: true\n        });\n        this.actionManager.executeAction(actionFinalize);\n        this.setState({\n          errorMessage: error.message || t(\"errors.imageInsertError\")\n        });\n      }\n    };\n    this.setImagePreviewCursor = async imageFile => {\n      // mustn't be larger than 128 px\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Basic_User_Interface/Using_URL_values_for_the_cursor_property\n      const cursorImageSizePx = 96;\n      const imagePreview = await resizeImageFile(imageFile, {\n        maxWidthOrHeight: cursorImageSizePx\n      });\n      let previewDataURL = await getDataURL(imagePreview);\n\n      // SVG cannot be resized via `resizeImageFile` so we resize by rendering to\n      // a small canvas\n      if (imageFile.type === MIME_TYPES.svg) {\n        const img = await loadHTMLImageElement(previewDataURL);\n        let height = Math.min(img.height, cursorImageSizePx);\n        let width = height * (img.width / img.height);\n        if (width > cursorImageSizePx) {\n          width = cursorImageSizePx;\n          height = width * (img.height / img.width);\n        }\n        const canvas = document.createElement(\"canvas\");\n        canvas.height = height;\n        canvas.width = width;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(img, 0, 0, width, height);\n        previewDataURL = canvas.toDataURL(MIME_TYPES.svg);\n      }\n      if (this.state.pendingImageElementId) {\n        setCursor(this.canvas, `url(${previewDataURL}) 4 4, auto`);\n      }\n    };\n    this.onImageAction = async function () {\n      let {\n        insertOnCanvasDirectly\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        insertOnCanvasDirectly: false\n      };\n      try {\n        const clientX = _this.state.width / 2 + _this.state.offsetLeft;\n        const clientY = _this.state.height / 2 + _this.state.offsetTop;\n        const {\n          x,\n          y\n        } = viewportCoordsToSceneCoords({\n          clientX,\n          clientY\n        }, _this.state);\n        const imageFile = await fileOpen({\n          description: \"Image\",\n          extensions: Object.keys(IMAGE_MIME_TYPES)\n        });\n        const imageElement = _this.createImageElement({\n          sceneX: x,\n          sceneY: y\n        });\n        if (insertOnCanvasDirectly) {\n          _this.insertImageElement(imageElement, imageFile);\n          _this.initializeImageDimensions(imageElement);\n          _this.setState({\n            selectedElementIds: makeNextSelectedElementIds({\n              [imageElement.id]: true\n            }, _this.state)\n          }, () => {\n            _this.actionManager.executeAction(actionFinalize);\n          });\n        } else {\n          _this.setState({\n            pendingImageElementId: imageElement.id\n          }, () => {\n            _this.insertImageElement(imageElement, imageFile, /* showCursorImagePreview */true);\n          });\n        }\n      } catch (error) {\n        if (error.name !== \"AbortError\") {\n          console.error(error);\n        } else {\n          console.warn(error);\n        }\n        _this.setState({\n          pendingImageElementId: null,\n          editingElement: null,\n          activeTool: updateActiveTool(_this.state, {\n            type: \"selection\"\n          })\n        }, () => {\n          _this.actionManager.executeAction(actionFinalize);\n        });\n      }\n    };\n    this.initializeImageDimensions = function (imageElement) {\n      var _this$imageCache$get;\n      let forceNaturalSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const image = isInitializedImageElement(imageElement) && ((_this$imageCache$get = _this.imageCache.get(imageElement.fileId)) === null || _this$imageCache$get === void 0 ? void 0 : _this$imageCache$get.image);\n      if (!image || image instanceof Promise) {\n        if (imageElement.width < DRAGGING_THRESHOLD / _this.state.zoom.value && imageElement.height < DRAGGING_THRESHOLD / _this.state.zoom.value) {\n          const placeholderSize = 100 / _this.state.zoom.value;\n          mutateElement(imageElement, {\n            x: imageElement.x - placeholderSize / 2,\n            y: imageElement.y - placeholderSize / 2,\n            width: placeholderSize,\n            height: placeholderSize\n          });\n        }\n        return;\n      }\n      if (forceNaturalSize ||\n      // if user-created bounding box is below threshold, assume the\n      // intention was to click instead of drag, and use the image's\n      // intrinsic size\n      imageElement.width < DRAGGING_THRESHOLD / _this.state.zoom.value && imageElement.height < DRAGGING_THRESHOLD / _this.state.zoom.value) {\n        const minHeight = Math.max(_this.state.height - 120, 160);\n        // max 65% of canvas height, clamped to <300px, vh - 120px>\n        const maxHeight = Math.min(minHeight, Math.floor(_this.state.height * 0.5) / _this.state.zoom.value);\n        const height = Math.min(image.naturalHeight, maxHeight);\n        const width = height * (image.naturalWidth / image.naturalHeight);\n\n        // add current imageElement width/height to account for previous centering\n        // of the placeholder image\n        const x = imageElement.x + imageElement.width / 2 - width / 2;\n        const y = imageElement.y + imageElement.height / 2 - height / 2;\n        mutateElement(imageElement, {\n          x,\n          y,\n          width,\n          height\n        });\n      }\n    };\n    /** updates image cache, refreshing updated elements and/or setting status\n        to error for images that fail during <img> element creation */\n    this.updateImageCache = async function (elements) {\n      let files = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.files;\n      const {\n        updatedFiles,\n        erroredFiles\n      } = await _updateImageCache({\n        imageCache: _this.imageCache,\n        fileIds: elements.map(element => element.fileId),\n        files\n      });\n      if (updatedFiles.size || erroredFiles.size) {\n        for (const element of elements) {\n          if (updatedFiles.has(element.fileId)) {\n            invalidateShapeForElement(element);\n          }\n        }\n      }\n      if (erroredFiles.size) {\n        _this.scene.replaceAllElements(_this.scene.getElementsIncludingDeleted().map(element => {\n          if (isInitializedImageElement(element) && erroredFiles.has(element.fileId)) {\n            return newElementWith(element, {\n              status: \"error\"\n            });\n          }\n          return element;\n        }));\n      }\n      return {\n        updatedFiles,\n        erroredFiles\n      };\n    };\n    /** adds new images to imageCache and re-renders if needed */\n    this.addNewImagesToImageCache = async function () {\n      let imageElements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getInitializedImageElements(_this.scene.getNonDeletedElements());\n      let files = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.files;\n      const uncachedImageElements = imageElements.filter(element => !element.isDeleted && !_this.imageCache.has(element.fileId));\n      if (uncachedImageElements.length) {\n        const {\n          updatedFiles\n        } = await _this.updateImageCache(uncachedImageElements, files);\n        if (updatedFiles.size) {\n          _this.scene.informMutation();\n        }\n      }\n    };\n    /** generally you should use `addNewImagesToImageCache()` directly if you need\n     *  to render new images. This is just a failsafe  */\n    this.scheduleImageRefresh = throttle(() => {\n      this.addNewImagesToImageCache();\n    }, IMAGE_RENDER_TIMEOUT);\n    this.updateBindingEnabledOnPointerMove = event => {\n      const shouldEnableBinding = shouldEnableBindingForPointerEvent(event);\n      if (this.state.isBindingEnabled !== shouldEnableBinding) {\n        this.setState({\n          isBindingEnabled: shouldEnableBinding\n        });\n      }\n    };\n    this.maybeSuggestBindingAtCursor = pointerCoords => {\n      const hoveredBindableElement = getHoveredElementForBinding(pointerCoords, this.scene);\n      this.setState({\n        suggestedBindings: hoveredBindableElement != null ? [hoveredBindableElement] : []\n      });\n    };\n    this.maybeSuggestBindingsForLinearElementAtCoords = (linearElement, pointerCoords, oppositeBindingBoundElement) => {\n      if (!pointerCoords.length) {\n        return;\n      }\n      const suggestedBindings = pointerCoords.reduce((acc, coords) => {\n        const hoveredBindableElement = getHoveredElementForBinding(coords, this.scene);\n        if (hoveredBindableElement != null && !isLinearElementSimpleAndAlreadyBound(linearElement, oppositeBindingBoundElement === null || oppositeBindingBoundElement === void 0 ? void 0 : oppositeBindingBoundElement.id, hoveredBindableElement)) {\n          acc.push(hoveredBindableElement);\n        }\n        return acc;\n      }, []);\n      this.setState({\n        suggestedBindings\n      });\n    };\n    this.handleCanvasRef = canvas => {\n      // canvas is null when unmounting\n      if (canvas !== null) {\n        this.canvas = canvas;\n        this.rc = rough.canvas(this.canvas);\n        this.canvas.addEventListener(EVENT.WHEEL, this.handleWheel, {\n          passive: false\n        });\n        this.canvas.addEventListener(EVENT.TOUCH_START, this.onTapStart);\n        this.canvas.addEventListener(EVENT.TOUCH_END, this.onTapEnd);\n      } else {\n        var _this$canvas, _this$canvas2, _this$canvas3;\n        (_this$canvas = this.canvas) === null || _this$canvas === void 0 ? void 0 : _this$canvas.removeEventListener(EVENT.WHEEL, this.handleWheel);\n        (_this$canvas2 = this.canvas) === null || _this$canvas2 === void 0 ? void 0 : _this$canvas2.removeEventListener(EVENT.TOUCH_START, this.onTapStart);\n        (_this$canvas3 = this.canvas) === null || _this$canvas3 === void 0 ? void 0 : _this$canvas3.removeEventListener(EVENT.TOUCH_END, this.onTapEnd);\n      }\n    };\n    this.handleAppOnDrop = async event => {\n      // must be retrieved first, in the same frame\n      const {\n        file,\n        fileHandle\n      } = await getFileFromEvent(event);\n      try {\n        if (isSupportedImageFile(file)) {\n          // first attempt to decode scene from the image if it's embedded\n          // ---------------------------------------------------------------------\n\n          if ((file === null || file === void 0 ? void 0 : file.type) === MIME_TYPES.png || (file === null || file === void 0 ? void 0 : file.type) === MIME_TYPES.svg) {\n            try {\n              const scene = await loadFromBlob(file, this.state, this.scene.getElementsIncludingDeleted(), fileHandle);\n              this.syncActionResult({\n                ...scene,\n                appState: {\n                  ...(scene.appState || this.state),\n                  isLoading: false\n                },\n                replaceFiles: true,\n                commitToHistory: true\n              });\n              return;\n            } catch (error) {\n              if (error.name !== \"EncodingError\") {\n                throw error;\n              }\n            }\n          }\n\n          // if no scene is embedded or we fail for whatever reason, fall back\n          // to importing as regular image\n          // ---------------------------------------------------------------------\n\n          const {\n            x: sceneX,\n            y: sceneY\n          } = viewportCoordsToSceneCoords(event, this.state);\n          const imageElement = this.createImageElement({\n            sceneX,\n            sceneY\n          });\n          this.insertImageElement(imageElement, file);\n          this.initializeImageDimensions(imageElement);\n          this.setState({\n            selectedElementIds: makeNextSelectedElementIds({\n              [imageElement.id]: true\n            }, this.state)\n          });\n          return;\n        }\n      } catch (error) {\n        return this.setState({\n          isLoading: false,\n          errorMessage: error.message\n        });\n      }\n      const libraryJSON = event.dataTransfer.getData(MIME_TYPES.excalidrawlib);\n      if (libraryJSON && typeof libraryJSON === \"string\") {\n        try {\n          const libraryItems = parseLibraryJSON(libraryJSON);\n          this.addElementsFromPasteOrLibrary({\n            elements: distributeLibraryItemsOnSquareGrid(libraryItems),\n            position: event,\n            files: null\n          });\n        } catch (error) {\n          this.setState({\n            errorMessage: error.message\n          });\n        }\n        return;\n      }\n      if (file) {\n        // atetmpt to parse an excalidraw/excalidrawlib file\n        await this.loadFileToCanvas(file, fileHandle);\n      }\n    };\n    this.loadFileToCanvas = async (file, fileHandle) => {\n      file = await normalizeFile(file);\n      try {\n        const ret = await loadSceneOrLibraryFromBlob(file, this.state, this.scene.getElementsIncludingDeleted(), fileHandle);\n        if (ret.type === MIME_TYPES.excalidraw) {\n          this.setState({\n            isLoading: true\n          });\n          this.syncActionResult({\n            ...ret.data,\n            appState: {\n              ...(ret.data.appState || this.state),\n              isLoading: false\n            },\n            replaceFiles: true,\n            commitToHistory: true\n          });\n        } else if (ret.type === MIME_TYPES.excalidrawlib) {\n          await this.library.updateLibrary({\n            libraryItems: file,\n            merge: true,\n            openLibraryMenu: true\n          }).catch(error => {\n            console.error(error);\n            this.setState({\n              errorMessage: t(\"errors.importLibraryError\")\n            });\n          });\n        }\n      } catch (error) {\n        this.setState({\n          isLoading: false,\n          errorMessage: error.message\n        });\n      }\n    };\n    this.handleCanvasContextMenu = event => {\n      event.preventDefault();\n      if ((event.nativeEvent.pointerType === \"touch\" || event.nativeEvent.pointerType === \"pen\" &&\n      // always allow if user uses a pen secondary button\n      event.button !== POINTER_BUTTON.SECONDARY) && this.state.activeTool.type !== \"selection\") {\n        return;\n      }\n      const {\n        x,\n        y\n      } = viewportCoordsToSceneCoords(event, this.state);\n      const element = this.getElementAtPosition(x, y, {\n        preferSelected: true,\n        includeLockedElements: true\n      });\n      const selectedElements = this.scene.getSelectedElements(this.state);\n      const isHittignCommonBoundBox = this.isHittingCommonBoundingBoxOfSelectedElements({\n        x,\n        y\n      }, selectedElements);\n      const type = element || isHittignCommonBoundBox ? \"element\" : \"canvas\";\n      const container = this.excalidrawContainerRef.current;\n      const {\n        top: offsetTop,\n        left: offsetLeft\n      } = container.getBoundingClientRect();\n      const left = event.clientX - offsetLeft;\n      const top = event.clientY - offsetTop;\n      trackEvent(\"contextMenu\", \"openContextMenu\", type);\n      this.setState({\n        ...(element && !this.state.selectedElementIds[element.id] ? selectGroupsForSelectedElements({\n          ...this.state,\n          selectedElementIds: {\n            [element.id]: true\n          },\n          selectedLinearElement: isLinearElement(element) ? new LinearElementEditor(element, this.scene) : null\n        }, this.scene.getNonDeletedElements(), this.state, this) : this.state),\n        showHyperlinkPopup: false\n      }, () => {\n        this.setState({\n          contextMenu: {\n            top,\n            left,\n            items: this.getContextMenuItems(type)\n          }\n        });\n      });\n    };\n    this.maybeDragNewGenericElement = (pointerDownState, event) => {\n      const draggingElement = this.state.draggingElement;\n      const pointerCoords = pointerDownState.lastCoords;\n      if (!draggingElement) {\n        return;\n      }\n      if (draggingElement.type === \"selection\" && this.state.activeTool.type !== \"eraser\") {\n        dragNewElement(draggingElement, this.state.activeTool.type, pointerDownState.origin.x, pointerDownState.origin.y, pointerCoords.x, pointerCoords.y, distance(pointerDownState.origin.x, pointerCoords.x), distance(pointerDownState.origin.y, pointerCoords.y), shouldMaintainAspectRatio(event), shouldResizeFromCenter(event));\n      } else {\n        var _this$imageCache$get2;\n        const [gridX, gridY] = getGridPoint(pointerCoords.x, pointerCoords.y, this.state.gridSize);\n        const image = isInitializedImageElement(draggingElement) && ((_this$imageCache$get2 = this.imageCache.get(draggingElement.fileId)) === null || _this$imageCache$get2 === void 0 ? void 0 : _this$imageCache$get2.image);\n        const aspectRatio = image && !(image instanceof Promise) ? image.width / image.height : null;\n        dragNewElement(draggingElement, this.state.activeTool.type, pointerDownState.originInGrid.x, pointerDownState.originInGrid.y, gridX, gridY, distance(pointerDownState.originInGrid.x, gridX), distance(pointerDownState.originInGrid.y, gridY), isImageElement(draggingElement) ? !shouldMaintainAspectRatio(event) : shouldMaintainAspectRatio(event), shouldResizeFromCenter(event), aspectRatio);\n        this.maybeSuggestBindingForAll([draggingElement]);\n\n        // highlight elements that are to be added to frames on frames creation\n        if (this.state.activeTool.type === \"frame\") {\n          this.setState({\n            elementsToHighlight: getElementsInResizingFrame(this.scene.getNonDeletedElements(), draggingElement, this.state)\n          });\n        }\n      }\n    };\n    this.maybeHandleResize = (pointerDownState, event) => {\n      const selectedElements = this.scene.getSelectedElements(this.state);\n      const selectedFrames = selectedElements.filter(element => element.type === \"frame\");\n      const transformHandleType = pointerDownState.resize.handleType;\n      if (selectedFrames.length > 0 && transformHandleType === \"rotation\") {\n        return false;\n      }\n      this.setState({\n        // TODO: rename this state field to \"isScaling\" to distinguish\n        // it from the generic \"isResizing\" which includes scaling and\n        // rotating\n        isResizing: transformHandleType && transformHandleType !== \"rotation\",\n        isRotating: transformHandleType === \"rotation\"\n      });\n      const pointerCoords = pointerDownState.lastCoords;\n      const [resizeX, resizeY] = getGridPoint(pointerCoords.x - pointerDownState.resize.offset.x, pointerCoords.y - pointerDownState.resize.offset.y, this.state.gridSize);\n      const frameElementsOffsetsMap = new Map();\n      selectedFrames.forEach(frame => {\n        const elementsInFrame = getFrameElements(this.scene.getNonDeletedElements(), frame.id);\n        elementsInFrame.forEach(element => {\n          frameElementsOffsetsMap.set(frame.id + element.id, {\n            x: element.x - frame.x,\n            y: element.y - frame.y\n          });\n        });\n      });\n      if (transformElements(pointerDownState, transformHandleType, selectedElements, pointerDownState.resize.arrowDirection, shouldRotateWithDiscreteAngle(event), shouldResizeFromCenter(event), selectedElements.length === 1 && isImageElement(selectedElements[0]) ? !shouldMaintainAspectRatio(event) : shouldMaintainAspectRatio(event), resizeX, resizeY, pointerDownState.resize.center.x, pointerDownState.resize.center.y)) {\n        this.maybeSuggestBindingForAll(selectedElements);\n        const elementsToHighlight = new Set();\n        selectedFrames.forEach(frame => {\n          const elementsInFrame = getFrameElements(this.scene.getNonDeletedElements(), frame.id);\n\n          // keep elements' positions relative to their frames on frames resizing\n          if (transformHandleType) {\n            if (transformHandleType.includes(\"w\")) {\n              elementsInFrame.forEach(element => {\n                var _frameElementsOffsets, _frameElementsOffsets2;\n                mutateElement(element, {\n                  x: frame.x + (((_frameElementsOffsets = frameElementsOffsetsMap.get(frame.id + element.id)) === null || _frameElementsOffsets === void 0 ? void 0 : _frameElementsOffsets.x) || 0),\n                  y: frame.y + (((_frameElementsOffsets2 = frameElementsOffsetsMap.get(frame.id + element.id)) === null || _frameElementsOffsets2 === void 0 ? void 0 : _frameElementsOffsets2.y) || 0)\n                });\n              });\n            }\n            if (transformHandleType.includes(\"n\")) {\n              elementsInFrame.forEach(element => {\n                var _frameElementsOffsets3, _frameElementsOffsets4;\n                mutateElement(element, {\n                  x: frame.x + (((_frameElementsOffsets3 = frameElementsOffsetsMap.get(frame.id + element.id)) === null || _frameElementsOffsets3 === void 0 ? void 0 : _frameElementsOffsets3.x) || 0),\n                  y: frame.y + (((_frameElementsOffsets4 = frameElementsOffsetsMap.get(frame.id + element.id)) === null || _frameElementsOffsets4 === void 0 ? void 0 : _frameElementsOffsets4.y) || 0)\n                });\n              });\n            }\n          }\n          getElementsInResizingFrame(this.scene.getNonDeletedElements(), frame, this.state).forEach(element => elementsToHighlight.add(element));\n        });\n        this.setState({\n          elementsToHighlight: [...elementsToHighlight]\n        });\n        return true;\n      }\n      return false;\n    };\n    this.getContextMenuItems = type => {\n      const options = [];\n      options.push(actionCopyAsPng, actionCopyAsSvg);\n\n      // canvas contextMenu\n      // -------------------------------------------------------------------------\n\n      if (type === \"canvas\") {\n        if (this.state.viewModeEnabled) {\n          return [...options, actionToggleGridMode, actionToggleZenMode, actionToggleViewMode, actionToggleStats];\n        }\n        return [actionPaste, CONTEXT_MENU_SEPARATOR, actionCopyAsPng, actionCopyAsSvg, copyText, CONTEXT_MENU_SEPARATOR, actionSelectAll, actionUnlockAllElements, CONTEXT_MENU_SEPARATOR, actionToggleGridMode, actionToggleZenMode, actionToggleViewMode, actionToggleStats];\n      }\n\n      // element contextMenu\n      // -------------------------------------------------------------------------\n\n      options.push(copyText);\n      if (this.state.viewModeEnabled) {\n        return [actionCopy, ...options];\n      }\n      return [actionCut, actionCopy, actionPaste, actionSelectAllElementsInFrame, actionRemoveAllElementsFromFrame, CONTEXT_MENU_SEPARATOR, ...options, CONTEXT_MENU_SEPARATOR, actionCopyStyles, actionPasteStyles, CONTEXT_MENU_SEPARATOR, actionGroup, actionUnbindText, actionBindText, actionWrapTextInContainer, actionUngroup, CONTEXT_MENU_SEPARATOR, actionAddToLibrary, CONTEXT_MENU_SEPARATOR, actionSendBackward, actionBringForward, actionSendToBack, actionBringToFront, CONTEXT_MENU_SEPARATOR, actionFlipHorizontal, actionFlipVertical, CONTEXT_MENU_SEPARATOR, actionToggleLinearEditor, actionLink, actionDuplicateSelection, actionToggleElementLock, CONTEXT_MENU_SEPARATOR, actionDeleteSelected];\n    };\n    this.handleWheel = withBatchedUpdates(event => {\n      event.preventDefault();\n      if (isPanning) {\n        return;\n      }\n      const {\n        deltaX,\n        deltaY\n      } = event;\n      // note that event.ctrlKey is necessary to handle pinch zooming\n      if (event.metaKey || event.ctrlKey) {\n        const sign = Math.sign(deltaY);\n        const MAX_STEP = ZOOM_STEP * 100;\n        const absDelta = Math.abs(deltaY);\n        let delta = deltaY;\n        if (absDelta > MAX_STEP) {\n          delta = MAX_STEP * sign;\n        }\n        let newZoom = this.state.zoom.value - delta / 100;\n        // increase zoom steps the more zoomed-in we are (applies to >100% only)\n        newZoom += Math.log10(Math.max(1, this.state.zoom.value)) * -sign *\n        // reduced amplification for small deltas (small movements on a trackpad)\n        Math.min(1, absDelta / 20);\n        this.translateCanvas(state => ({\n          ...getStateForZoom({\n            viewportX: this.lastViewportPosition.x,\n            viewportY: this.lastViewportPosition.y,\n            nextZoom: getNormalizedZoom(newZoom)\n          }, state),\n          shouldCacheIgnoreZoom: true\n        }));\n        this.resetShouldCacheIgnoreZoomDebounced();\n        return;\n      }\n\n      // scroll horizontally when shift pressed\n      if (event.shiftKey) {\n        this.translateCanvas(_ref8 => {\n          let {\n            zoom,\n            scrollX\n          } = _ref8;\n          return {\n            // on Mac, shift+wheel tends to result in deltaX\n            scrollX: scrollX - (deltaY || deltaX) / zoom.value\n          };\n        });\n        return;\n      }\n      this.translateCanvas(_ref9 => {\n        let {\n          zoom,\n          scrollX,\n          scrollY\n        } = _ref9;\n        return {\n          scrollX: scrollX - deltaX / zoom.value,\n          scrollY: scrollY - deltaY / zoom.value\n        };\n      });\n    });\n    this.savePointer = (x, y, button) => {\n      var _this$props$onPointer2, _this$props3;\n      if (!x || !y) {\n        return;\n      }\n      const pointer = viewportCoordsToSceneCoords({\n        clientX: x,\n        clientY: y\n      }, this.state);\n      if (isNaN(pointer.x) || isNaN(pointer.y)) {\n        // sometimes the pointer goes off screen\n      }\n      (_this$props$onPointer2 = (_this$props3 = this.props).onPointerUpdate) === null || _this$props$onPointer2 === void 0 ? void 0 : _this$props$onPointer2.call(_this$props3, {\n        pointer,\n        button,\n        pointersMap: gesture.pointers\n      });\n    };\n    this.resetShouldCacheIgnoreZoomDebounced = debounce(() => {\n      if (!this.unmounted) {\n        this.setState({\n          shouldCacheIgnoreZoom: false\n        });\n      }\n    }, 300);\n    this.updateDOMRect = cb => {\n      var _this$excalidrawConta5;\n      if ((_this$excalidrawConta5 = this.excalidrawContainerRef) !== null && _this$excalidrawConta5 !== void 0 && _this$excalidrawConta5.current) {\n        const excalidrawContainer = this.excalidrawContainerRef.current;\n        const {\n          width,\n          height,\n          left: offsetLeft,\n          top: offsetTop\n        } = excalidrawContainer.getBoundingClientRect();\n        const {\n          width: currentWidth,\n          height: currentHeight,\n          offsetTop: currentOffsetTop,\n          offsetLeft: currentOffsetLeft\n        } = this.state;\n        if (width === currentWidth && height === currentHeight && offsetLeft === currentOffsetLeft && offsetTop === currentOffsetTop) {\n          if (cb) {\n            cb();\n          }\n          return;\n        }\n        this.setState({\n          width,\n          height,\n          offsetLeft,\n          offsetTop\n        }, () => {\n          cb && cb();\n        });\n      }\n    };\n    this.refresh = () => {\n      this.setState({\n        ...this.getCanvasOffsets()\n      });\n    };\n    const defaultAppState = getDefaultAppState();\n    const {\n      excalidrawRef,\n      viewModeEnabled: _viewModeEnabled = false,\n      zenModeEnabled: _zenModeEnabled = false,\n      gridModeEnabled = false,\n      theme: _theme = defaultAppState.theme,\n      name: _name = defaultAppState.name\n    } = props;\n    this.state = {\n      ...defaultAppState,\n      theme: _theme,\n      isLoading: true,\n      ...this.getCanvasOffsets(),\n      viewModeEnabled: _viewModeEnabled,\n      zenModeEnabled: _zenModeEnabled,\n      gridSize: gridModeEnabled ? GRID_SIZE : null,\n      name: _name,\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n    this.id = nanoid();\n    this.library = new Library(this);\n    if (excalidrawRef) {\n      var _excalidrawRef$curren;\n      const readyPromise = \"current\" in excalidrawRef && ((_excalidrawRef$curren = excalidrawRef.current) === null || _excalidrawRef$curren === void 0 ? void 0 : _excalidrawRef$curren.readyPromise) || resolvablePromise();\n      const api = {\n        ready: true,\n        readyPromise,\n        updateScene: this.updateScene,\n        updateLibrary: this.library.updateLibrary,\n        addFiles: this.addFiles,\n        resetScene: this.resetScene,\n        getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,\n        history: {\n          clear: this.resetHistory\n        },\n        scrollToContent: this.scrollToContent,\n        getSceneElements: this.getSceneElements,\n        getAppState: () => this.state,\n        getFiles: () => this.files,\n        refresh: this.refresh,\n        setToast: this.setToast,\n        id: this.id,\n        setActiveTool: this.setActiveTool,\n        setCursor: this.setCursor,\n        resetCursor: this.resetCursor,\n        updateFrameRendering: this.updateFrameRendering,\n        toggleSidebar: this.toggleSidebar\n      };\n      if (typeof excalidrawRef === \"function\") {\n        excalidrawRef(api);\n      } else {\n        excalidrawRef.current = api;\n      }\n      readyPromise.resolve(api);\n    }\n    this.excalidrawContainerValue = {\n      container: this.excalidrawContainerRef.current,\n      id: this.id\n    };\n    this.scene = new Scene();\n    this.fonts = new Fonts({\n      scene: this.scene,\n      onSceneUpdated: this.onSceneUpdated\n    });\n    this.history = new History();\n    this.actionManager = new ActionManager(this.syncActionResult, () => this.state, () => this.scene.getElementsIncludingDeleted(), this);\n    this.actionManager.registerAll(actions);\n    this.actionManager.registerAction(createUndoAction(this.history));\n    this.actionManager.registerAction(createRedoAction(this.history));\n  }\n  renderCanvas() {\n    const canvasScale = window.devicePixelRatio;\n    const {\n      width: canvasDOMWidth,\n      height: canvasDOMHeight,\n      viewModeEnabled\n    } = this.state;\n    const canvasWidth = canvasDOMWidth * canvasScale;\n    const canvasHeight = canvasDOMHeight * canvasScale;\n    if (viewModeEnabled) {\n      return /*#__PURE__*/_jsxDEV(\"canvas\", {\n        className: \"excalidraw__canvas\",\n        style: {\n          width: canvasDOMWidth,\n          height: canvasDOMHeight,\n          cursor: CURSOR_TYPE.GRAB\n        },\n        width: canvasWidth,\n        height: canvasHeight,\n        ref: this.handleCanvasRef,\n        onContextMenu: event => this.handleCanvasContextMenu(event),\n        onPointerMove: this.handleCanvasPointerMove,\n        onPointerUp: this.handleCanvasPointerUp,\n        onPointerCancel: this.removePointer,\n        onTouchMove: this.handleTouchMove,\n        onPointerDown: this.handleCanvasPointerDown,\n        children: t(\"labels.drawingCanvas\")\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 552,\n        columnNumber: 9\n      }, this);\n    }\n    return /*#__PURE__*/_jsxDEV(\"canvas\", {\n      className: \"excalidraw__canvas\",\n      style: {\n        width: canvasDOMWidth,\n        height: canvasDOMHeight\n      },\n      width: canvasWidth,\n      height: canvasHeight,\n      ref: this.handleCanvasRef,\n      onContextMenu: event => this.handleCanvasContextMenu(event),\n      onPointerDown: this.handleCanvasPointerDown,\n      onDoubleClick: this.handleCanvasDoubleClick,\n      onPointerMove: this.handleCanvasPointerMove,\n      onPointerUp: this.handleCanvasPointerUp,\n      onPointerCancel: this.removePointer,\n      onTouchMove: this.handleTouchMove,\n      children: t(\"labels.drawingCanvas\")\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 576,\n      columnNumber: 7\n    }, this);\n  }\n  render() {\n    var _this$props4;\n    const selectedElement = this.scene.getSelectedElements(this.state);\n    const {\n      renderTopRightUI,\n      renderCustomStats\n    } = this.props;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: clsx(\"excalidraw excalidraw-container\", {\n        \"excalidraw--view-mode\": this.state.viewModeEnabled,\n        \"excalidraw--mobile\": this.device.isMobile\n      }),\n      ref: this.excalidrawContainerRef,\n      onDrop: this.handleAppOnDrop,\n      tabIndex: 0,\n      onKeyDown: this.props.handleKeyboardGlobally ? undefined : this.onKeyDown,\n      children: /*#__PURE__*/_jsxDEV(AppContext.Provider, {\n        value: this,\n        children: /*#__PURE__*/_jsxDEV(AppPropsContext.Provider, {\n          value: this.props,\n          children: /*#__PURE__*/_jsxDEV(ExcalidrawContainerContext.Provider, {\n            value: this.excalidrawContainerValue,\n            children: /*#__PURE__*/_jsxDEV(DeviceContext.Provider, {\n              value: this.device,\n              children: /*#__PURE__*/_jsxDEV(ExcalidrawSetAppStateContext.Provider, {\n                value: this.setAppState,\n                children: /*#__PURE__*/_jsxDEV(ExcalidrawAppStateContext.Provider, {\n                  value: this.state,\n                  children: /*#__PURE__*/_jsxDEV(ExcalidrawElementsContext.Provider, {\n                    value: this.scene.getNonDeletedElements(),\n                    children: /*#__PURE__*/_jsxDEV(ExcalidrawActionManagerContext.Provider, {\n                      value: this.actionManager,\n                      children: [/*#__PURE__*/_jsxDEV(LayerUI, {\n                        canvas: this.canvas,\n                        appState: this.state,\n                        files: this.files,\n                        setAppState: this.setAppState,\n                        actionManager: this.actionManager,\n                        elements: this.scene.getNonDeletedElements(),\n                        onLockToggle: this.toggleLock,\n                        onPenModeToggle: this.togglePenMode,\n                        onHandToolToggle: this.onHandToolToggle,\n                        langCode: getLanguage().code,\n                        renderTopRightUI: renderTopRightUI,\n                        renderCustomStats: renderCustomStats,\n                        showExitZenModeBtn: typeof ((_this$props4 = this.props) === null || _this$props4 === void 0 ? void 0 : _this$props4.zenModeEnabled) === \"undefined\" && this.state.zenModeEnabled,\n                        UIOptions: this.props.UIOptions,\n                        onImageAction: this.onImageAction,\n                        onExportImage: this.onExportImage,\n                        renderWelcomeScreen: !this.state.isLoading && this.state.showWelcomeScreen && this.state.activeTool.type === \"selection\" && !this.state.zenModeEnabled && !this.scene.getElementsIncludingDeleted().length,\n                        app: this,\n                        children: this.props.children\n                      }, void 0, false, {\n                        fileName: _jsxFileName,\n                        lineNumber: 831,\n                        columnNumber: 25\n                      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n                        className: \"excalidraw-textEditorContainer\"\n                      }, void 0, false, {\n                        fileName: _jsxFileName,\n                        lineNumber: 862,\n                        columnNumber: 25\n                      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n                        className: \"excalidraw-contextMenuContainer\"\n                      }, void 0, false, {\n                        fileName: _jsxFileName,\n                        lineNumber: 863,\n                        columnNumber: 25\n                      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n                        className: \"excalidraw-eye-dropper-container\"\n                      }, void 0, false, {\n                        fileName: _jsxFileName,\n                        lineNumber: 864,\n                        columnNumber: 25\n                      }, this), selectedElement.length === 1 && !this.state.contextMenu && this.state.showHyperlinkPopup && /*#__PURE__*/_jsxDEV(Hyperlink, {\n                        element: selectedElement[0],\n                        setAppState: this.setAppState,\n                        onLinkOpen: this.props.onLinkOpen\n                      }, selectedElement[0].id, false, {\n                        fileName: _jsxFileName,\n                        lineNumber: 868,\n                        columnNumber: 29\n                      }, this), this.state.toast !== null && /*#__PURE__*/_jsxDEV(Toast, {\n                        message: this.state.toast.message,\n                        onClose: () => this.setToast(null),\n                        duration: this.state.toast.duration,\n                        closable: this.state.toast.closable\n                      }, void 0, false, {\n                        fileName: _jsxFileName,\n                        lineNumber: 876,\n                        columnNumber: 27\n                      }, this), this.state.contextMenu && /*#__PURE__*/_jsxDEV(ContextMenu, {\n                        items: this.state.contextMenu.items,\n                        top: this.state.contextMenu.top,\n                        left: this.state.contextMenu.left,\n                        actionManager: this.actionManager\n                      }, void 0, false, {\n                        fileName: _jsxFileName,\n                        lineNumber: 884,\n                        columnNumber: 27\n                      }, this), /*#__PURE__*/_jsxDEV(\"main\", {\n                        children: this.renderCanvas()\n                      }, void 0, false, {\n                        fileName: _jsxFileName,\n                        lineNumber: 891,\n                        columnNumber: 25\n                      }, this), this.renderFrameNames()]\n                    }, void 0, true, {\n                      fileName: _jsxFileName,\n                      lineNumber: 828,\n                      columnNumber: 23\n                    }, this)\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 825,\n                    columnNumber: 21\n                  }, this)\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 824,\n                  columnNumber: 19\n                }, this)\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 823,\n                columnNumber: 17\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 822,\n              columnNumber: 15\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 819,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 818,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 817,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 805,\n      columnNumber: 7\n    }, this);\n  }\n  async componentDidMount() {\n    var _this2 = this,\n      _this$excalidrawConta6;\n    this.unmounted = false;\n    this.excalidrawContainerValue.container = this.excalidrawContainerRef.current;\n    if (process.env.NODE_ENV === ENV.TEST || process.env.NODE_ENV === ENV.DEVELOPMENT) {\n      const setState = this.setState.bind(this);\n      Object.defineProperties(window.h, {\n        state: {\n          configurable: true,\n          get: () => {\n            return this.state;\n          }\n        },\n        setState: {\n          configurable: true,\n          value: function () {\n            return _this2.setState(...arguments);\n          }\n        },\n        app: {\n          configurable: true,\n          value: this\n        },\n        history: {\n          configurable: true,\n          value: this.history\n        }\n      });\n    }\n    this.scene.addCallback(this.onSceneUpdated);\n    this.addEventListeners();\n    if (this.props.autoFocus && this.excalidrawContainerRef.current) {\n      this.focusContainer();\n    }\n    if (this.excalidrawContainerRef.current &&\n    // bounding rects don't work in tests so updating\n    // the state on init would result in making the test enviro run\n    // in mobile breakpoint (0 width/height), making everything fail\n    process.env.NODE_ENV !== \"test\") {\n      this.refreshDeviceState(this.excalidrawContainerRef.current);\n    }\n    if (\"ResizeObserver\" in window && (_this$excalidrawConta6 = this.excalidrawContainerRef) !== null && _this$excalidrawConta6 !== void 0 && _this$excalidrawConta6.current) {\n      var _this$resizeObserver;\n      this.resizeObserver = new ResizeObserver(() => {\n        THROTTLE_NEXT_RENDER = false;\n        // recompute device dimensions state\n        // ---------------------------------------------------------------------\n        this.refreshDeviceState(this.excalidrawContainerRef.current);\n        // refresh offsets\n        // ---------------------------------------------------------------------\n        this.updateDOMRect();\n      });\n      (_this$resizeObserver = this.resizeObserver) === null || _this$resizeObserver === void 0 ? void 0 : _this$resizeObserver.observe(this.excalidrawContainerRef.current);\n    } else if (window.matchMedia) {\n      const mdScreenQuery = window.matchMedia(`(max-width: ${MQ_MAX_WIDTH_PORTRAIT}px), (max-height: ${MQ_MAX_HEIGHT_LANDSCAPE}px) and (max-width: ${MQ_MAX_WIDTH_LANDSCAPE}px)`);\n      const smScreenQuery = window.matchMedia(`(max-width: ${MQ_SM_MAX_WIDTH}px)`);\n      const canDeviceFitSidebarMediaQuery = window.matchMedia(`(min-width: ${\n      // NOTE this won't update if a different breakpoint is supplied\n      // after mount\n      this.props.UIOptions.dockedSidebarBreakpoint != null ? this.props.UIOptions.dockedSidebarBreakpoint : MQ_RIGHT_SIDEBAR_MIN_WIDTH}px)`);\n      const handler = () => {\n        this.excalidrawContainerRef.current.getBoundingClientRect();\n        this.device = updateObject(this.device, {\n          isSmScreen: smScreenQuery.matches,\n          isMobile: mdScreenQuery.matches,\n          canDeviceFitSidebar: canDeviceFitSidebarMediaQuery.matches\n        });\n      };\n      mdScreenQuery.addListener(handler);\n      this.detachIsMobileMqHandler = () => mdScreenQuery.removeListener(handler);\n    }\n    const searchParams = new URLSearchParams(window.location.search.slice(1));\n    if (searchParams.has(\"web-share-target\")) {\n      // Obtain a file that was shared via the Web Share Target API.\n      this.restoreFileFromShare();\n    } else {\n      this.updateDOMRect(this.initializeScene);\n    }\n\n    // note that this check seems to always pass in localhost\n    if (isBrave() && !isMeasureTextSupported()) {\n      this.setState({\n        errorMessage: /*#__PURE__*/_jsxDEV(BraveMeasureTextError, {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1339,\n          columnNumber: 23\n        }, this)\n      });\n    }\n  }\n  componentWillUnmount() {\n    var _this$resizeObserver2;\n    this.files = {};\n    this.imageCache.clear();\n    (_this$resizeObserver2 = this.resizeObserver) === null || _this$resizeObserver2 === void 0 ? void 0 : _this$resizeObserver2.disconnect();\n    this.unmounted = true;\n    this.removeEventListeners();\n    this.scene.destroy();\n    this.library.destroy();\n    clearTimeout(touchTimeout);\n    isSomeElementSelected.clearCache();\n    touchTimeout = 0;\n  }\n  removeEventListeners() {\n    var _this$excalidrawConta7, _this$nearestScrollab, _this$excalidrawConta8, _this$excalidrawConta9, _this$detachIsMobileM;\n    document.removeEventListener(EVENT.POINTER_UP, this.removePointer);\n    document.removeEventListener(EVENT.COPY, this.onCopy);\n    document.removeEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.removeEventListener(EVENT.CUT, this.onCut);\n    (_this$excalidrawConta7 = this.excalidrawContainerRef.current) === null || _this$excalidrawConta7 === void 0 ? void 0 : _this$excalidrawConta7.removeEventListener(EVENT.WHEEL, this.onWheel);\n    (_this$nearestScrollab = this.nearestScrollableContainer) === null || _this$nearestScrollab === void 0 ? void 0 : _this$nearestScrollab.removeEventListener(EVENT.SCROLL, this.onScroll);\n    document.removeEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    document.removeEventListener(EVENT.MOUSE_MOVE, this.updateCurrentCursorPosition, false);\n    document.removeEventListener(EVENT.KEYUP, this.onKeyUp);\n    window.removeEventListener(EVENT.RESIZE, this.onResize, false);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.removeEventListener(EVENT.BLUR, this.onBlur, false);\n    (_this$excalidrawConta8 = this.excalidrawContainerRef.current) === null || _this$excalidrawConta8 === void 0 ? void 0 : _this$excalidrawConta8.removeEventListener(EVENT.DRAG_OVER, this.disableEvent, false);\n    (_this$excalidrawConta9 = this.excalidrawContainerRef.current) === null || _this$excalidrawConta9 === void 0 ? void 0 : _this$excalidrawConta9.removeEventListener(EVENT.DROP, this.disableEvent, false);\n    document.removeEventListener(EVENT.GESTURE_START, this.onGestureStart, false);\n    document.removeEventListener(EVENT.GESTURE_CHANGE, this.onGestureChange, false);\n    document.removeEventListener(EVENT.GESTURE_END, this.onGestureEnd, false);\n    (_this$detachIsMobileM = this.detachIsMobileMqHandler) === null || _this$detachIsMobileM === void 0 ? void 0 : _this$detachIsMobileM.call(this);\n  }\n  addEventListeners() {\n    var _this$excalidrawConta10, _document$fonts, _document$fonts$addEv, _this$excalidrawConta11, _this$excalidrawConta12;\n    this.removeEventListeners();\n    document.addEventListener(EVENT.POINTER_UP, this.removePointer); // #3553\n    document.addEventListener(EVENT.COPY, this.onCopy);\n    (_this$excalidrawConta10 = this.excalidrawContainerRef.current) === null || _this$excalidrawConta10 === void 0 ? void 0 : _this$excalidrawConta10.addEventListener(EVENT.WHEEL, this.onWheel, {\n      passive: false\n    });\n    if (this.props.handleKeyboardGlobally) {\n      document.addEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    }\n    document.addEventListener(EVENT.KEYUP, this.onKeyUp, {\n      passive: true\n    });\n    document.addEventListener(EVENT.MOUSE_MOVE, this.updateCurrentCursorPosition);\n    // rerender text elements on font load to fix #637 && #1553\n    (_document$fonts = document.fonts) === null || _document$fonts === void 0 ? void 0 : (_document$fonts$addEv = _document$fonts.addEventListener) === null || _document$fonts$addEv === void 0 ? void 0 : _document$fonts$addEv.call(_document$fonts, \"loadingdone\", event => {\n      const loadedFontFaces = event.fontfaces;\n      this.fonts.onFontsLoaded(loadedFontFaces);\n    });\n\n    // Safari-only desktop pinch zoom\n    document.addEventListener(EVENT.GESTURE_START, this.onGestureStart, false);\n    document.addEventListener(EVENT.GESTURE_CHANGE, this.onGestureChange, false);\n    document.addEventListener(EVENT.GESTURE_END, this.onGestureEnd, false);\n    if (this.state.viewModeEnabled) {\n      return;\n    }\n    document.addEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.addEventListener(EVENT.CUT, this.onCut);\n    if (this.props.detectScroll) {\n      this.nearestScrollableContainer = getNearestScrollableContainer(this.excalidrawContainerRef.current);\n      this.nearestScrollableContainer.addEventListener(EVENT.SCROLL, this.onScroll);\n    }\n    window.addEventListener(EVENT.RESIZE, this.onResize, false);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.addEventListener(EVENT.BLUR, this.onBlur, false);\n    (_this$excalidrawConta11 = this.excalidrawContainerRef.current) === null || _this$excalidrawConta11 === void 0 ? void 0 : _this$excalidrawConta11.addEventListener(EVENT.DRAG_OVER, this.disableEvent, false);\n    (_this$excalidrawConta12 = this.excalidrawContainerRef.current) === null || _this$excalidrawConta12 === void 0 ? void 0 : _this$excalidrawConta12.addEventListener(EVENT.DROP, this.disableEvent, false);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    var _this$excalidrawConta13, _this$state$editingEl2;\n    if (!this.state.showWelcomeScreen && !this.scene.getElementsIncludingDeleted().length) {\n      this.setState({\n        showWelcomeScreen: true\n      });\n    }\n    if (this.excalidrawContainerRef.current && prevProps.UIOptions.dockedSidebarBreakpoint !== this.props.UIOptions.dockedSidebarBreakpoint) {\n      this.refreshDeviceState(this.excalidrawContainerRef.current);\n    }\n    if (prevState.scrollX !== this.state.scrollX || prevState.scrollY !== this.state.scrollY) {\n      var _this$props5, _this$props5$onScroll;\n      (_this$props5 = this.props) === null || _this$props5 === void 0 ? void 0 : (_this$props5$onScroll = _this$props5.onScrollChange) === null || _this$props5$onScroll === void 0 ? void 0 : _this$props5$onScroll.call(_this$props5, this.state.scrollX, this.state.scrollY);\n    }\n    if (Object.keys(this.state.selectedElementIds).length && isEraserActive(this.state)) {\n      this.setState({\n        activeTool: updateActiveTool(this.state, {\n          type: \"selection\"\n        })\n      });\n    }\n    if (this.state.activeTool.type === \"eraser\" && prevState.theme !== this.state.theme) {\n      setEraserCursor(this.canvas, this.state.theme);\n    }\n    // Hide hyperlink popup if shown when element type is not selection\n    if (prevState.activeTool.type === \"selection\" && this.state.activeTool.type !== \"selection\" && this.state.showHyperlinkPopup) {\n      this.setState({\n        showHyperlinkPopup: false\n      });\n    }\n    if (prevProps.langCode !== this.props.langCode) {\n      this.updateLanguage();\n    }\n    if (prevProps.viewModeEnabled !== this.props.viewModeEnabled) {\n      this.setState({\n        viewModeEnabled: !!this.props.viewModeEnabled\n      });\n    }\n    if (prevState.viewModeEnabled !== this.state.viewModeEnabled) {\n      this.addEventListeners();\n      this.deselectElements();\n    }\n    if (prevProps.zenModeEnabled !== this.props.zenModeEnabled) {\n      this.setState({\n        zenModeEnabled: !!this.props.zenModeEnabled\n      });\n    }\n    if (prevProps.theme !== this.props.theme && this.props.theme) {\n      this.setState({\n        theme: this.props.theme\n      });\n    }\n    if (prevProps.gridModeEnabled !== this.props.gridModeEnabled) {\n      this.setState({\n        gridSize: this.props.gridModeEnabled ? GRID_SIZE : null\n      });\n    }\n    if (this.props.name && prevProps.name !== this.props.name) {\n      this.setState({\n        name: this.props.name\n      });\n    }\n    (_this$excalidrawConta13 = this.excalidrawContainerRef.current) === null || _this$excalidrawConta13 === void 0 ? void 0 : _this$excalidrawConta13.classList.toggle(\"theme--dark\", this.state.theme === \"dark\");\n    if (this.state.editingLinearElement && !this.state.selectedElementIds[this.state.editingLinearElement.elementId]) {\n      // defer so that the commitToHistory flag isn't reset via current update\n      setTimeout(() => {\n        // execute only if the condition still holds when the deferred callback\n        // executes (it can be scheduled multiple times depending on how\n        // many times the component renders)\n        this.state.editingLinearElement && this.actionManager.executeAction(actionFinalize);\n      });\n    }\n\n    // failsafe in case the state is being updated in incorrect order resulting\n    // in the editingElement being now a deleted element\n    if ((_this$state$editingEl2 = this.state.editingElement) !== null && _this$state$editingEl2 !== void 0 && _this$state$editingEl2.isDeleted) {\n      this.setState({\n        editingElement: null\n      });\n    }\n    if (this.state.selectedLinearElement && !this.state.selectedElementIds[this.state.selectedLinearElement.elementId]) {\n      // To make sure `selectedLinearElement` is in sync with `selectedElementIds`, however this shouldn't be needed once\n      // we have a single API to update `selectedElementIds`\n      this.setState({\n        selectedLinearElement: null\n      });\n    }\n    const {\n      multiElement\n    } = prevState;\n    if (prevState.activeTool !== this.state.activeTool && multiElement != null && isBindingEnabled(this.state) && isBindingElement(multiElement, false)) {\n      maybeBindLinearElement(multiElement, this.state, this.scene, tupleToCoors(LinearElementEditor.getPointAtIndexGlobalCoordinates(multiElement, -1)));\n    }\n    this.renderScene();\n    this.history.record(this.state, this.scene.getElementsIncludingDeleted());\n\n    // Do not notify consumers if we're still loading the scene. Among other\n    // potential issues, this fixes a case where the tab isn't focused during\n    // init, which would trigger onChange with empty elements, which would then\n    // override whatever is in localStorage currently.\n    if (!this.state.isLoading) {\n      var _this$props$onChange, _this$props6;\n      (_this$props$onChange = (_this$props6 = this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props6, this.scene.getElementsIncludingDeleted(), this.state, this.files);\n    }\n  }\n  static resetTapTwice() {\n    didTapTwice = false;\n  }\n  addTextFromPaste(text) {\n    let isPlainPaste = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      x,\n      y\n    } = viewportCoordsToSceneCoords({\n      clientX: this.lastViewportPosition.x,\n      clientY: this.lastViewportPosition.y\n    }, this.state);\n    const textElementProps = {\n      x,\n      y,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roundness: null,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      text,\n      fontSize: this.state.currentItemFontSize,\n      fontFamily: this.state.currentItemFontFamily,\n      textAlign: this.state.currentItemTextAlign,\n      verticalAlign: DEFAULT_VERTICAL_ALIGN,\n      locked: false\n    };\n    const LINE_GAP = 10;\n    let currentY = y;\n    const lines = isPlainPaste ? [text] : text.split(\"\\n\");\n    const textElements = lines.reduce((acc, line, idx) => {\n      const text = line.trim();\n      const lineHeight = getDefaultLineHeight(textElementProps.fontFamily);\n      if (text.length) {\n        const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n          x,\n          y: currentY\n        });\n        const element = newTextElement({\n          ...textElementProps,\n          x,\n          y: currentY,\n          text,\n          lineHeight,\n          frameId: topLayerFrame ? topLayerFrame.id : null\n        });\n        acc.push(element);\n        currentY += element.height + LINE_GAP;\n      } else {\n        var _lines;\n        const prevLine = (_lines = lines[idx - 1]) === null || _lines === void 0 ? void 0 : _lines.trim();\n        // add paragraph only if previous line was not empty, IOW don't add\n        // more than one empty line\n        if (prevLine) {\n          currentY += getLineHeightInPx(textElementProps.fontSize, lineHeight) + LINE_GAP;\n        }\n      }\n      return acc;\n    }, []);\n    if (textElements.length === 0) {\n      return;\n    }\n    const frameId = textElements[0].frameId;\n    if (frameId) {\n      this.scene.insertElementsAtIndex(textElements, this.scene.getElementIndex(frameId));\n    } else {\n      this.scene.replaceAllElements([...this.scene.getElementsIncludingDeleted(), ...textElements]);\n    }\n    this.setState({\n      selectedElementIds: makeNextSelectedElementIds(Object.fromEntries(textElements.map(el => [el.id, true])), this.state)\n    });\n    if (!isPlainPaste && textElements.length > 1 && PLAIN_PASTE_TOAST_SHOWN === false && !this.device.isMobile) {\n      this.setToast({\n        message: t(\"toast.pasteAsSingleElement\", {\n          shortcut: getShortcutKey(\"CtrlOrCmd+Shift+V\")\n        }),\n        duration: 5000\n      });\n      PLAIN_PASTE_TOAST_SHOWN = true;\n    }\n    this.history.resumeRecording();\n  }\n  handleTextWysiwyg(element, _ref10) {\n    let {\n      isExistingElement = false\n    } = _ref10;\n    const updateElement = (text, originalText, isDeleted) => {\n      this.scene.replaceAllElements([...this.scene.getElementsIncludingDeleted().map(_element => {\n        if (_element.id === element.id && isTextElement(_element)) {\n          return updateTextElement(_element, {\n            text,\n            isDeleted,\n            originalText\n          });\n        }\n        return _element;\n      })]);\n    };\n    textWysiwyg({\n      id: element.id,\n      canvas: this.canvas,\n      getViewportCoords: (x, y) => {\n        const {\n          x: viewportX,\n          y: viewportY\n        } = sceneCoordsToViewportCoords({\n          sceneX: x,\n          sceneY: y\n        }, this.state);\n        return [viewportX - this.state.offsetLeft, viewportY - this.state.offsetTop];\n      },\n      onChange: withBatchedUpdates(text => {\n        updateElement(text, text, false);\n        if (isNonDeletedElement(element)) {\n          updateBoundElements(element);\n        }\n      }),\n      onSubmit: withBatchedUpdates(_ref11 => {\n        let {\n          text,\n          viaKeyboard,\n          originalText\n        } = _ref11;\n        const isDeleted = !text.trim();\n        updateElement(text, originalText, isDeleted);\n        // select the created text element only if submitting via keyboard\n        // (when submitting via click it should act as signal to deselect)\n        if (!isDeleted && viaKeyboard) {\n          const elementIdToSelect = element.containerId ? element.containerId : element.id;\n          this.setState(prevState => ({\n            selectedElementIds: makeNextSelectedElementIds({\n              ...prevState.selectedElementIds,\n              [elementIdToSelect]: true\n            }, prevState)\n          }));\n        }\n        if (isDeleted) {\n          fixBindingsAfterDeletion(this.scene.getNonDeletedElements(), [element]);\n        }\n        if (!isDeleted || isExistingElement) {\n          this.history.resumeRecording();\n        }\n        this.setState({\n          draggingElement: null,\n          editingElement: null\n        });\n        if (this.state.activeTool.locked) {\n          setCursorForShape(this.canvas, this.state);\n        }\n        this.focusContainer();\n      }),\n      element,\n      excalidrawContainer: this.excalidrawContainerRef.current,\n      app: this\n    });\n    // deselect all other elements when inserting text\n    this.deselectElements();\n\n    // do an initial update to re-initialize element position since we were\n    // modifying element's x/y for sake of editor (case: syncing to remote)\n    updateElement(element.text, element.originalText, false);\n  }\n  deselectElements() {\n    this.setState({\n      selectedElementIds: makeNextSelectedElementIds({}, this.state),\n      selectedGroupIds: {},\n      editingGroupId: null\n    });\n  }\n  getTextElementAtPosition(x, y) {\n    const element = this.getElementAtPosition(x, y, {\n      includeBoundTextElement: true\n    });\n    if (element && isTextElement(element) && !element.isDeleted) {\n      return element;\n    }\n    return null;\n  }\n  getElementAtPosition(x, y, opts) {\n    const allHitElements = this.getElementsAtPosition(x, y, opts === null || opts === void 0 ? void 0 : opts.includeBoundTextElement, opts === null || opts === void 0 ? void 0 : opts.includeLockedElements);\n    if (allHitElements.length > 1) {\n      if (opts !== null && opts !== void 0 && opts.preferSelected) {\n        for (let index = allHitElements.length - 1; index > -1; index--) {\n          if (this.state.selectedElementIds[allHitElements[index].id]) {\n            return allHitElements[index];\n          }\n        }\n      }\n      const elementWithHighestZIndex = allHitElements[allHitElements.length - 1];\n      // If we're hitting element with highest z-index only on its bounding box\n      // while also hitting other element figure, the latter should be considered.\n      return isHittingElementBoundingBoxWithoutHittingElement(elementWithHighestZIndex, this.state, this.frameNameBoundsCache, x, y) ? allHitElements[allHitElements.length - 2] : elementWithHighestZIndex;\n    }\n    if (allHitElements.length === 1) {\n      return allHitElements[0];\n    }\n    return null;\n  }\n  getElementsAtPosition(x, y) {\n    let includeBoundTextElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let includeLockedElements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const elements = includeBoundTextElement && includeLockedElements ? this.scene.getNonDeletedElements() : this.scene.getNonDeletedElements().filter(element => (includeLockedElements || !element.locked) && (includeBoundTextElement || !(isTextElement(element) && element.containerId)));\n    return getElementsAtPosition(elements, element => hitTest(element, this.state, this.frameNameBoundsCache, x, y)).filter(element => {\n      // hitting a frame's element from outside the frame is not considered a hit\n      const containingFrame = getContainingFrame(element);\n      return containingFrame && this.state.frameRendering.enabled && this.state.frameRendering.clip ? isCursorInFrame({\n        x,\n        y\n      }, containingFrame) : true;\n    });\n  }\n  handleHoverSelectedLinearElement(linearElementEditor, scenePointerX, scenePointerY) {\n    const element = LinearElementEditor.getElement(linearElementEditor.elementId);\n    const boundTextElement = getBoundTextElement(element);\n    if (!element) {\n      return;\n    }\n    if (this.state.selectedLinearElement) {\n      let hoverPointIndex = -1;\n      let segmentMidPointHoveredCoords = null;\n      if (isHittingElementNotConsideringBoundingBox(element, this.state, this.frameNameBoundsCache, [scenePointerX, scenePointerY])) {\n        hoverPointIndex = LinearElementEditor.getPointIndexUnderCursor(element, this.state.zoom, scenePointerX, scenePointerY);\n        segmentMidPointHoveredCoords = LinearElementEditor.getSegmentMidpointHitCoords(linearElementEditor, {\n          x: scenePointerX,\n          y: scenePointerY\n        }, this.state);\n        if (hoverPointIndex >= 0 || segmentMidPointHoveredCoords) {\n          setCursor(this.canvas, CURSOR_TYPE.POINTER);\n        } else {\n          setCursor(this.canvas, CURSOR_TYPE.MOVE);\n        }\n      } else if (shouldShowBoundingBox([element], this.state) && isHittingElementBoundingBoxWithoutHittingElement(element, this.state, this.frameNameBoundsCache, scenePointerX, scenePointerY)) {\n        setCursor(this.canvas, CURSOR_TYPE.MOVE);\n      } else if (boundTextElement && hitTest(boundTextElement, this.state, this.frameNameBoundsCache, scenePointerX, scenePointerY)) {\n        setCursor(this.canvas, CURSOR_TYPE.MOVE);\n      }\n      if (this.state.selectedLinearElement.hoverPointIndex !== hoverPointIndex) {\n        this.setState({\n          selectedLinearElement: {\n            ...this.state.selectedLinearElement,\n            hoverPointIndex\n          }\n        });\n      }\n      if (!LinearElementEditor.arePointsEqual(this.state.selectedLinearElement.segmentMidPointHoveredCoords, segmentMidPointHoveredCoords)) {\n        this.setState({\n          selectedLinearElement: {\n            ...this.state.selectedLinearElement,\n            segmentMidPointHoveredCoords\n          }\n        });\n      }\n    } else {\n      setCursor(this.canvas, CURSOR_TYPE.AUTO);\n    }\n  }\n  maybeCleanupAfterMissingPointerUp(event) {\n    if (lastPointerUp !== null) {\n      // Unfortunately, sometimes we don't get a pointerup after a pointerdown,\n      // this can happen when a contextual menu or alert is triggered. In order to avoid\n      // being in a weird state, we clean up on the next pointerdown\n      lastPointerUp(event);\n    }\n  }\n  updateGestureOnPointerDown(event) {\n    gesture.pointers.set(event.pointerId, {\n      x: event.clientX,\n      y: event.clientY\n    });\n    if (gesture.pointers.size === 2) {\n      gesture.lastCenter = getCenter(gesture.pointers);\n      gesture.initialScale = this.state.zoom.value;\n      gesture.initialDistance = getDistance(Array.from(gesture.pointers.values()));\n    }\n  }\n  initialPointerDownState(event) {\n    const origin = viewportCoordsToSceneCoords(event, this.state);\n    const selectedElements = this.scene.getSelectedElements(this.state);\n    const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);\n    return {\n      origin,\n      withCmdOrCtrl: event[KEYS.CTRL_OR_CMD],\n      originInGrid: tupleToCoors(getGridPoint(origin.x, origin.y, this.state.gridSize)),\n      scrollbars: isOverScrollBars(currentScrollBars, event.clientX - this.state.offsetLeft, event.clientY - this.state.offsetTop),\n      // we need to duplicate because we'll be updating this state\n      lastCoords: {\n        ...origin\n      },\n      originalElements: this.scene.getNonDeletedElements().reduce((acc, element) => {\n        acc.set(element.id, deepCopyElement(element));\n        return acc;\n      }, new Map()),\n      resize: {\n        handleType: false,\n        isResizing: false,\n        offset: {\n          x: 0,\n          y: 0\n        },\n        arrowDirection: \"origin\",\n        center: {\n          x: (maxX + minX) / 2,\n          y: (maxY + minY) / 2\n        }\n      },\n      hit: {\n        element: null,\n        allHitElements: [],\n        wasAddedToSelection: false,\n        hasBeenDuplicated: false,\n        hasHitCommonBoundingBoxOfSelectedElements: this.isHittingCommonBoundingBoxOfSelectedElements(origin, selectedElements)\n      },\n      drag: {\n        hasOccurred: false,\n        offset: null\n      },\n      eventListeners: {\n        onMove: null,\n        onUp: null,\n        onKeyUp: null,\n        onKeyDown: null\n      },\n      boxSelection: {\n        hasOccurred: false\n      },\n      elementIdsToErase: {}\n    };\n  }\n\n  // Returns whether the event is a dragging a scrollbar\n  handleDraggingScrollBar(event, pointerDownState) {\n    if (!(pointerDownState.scrollbars.isOverEither && !this.state.multiElement)) {\n      return false;\n    }\n    isDraggingScrollBar = true;\n    pointerDownState.lastCoords.x = event.clientX;\n    pointerDownState.lastCoords.y = event.clientY;\n    const onPointerMove = withBatchedUpdatesThrottled(event => {\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n      this.handlePointerMoveOverScrollbars(event, pointerDownState);\n    });\n    const onPointerUp = withBatchedUpdates(() => {\n      isDraggingScrollBar = false;\n      setCursorForShape(this.canvas, this.state);\n      lastPointerUp = null;\n      this.setState({\n        cursorButton: \"up\"\n      });\n      this.savePointer(event.clientX, event.clientY, \"up\");\n      window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.removeEventListener(EVENT.POINTER_UP, onPointerUp);\n      onPointerMove.flush();\n    });\n    lastPointerUp = onPointerUp;\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n    window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n    return true;\n  }\n  isASelectedElement(hitElement) {\n    return hitElement != null && this.state.selectedElementIds[hitElement.id];\n  }\n  isHittingCommonBoundingBoxOfSelectedElements(point, selectedElements) {\n    if (selectedElements.length < 2) {\n      return false;\n    }\n\n    // How many pixels off the shape boundary we still consider a hit\n    const threshold = 10 / this.state.zoom.value;\n    const [x1, y1, x2, y2] = getCommonBounds(selectedElements);\n    return point.x > x1 - threshold && point.x < x2 + threshold && point.y > y1 - threshold && point.y < y2 + threshold;\n  }\n  onKeyDownFromPointerDownHandler(pointerDownState) {\n    return withBatchedUpdates(event => {\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n  onKeyUpFromPointerDownHandler(pointerDownState) {\n    return withBatchedUpdates(event => {\n      // Prevents focus from escaping excalidraw tab\n      event.key === KEYS.ALT && event.preventDefault();\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n  onPointerMoveFromPointerDownHandler(pointerDownState) {\n    return withBatchedUpdatesThrottled(event => {\n      var _pointerDownState$hit2;\n      // We need to initialize dragOffsetXY only after we've updated\n      // `state.selectedElementIds` on pointerDown. Doing it here in pointerMove\n      // event handler should hopefully ensure we're already working with\n      // the updated state.\n      if (pointerDownState.drag.offset === null) {\n        pointerDownState.drag.offset = tupleToCoors(getDragOffsetXY(this.scene.getSelectedElements(this.state), pointerDownState.origin.x, pointerDownState.origin.y));\n      }\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n      if (this.handlePointerMoveOverScrollbars(event, pointerDownState)) {\n        return;\n      }\n      const pointerCoords = viewportCoordsToSceneCoords(event, this.state);\n      if (isEraserActive(this.state)) {\n        this.handleEraser(event, pointerDownState, pointerCoords);\n        return;\n      }\n      const [gridX, gridY] = getGridPoint(pointerCoords.x, pointerCoords.y, this.state.gridSize);\n\n      // for arrows/lines, don't start dragging until a given threshold\n      // to ensure we don't create a 2-point arrow by mistake when\n      // user clicks mouse in a way that it moves a tiny bit (thus\n      // triggering pointermove)\n      if (!pointerDownState.drag.hasOccurred && (this.state.activeTool.type === \"arrow\" || this.state.activeTool.type === \"line\")) {\n        if (distance2d(pointerCoords.x, pointerCoords.y, pointerDownState.origin.x, pointerDownState.origin.y) < DRAGGING_THRESHOLD) {\n          return;\n        }\n      }\n      if (pointerDownState.resize.isResizing) {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        if (this.maybeHandleResize(pointerDownState, event)) {\n          return true;\n        }\n      }\n      if (this.state.selectedLinearElement) {\n        const linearElementEditor = this.state.editingLinearElement || this.state.selectedLinearElement;\n        if (LinearElementEditor.shouldAddMidpoint(this.state.selectedLinearElement, pointerCoords, this.state)) {\n          const ret = LinearElementEditor.addMidpoint(this.state.selectedLinearElement, pointerCoords, this.state);\n          if (!ret) {\n            return;\n          }\n\n          // Since we are reading from previous state which is not possible with\n          // automatic batching in React 18 hence using flush sync to synchronously\n          // update the state. Check https://github.com/excalidraw/excalidraw/pull/5508 for more details.\n\n          flushSync(() => {\n            if (this.state.selectedLinearElement) {\n              this.setState({\n                selectedLinearElement: {\n                  ...this.state.selectedLinearElement,\n                  pointerDownState: ret.pointerDownState,\n                  selectedPointsIndices: ret.selectedPointsIndices\n                }\n              });\n            }\n            if (this.state.editingLinearElement) {\n              this.setState({\n                editingLinearElement: {\n                  ...this.state.editingLinearElement,\n                  pointerDownState: ret.pointerDownState,\n                  selectedPointsIndices: ret.selectedPointsIndices\n                }\n              });\n            }\n          });\n          return;\n        } else if (linearElementEditor.pointerDownState.segmentMidpoint.value !== null && !linearElementEditor.pointerDownState.segmentMidpoint.added) {\n          return;\n        }\n        const didDrag = LinearElementEditor.handlePointDragging(event, this.state, pointerCoords.x, pointerCoords.y, (element, pointsSceneCoords) => {\n          this.maybeSuggestBindingsForLinearElementAtCoords(element, pointsSceneCoords);\n        }, linearElementEditor);\n        if (didDrag) {\n          pointerDownState.lastCoords.x = pointerCoords.x;\n          pointerDownState.lastCoords.y = pointerCoords.y;\n          pointerDownState.drag.hasOccurred = true;\n          if (this.state.editingLinearElement && !this.state.editingLinearElement.isDragging) {\n            this.setState({\n              editingLinearElement: {\n                ...this.state.editingLinearElement,\n                isDragging: true\n              }\n            });\n          }\n          if (!this.state.selectedLinearElement.isDragging) {\n            this.setState({\n              selectedLinearElement: {\n                ...this.state.selectedLinearElement,\n                isDragging: true\n              }\n            });\n          }\n          return;\n        }\n      }\n      const hasHitASelectedElement = pointerDownState.hit.allHitElements.some(element => this.isASelectedElement(element));\n      const isSelectingPointsInLineEditor = this.state.editingLinearElement && event.shiftKey && this.state.editingLinearElement.elementId === ((_pointerDownState$hit2 = pointerDownState.hit.element) === null || _pointerDownState$hit2 === void 0 ? void 0 : _pointerDownState$hit2.id);\n      if ((hasHitASelectedElement || pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) && !isSelectingPointsInLineEditor) {\n        const selectedElements = this.scene.getSelectedElements(this.state);\n        if (selectedElements.every(element => element.locked)) {\n          return;\n        }\n        const selectedElementsHasAFrame = selectedElements.find(e => isFrameElement(e));\n        const topLayerFrame = this.getTopLayerFrameAtSceneCoords(pointerCoords);\n        this.setState({\n          frameToHighlight: topLayerFrame && !selectedElementsHasAFrame ? topLayerFrame : null\n        });\n\n        // Marking that click was used for dragging to check\n        // if elements should be deselected on pointerup\n        pointerDownState.drag.hasOccurred = true;\n        this.setState({\n          selectedElementsAreBeingDragged: true\n        });\n        // prevent dragging even if we're no longer holding cmd/ctrl otherwise\n        // it would have weird results (stuff jumping all over the screen)\n        // Checking for editingElement to avoid jump while editing on mobile #6503\n        if (selectedElements.length > 0 && !pointerDownState.withCmdOrCtrl && !this.state.editingElement) {\n          const [dragX, dragY] = getGridPoint(pointerCoords.x - pointerDownState.drag.offset.x, pointerCoords.y - pointerDownState.drag.offset.y, this.state.gridSize);\n          const [dragDistanceX, dragDistanceY] = [Math.abs(pointerCoords.x - pointerDownState.origin.x), Math.abs(pointerCoords.y - pointerDownState.origin.y)];\n\n          // We only drag in one direction if shift is pressed\n          const lockDirection = event.shiftKey;\n          // when we're editing the name of a frame, we want the user to be\n          // able to select and interact with the text input\n          !this.state.editingFrame && dragSelectedElements(pointerDownState, selectedElements, dragX, dragY, lockDirection, dragDistanceX, dragDistanceY, this.state, this.scene);\n          this.maybeSuggestBindingForAll(selectedElements);\n\n          // We duplicate the selected element if alt is pressed on pointer move\n          if (event.altKey && !pointerDownState.hit.hasBeenDuplicated) {\n            // Move the currently selected elements to the top of the z index stack, and\n            // put the duplicates where the selected elements used to be.\n            // (the origin point where the dragging started)\n\n            pointerDownState.hit.hasBeenDuplicated = true;\n            const nextElements = [];\n            const elementsToAppend = [];\n            const groupIdMap = new Map();\n            const oldIdToDuplicatedId = new Map();\n            const hitElement = pointerDownState.hit.element;\n            const selectedElementIds = new Set(this.scene.getSelectedElements({\n              selectedElementIds: this.state.selectedElementIds,\n              includeBoundTextElement: true,\n              includeElementsInFrames: true\n            }).map(element => element.id));\n            const elements = this.scene.getNonDeletedElements();\n            for (const element of elements) {\n              if (selectedElementIds.has(element.id) ||\n              // case: the state.selectedElementIds might not have been\n              // updated yet by the time this mousemove event is fired\n              element.id === (hitElement === null || hitElement === void 0 ? void 0 : hitElement.id) && pointerDownState.hit.wasAddedToSelection) {\n                const duplicatedElement = duplicateElement(this.state.editingGroupId, groupIdMap, element);\n                const [originDragX, originDragY] = getGridPoint(pointerDownState.origin.x - pointerDownState.drag.offset.x, pointerDownState.origin.y - pointerDownState.drag.offset.y, this.state.gridSize);\n                mutateElement(duplicatedElement, {\n                  x: duplicatedElement.x + (originDragX - dragX),\n                  y: duplicatedElement.y + (originDragY - dragY)\n                });\n                nextElements.push(duplicatedElement);\n                elementsToAppend.push(element);\n                oldIdToDuplicatedId.set(element.id, duplicatedElement.id);\n              } else {\n                nextElements.push(element);\n              }\n            }\n            const nextSceneElements = [...nextElements, ...elementsToAppend];\n            bindTextToShapeAfterDuplication(nextElements, elementsToAppend, oldIdToDuplicatedId);\n            fixBindingsAfterDuplication(nextSceneElements, elementsToAppend, oldIdToDuplicatedId, \"duplicatesServeAsOld\");\n            bindElementsToFramesAfterDuplication(nextSceneElements, elementsToAppend, oldIdToDuplicatedId);\n            this.scene.replaceAllElements(nextSceneElements);\n          }\n          return;\n        }\n      }\n\n      // It is very important to read this.state within each move event,\n      // otherwise we would read a stale one!\n      const draggingElement = this.state.draggingElement;\n      if (!draggingElement) {\n        return;\n      }\n      if (draggingElement.type === \"freedraw\") {\n        const points = draggingElement.points;\n        const dx = pointerCoords.x - draggingElement.x;\n        const dy = pointerCoords.y - draggingElement.y;\n        const lastPoint = points.length > 0 && points[points.length - 1];\n        const discardPoint = lastPoint && lastPoint[0] === dx && lastPoint[1] === dy;\n        if (!discardPoint) {\n          const pressures = draggingElement.simulatePressure ? draggingElement.pressures : [...draggingElement.pressures, event.pressure];\n          mutateElement(draggingElement, {\n            points: [...points, [dx, dy]],\n            pressures\n          });\n        }\n      } else if (isLinearElement(draggingElement)) {\n        pointerDownState.drag.hasOccurred = true;\n        this.setState({\n          selectedElementsAreBeingDragged: true\n        });\n        const points = draggingElement.points;\n        let dx = gridX - draggingElement.x;\n        let dy = gridY - draggingElement.y;\n        if (shouldRotateWithDiscreteAngle(event) && points.length === 2) {\n          ({\n            width: dx,\n            height: dy\n          } = getLockedLinearCursorAlignSize(draggingElement.x, draggingElement.y, pointerCoords.x, pointerCoords.y));\n        }\n        if (points.length === 1) {\n          mutateElement(draggingElement, {\n            points: [...points, [dx, dy]]\n          });\n        } else if (points.length === 2) {\n          mutateElement(draggingElement, {\n            points: [...points.slice(0, -1), [dx, dy]]\n          });\n        }\n        if (isBindingElement(draggingElement, false)) {\n          // When creating a linear element by dragging\n          this.maybeSuggestBindingsForLinearElementAtCoords(draggingElement, [pointerCoords], this.state.startBoundElement);\n        }\n      } else {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        this.maybeDragNewGenericElement(pointerDownState, event);\n      }\n      if (this.state.activeTool.type === \"selection\") {\n        pointerDownState.boxSelection.hasOccurred = true;\n        const elements = this.scene.getNonDeletedElements();\n        if (!event.shiftKey &&\n        // allows for box-selecting points (without shift)\n        !this.state.editingLinearElement && isSomeElementSelected(elements, this.state)) {\n          if (pointerDownState.withCmdOrCtrl && pointerDownState.hit.element) {\n            this.setState(prevState => selectGroupsForSelectedElements({\n              ...prevState,\n              selectedElementIds: {\n                [pointerDownState.hit.element.id]: true\n              }\n            }, this.scene.getNonDeletedElements(), prevState, this));\n          }\n        }\n        // box-select line editor points\n        if (this.state.editingLinearElement) {\n          LinearElementEditor.handleBoxSelection(event, this.state, this.setState.bind(this));\n          // regular box-select\n        } else {\n          const elementsWithinSelection = getElementsWithinSelection(elements, draggingElement);\n          this.setState(prevState => {\n            const nextSelectedElementIds = elementsWithinSelection.reduce((acc, element) => {\n              acc[element.id] = true;\n              return acc;\n            }, {});\n            if (pointerDownState.hit.element) {\n              // if using ctrl/cmd, select the hitElement only if we\n              // haven't box-selected anything else\n              if (!elementsWithinSelection.length) {\n                nextSelectedElementIds[pointerDownState.hit.element.id] = true;\n              } else {\n                delete nextSelectedElementIds[pointerDownState.hit.element.id];\n              }\n            }\n            return selectGroupsForSelectedElements({\n              ...prevState,\n              selectedElementIds: nextSelectedElementIds,\n              showHyperlinkPopup: elementsWithinSelection.length === 1 && elementsWithinSelection[0].link ? \"info\" : false,\n              // select linear element only when we haven't box-selected anything else\n              selectedLinearElement: elementsWithinSelection.length === 1 && isLinearElement(elementsWithinSelection[0]) ? new LinearElementEditor(elementsWithinSelection[0], this.scene) : null\n            }, this.scene.getNonDeletedElements(), prevState, this);\n          });\n        }\n      }\n    });\n  }\n\n  // Returns whether the pointer move happened over either scrollbar\n  handlePointerMoveOverScrollbars(event, pointerDownState) {\n    if (pointerDownState.scrollbars.isOverHorizontal) {\n      const x = event.clientX;\n      const dx = x - pointerDownState.lastCoords.x;\n      this.translateCanvas({\n        scrollX: this.state.scrollX - dx / this.state.zoom.value\n      });\n      pointerDownState.lastCoords.x = x;\n      return true;\n    }\n    if (pointerDownState.scrollbars.isOverVertical) {\n      const y = event.clientY;\n      const dy = y - pointerDownState.lastCoords.y;\n      this.translateCanvas({\n        scrollY: this.state.scrollY - dy / this.state.zoom.value\n      });\n      pointerDownState.lastCoords.y = y;\n      return true;\n    }\n    return false;\n  }\n  onPointerUpFromPointerDownHandler(pointerDownState) {\n    return withBatchedUpdates(childEvent => {\n      var _this$state$selectedL;\n      if (pointerDownState.eventListeners.onMove) {\n        pointerDownState.eventListeners.onMove.flush();\n      }\n      const {\n        draggingElement,\n        resizingElement,\n        multiElement,\n        activeTool,\n        isResizing,\n        isRotating\n      } = this.state;\n      this.setState({\n        isResizing: false,\n        isRotating: false,\n        resizingElement: null,\n        selectionElement: null,\n        frameToHighlight: null,\n        elementsToHighlight: null,\n        cursorButton: \"up\",\n        // text elements are reset on finalize, and resetting on pointerup\n        // may cause issues with double taps\n        editingElement: multiElement || isTextElement(this.state.editingElement) ? this.state.editingElement : null\n      });\n      this.savePointer(childEvent.clientX, childEvent.clientY, \"up\");\n      this.setState({\n        selectedElementsAreBeingDragged: false\n      });\n\n      // Handle end of dragging a point of a linear element, might close a loop\n      // and sets binding element\n      if (this.state.editingLinearElement) {\n        var _pointerDownState$hit3, _pointerDownState$hit4;\n        if (!pointerDownState.boxSelection.hasOccurred && ((_pointerDownState$hit3 = pointerDownState.hit) === null || _pointerDownState$hit3 === void 0 ? void 0 : (_pointerDownState$hit4 = _pointerDownState$hit3.element) === null || _pointerDownState$hit4 === void 0 ? void 0 : _pointerDownState$hit4.id) !== this.state.editingLinearElement.elementId) {\n          this.actionManager.executeAction(actionFinalize);\n        } else {\n          const editingLinearElement = LinearElementEditor.handlePointerUp(childEvent, this.state.editingLinearElement, this.state);\n          if (editingLinearElement !== this.state.editingLinearElement) {\n            this.setState({\n              editingLinearElement,\n              suggestedBindings: []\n            });\n          }\n        }\n      } else if (this.state.selectedLinearElement) {\n        var _pointerDownState$hit5, _pointerDownState$hit6;\n        if (((_pointerDownState$hit5 = pointerDownState.hit) === null || _pointerDownState$hit5 === void 0 ? void 0 : (_pointerDownState$hit6 = _pointerDownState$hit5.element) === null || _pointerDownState$hit6 === void 0 ? void 0 : _pointerDownState$hit6.id) !== this.state.selectedLinearElement.elementId) {\n          const selectedELements = this.scene.getSelectedElements(this.state);\n          // set selectedLinearElement to null if there is more than one element selected since we don't want to show linear element handles\n          if (selectedELements.length > 1) {\n            this.setState({\n              selectedLinearElement: null\n            });\n          }\n        } else {\n          const linearElementEditor = LinearElementEditor.handlePointerUp(childEvent, this.state.selectedLinearElement, this.state);\n          const {\n            startBindingElement,\n            endBindingElement\n          } = linearElementEditor;\n          const element = this.scene.getElement(linearElementEditor.elementId);\n          if (isBindingElement(element)) {\n            bindOrUnbindLinearElement(element, startBindingElement, endBindingElement);\n          }\n          if (linearElementEditor !== this.state.selectedLinearElement) {\n            this.setState({\n              selectedLinearElement: {\n                ...linearElementEditor,\n                selectedPointsIndices: null\n              },\n              suggestedBindings: []\n            });\n          }\n        }\n      }\n      lastPointerUp = null;\n      window.removeEventListener(EVENT.POINTER_MOVE, pointerDownState.eventListeners.onMove);\n      window.removeEventListener(EVENT.POINTER_UP, pointerDownState.eventListeners.onUp);\n      window.removeEventListener(EVENT.KEYDOWN, pointerDownState.eventListeners.onKeyDown);\n      window.removeEventListener(EVENT.KEYUP, pointerDownState.eventListeners.onKeyUp);\n      if (this.state.pendingImageElementId) {\n        this.setState({\n          pendingImageElementId: null\n        });\n      }\n      if ((draggingElement === null || draggingElement === void 0 ? void 0 : draggingElement.type) === \"freedraw\") {\n        const pointerCoords = viewportCoordsToSceneCoords(childEvent, this.state);\n        const points = draggingElement.points;\n        let dx = pointerCoords.x - draggingElement.x;\n        let dy = pointerCoords.y - draggingElement.y;\n\n        // Allows dots to avoid being flagged as infinitely small\n        if (dx === points[0][0] && dy === points[0][1]) {\n          dy += 0.0001;\n          dx += 0.0001;\n        }\n        const pressures = draggingElement.simulatePressure ? [] : [...draggingElement.pressures, childEvent.pressure];\n        mutateElement(draggingElement, {\n          points: [...points, [dx, dy]],\n          pressures,\n          lastCommittedPoint: [dx, dy]\n        });\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n      if (isImageElement(draggingElement)) {\n        const imageElement = draggingElement;\n        try {\n          this.initializeImageDimensions(imageElement);\n          this.setState({\n            selectedElementIds: makeNextSelectedElementIds({\n              [imageElement.id]: true\n            }, this.state)\n          }, () => {\n            this.actionManager.executeAction(actionFinalize);\n          });\n        } catch (error) {\n          console.error(error);\n          this.scene.replaceAllElements(this.scene.getElementsIncludingDeleted().filter(el => el.id !== imageElement.id));\n          this.actionManager.executeAction(actionFinalize);\n        }\n        return;\n      }\n      if (isLinearElement(draggingElement)) {\n        if (draggingElement.points.length > 1) {\n          this.history.resumeRecording();\n        }\n        const pointerCoords = viewportCoordsToSceneCoords(childEvent, this.state);\n        if (!pointerDownState.drag.hasOccurred && draggingElement && !multiElement) {\n          mutateElement(draggingElement, {\n            points: [...draggingElement.points, [pointerCoords.x - draggingElement.x, pointerCoords.y - draggingElement.y]]\n          });\n          this.setState({\n            multiElement: draggingElement,\n            editingElement: this.state.draggingElement\n          });\n        } else if (pointerDownState.drag.hasOccurred && !multiElement) {\n          if (isBindingEnabled(this.state) && isBindingElement(draggingElement, false)) {\n            maybeBindLinearElement(draggingElement, this.state, this.scene, pointerCoords);\n          }\n          this.setState({\n            suggestedBindings: [],\n            startBoundElement: null\n          });\n          if (!activeTool.locked) {\n            resetCursor(this.canvas);\n            this.setState(prevState => ({\n              draggingElement: null,\n              activeTool: updateActiveTool(this.state, {\n                type: \"selection\"\n              }),\n              selectedElementIds: makeNextSelectedElementIds({\n                ...prevState.selectedElementIds,\n                [draggingElement.id]: true\n              }, prevState),\n              selectedLinearElement: new LinearElementEditor(draggingElement, this.scene)\n            }));\n          } else {\n            this.setState(prevState => ({\n              draggingElement: null\n            }));\n          }\n        }\n        return;\n      }\n      if (activeTool.type !== \"selection\" && draggingElement && isInvisiblySmallElement(draggingElement)) {\n        // remove invisible element which was added in onPointerDown\n        this.scene.replaceAllElements(this.scene.getElementsIncludingDeleted().slice(0, -1));\n        this.setState({\n          draggingElement: null\n        });\n        return;\n      }\n      if (draggingElement) {\n        if (pointerDownState.drag.hasOccurred) {\n          const sceneCoords = viewportCoordsToSceneCoords(childEvent, this.state);\n\n          // when editing the points of a linear element, we check if the\n          // linear element still is in the frame afterwards\n          // if not, the linear element will be removed from its frame (if any)\n          if (this.state.selectedLinearElement && this.state.selectedLinearElement.isDragging) {\n            const linearElement = this.scene.getElement(this.state.selectedLinearElement.elementId);\n            if (linearElement !== null && linearElement !== void 0 && linearElement.frameId) {\n              const frame = getContainingFrame(linearElement);\n              if (frame && linearElement) {\n                if (!elementOverlapsWithFrame(linearElement, frame)) {\n                  // remove the linear element from all groups\n                  // before removing it from the frame as well\n                  mutateElement(linearElement, {\n                    groupIds: []\n                  });\n                  this.scene.replaceAllElements(removeElementsFromFrame(this.scene.getElementsIncludingDeleted(), [linearElement], this.state));\n                }\n              }\n            }\n          } else {\n            // update the relationships between selected elements and frames\n            const topLayerFrame = this.getTopLayerFrameAtSceneCoords(sceneCoords);\n            const selectedElements = this.scene.getSelectedElements(this.state);\n            let nextElements = this.scene.getElementsIncludingDeleted();\n            const updateGroupIdsAfterEditingGroup = elements => {\n              if (elements.length > 0) {\n                for (const element of elements) {\n                  const index = element.groupIds.indexOf(this.state.editingGroupId);\n                  mutateElement(element, {\n                    groupIds: element.groupIds.slice(0, index)\n                  }, false);\n                }\n                nextElements.forEach(element => {\n                  if (element.groupIds.length && getElementsInGroup(nextElements, element.groupIds[element.groupIds.length - 1]).length < 2) {\n                    mutateElement(element, {\n                      groupIds: []\n                    }, false);\n                  }\n                });\n                this.setState({\n                  editingGroupId: null\n                });\n              }\n            };\n            if (topLayerFrame && !this.state.selectedElementIds[topLayerFrame.id]) {\n              const elementsToAdd = selectedElements.filter(element => element.frameId !== topLayerFrame.id && isElementInFrame(element, nextElements, this.state));\n              if (this.state.editingGroupId) {\n                updateGroupIdsAfterEditingGroup(elementsToAdd);\n              }\n              nextElements = addElementsToFrame(nextElements, elementsToAdd, topLayerFrame);\n            } else if (!topLayerFrame) {\n              if (this.state.editingGroupId) {\n                const elementsToRemove = selectedElements.filter(element => element.frameId && !isElementInFrame(element, nextElements, this.state));\n                updateGroupIdsAfterEditingGroup(elementsToRemove);\n              }\n            }\n            nextElements = updateFrameMembershipOfSelectedElements(this.scene.getElementsIncludingDeleted(), this.state, this);\n            this.scene.replaceAllElements(nextElements);\n          }\n        }\n        if (draggingElement.type === \"frame\") {\n          const elementsInsideFrame = getElementsInNewFrame(this.scene.getElementsIncludingDeleted(), draggingElement);\n          this.scene.replaceAllElements(addElementsToFrame(this.scene.getElementsIncludingDeleted(), elementsInsideFrame, draggingElement));\n        }\n        mutateElement(draggingElement, getNormalizedDimensions(draggingElement));\n      }\n      if (resizingElement) {\n        this.history.resumeRecording();\n      }\n      if (resizingElement && isInvisiblySmallElement(resizingElement)) {\n        this.scene.replaceAllElements(this.scene.getElementsIncludingDeleted().filter(el => el.id !== resizingElement.id));\n      }\n\n      // handle frame membership for resizing frames and/or selected elements\n      if (pointerDownState.resize.isResizing) {\n        let nextElements = updateFrameMembershipOfSelectedElements(this.scene.getElementsIncludingDeleted(), this.state, this);\n        const selectedFrames = this.scene.getSelectedElements(this.state).filter(element => element.type === \"frame\");\n        for (const frame of selectedFrames) {\n          nextElements = replaceAllElementsInFrame(nextElements, getElementsInResizingFrame(this.scene.getElementsIncludingDeleted(), frame, this.state), frame, this.state);\n        }\n        this.scene.replaceAllElements(nextElements);\n      }\n\n      // Code below handles selection when element(s) weren't\n      // drag or added to selection on pointer down phase.\n      const hitElement = pointerDownState.hit.element;\n      if (((_this$state$selectedL = this.state.selectedLinearElement) === null || _this$state$selectedL === void 0 ? void 0 : _this$state$selectedL.elementId) !== (hitElement === null || hitElement === void 0 ? void 0 : hitElement.id) && isLinearElement(hitElement)) {\n        const selectedELements = this.scene.getSelectedElements(this.state);\n        // set selectedLinearElement when no other element selected except\n        // the one we've hit\n        if (selectedELements.length === 1) {\n          this.setState({\n            selectedLinearElement: new LinearElementEditor(hitElement, this.scene)\n          });\n        }\n      }\n      if (isEraserActive(this.state)) {\n        const draggedDistance = distance2d(this.lastPointerDown.clientX, this.lastPointerDown.clientY, this.lastPointerUp.clientX, this.lastPointerUp.clientY);\n        if (draggedDistance === 0) {\n          const scenePointer = viewportCoordsToSceneCoords({\n            clientX: this.lastPointerUp.clientX,\n            clientY: this.lastPointerUp.clientY\n          }, this.state);\n          const hitElements = this.getElementsAtPosition(scenePointer.x, scenePointer.y);\n          hitElements.forEach(hitElement => pointerDownState.elementIdsToErase[hitElement.id] = {\n            erase: true,\n            opacity: hitElement.opacity\n          });\n        }\n        this.eraseElements(pointerDownState);\n        return;\n      } else if (Object.keys(pointerDownState.elementIdsToErase).length) {\n        this.restoreReadyToEraseElements(pointerDownState);\n      }\n      if (hitElement && !pointerDownState.drag.hasOccurred && !pointerDownState.hit.wasAddedToSelection && (\n      // if we're editing a line, pointerup shouldn't switch selection if\n      // box selected\n      !this.state.editingLinearElement || !pointerDownState.boxSelection.hasOccurred)) {\n        // when inside line editor, shift selects points instead\n        if (childEvent.shiftKey && !this.state.editingLinearElement) {\n          if (this.state.selectedElementIds[hitElement.id]) {\n            var _this$state$selectedL2;\n            if (isSelectedViaGroup(this.state, hitElement)) {\n              this.setState(_prevState => {\n                const nextSelectedElementIds = {\n                  ..._prevState.selectedElementIds\n                };\n\n                // We want to unselect all groups hitElement is part of\n                // as well as all elements that are part of the groups\n                // hitElement is part of\n                for (const groupedElement of hitElement.groupIds.flatMap(groupId => getElementsInGroup(this.scene.getNonDeletedElements(), groupId))) {\n                  delete nextSelectedElementIds[groupedElement.id];\n                }\n                return {\n                  selectedGroupIds: {\n                    ..._prevState.selectedElementIds,\n                    ...hitElement.groupIds.map(gId => ({\n                      [gId]: false\n                    })).reduce((prev, acc) => ({\n                      ...prev,\n                      ...acc\n                    }), {})\n                  },\n                  selectedElementIds: makeNextSelectedElementIds(nextSelectedElementIds, _prevState)\n                };\n              });\n              // if not gragging a linear element point (outside editor)\n            } else if (!((_this$state$selectedL2 = this.state.selectedLinearElement) !== null && _this$state$selectedL2 !== void 0 && _this$state$selectedL2.isDragging)) {\n              // remove element from selection while\n              // keeping prev elements selected\n\n              this.setState(prevState => {\n                const newSelectedElementIds = {\n                  ...prevState.selectedElementIds\n                };\n                delete newSelectedElementIds[hitElement.id];\n                const newSelectedElements = getSelectedElements(this.scene.getNonDeletedElements(), {\n                  selectedElementIds: newSelectedElementIds\n                });\n                return selectGroupsForSelectedElements({\n                  ...prevState,\n                  selectedElementIds: newSelectedElementIds,\n                  // set selectedLinearElement only if thats the only element selected\n                  selectedLinearElement: newSelectedElements.length === 1 && isLinearElement(newSelectedElements[0]) ? new LinearElementEditor(newSelectedElements[0], this.scene) : prevState.selectedLinearElement\n                }, this.scene.getNonDeletedElements(), prevState, this);\n              });\n            }\n          } else if (hitElement.frameId && this.state.selectedElementIds[hitElement.frameId]) {\n            // when hitElement is part of a selected frame, deselect the frame\n            // to avoid frame and containing elements selected simultaneously\n            this.setState(prevState => {\n              var _this$scene$getElemen, _this$scene$getElemen2;\n              const nextSelectedElementIds = {\n                ...prevState.selectedElementIds,\n                [hitElement.id]: true\n              };\n              // deselect the frame\n              delete nextSelectedElementIds[hitElement.frameId];\n\n              // deselect groups containing the frame\n              ((_this$scene$getElemen = (_this$scene$getElemen2 = this.scene.getElement(hitElement.frameId)) === null || _this$scene$getElemen2 === void 0 ? void 0 : _this$scene$getElemen2.groupIds) !== null && _this$scene$getElemen !== void 0 ? _this$scene$getElemen : []).flatMap(gid => getElementsInGroup(this.scene.getNonDeletedElements(), gid)).forEach(element => {\n                delete nextSelectedElementIds[element.id];\n              });\n              return selectGroupsForSelectedElements({\n                ...prevState,\n                selectedElementIds: nextSelectedElementIds,\n                showHyperlinkPopup: hitElement.link ? \"info\" : false\n              }, this.scene.getNonDeletedElements(), prevState, this);\n            });\n          } else {\n            // add element to selection while keeping prev elements selected\n            this.setState(_prevState => ({\n              selectedElementIds: makeNextSelectedElementIds({\n                ..._prevState.selectedElementIds,\n                [hitElement.id]: true\n              }, _prevState)\n            }));\n          }\n        } else {\n          this.setState(prevState => {\n            var _prevState$selectedLi;\n            return {\n              ...selectGroupsForSelectedElements({\n                ...prevState,\n                selectedElementIds: {\n                  [hitElement.id]: true\n                },\n                selectedLinearElement: isLinearElement(hitElement) &&\n                // Don't set `selectedLinearElement` if its same as the hitElement, this is mainly to prevent resetting the `hoverPointIndex` to -1.\n                // Future we should update the API to take care of setting the correct `hoverPointIndex` when initialized\n                ((_prevState$selectedLi = prevState.selectedLinearElement) === null || _prevState$selectedLi === void 0 ? void 0 : _prevState$selectedLi.elementId) !== hitElement.id ? new LinearElementEditor(hitElement, this.scene) : prevState.selectedLinearElement\n              }, this.scene.getNonDeletedElements(), prevState, this)\n            };\n          });\n        }\n      }\n      if (!pointerDownState.drag.hasOccurred && !this.state.isResizing && (hitElement && isHittingElementBoundingBoxWithoutHittingElement(hitElement, this.state, this.frameNameBoundsCache, pointerDownState.origin.x, pointerDownState.origin.y) || !hitElement && pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements)) {\n        if (this.state.editingLinearElement) {\n          this.setState({\n            editingLinearElement: null\n          });\n        } else {\n          // Deselect selected elements\n          this.setState({\n            selectedElementIds: makeNextSelectedElementIds({}, this.state),\n            selectedGroupIds: {},\n            editingGroupId: null\n          });\n        }\n        return;\n      }\n      if (!activeTool.locked && activeTool.type !== \"freedraw\" && draggingElement && draggingElement.type !== \"selection\") {\n        this.setState(prevState => ({\n          selectedElementIds: makeNextSelectedElementIds({\n            ...prevState.selectedElementIds,\n            [draggingElement.id]: true\n          }, prevState)\n        }));\n      }\n      if (activeTool.type !== \"selection\" || isSomeElementSelected(this.scene.getNonDeletedElements(), this.state)) {\n        this.history.resumeRecording();\n      }\n      if (pointerDownState.drag.hasOccurred || isResizing || isRotating) {\n        (isBindingEnabled(this.state) ? bindOrUnbindSelectedElements : unbindLinearElements)(this.scene.getSelectedElements(this.state));\n      }\n      if (!activeTool.locked && activeTool.type !== \"freedraw\") {\n        resetCursor(this.canvas);\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: [],\n          activeTool: updateActiveTool(this.state, {\n            type: \"selection\"\n          })\n        });\n      } else {\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: []\n        });\n      }\n    });\n  }\n  maybeSuggestBindingForAll(selectedElements) {\n    const suggestedBindings = getEligibleElementsForBinding(selectedElements);\n    this.setState({\n      suggestedBindings\n    });\n  }\n  clearSelection(hitElement) {\n    this.setState(prevState => ({\n      selectedElementIds: makeNextSelectedElementIds({}, prevState),\n      selectedGroupIds: {},\n      // Continue editing the same group if the user selected a different\n      // element from it\n      editingGroupId: prevState.editingGroupId && hitElement != null && isElementInGroup(hitElement, prevState.editingGroupId) ? prevState.editingGroupId : null\n    }));\n    this.setState({\n      selectedElementIds: makeNextSelectedElementIds({}, this.state),\n      previousSelectedElementIds: this.state.selectedElementIds\n    });\n  }\n  getTextWysiwygSnappedToCenterPosition(x, y, appState, container) {\n    if (container) {\n      let elementCenterX = container.x + container.width / 2;\n      let elementCenterY = container.y + container.height / 2;\n      const elementCenter = getContainerCenter(container, appState);\n      if (elementCenter) {\n        elementCenterX = elementCenter.x;\n        elementCenterY = elementCenter.y;\n      }\n      const distanceToCenter = Math.hypot(x - elementCenterX, y - elementCenterY);\n      const isSnappedToCenter = distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;\n      if (isSnappedToCenter) {\n        const {\n          x: viewportX,\n          y: viewportY\n        } = sceneCoordsToViewportCoords({\n          sceneX: elementCenterX,\n          sceneY: elementCenterY\n        }, appState);\n        return {\n          viewportX,\n          viewportY,\n          elementCenterX,\n          elementCenterY\n        };\n      }\n    }\n  }\n  getCanvasOffsets() {\n    var _this$excalidrawConta14;\n    if ((_this$excalidrawConta14 = this.excalidrawContainerRef) !== null && _this$excalidrawConta14 !== void 0 && _this$excalidrawConta14.current) {\n      const excalidrawContainer = this.excalidrawContainerRef.current;\n      const {\n        left,\n        top\n      } = excalidrawContainer.getBoundingClientRect();\n      return {\n        offsetLeft: left,\n        offsetTop: top\n      };\n    }\n    return {\n      offsetLeft: 0,\n      offsetTop: 0\n    };\n  }\n  async updateLanguage() {\n    const currentLang = languages.find(lang => lang.code === this.props.langCode) || defaultLang;\n    await setLanguage(currentLang);\n    this.setAppState({});\n  }\n}\n\n// -----------------------------------------------------------------------------\n// TEST HOOKS\n// -----------------------------------------------------------------------------\nApp.defaultProps = {\n  // needed for tests to pass since we directly render App in many tests\n  UIOptions: DEFAULT_UI_OPTIONS\n};\nif (process.env.NODE_ENV === ENV.TEST || process.env.NODE_ENV === ENV.DEVELOPMENT) {\n  window.h = window.h || {};\n  Object.defineProperties(window.h, {\n    elements: {\n      configurable: true,\n      get() {\n        var _this$app;\n        return (_this$app = this.app) === null || _this$app === void 0 ? void 0 : _this$app.scene.getElementsIncludingDeleted();\n      },\n      set(elements) {\n        var _this$app2;\n        return (_this$app2 = this.app) === null || _this$app2 === void 0 ? void 0 : _this$app2.scene.replaceAllElements(elements);\n      }\n    }\n  });\n}\nexport default App;","map":{"version":3,"names":["React","useContext","flushSync","rough","clsx","nanoid","actionAddToLibrary","actionBringForward","actionBringToFront","actionCopy","actionCopyAsPng","actionCopyAsSvg","copyText","actionCopyStyles","actionCut","actionDeleteSelected","actionDuplicateSelection","actionFinalize","actionFlipHorizontal","actionFlipVertical","actionGroup","actionPasteStyles","actionSelectAll","actionSendBackward","actionSendToBack","actionToggleGridMode","actionToggleStats","actionToggleZenMode","actionUnbindText","actionBindText","actionUngroup","actionLink","actionToggleElementLock","actionToggleLinearEditor","createRedoAction","createUndoAction","ActionManager","actions","trackEvent","getDefaultAppState","isEraserActive","isHandToolActive","parseClipboard","APP_NAME","CURSOR_TYPE","DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT","DEFAULT_UI_OPTIONS","DEFAULT_VERTICAL_ALIGN","DRAGGING_THRESHOLD","ELEMENT_READY_TO_ERASE_OPACITY","ELEMENT_SHIFT_TRANSLATE_AMOUNT","ELEMENT_TRANSLATE_AMOUNT","ENV","EVENT","FRAME_STYLE","GRID_SIZE","IMAGE_MIME_TYPES","IMAGE_RENDER_TIMEOUT","isAndroid","isBrave","LINE_CONFIRM_THRESHOLD","MAX_ALLOWED_FILE_BYTES","MIME_TYPES","MQ_MAX_HEIGHT_LANDSCAPE","MQ_MAX_WIDTH_LANDSCAPE","MQ_MAX_WIDTH_PORTRAIT","MQ_RIGHT_SIDEBAR_MIN_WIDTH","MQ_SM_MAX_WIDTH","POINTER_BUTTON","ROUNDNESS","SCROLL_TIMEOUT","TAP_TWICE_TIMEOUT","TEXT_TO_CENTER_SNAP_THRESHOLD","THEME","THEME_FILTER","TOUCH_CTX_MENU_TIMEOUT","VERTICAL_ALIGN","ZOOM_STEP","exportCanvas","loadFromBlob","Library","distributeLibraryItemsOnSquareGrid","restore","restoreElements","dragNewElement","dragSelectedElements","duplicateElement","getCommonBounds","getCursorForResizingElement","getDragOffsetXY","getElementWithTransformHandleType","getNormalizedDimensions","getResizeArrowDirection","getResizeOffsetXY","getLockedLinearCursorAlignSize","getTransformHandleTypeFromCoords","hitTest","isHittingElementBoundingBoxWithoutHittingElement","isInvisiblySmallElement","isNonDeletedElement","isTextElement","newElement","newLinearElement","newTextElement","newImageElement","textWysiwyg","transformElements","updateTextElement","redrawTextBoundingBox","bindOrUnbindLinearElement","bindOrUnbindSelectedElements","fixBindingsAfterDeletion","fixBindingsAfterDuplication","getEligibleElementsForBinding","getHoveredElementForBinding","isBindingEnabled","isLinearElementSimpleAndAlreadyBound","maybeBindLinearElement","shouldEnableBindingForPointerEvent","unbindLinearElements","updateBoundElements","LinearElementEditor","mutateElement","newElementWith","deepCopyElement","duplicateElements","newFrameElement","newFreeDrawElement","hasBoundTextElement","isArrowElement","isBindingElement","isBindingElementType","isBoundToContainer","isFrameElement","isImageElement","isInitializedImageElement","isLinearElement","isLinearElementType","isUsingAdaptiveRadius","getCenter","getDistance","editGroupForSelectedElement","getElementsInGroup","getSelectedGroupIdForElement","getSelectedGroupIds","isElementInGroup","isSelectedViaGroup","selectGroupsForSelectedElements","History","defaultLang","getLanguage","languages","setLanguage","t","CODES","shouldResizeFromCenter","shouldMaintainAspectRatio","shouldRotateWithDiscreteAngle","isArrowKey","KEYS","distance2d","getGridPoint","isPathALoop","isVisibleElement","renderScene","invalidateShapeForElement","calculateScrollCenter","getElementsAtPosition","getElementsWithinSelection","getNormalizedZoom","getSelectedElements","hasBackground","isOverScrollBars","isSomeElementSelected","Scene","getStateForZoom","findShapeByKey","debounce","distance","getFontString","getNearestScrollableContainer","isInputLike","isToolIcon","isWritableElement","resetCursor","resolvablePromise","sceneCoordsToViewportCoords","setCursor","setCursorForShape","tupleToCoors","viewportCoordsToSceneCoords","withBatchedUpdates","wrapEvent","withBatchedUpdatesThrottled","updateObject","setEraserCursor","updateActiveTool","getShortcutKey","isTransparent","easeToValuesRAF","muteFSAbortError","easeOut","ContextMenu","CONTEXT_MENU_SEPARATOR","LayerUI","Toast","actionToggleViewMode","dataURLToFile","generateIdFromFile","getDataURL","getFileFromEvent","isImageFileHandle","isSupportedImageFile","loadSceneOrLibraryFromBlob","normalizeFile","parseLibraryJSON","resizeImageFile","SVGStringToFile","getInitializedImageElements","loadHTMLImageElement","normalizeSVG","updateImageCache","_updateImageCache","throttle","fileOpen","bindTextToShapeAfterDuplication","getApproxMinLineHeight","getApproxMinLineWidth","getBoundTextElement","getContainerCenter","getContainerDims","getContainerElement","getDefaultLineHeight","getLineHeightInPx","getTextBindableContainerAtPosition","isMeasureTextSupported","isValidTextContainer","isHittingElementNotConsideringBoundingBox","showHyperlinkTooltip","hideHyperlinkToolip","Hyperlink","isPointHittingLinkIcon","isLocalLink","normalizeLink","shouldShowBoundingBox","actionUnlockAllElements","Fonts","getFrameElements","isCursorInFrame","bindElementsToFramesAfterDuplication","addElementsToFrame","replaceAllElementsInFrame","removeElementsFromFrame","getElementsInResizingFrame","getElementsInNewFrame","getContainingFrame","elementOverlapsWithFrame","updateFrameMembershipOfSelectedElements","isElementInFrame","excludeElementsInFramesFromSelection","makeNextSelectedElementIds","actionPaste","actionRemoveAllElementsFromFrame","actionSelectAllElementsInFrame","actionToggleHandTool","zoomToFit","jotaiStore","activeConfirmDialogAtom","actionWrapTextInContainer","BraveMeasureTextError","activeEyeDropperAtom","isSidebarDockedAtom","jsxDEV","_jsxDEV","AppContext","createContext","AppPropsContext","deviceContextInitialValue","isSmScreen","isMobile","isTouchScreen","canDeviceFitSidebar","isLandscape","DeviceContext","displayName","ExcalidrawContainerContext","container","id","ExcalidrawElementsContext","ExcalidrawAppStateContext","width","height","offsetLeft","offsetTop","ExcalidrawSetAppStateContext","console","warn","ExcalidrawActionManagerContext","useApp","useAppProps","useDevice","useExcalidrawContainer","useExcalidrawElements","useExcalidrawAppState","useExcalidrawSetAppState","useExcalidrawActionManager","didTapTwice","tappedTwiceTimer","isHoldingSpace","isPanning","isDraggingScrollBar","currentScrollBars","horizontal","vertical","touchTimeout","invalidateContextMenu","THROTTLE_NEXT_RENDER","IS_PLAIN_PASTE","IS_PLAIN_PASTE_TIMER","PLAIN_PASTE_TOAST_SHOWN","lastPointerUp","gesture","pointers","Map","lastCenter","initialDistance","initialScale","App","Component","constructor","props","_this","this","canvas","rc","unmounted","actionManager","device","detachIsMobileMqHandler","excalidrawContainerRef","createRef","scene","fonts","resizeObserver","nearestScrollableContainer","library","libraryItemsFromStorage","history","excalidrawContainerValue","files","imageCache","hitLinkElement","lastPointerDown","lastViewportPosition","x","y","getFrameNameDOMId","frameElement","frameNameBoundsCache","get","bounds","_cache","zoom","state","value","versionNonce","frameNameDiv","document","getElementById","box","getBoundingClientRect","boxSceneTopLeft","clientX","clientY","boxSceneBottomRight","right","bottom","angle","set","renderFrameNames","frameRendering","enabled","name","isDarkTheme","theme","getNonDeletedFrames","map","f","index","window","devicePixelRatio","scrollX","scrollY","x1","y1","sceneX","sceneY","x2","FRAME_NAME_GAP","FRAME_NAME_EDIT_PADDING","reset","_f$name","trim","setState","editingFrame","frameNameJSX","frameNameInEdit","autoFocus","onChange","e","target","onBlur","onKeyDown","event","key","ESCAPE","ENTER","style","background","viewBackgroundColor","filter","zIndex","border","display","padding","borderRadius","boxShadow","fontFamily","fontSize","transform","color","overflow","maxWidth","Math","min","body","clientWidth","size","length","dir","autoComplete","autoCapitalize","autoCorrect","fileName","_jsxFileName","lineNumber","columnNumber","position","top","left","whiteSpace","textOverflow","cursor","MOVE","pointerEvents","viewModeEnabled","onPointerDown","handleCanvasPointerDown","onWheel","handleWheel","onContextMenu","handleCanvasContextMenu","onDoubleClick","children","focusContainer","_this$excalidrawConta","current","focus","getSceneElementsIncludingDeleted","getElementsIncludingDeleted","getSceneElements","getNonDeletedElements","onInsertElements","elements","addElementsFromPasteOrLibrary","onExportImage","type","fileHandle","exportBackground","catch","error","errorMessage","message","exportEmbedScene","openEyeDropper","_ref","swapPreviewOnAlt","previewType","onSelect","shouldUpdateStrokeColor","altKey","selectedElements","activeTool","currentItemStrokeColor","currentItemBackgroundColor","updateScene","el","selectedElementIds","keepOpenOnAlt","syncActionResult","actionResult","editingElement","forEach","element","_this$state$editingEl","replaceAllElements","commitToHistory","resumeRecording","replaceFiles","addNewImagesToImageCache","appState","contextMenu","_actionResult$appStat","_actionResult$appStat2","_actionResult$appStat3","_actionResult$appStat4","_actionResult$appStat5","_actionResult$appStat6","_actionResult$appStat7","_actionResult$appStat8","_actionResult$appStat9","_editingElement","zenModeEnabled","gridSize","LIGHT","gridModeEnabled","isDeleted","Object","assign","syncHistory","setCurrentState","onUnload","disableEvent","preventDefault","resetHistory","clear","resetScene","opts","isLoading","resetLoadingState","initializeScene","_scene$appState","_initialData2","launchQueue","setConsumer","launchParams","blob","getFile","loadFileToCanvas","File","initialData","_initialData","libraryItems","updateLibrary","merge","repairBindings","openSidebar","toast","scrollToContent","loadFontsForElements","refreshDeviceState","sidebarBreakpoint","UIOptions","dockedSidebarBreakpoint","onResize","cursorButton","pointerViewportCoords","remoteSelectedElementIds","pointerUsernames","pointerUserStates","collaborators","user","socketId","keys","push","pointer","username","userState","button","renderingElements","pendingImageElementId","selectionColor","getComputedStyle","querySelector","getPropertyValue","scale","renderConfig","remotePointerViewportCoords","remotePointerButton","remotePointerUsernames","remotePointerUserStates","shouldCacheIgnoreZoom","isExporting","renderScrollbars","callback","_ref2","atLeastOneVisibleElement","scrollBars","scrolledOutside","scheduleImageRefresh","EXCALIDRAW_THROTTLE_RENDER","onScroll","getCanvasOffsets","onCut","_this$excalidrawConta2","isExcalidrawActive","contains","activeElement","cutAll","stopPropagation","onCopy","_this$excalidrawConta3","copyAll","executeAction","onTapStart","clearTimeout","setTimeout","resetTapTwice","touches","touch","handleCanvasDoubleClick","onTapEnd","resetContextMenuTimer","previousSelectedElementIds","pasteFromClipboard","_this$excalidrawConta4","_event$clipboardData","isPlainPaste","elementUnderCursor","elementFromPoint","HTMLCanvasElement","file","clipboardData","data","text","string","startsWith","endsWith","spreadsheet","imageElement","createImageElement","insertImageElement","initializeImageDimensions","onPaste","pasteDialog","shown","retainSeed","addTextFromPaste","setActiveTool","minX","minY","maxX","maxY","elementsCenterX","elementsCenterY","dx","dy","gridX","gridY","newElements","randomizeSeed","nextElements","nextElementsToSelect","reduce","acc","selectedGroupIds","setAppState","removePointer","delete","pointerId","toggleLock","source","arguments","undefined","locked","prevState","updateFrameRendering","_next$enabled","_next$clip","_next$name","_next$outline","next","clip","outline","togglePenMode","penMode","onHandToolToggle","zoomCanvas","viewportX","viewportY","nextZoom","cancelInProgresAnimation","_this$cancelInProgres","call","targetElements","Array","isArray","fitToContent","fitToViewport","viewportZoomFactor","scroll","animate","_opts$duration","origScrollX","origScrollY","origZoom","cancel","fromValues","toValues","interpolateValue","from","to","progress","pow","onStep","_ref3","onStart","onEnd","onCancel","duration","translateCanvas","_this$cancelInProgres2","setToast","restoreFileFromShare","webShareTargetCache","caches","open","response","match","replaceState","location","pathname","addFiles","filesMap","fileData","fromEntries","has","fileId","informMutation","sceneData","onSceneUpdated","toggleSidebar","_ref4","tab","force","nextName","_this$state$openSideb","updateCurrentCursorPosition","shiftKey","test","Proxy","ev","prop","bind","toUpperCase","toLowerCase","CTRL_OR_CMD","V","code","MINUS","EQUAL","QUESTION_MARK","openDialog","E","PAGE_UP","PAGE_DOWN","offset","handleKeyDown","step","offsetX","offsetY","ARROW_LEFT","ARROW_RIGHT","ARROW_UP","ARROW_DOWN","includeBoundTextElement","includeElementsInFrames","simultaneouslyUpdated","maybeSuggestBindingForAll","selectedElement","editingLinearElement","elementId","midPoint","startTextEditing","ctrlKey","metaKey","draggingElement","shape","Q","SPACE","GRAB","G","S","some","openPopup","BACKSPACE","DELETE","lowerCased","toLocaleLowerCase","isPickingStroke","isPickingBackground","I","onKeyUp","editingGroupId","suggestedBindings","tool","nextActiveTool","onImageAction","isTouchScreenMultiTouchGesture","onGestureStart","onGestureChange","onGestureEnd","_ref5","_existingTextElement","_existingTextElement2","_container$groupIds","_container$angle","insertAtParentCenter","shouldBindToContainer","parentCenterPosition","getTextWysiwygSnappedToCenterPosition","boundTextElementToContainer","existingTextElement","getTextElementAtPosition","currentItemFontFamily","lineHeight","currentItemFontSize","fontString","minWidth","minHeight","containerDims","newHeight","max","newWidth","topLayerFrame","getTopLayerFrameAtSceneCoords","elementCenterX","elementCenterY","strokeColor","backgroundColor","fillStyle","currentItemFillStyle","strokeWidth","currentItemStrokeWidth","strokeStyle","currentItemStrokeStyle","roughness","currentItemRoughness","opacity","currentItemOpacity","textAlign","currentItemTextAlign","verticalAlign","MIDDLE","containerId","groupIds","frameId","boundElements","concat","containerIndex","getElementIndex","insertElementAtIndex","addNewElement","handleTextWysiwyg","isExistingElement","multiElement","hitElement","getElementAtPosition","selectedGroupId","getElementLinkAtPosition","scenePointer","slice","reverse","hitElementIndex","Infinity","find","link","redirectToLink","draggedDistance","lastPointerDownCoords","lastPointerDownHittingLinkIcon","lastPointerUpCoords","lastPointerUpHittingLinkIcon","url","_customEvent","customEvent","onLinkOpen","EXCALIDRAW_LINK","nativeEvent","defaultPrevented","newWindow","opener","sceneCoords","frames","frame","handleCanvasPointerMove","savePointer","center","deltaX","deltaY","values","scaleFactor","zoomState","resetShouldCacheIgnoreZoomDebounced","isPointerOverScrollBars","isOverScrollBar","isOverEither","scenePointerX","scenePointerY","isDragging","handlePointerMove","lastUncommittedPoint","maybeSuggestBindingAtCursor","maybeSuggestBindingsForLinearElementAtCoords","startBoundElement","rx","ry","points","lastCommittedPoint","lastPoint","POINTER","_multiElement$lastCom","lastCommittedX","lastCommittedY","dxFromLastCommitted","dyFromLastCommitted","hasDeselectedButton","Boolean","buttons","elementWithTransformHandleType","pointerType","transformHandleType","showHyperlinkPopup","TEXT","CROSSHAIR","AUTO","selectedLinearElement","handleHoverSelectedLinearElement","isHittingCommonBoundingBoxOfSelectedElements","handleEraser","pointerDownState","updateElementIds","idsToUpdate","elementIdsToErase","erase","lastCoords","threshold","point","samplingInterval","hitElements","distanceRatio","nextX","nextY","ele","includes","handleTouchMove","_this$props","_this$props$onPointer","updateGestureOnPointerDown","obj","selection","getSelection","anchorNode","removeAllRanges","maybeOpenContextMenuAfterPointerDownOnTouchDevices","maybeCleanupAfterMissingPointerUp","penDetected","lastPointerDownWith","handleCanvasPanUsingWheelOrSpaceDrag","MAIN","TOUCH","initialPointerDownState","selectedElementsAreBeingDragged","handleDraggingScrollBar","clearSelectionIfNotUsingSelection","updateBindingEnabledOnPointerMove","handleSelectionOnPointerDown","allowOnPointerDown","handleTextOnPointerDown","handleLinearElementOnPointerDown","pendingImageElement","getElement","handleFreeDrawElementOnPointerDown","createFrameElementOnPointerDown","createGenericElementOnPointerDown","onPointerMove","onPointerMoveFromPointerDownHandler","onPointerUp","onPointerUpFromPointerDownHandler","onKeyDownFromPointerDownHandler","onKeyUpFromPointerDownHandler","addEventListener","POINTER_MOVE","POINTER_UP","KEYDOWN","KEYUP","eventListeners","onMove","onUp","handleCanvasPointerUp","WHEEL","nextPastePrevented","isLinux","navigator","platform","GRABBING","lastX","lastY","abs","preventNextPaste","removeEventListener","PASTE","enableNextPaste","teardown","BLUR","flush","passive","origin","resizingElement","resize","handleType","isResizing","arrowDirection","_pointerDownState$hit","linearElementEditor","ret","handlePointerDown","hit","didAddPoint","allHitElements","someHitElementIsSelected","isASelectedElement","hasHitCommonBoundingBoxOfSelectedElements","clearSelection","wasAddedToSelection","nextSelectedElementIds","previouslySelectedElements","framesInGroups","Set","flatMap","gid","elementType","roundness","simulatePressure","pressure","pressures","boundElement","_ref6","currentItemStartArrowhead","currentItemEndArrowhead","startArrowhead","endArrowhead","currentItemRoundness","PROPORTIONAL_RADIUS","ADAPTIVE_RADIUS","selectionElement","restoreReadyToEraseElements","eraseElements","initializeImage","_ref7","_this$props$generateI","_this$props2","_this$files$fileId2","imageFile","_imageElement","showCursorImagePreview","Error","mimeType","svg","generateIdForFile","existingFileData","dataURL","maxWidthOrHeight","maxSize","trunc","_this$files$fileId","resizedFile","setImagePreviewCursor","Promise","resolve","reject","_this$state$draggingE","created","Date","now","lastRetrieved","cachedImageData","image","cursorImageSizePx","imagePreview","previewDataURL","img","createElement","context","getContext","drawImage","toDataURL","insertOnCanvasDirectly","description","extensions","_this$imageCache$get","forceNaturalSize","placeholderSize","maxHeight","floor","naturalHeight","naturalWidth","updatedFiles","erroredFiles","fileIds","status","imageElements","uncachedImageElements","shouldEnableBinding","pointerCoords","hoveredBindableElement","linearElement","oppositeBindingBoundElement","coords","handleCanvasRef","TOUCH_START","TOUCH_END","_this$canvas","_this$canvas2","_this$canvas3","handleAppOnDrop","png","libraryJSON","dataTransfer","getData","excalidrawlib","excalidraw","openLibraryMenu","SECONDARY","preferSelected","includeLockedElements","isHittignCommonBoundBox","items","getContextMenuItems","maybeDragNewGenericElement","_this$imageCache$get2","aspectRatio","originInGrid","elementsToHighlight","maybeHandleResize","selectedFrames","isRotating","resizeX","resizeY","frameElementsOffsetsMap","elementsInFrame","_frameElementsOffsets","_frameElementsOffsets2","_frameElementsOffsets3","_frameElementsOffsets4","add","options","sign","MAX_STEP","absDelta","delta","newZoom","log10","_ref8","_ref9","_this$props$onPointer2","_this$props3","isNaN","onPointerUpdate","pointersMap","updateDOMRect","cb","_this$excalidrawConta5","excalidrawContainer","currentWidth","currentHeight","currentOffsetTop","currentOffsetLeft","refresh","defaultAppState","excalidrawRef","innerWidth","innerHeight","_excalidrawRef$curren","readyPromise","api","ready","getAppState","getFiles","registerAll","registerAction","renderCanvas","canvasScale","canvasDOMWidth","canvasDOMHeight","canvasWidth","canvasHeight","className","ref","onPointerCancel","onTouchMove","render","_this$props4","renderTopRightUI","renderCustomStats","onDrop","tabIndex","handleKeyboardGlobally","Provider","onLockToggle","onPenModeToggle","langCode","showExitZenModeBtn","renderWelcomeScreen","showWelcomeScreen","app","onClose","closable","componentDidMount","_this2","_this$excalidrawConta6","process","env","NODE_ENV","TEST","DEVELOPMENT","defineProperties","h","configurable","addCallback","addEventListeners","_this$resizeObserver","ResizeObserver","observe","matchMedia","mdScreenQuery","smScreenQuery","canDeviceFitSidebarMediaQuery","handler","matches","addListener","removeListener","searchParams","URLSearchParams","search","componentWillUnmount","_this$resizeObserver2","disconnect","removeEventListeners","destroy","clearCache","_this$excalidrawConta7","_this$nearestScrollab","_this$excalidrawConta8","_this$excalidrawConta9","_this$detachIsMobileM","COPY","CUT","SCROLL","MOUSE_MOVE","RESIZE","UNLOAD","DRAG_OVER","DROP","GESTURE_START","GESTURE_CHANGE","GESTURE_END","_this$excalidrawConta10","_document$fonts","_document$fonts$addEv","_this$excalidrawConta11","_this$excalidrawConta12","loadedFontFaces","fontfaces","onFontsLoaded","detectScroll","componentDidUpdate","prevProps","_this$excalidrawConta13","_this$state$editingEl2","_this$props5","_this$props5$onScroll","onScrollChange","updateLanguage","deselectElements","classList","toggle","getPointAtIndexGlobalCoordinates","record","_this$props$onChange","_this$props6","textElementProps","LINE_GAP","currentY","lines","split","textElements","line","idx","_lines","prevLine","insertElementsAtIndex","shortcut","_ref10","updateElement","originalText","_element","getViewportCoords","onSubmit","_ref11","viaKeyboard","elementIdToSelect","elementWithHighestZIndex","containingFrame","boundTextElement","hoverPointIndex","segmentMidPointHoveredCoords","getPointIndexUnderCursor","getSegmentMidpointHitCoords","arePointsEqual","withCmdOrCtrl","scrollbars","originalElements","hasBeenDuplicated","drag","hasOccurred","boxSelection","HTMLElement","handlePointerMoveOverScrollbars","y2","ALT","_pointerDownState$hit2","shouldAddMidpoint","addMidpoint","selectedPointsIndices","segmentMidpoint","added","didDrag","handlePointDragging","pointsSceneCoords","hasHitASelectedElement","isSelectingPointsInLineEditor","every","selectedElementsHasAFrame","frameToHighlight","dragX","dragY","dragDistanceX","dragDistanceY","lockDirection","elementsToAppend","groupIdMap","oldIdToDuplicatedId","duplicatedElement","originDragX","originDragY","nextSceneElements","discardPoint","handleBoxSelection","elementsWithinSelection","isOverHorizontal","isOverVertical","childEvent","_this$state$selectedL","_pointerDownState$hit3","_pointerDownState$hit4","handlePointerUp","_pointerDownState$hit5","_pointerDownState$hit6","selectedELements","startBindingElement","endBindingElement","updateGroupIdsAfterEditingGroup","indexOf","elementsToAdd","elementsToRemove","elementsInsideFrame","_this$state$selectedL2","_prevState","groupedElement","groupId","gId","prev","newSelectedElementIds","newSelectedElements","_this$scene$getElemen","_this$scene$getElemen2","_prevState$selectedLi","elementCenter","distanceToCenter","hypot","isSnappedToCenter","_this$excalidrawConta14","currentLang","lang","defaultProps","_this$app","_this$app2"],"sources":["D:/project/excalidraw-cn/src/components/App.tsx"],"sourcesContent":["import React, { useContext } from \"react\";\nimport { flushSync } from \"react-dom\";\n\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport rough from \"roughjs/bin/rough\";\nimport clsx from \"clsx\";\nimport { nanoid } from \"nanoid\";\n\nimport {\n  actionAddToLibrary,\n  actionBringForward,\n  actionBringToFront,\n  actionCopy,\n  actionCopyAsPng,\n  actionCopyAsSvg,\n  copyText,\n  actionCopyStyles,\n  actionCut,\n  actionDeleteSelected,\n  actionDuplicateSelection,\n  actionFinalize,\n  actionFlipHorizontal,\n  actionFlipVertical,\n  actionGroup,\n  actionPasteStyles,\n  actionSelectAll,\n  actionSendBackward,\n  actionSendToBack,\n  actionToggleGridMode,\n  actionToggleStats,\n  actionToggleZenMode,\n  actionUnbindText,\n  actionBindText,\n  actionUngroup,\n  actionLink,\n  actionToggleElementLock,\n  actionToggleLinearEditor,\n} from \"../actions\";\nimport { createRedoAction, createUndoAction } from \"../actions/actionHistory\";\nimport { ActionManager } from \"../actions/manager\";\nimport { actions } from \"../actions/register\";\nimport { ActionResult } from \"../actions/types\";\nimport { trackEvent } from \"../analytics\";\nimport {\n  getDefaultAppState,\n  isEraserActive,\n  isHandToolActive,\n} from \"../appState\";\nimport { parseClipboard } from \"../clipboard\";\nimport {\n  APP_NAME,\n  CURSOR_TYPE,\n  DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT,\n  DEFAULT_UI_OPTIONS,\n  DEFAULT_VERTICAL_ALIGN,\n  DRAGGING_THRESHOLD,\n  ELEMENT_READY_TO_ERASE_OPACITY,\n  ELEMENT_SHIFT_TRANSLATE_AMOUNT,\n  ELEMENT_TRANSLATE_AMOUNT,\n  ENV,\n  EVENT,\n  FRAME_STYLE,\n  EXPORT_IMAGE_TYPES,\n  GRID_SIZE,\n  IMAGE_MIME_TYPES,\n  IMAGE_RENDER_TIMEOUT,\n  isAndroid,\n  isBrave,\n  LINE_CONFIRM_THRESHOLD,\n  MAX_ALLOWED_FILE_BYTES,\n  MIME_TYPES,\n  MQ_MAX_HEIGHT_LANDSCAPE,\n  MQ_MAX_WIDTH_LANDSCAPE,\n  MQ_MAX_WIDTH_PORTRAIT,\n  MQ_RIGHT_SIDEBAR_MIN_WIDTH,\n  MQ_SM_MAX_WIDTH,\n  POINTER_BUTTON,\n  ROUNDNESS,\n  SCROLL_TIMEOUT,\n  TAP_TWICE_TIMEOUT,\n  TEXT_TO_CENTER_SNAP_THRESHOLD,\n  THEME,\n  THEME_FILTER,\n  TOUCH_CTX_MENU_TIMEOUT,\n  VERTICAL_ALIGN,\n  ZOOM_STEP,\n} from \"../constants\";\nimport { exportCanvas, loadFromBlob } from \"../data\";\nimport Library, { distributeLibraryItemsOnSquareGrid } from \"../data/library\";\nimport { restore, restoreElements } from \"../data/restore\";\nimport {\n  dragNewElement,\n  dragSelectedElements,\n  duplicateElement,\n  getCommonBounds,\n  getCursorForResizingElement,\n  getDragOffsetXY,\n  getElementWithTransformHandleType,\n  getNormalizedDimensions,\n  getResizeArrowDirection,\n  getResizeOffsetXY,\n  getLockedLinearCursorAlignSize,\n  getTransformHandleTypeFromCoords,\n  hitTest,\n  isHittingElementBoundingBoxWithoutHittingElement,\n  isInvisiblySmallElement,\n  isNonDeletedElement,\n  isTextElement,\n  newElement,\n  newLinearElement,\n  newTextElement,\n  newImageElement,\n  textWysiwyg,\n  transformElements,\n  updateTextElement,\n  redrawTextBoundingBox,\n} from \"../element\";\nimport {\n  bindOrUnbindLinearElement,\n  bindOrUnbindSelectedElements,\n  fixBindingsAfterDeletion,\n  fixBindingsAfterDuplication,\n  getEligibleElementsForBinding,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n  isLinearElementSimpleAndAlreadyBound,\n  maybeBindLinearElement,\n  shouldEnableBindingForPointerEvent,\n  unbindLinearElements,\n  updateBoundElements,\n} from \"../element/binding\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { mutateElement, newElementWith } from \"../element/mutateElement\";\nimport {\n  deepCopyElement,\n  duplicateElements,\n  newFrameElement,\n  newFreeDrawElement,\n} from \"../element/newElement\";\nimport {\n  hasBoundTextElement,\n  isArrowElement,\n  isBindingElement,\n  isBindingElementType,\n  isBoundToContainer,\n  isFrameElement,\n  isImageElement,\n  isInitializedImageElement,\n  isLinearElement,\n  isLinearElementType,\n  isUsingAdaptiveRadius,\n} from \"../element/typeChecks\";\nimport {\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawGenericElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeleted,\n  InitializedExcalidrawImageElement,\n  ExcalidrawImageElement,\n  FileId,\n  NonDeletedExcalidrawElement,\n  ExcalidrawTextContainer,\n  ExcalidrawFrameElement,\n} from \"../element/types\";\nimport { getCenter, getDistance } from \"../gesture\";\nimport {\n  editGroupForSelectedElement,\n  getElementsInGroup,\n  getSelectedGroupIdForElement,\n  getSelectedGroupIds,\n  isElementInGroup,\n  isSelectedViaGroup,\n  selectGroupsForSelectedElements,\n} from \"../groups\";\nimport History from \"../history\";\nimport { defaultLang, getLanguage, languages, setLanguage, t } from \"../i18n\";\nimport {\n  CODES,\n  shouldResizeFromCenter,\n  shouldMaintainAspectRatio,\n  shouldRotateWithDiscreteAngle,\n  isArrowKey,\n  KEYS,\n} from \"../keys\";\nimport { distance2d, getGridPoint, isPathALoop } from \"../math\";\nimport { isVisibleElement, renderScene } from \"../renderer/renderScene\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport {\n  calculateScrollCenter,\n  getElementsAtPosition,\n  getElementsWithinSelection,\n  getNormalizedZoom,\n  getSelectedElements,\n  hasBackground,\n  isOverScrollBars,\n  isSomeElementSelected,\n} from \"../scene\";\nimport Scene from \"../scene/Scene\";\nimport { RenderConfig, ScrollBars } from \"../scene/types\";\nimport { getStateForZoom } from \"../scene/zoom\";\nimport { findShapeByKey, SHAPES } from \"../shapes\";\nimport {\n  AppClassProperties,\n  AppProps,\n  AppState,\n  BinaryFileData,\n  DataURL,\n  ExcalidrawImperativeAPI,\n  BinaryFiles,\n  Gesture,\n  GestureEvent,\n  LibraryItems,\n  PointerDownState,\n  SceneData,\n  Device,\n  FrameNameBoundsCache,\n  SidebarName,\n  SidebarTabName,\n} from \"../types\";\nimport {\n  debounce,\n  distance,\n  getFontString,\n  getNearestScrollableContainer,\n  isInputLike,\n  isToolIcon,\n  isWritableElement,\n  resetCursor,\n  resolvablePromise,\n  sceneCoordsToViewportCoords,\n  setCursor,\n  setCursorForShape,\n  tupleToCoors,\n  viewportCoordsToSceneCoords,\n  withBatchedUpdates,\n  wrapEvent,\n  withBatchedUpdatesThrottled,\n  updateObject,\n  setEraserCursor,\n  updateActiveTool,\n  getShortcutKey,\n  isTransparent,\n  easeToValuesRAF,\n  muteFSAbortError,\n  easeOut,\n} from \"../utils\";\nimport {\n  ContextMenu,\n  ContextMenuItems,\n  CONTEXT_MENU_SEPARATOR,\n} from \"./ContextMenu\";\nimport LayerUI from \"./LayerUI\";\nimport { Toast } from \"./Toast\";\nimport { actionToggleViewMode } from \"../actions/actionToggleViewMode\";\nimport {\n  dataURLToFile,\n  generateIdFromFile,\n  getDataURL,\n  getFileFromEvent,\n  isImageFileHandle,\n  isSupportedImageFile,\n  loadSceneOrLibraryFromBlob,\n  normalizeFile,\n  parseLibraryJSON,\n  resizeImageFile,\n  SVGStringToFile,\n} from \"../data/blob\";\nimport {\n  getInitializedImageElements,\n  loadHTMLImageElement,\n  normalizeSVG,\n  updateImageCache as _updateImageCache,\n} from \"../element/image\";\nimport throttle from \"lodash.throttle\";\nimport { fileOpen, FileSystemHandle } from \"../data/filesystem\";\nimport {\n  bindTextToShapeAfterDuplication,\n  getApproxMinLineHeight,\n  getApproxMinLineWidth,\n  getBoundTextElement,\n  getContainerCenter,\n  getContainerDims,\n  getContainerElement,\n  getDefaultLineHeight,\n  getLineHeightInPx,\n  getTextBindableContainerAtPosition,\n  isMeasureTextSupported,\n  isValidTextContainer,\n} from \"../element/textElement\";\nimport { isHittingElementNotConsideringBoundingBox } from \"../element/collision\";\nimport {\n  showHyperlinkTooltip,\n  hideHyperlinkToolip,\n  Hyperlink,\n  isPointHittingLinkIcon,\n} from \"../element/Hyperlink\";\nimport { isLocalLink, normalizeLink } from \"../data/url\";\nimport { shouldShowBoundingBox } from \"../element/transformHandles\";\nimport { actionUnlockAllElements } from \"../actions/actionElementLock\";\nimport { Fonts } from \"../scene/Fonts\";\nimport {\n  getFrameElements,\n  isCursorInFrame,\n  bindElementsToFramesAfterDuplication,\n  addElementsToFrame,\n  replaceAllElementsInFrame,\n  removeElementsFromFrame,\n  getElementsInResizingFrame,\n  getElementsInNewFrame,\n  getContainingFrame,\n  elementOverlapsWithFrame,\n  updateFrameMembershipOfSelectedElements,\n  isElementInFrame,\n} from \"../frame\";\nimport {\n  excludeElementsInFramesFromSelection,\n  makeNextSelectedElementIds,\n} from \"../scene/selection\";\nimport { actionPaste } from \"../actions/actionClipboard\";\nimport {\n  actionRemoveAllElementsFromFrame,\n  actionSelectAllElementsInFrame,\n} from \"../actions/actionFrame\";\nimport { actionToggleHandTool, zoomToFit } from \"../actions/actionCanvas\";\nimport { jotaiStore } from \"../jotai\";\nimport { activeConfirmDialogAtom } from \"./ActiveConfirmDialog\";\nimport { actionWrapTextInContainer } from \"../actions/actionBoundText\";\nimport BraveMeasureTextError from \"./BraveMeasureTextError\";\nimport { activeEyeDropperAtom } from \"./EyeDropper\";\nimport { isSidebarDockedAtom } from \"./Sidebar/Sidebar\";\n\nconst AppContext = React.createContext<AppClassProperties>(null!);\nconst AppPropsContext = React.createContext<AppProps>(null!);\n\nconst deviceContextInitialValue = {\n  isSmScreen: false,\n  isMobile: false,\n  isTouchScreen: false,\n  canDeviceFitSidebar: false,\n  isLandscape: false,\n};\nconst DeviceContext = React.createContext<Device>(deviceContextInitialValue);\nDeviceContext.displayName = \"DeviceContext\";\n\nexport const ExcalidrawContainerContext = React.createContext<{\n  container: HTMLDivElement | null;\n  id: string | null;\n}>({ container: null, id: null });\nExcalidrawContainerContext.displayName = \"ExcalidrawContainerContext\";\n\nconst ExcalidrawElementsContext = React.createContext<\n  readonly NonDeletedExcalidrawElement[]\n>([]);\nExcalidrawElementsContext.displayName = \"ExcalidrawElementsContext\";\n\nconst ExcalidrawAppStateContext = React.createContext<AppState>({\n  ...getDefaultAppState(),\n  width: 0,\n  height: 0,\n  offsetLeft: 0,\n  offsetTop: 0,\n});\nExcalidrawAppStateContext.displayName = \"ExcalidrawAppStateContext\";\n\nconst ExcalidrawSetAppStateContext = React.createContext<\n  React.Component<any, AppState>[\"setState\"]\n>(() => {\n  console.warn(\"unitialized ExcalidrawSetAppStateContext context!\");\n});\nExcalidrawSetAppStateContext.displayName = \"ExcalidrawSetAppStateContext\";\n\nconst ExcalidrawActionManagerContext = React.createContext<ActionManager>(\n  null!,\n);\nExcalidrawActionManagerContext.displayName = \"ExcalidrawActionManagerContext\";\n\nexport const useApp = () => useContext(AppContext);\nexport const useAppProps = () => useContext(AppPropsContext);\nexport const useDevice = () => useContext<Device>(DeviceContext);\nexport const useExcalidrawContainer = () =>\n  useContext(ExcalidrawContainerContext);\nexport const useExcalidrawElements = () =>\n  useContext(ExcalidrawElementsContext);\nexport const useExcalidrawAppState = () =>\n  useContext(ExcalidrawAppStateContext);\nexport const useExcalidrawSetAppState = () =>\n  useContext(ExcalidrawSetAppStateContext);\nexport const useExcalidrawActionManager = () =>\n  useContext(ExcalidrawActionManagerContext);\n\nlet didTapTwice: boolean = false;\nlet tappedTwiceTimer = 0;\nlet isHoldingSpace: boolean = false;\nlet isPanning: boolean = false;\nlet isDraggingScrollBar: boolean = false;\nlet currentScrollBars: ScrollBars = { horizontal: null, vertical: null };\nlet touchTimeout = 0;\nlet invalidateContextMenu = false;\n\n// remove this hack when we can sync render & resizeObserver (state update)\n// to rAF. See #5439\nlet THROTTLE_NEXT_RENDER = true;\n\nlet IS_PLAIN_PASTE = false;\nlet IS_PLAIN_PASTE_TIMER = 0;\nlet PLAIN_PASTE_TOAST_SHOWN = false;\n\nlet lastPointerUp: ((event: any) => void) | null = null;\nconst gesture: Gesture = {\n  pointers: new Map(),\n  lastCenter: null,\n  initialDistance: null,\n  initialScale: null,\n};\n\nclass App extends React.Component<AppProps, AppState> {\n  canvas: AppClassProperties[\"canvas\"] = null;\n  rc: RoughCanvas | null = null;\n  unmounted: boolean = false;\n  actionManager: ActionManager;\n  device: Device = deviceContextInitialValue;\n  detachIsMobileMqHandler?: () => void;\n\n  private excalidrawContainerRef = React.createRef<HTMLDivElement>();\n\n  public static defaultProps: Partial<AppProps> = {\n    // needed for tests to pass since we directly render App in many tests\n    UIOptions: DEFAULT_UI_OPTIONS,\n  };\n\n  public scene: Scene;\n  private fonts: Fonts;\n  private resizeObserver: ResizeObserver | undefined;\n  private nearestScrollableContainer: HTMLElement | Document | undefined;\n  public library: AppClassProperties[\"library\"];\n  public libraryItemsFromStorage: LibraryItems | undefined;\n  public id: string;\n  private history: History;\n  private excalidrawContainerValue: {\n    container: HTMLDivElement | null;\n    id: string;\n  };\n\n  public files: BinaryFiles = {};\n  public imageCache: AppClassProperties[\"imageCache\"] = new Map();\n\n  hitLinkElement?: NonDeletedExcalidrawElement;\n  lastPointerDown: React.PointerEvent<HTMLElement> | null = null;\n  lastPointerUp: React.PointerEvent<HTMLElement> | PointerEvent | null = null;\n  lastViewportPosition = { x: 0, y: 0 };\n\n  constructor(props: AppProps) {\n    super(props);\n    const defaultAppState = getDefaultAppState();\n    const {\n      excalidrawRef,\n      viewModeEnabled = false,\n      zenModeEnabled = false,\n      gridModeEnabled = false,\n      theme = defaultAppState.theme,\n      name = defaultAppState.name,\n    } = props;\n    this.state = {\n      ...defaultAppState,\n      theme,\n      isLoading: true,\n      ...this.getCanvasOffsets(),\n      viewModeEnabled,\n      zenModeEnabled,\n      gridSize: gridModeEnabled ? GRID_SIZE : null,\n      name,\n      width: window.innerWidth,\n      height: window.innerHeight,\n    };\n\n    this.id = nanoid();\n    this.library = new Library(this);\n    if (excalidrawRef) {\n      const readyPromise =\n        (\"current\" in excalidrawRef && excalidrawRef.current?.readyPromise) ||\n        resolvablePromise<ExcalidrawImperativeAPI>();\n\n      const api: ExcalidrawImperativeAPI = {\n        ready: true,\n        readyPromise,\n        updateScene: this.updateScene,\n        updateLibrary: this.library.updateLibrary,\n        addFiles: this.addFiles,\n        resetScene: this.resetScene,\n        getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,\n        history: {\n          clear: this.resetHistory,\n        },\n        scrollToContent: this.scrollToContent,\n        getSceneElements: this.getSceneElements,\n        getAppState: () => this.state,\n        getFiles: () => this.files,\n        refresh: this.refresh,\n        setToast: this.setToast,\n        id: this.id,\n        setActiveTool: this.setActiveTool,\n        setCursor: this.setCursor,\n        resetCursor: this.resetCursor,\n        updateFrameRendering: this.updateFrameRendering,\n        toggleSidebar: this.toggleSidebar,\n      } as const;\n      if (typeof excalidrawRef === \"function\") {\n        excalidrawRef(api);\n      } else {\n        excalidrawRef.current = api;\n      }\n      readyPromise.resolve(api);\n    }\n\n    this.excalidrawContainerValue = {\n      container: this.excalidrawContainerRef.current,\n      id: this.id,\n    };\n\n    this.scene = new Scene();\n    this.fonts = new Fonts({\n      scene: this.scene,\n      onSceneUpdated: this.onSceneUpdated,\n    });\n    this.history = new History();\n    this.actionManager = new ActionManager(\n      this.syncActionResult,\n      () => this.state,\n      () => this.scene.getElementsIncludingDeleted(),\n      this,\n    );\n    this.actionManager.registerAll(actions);\n\n    this.actionManager.registerAction(createUndoAction(this.history));\n    this.actionManager.registerAction(createRedoAction(this.history));\n  }\n\n  private renderCanvas() {\n    const canvasScale = window.devicePixelRatio;\n    const {\n      width: canvasDOMWidth,\n      height: canvasDOMHeight,\n      viewModeEnabled,\n    } = this.state;\n    const canvasWidth = canvasDOMWidth * canvasScale;\n    const canvasHeight = canvasDOMHeight * canvasScale;\n    if (viewModeEnabled) {\n      return (\n        <canvas\n          className=\"excalidraw__canvas\"\n          style={{\n            width: canvasDOMWidth,\n            height: canvasDOMHeight,\n            cursor: CURSOR_TYPE.GRAB,\n          }}\n          width={canvasWidth}\n          height={canvasHeight}\n          ref={this.handleCanvasRef}\n          onContextMenu={(event: React.PointerEvent<HTMLCanvasElement>) =>\n            this.handleCanvasContextMenu(event)\n          }\n          onPointerMove={this.handleCanvasPointerMove}\n          onPointerUp={this.handleCanvasPointerUp}\n          onPointerCancel={this.removePointer}\n          onTouchMove={this.handleTouchMove}\n          onPointerDown={this.handleCanvasPointerDown}\n        >\n          {t(\"labels.drawingCanvas\")}\n        </canvas>\n      );\n    }\n    return (\n      <canvas\n        className=\"excalidraw__canvas\"\n        style={{\n          width: canvasDOMWidth,\n          height: canvasDOMHeight,\n        }}\n        width={canvasWidth}\n        height={canvasHeight}\n        ref={this.handleCanvasRef}\n        onContextMenu={(event: React.PointerEvent<HTMLCanvasElement>) =>\n          this.handleCanvasContextMenu(event)\n        }\n        onPointerDown={this.handleCanvasPointerDown}\n        onDoubleClick={this.handleCanvasDoubleClick}\n        onPointerMove={this.handleCanvasPointerMove}\n        onPointerUp={this.handleCanvasPointerUp}\n        onPointerCancel={this.removePointer}\n        onTouchMove={this.handleTouchMove}\n      >\n        {t(\"labels.drawingCanvas\")}\n      </canvas>\n    );\n  }\n\n  private getFrameNameDOMId = (frameElement: ExcalidrawElement) => {\n    return `${this.id}-frame-name-${frameElement.id}`;\n  };\n\n  frameNameBoundsCache: FrameNameBoundsCache = {\n    get: (frameElement) => {\n      let bounds = this.frameNameBoundsCache._cache.get(frameElement.id);\n      if (\n        !bounds ||\n        bounds.zoom !== this.state.zoom.value ||\n        bounds.versionNonce !== frameElement.versionNonce\n      ) {\n        const frameNameDiv = document.getElementById(\n          this.getFrameNameDOMId(frameElement),\n        );\n\n        if (frameNameDiv) {\n          const box = frameNameDiv.getBoundingClientRect();\n          const boxSceneTopLeft = viewportCoordsToSceneCoords(\n            { clientX: box.x, clientY: box.y },\n            this.state,\n          );\n          const boxSceneBottomRight = viewportCoordsToSceneCoords(\n            { clientX: box.right, clientY: box.bottom },\n            this.state,\n          );\n\n          bounds = {\n            x: boxSceneTopLeft.x,\n            y: boxSceneTopLeft.y,\n            width: boxSceneBottomRight.x - boxSceneTopLeft.x,\n            height: boxSceneBottomRight.y - boxSceneTopLeft.y,\n            angle: 0,\n            zoom: this.state.zoom.value,\n            versionNonce: frameElement.versionNonce,\n          };\n\n          this.frameNameBoundsCache._cache.set(frameElement.id, bounds);\n\n          return bounds;\n        }\n        return null;\n      }\n\n      return bounds;\n    },\n    /**\n     * @private\n     */\n    _cache: new Map(),\n  };\n\n  private renderFrameNames = () => {\n    if (!this.state.frameRendering.enabled || !this.state.frameRendering.name) {\n      return null;\n    }\n\n    const isDarkTheme = this.state.theme === \"dark\";\n\n    return this.scene.getNonDeletedFrames().map((f, index) => {\n      if (\n        !this.canvas ||\n        !isVisibleElement(\n          f,\n          this.canvas.width / window.devicePixelRatio,\n          this.canvas.height / window.devicePixelRatio,\n          {\n            offsetLeft: this.state.offsetLeft,\n            offsetTop: this.state.offsetTop,\n            scrollX: this.state.scrollX,\n            scrollY: this.state.scrollY,\n            zoom: this.state.zoom,\n          },\n        )\n      ) {\n        // if frame not visible, don't render its name\n        return null;\n      }\n\n      const { x: x1, y: y1 } = sceneCoordsToViewportCoords(\n        { sceneX: f.x, sceneY: f.y },\n        this.state,\n      );\n\n      const { x: x2 } = sceneCoordsToViewportCoords(\n        { sceneX: f.x + f.width, sceneY: f.y + f.height },\n        this.state,\n      );\n\n      const FRAME_NAME_GAP = 20;\n      const FRAME_NAME_EDIT_PADDING = 6;\n\n      const reset = () => {\n        if (f.name?.trim() === \"\") {\n          mutateElement(f, { name: null });\n        }\n\n        this.setState({ editingFrame: null });\n      };\n\n      let frameNameJSX;\n\n      if (f.id === this.state.editingFrame) {\n        const frameNameInEdit = f.name == null ? `Frame ${index + 1}` : f.name;\n\n        frameNameJSX = (\n          <input\n            autoFocus\n            value={frameNameInEdit}\n            onChange={(e) => {\n              mutateElement(f, {\n                name: e.target.value,\n              });\n            }}\n            onBlur={() => reset()}\n            onKeyDown={(event) => {\n              // for some inexplicable reason, `onBlur` triggered on ESC\n              // does not reset `state.editingFrame` despite being called,\n              // and we need to reset it here as well\n              if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {\n                reset();\n              }\n            }}\n            style={{\n              background: this.state.viewBackgroundColor,\n              filter: isDarkTheme ? THEME_FILTER : \"none\",\n              zIndex: 2,\n              border: \"none\",\n              display: \"block\",\n              padding: `${FRAME_NAME_EDIT_PADDING}px`,\n              borderRadius: 4,\n              boxShadow: \"inset 0 0 0 1px var(--color-primary)\",\n              fontFamily: \"Assistant\",\n              fontSize: \"14px\",\n              transform: `translateY(-${FRAME_NAME_EDIT_PADDING}px)`,\n              color: \"var(--color-gray-80)\",\n              overflow: \"hidden\",\n              maxWidth: `${Math.min(\n                x2 - x1 - FRAME_NAME_EDIT_PADDING,\n                document.body.clientWidth - x1 - FRAME_NAME_EDIT_PADDING,\n              )}px`,\n            }}\n            size={frameNameInEdit.length + 1 || 1}\n            dir=\"auto\"\n            autoComplete=\"off\"\n            autoCapitalize=\"off\"\n            autoCorrect=\"off\"\n          />\n        );\n      } else {\n        frameNameJSX =\n          f.name == null || f.name.trim() === \"\"\n            ? `Frame ${index + 1}`\n            : f.name.trim();\n      }\n\n      return (\n        <div\n          id={this.getFrameNameDOMId(f)}\n          key={f.id}\n          style={{\n            position: \"absolute\",\n            top: `${y1 - FRAME_NAME_GAP - this.state.offsetTop}px`,\n            left: `${\n              x1 -\n              this.state.offsetLeft -\n              (this.state.editingFrame === f.id ? FRAME_NAME_EDIT_PADDING : 0)\n            }px`,\n            zIndex: 2,\n            fontSize: \"14px\",\n            color: isDarkTheme\n              ? \"var(--color-gray-60)\"\n              : \"var(--color-gray-50)\",\n            width: \"max-content\",\n            maxWidth: `${x2 - x1 + FRAME_NAME_EDIT_PADDING * 2}px`,\n            overflow: f.id === this.state.editingFrame ? \"visible\" : \"hidden\",\n            whiteSpace: \"nowrap\",\n            textOverflow: \"ellipsis\",\n            cursor: CURSOR_TYPE.MOVE,\n            // disable all interaction (e.g. cursor change) when in view\n            // mode\n            pointerEvents: this.state.viewModeEnabled ? \"none\" : \"all\",\n          }}\n          onPointerDown={(event) => this.handleCanvasPointerDown(event)}\n          onWheel={(event) => this.handleWheel(event)}\n          onContextMenu={(event: React.PointerEvent<HTMLDivElement>) => {\n            this.handleCanvasContextMenu(event);\n          }}\n          onDoubleClick={() => {\n            this.setState({\n              editingFrame: f.id,\n            });\n          }}\n        >\n          {frameNameJSX}\n        </div>\n      );\n    });\n  };\n\n  public render() {\n    const selectedElement = this.scene.getSelectedElements(this.state);\n    const { renderTopRightUI, renderCustomStats } = this.props;\n\n    return (\n      <div\n        className={clsx(\"excalidraw excalidraw-container\", {\n          \"excalidraw--view-mode\": this.state.viewModeEnabled,\n          \"excalidraw--mobile\": this.device.isMobile,\n        })}\n        ref={this.excalidrawContainerRef}\n        onDrop={this.handleAppOnDrop}\n        tabIndex={0}\n        onKeyDown={\n          this.props.handleKeyboardGlobally ? undefined : this.onKeyDown\n        }\n      >\n        <AppContext.Provider value={this}>\n          <AppPropsContext.Provider value={this.props}>\n            <ExcalidrawContainerContext.Provider\n              value={this.excalidrawContainerValue}\n            >\n              <DeviceContext.Provider value={this.device}>\n                <ExcalidrawSetAppStateContext.Provider value={this.setAppState}>\n                  <ExcalidrawAppStateContext.Provider value={this.state}>\n                    <ExcalidrawElementsContext.Provider\n                      value={this.scene.getNonDeletedElements()}\n                    >\n                      <ExcalidrawActionManagerContext.Provider\n                        value={this.actionManager}\n                      >\n                        <LayerUI\n                          canvas={this.canvas}\n                          appState={this.state}\n                          files={this.files}\n                          setAppState={this.setAppState}\n                          actionManager={this.actionManager}\n                          elements={this.scene.getNonDeletedElements()}\n                          onLockToggle={this.toggleLock}\n                          onPenModeToggle={this.togglePenMode}\n                          onHandToolToggle={this.onHandToolToggle}\n                          langCode={getLanguage().code}\n                          renderTopRightUI={renderTopRightUI}\n                          renderCustomStats={renderCustomStats}\n                          showExitZenModeBtn={\n                            typeof this.props?.zenModeEnabled === \"undefined\" &&\n                            this.state.zenModeEnabled\n                          }\n                          UIOptions={this.props.UIOptions}\n                          onImageAction={this.onImageAction}\n                          onExportImage={this.onExportImage}\n                          renderWelcomeScreen={\n                            !this.state.isLoading &&\n                            this.state.showWelcomeScreen &&\n                            this.state.activeTool.type === \"selection\" &&\n                            !this.state.zenModeEnabled &&\n                            !this.scene.getElementsIncludingDeleted().length\n                          }\n                          app={this}\n                        >\n                          {this.props.children}\n                        </LayerUI>\n                        <div className=\"excalidraw-textEditorContainer\" />\n                        <div className=\"excalidraw-contextMenuContainer\" />\n                        <div className=\"excalidraw-eye-dropper-container\" />\n                        {selectedElement.length === 1 &&\n                          !this.state.contextMenu &&\n                          this.state.showHyperlinkPopup && (\n                            <Hyperlink\n                              key={selectedElement[0].id}\n                              element={selectedElement[0]}\n                              setAppState={this.setAppState}\n                              onLinkOpen={this.props.onLinkOpen}\n                            />\n                          )}\n                        {this.state.toast !== null && (\n                          <Toast\n                            message={this.state.toast.message}\n                            onClose={() => this.setToast(null)}\n                            duration={this.state.toast.duration}\n                            closable={this.state.toast.closable}\n                          />\n                        )}\n                        {this.state.contextMenu && (\n                          <ContextMenu\n                            items={this.state.contextMenu.items}\n                            top={this.state.contextMenu.top}\n                            left={this.state.contextMenu.left}\n                            actionManager={this.actionManager}\n                          />\n                        )}\n                        <main>{this.renderCanvas()}</main>\n                        {this.renderFrameNames()}\n                      </ExcalidrawActionManagerContext.Provider>\n                    </ExcalidrawElementsContext.Provider>\n                  </ExcalidrawAppStateContext.Provider>\n                </ExcalidrawSetAppStateContext.Provider>\n              </DeviceContext.Provider>\n            </ExcalidrawContainerContext.Provider>\n          </AppPropsContext.Provider>\n        </AppContext.Provider>\n      </div>\n    );\n  }\n\n  public focusContainer: AppClassProperties[\"focusContainer\"] = () => {\n    this.excalidrawContainerRef.current?.focus();\n  };\n\n  public getSceneElementsIncludingDeleted = () => {\n    return this.scene.getElementsIncludingDeleted();\n  };\n\n  public getSceneElements = () => {\n    return this.scene.getNonDeletedElements();\n  };\n\n  public onInsertElements = (elements: readonly ExcalidrawElement[]) => {\n    this.addElementsFromPasteOrLibrary({\n      elements,\n      position: \"center\",\n      files: null,\n    });\n  };\n\n  public onExportImage = async (\n    type: keyof typeof EXPORT_IMAGE_TYPES,\n    elements: readonly NonDeletedExcalidrawElement[],\n  ) => {\n    trackEvent(\"export\", type, \"ui\");\n    const fileHandle = await exportCanvas(\n      type,\n      elements,\n      this.state,\n      this.files,\n      {\n        exportBackground: this.state.exportBackground,\n        name: this.state.name,\n        viewBackgroundColor: this.state.viewBackgroundColor,\n      },\n    )\n      .catch(muteFSAbortError)\n      .catch((error) => {\n        console.error(error);\n        this.setState({ errorMessage: error.message });\n      });\n\n    if (\n      this.state.exportEmbedScene &&\n      fileHandle &&\n      isImageFileHandle(fileHandle)\n    ) {\n      this.setState({ fileHandle });\n    }\n  };\n\n  private openEyeDropper = ({ type }: { type: \"stroke\" | \"background\" }) => {\n    jotaiStore.set(activeEyeDropperAtom, {\n      swapPreviewOnAlt: true,\n      previewType: type === \"stroke\" ? \"strokeColor\" : \"backgroundColor\",\n      onSelect: (color, event) => {\n        const shouldUpdateStrokeColor =\n          (type === \"background\" && event.altKey) ||\n          (type === \"stroke\" && !event.altKey);\n        const selectedElements = this.scene.getSelectedElements(this.state);\n        if (\n          !selectedElements.length ||\n          this.state.activeTool.type !== \"selection\"\n        ) {\n          if (shouldUpdateStrokeColor) {\n            this.setState({\n              currentItemStrokeColor: color,\n            });\n          } else {\n            this.setState({\n              currentItemBackgroundColor: color,\n            });\n          }\n        } else {\n          this.updateScene({\n            elements: this.scene.getElementsIncludingDeleted().map((el) => {\n              if (this.state.selectedElementIds[el.id]) {\n                return newElementWith(el, {\n                  [shouldUpdateStrokeColor ? \"strokeColor\" : \"backgroundColor\"]:\n                    color,\n                });\n              }\n              return el;\n            }),\n          });\n        }\n      },\n      keepOpenOnAlt: false,\n    });\n  };\n\n  private syncActionResult = withBatchedUpdates(\n    (actionResult: ActionResult) => {\n      if (this.unmounted || actionResult === false) {\n        return;\n      }\n\n      let editingElement: AppState[\"editingElement\"] | null = null;\n      if (actionResult.elements) {\n        actionResult.elements.forEach((element) => {\n          if (\n            this.state.editingElement?.id === element.id &&\n            this.state.editingElement !== element &&\n            isNonDeletedElement(element)\n          ) {\n            editingElement = element;\n          }\n        });\n        this.scene.replaceAllElements(actionResult.elements);\n        if (actionResult.commitToHistory) {\n          this.history.resumeRecording();\n        }\n      }\n\n      if (actionResult.files) {\n        this.files = actionResult.replaceFiles\n          ? actionResult.files\n          : { ...this.files, ...actionResult.files };\n        this.addNewImagesToImageCache();\n      }\n\n      if (actionResult.appState || editingElement || this.state.contextMenu) {\n        if (actionResult.commitToHistory) {\n          this.history.resumeRecording();\n        }\n\n        let viewModeEnabled = actionResult?.appState?.viewModeEnabled || false;\n        let zenModeEnabled = actionResult?.appState?.zenModeEnabled || false;\n        let gridSize = actionResult?.appState?.gridSize || null;\n        const theme =\n          actionResult?.appState?.theme || this.props.theme || THEME.LIGHT;\n        let name = actionResult?.appState?.name ?? this.state.name;\n        const errorMessage =\n          actionResult?.appState?.errorMessage ?? this.state.errorMessage;\n        if (typeof this.props.viewModeEnabled !== \"undefined\") {\n          viewModeEnabled = this.props.viewModeEnabled;\n        }\n\n        if (typeof this.props.zenModeEnabled !== \"undefined\") {\n          zenModeEnabled = this.props.zenModeEnabled;\n        }\n\n        if (typeof this.props.gridModeEnabled !== \"undefined\") {\n          gridSize = this.props.gridModeEnabled ? GRID_SIZE : null;\n        }\n\n        if (typeof this.props.name !== \"undefined\") {\n          name = this.props.name;\n        }\n\n        editingElement =\n          editingElement || actionResult.appState?.editingElement || null;\n\n        if (editingElement?.isDeleted) {\n          editingElement = null;\n        }\n\n        this.setState(\n          (state) => {\n            // using Object.assign instead of spread to fool TS 4.2.2+ into\n            // regarding the resulting type as not containing undefined\n            // (which the following expression will never contain)\n            return Object.assign(actionResult.appState || {}, {\n              // NOTE this will prevent opening context menu using an action\n              // or programmatically from the host, so it will need to be\n              // rewritten later\n              contextMenu: null,\n              editingElement,\n              viewModeEnabled,\n              zenModeEnabled,\n              gridSize,\n              theme,\n              name,\n              errorMessage,\n            });\n          },\n          () => {\n            if (actionResult.syncHistory) {\n              this.history.setCurrentState(\n                this.state,\n                this.scene.getElementsIncludingDeleted(),\n              );\n            }\n          },\n        );\n      }\n    },\n  );\n\n  // Lifecycle\n\n  private onBlur = withBatchedUpdates(() => {\n    isHoldingSpace = false;\n    this.setState({ isBindingEnabled: true });\n  });\n\n  private onUnload = () => {\n    this.onBlur();\n  };\n\n  private disableEvent: EventListener = (event) => {\n    event.preventDefault();\n  };\n\n  private resetHistory = () => {\n    this.history.clear();\n  };\n\n  /**\n   * Resets scene & history.\n   * ! Do not use to clear scene user action !\n   */\n  private resetScene = withBatchedUpdates(\n    (opts?: { resetLoadingState: boolean }) => {\n      this.scene.replaceAllElements([]);\n      this.setState((state) => ({\n        ...getDefaultAppState(),\n        isLoading: opts?.resetLoadingState ? false : state.isLoading,\n        theme: this.state.theme,\n      }));\n      this.resetHistory();\n    },\n  );\n\n  private initializeScene = async () => {\n    if (\"launchQueue\" in window && \"LaunchParams\" in window) {\n      (window as any).launchQueue.setConsumer(\n        async (launchParams: { files: any[] }) => {\n          if (!launchParams.files.length) {\n            return;\n          }\n          const fileHandle = launchParams.files[0];\n          const blob: Blob = await fileHandle.getFile();\n          this.loadFileToCanvas(\n            new File([blob], blob.name || \"\", { type: blob.type }),\n            fileHandle,\n          );\n        },\n      );\n    }\n\n    if (this.props.theme) {\n      this.setState({ theme: this.props.theme });\n    }\n    if (!this.state.isLoading) {\n      this.setState({ isLoading: true });\n    }\n    let initialData = null;\n    try {\n      initialData = (await this.props.initialData) || null;\n      if (initialData?.libraryItems) {\n        this.library\n          .updateLibrary({\n            libraryItems: initialData.libraryItems,\n            merge: true,\n          })\n          .catch((error) => {\n            console.error(error);\n          });\n      }\n    } catch (error: any) {\n      console.error(error);\n      initialData = {\n        appState: {\n          errorMessage:\n            error.message ||\n            \"Encountered an error during importing or restoring scene data\",\n        },\n      };\n    }\n    const scene = restore(initialData, null, null, { repairBindings: true });\n    scene.appState = {\n      ...scene.appState,\n      theme: this.props.theme || scene.appState.theme,\n      // we're falling back to current (pre-init) state when deciding\n      // whether to open the library, to handle a case where we\n      // update the state outside of initialData (e.g. when loading the app\n      // with a library install link, which should auto-open the library)\n      openSidebar: scene.appState?.openSidebar || this.state.openSidebar,\n      activeTool:\n        scene.appState.activeTool.type === \"image\"\n          ? { ...scene.appState.activeTool, type: \"selection\" }\n          : scene.appState.activeTool,\n      isLoading: false,\n      toast: this.state.toast,\n    };\n    if (initialData?.scrollToContent) {\n      scene.appState = {\n        ...scene.appState,\n        ...calculateScrollCenter(\n          scene.elements,\n          {\n            ...scene.appState,\n            width: this.state.width,\n            height: this.state.height,\n            offsetTop: this.state.offsetTop,\n            offsetLeft: this.state.offsetLeft,\n          },\n          null,\n        ),\n      };\n    }\n    // FontFaceSet loadingdone event we listen on may not always fire\n    // (looking at you Safari), so on init we manually load fonts for current\n    // text elements on canvas, and rerender them once done. This also\n    // seems faster even in browsers that do fire the loadingdone event.\n    this.fonts.loadFontsForElements(scene.elements);\n\n    this.resetHistory();\n    this.syncActionResult({\n      ...scene,\n      commitToHistory: true,\n    });\n  };\n\n  private refreshDeviceState = (container: HTMLDivElement) => {\n    const { width, height } = container.getBoundingClientRect();\n    const sidebarBreakpoint =\n      this.props.UIOptions.dockedSidebarBreakpoint != null\n        ? this.props.UIOptions.dockedSidebarBreakpoint\n        : MQ_RIGHT_SIDEBAR_MIN_WIDTH;\n    this.device = updateObject(this.device, {\n      isLandscape: width > height,\n      isSmScreen: width < MQ_SM_MAX_WIDTH,\n      isMobile:\n        width < MQ_MAX_WIDTH_PORTRAIT ||\n        (height < MQ_MAX_HEIGHT_LANDSCAPE && width < MQ_MAX_WIDTH_LANDSCAPE),\n      canDeviceFitSidebar: width > sidebarBreakpoint,\n    });\n  };\n\n  public async componentDidMount() {\n    this.unmounted = false;\n    this.excalidrawContainerValue.container =\n      this.excalidrawContainerRef.current;\n\n    if (\n      process.env.NODE_ENV === ENV.TEST ||\n      process.env.NODE_ENV === ENV.DEVELOPMENT\n    ) {\n      const setState = this.setState.bind(this);\n      Object.defineProperties(window.h, {\n        state: {\n          configurable: true,\n          get: () => {\n            return this.state;\n          },\n        },\n        setState: {\n          configurable: true,\n          value: (...args: Parameters<typeof setState>) => {\n            return this.setState(...args);\n          },\n        },\n        app: {\n          configurable: true,\n          value: this,\n        },\n        history: {\n          configurable: true,\n          value: this.history,\n        },\n      });\n    }\n\n    this.scene.addCallback(this.onSceneUpdated);\n    this.addEventListeners();\n\n    if (this.props.autoFocus && this.excalidrawContainerRef.current) {\n      this.focusContainer();\n    }\n\n    if (\n      this.excalidrawContainerRef.current &&\n      // bounding rects don't work in tests so updating\n      // the state on init would result in making the test enviro run\n      // in mobile breakpoint (0 width/height), making everything fail\n      process.env.NODE_ENV !== \"test\"\n    ) {\n      this.refreshDeviceState(this.excalidrawContainerRef.current);\n    }\n\n    if (\"ResizeObserver\" in window && this.excalidrawContainerRef?.current) {\n      this.resizeObserver = new ResizeObserver(() => {\n        THROTTLE_NEXT_RENDER = false;\n        // recompute device dimensions state\n        // ---------------------------------------------------------------------\n        this.refreshDeviceState(this.excalidrawContainerRef.current!);\n        // refresh offsets\n        // ---------------------------------------------------------------------\n        this.updateDOMRect();\n      });\n      this.resizeObserver?.observe(this.excalidrawContainerRef.current);\n    } else if (window.matchMedia) {\n      const mdScreenQuery = window.matchMedia(\n        `(max-width: ${MQ_MAX_WIDTH_PORTRAIT}px), (max-height: ${MQ_MAX_HEIGHT_LANDSCAPE}px) and (max-width: ${MQ_MAX_WIDTH_LANDSCAPE}px)`,\n      );\n      const smScreenQuery = window.matchMedia(\n        `(max-width: ${MQ_SM_MAX_WIDTH}px)`,\n      );\n      const canDeviceFitSidebarMediaQuery = window.matchMedia(\n        `(min-width: ${\n          // NOTE this won't update if a different breakpoint is supplied\n          // after mount\n          this.props.UIOptions.dockedSidebarBreakpoint != null\n            ? this.props.UIOptions.dockedSidebarBreakpoint\n            : MQ_RIGHT_SIDEBAR_MIN_WIDTH\n        }px)`,\n      );\n      const handler = () => {\n        this.excalidrawContainerRef.current!.getBoundingClientRect();\n        this.device = updateObject(this.device, {\n          isSmScreen: smScreenQuery.matches,\n          isMobile: mdScreenQuery.matches,\n          canDeviceFitSidebar: canDeviceFitSidebarMediaQuery.matches,\n        });\n      };\n      mdScreenQuery.addListener(handler);\n      this.detachIsMobileMqHandler = () =>\n        mdScreenQuery.removeListener(handler);\n    }\n\n    const searchParams = new URLSearchParams(window.location.search.slice(1));\n\n    if (searchParams.has(\"web-share-target\")) {\n      // Obtain a file that was shared via the Web Share Target API.\n      this.restoreFileFromShare();\n    } else {\n      this.updateDOMRect(this.initializeScene);\n    }\n\n    // note that this check seems to always pass in localhost\n    if (isBrave() && !isMeasureTextSupported()) {\n      this.setState({\n        errorMessage: <BraveMeasureTextError />,\n      });\n    }\n  }\n\n  public componentWillUnmount() {\n    this.files = {};\n    this.imageCache.clear();\n    this.resizeObserver?.disconnect();\n    this.unmounted = true;\n    this.removeEventListeners();\n    this.scene.destroy();\n    this.library.destroy();\n    clearTimeout(touchTimeout);\n    isSomeElementSelected.clearCache();\n    touchTimeout = 0;\n  }\n\n  private onResize = withBatchedUpdates(() => {\n    this.scene\n      .getElementsIncludingDeleted()\n      .forEach((element) => invalidateShapeForElement(element));\n    this.setState({});\n  });\n\n  private removeEventListeners() {\n    document.removeEventListener(EVENT.POINTER_UP, this.removePointer);\n    document.removeEventListener(EVENT.COPY, this.onCopy);\n    document.removeEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.removeEventListener(EVENT.CUT, this.onCut);\n    this.excalidrawContainerRef.current?.removeEventListener(\n      EVENT.WHEEL,\n      this.onWheel,\n    );\n    this.nearestScrollableContainer?.removeEventListener(\n      EVENT.SCROLL,\n      this.onScroll,\n    );\n    document.removeEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    document.removeEventListener(\n      EVENT.MOUSE_MOVE,\n      this.updateCurrentCursorPosition,\n      false,\n    );\n    document.removeEventListener(EVENT.KEYUP, this.onKeyUp);\n    window.removeEventListener(EVENT.RESIZE, this.onResize, false);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.removeEventListener(EVENT.BLUR, this.onBlur, false);\n    this.excalidrawContainerRef.current?.removeEventListener(\n      EVENT.DRAG_OVER,\n      this.disableEvent,\n      false,\n    );\n    this.excalidrawContainerRef.current?.removeEventListener(\n      EVENT.DROP,\n      this.disableEvent,\n      false,\n    );\n\n    document.removeEventListener(\n      EVENT.GESTURE_START,\n      this.onGestureStart as any,\n      false,\n    );\n    document.removeEventListener(\n      EVENT.GESTURE_CHANGE,\n      this.onGestureChange as any,\n      false,\n    );\n    document.removeEventListener(\n      EVENT.GESTURE_END,\n      this.onGestureEnd as any,\n      false,\n    );\n\n    this.detachIsMobileMqHandler?.();\n  }\n\n  private addEventListeners() {\n    this.removeEventListeners();\n    document.addEventListener(EVENT.POINTER_UP, this.removePointer); // #3553\n    document.addEventListener(EVENT.COPY, this.onCopy);\n    this.excalidrawContainerRef.current?.addEventListener(\n      EVENT.WHEEL,\n      this.onWheel,\n      { passive: false },\n    );\n\n    if (this.props.handleKeyboardGlobally) {\n      document.addEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    }\n    document.addEventListener(EVENT.KEYUP, this.onKeyUp, { passive: true });\n    document.addEventListener(\n      EVENT.MOUSE_MOVE,\n      this.updateCurrentCursorPosition,\n    );\n    // rerender text elements on font load to fix #637 && #1553\n    document.fonts?.addEventListener?.(\"loadingdone\", (event) => {\n      const loadedFontFaces = (event as FontFaceSetLoadEvent).fontfaces;\n      this.fonts.onFontsLoaded(loadedFontFaces);\n    });\n\n    // Safari-only desktop pinch zoom\n    document.addEventListener(\n      EVENT.GESTURE_START,\n      this.onGestureStart as any,\n      false,\n    );\n    document.addEventListener(\n      EVENT.GESTURE_CHANGE,\n      this.onGestureChange as any,\n      false,\n    );\n    document.addEventListener(\n      EVENT.GESTURE_END,\n      this.onGestureEnd as any,\n      false,\n    );\n    if (this.state.viewModeEnabled) {\n      return;\n    }\n\n    document.addEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.addEventListener(EVENT.CUT, this.onCut);\n    if (this.props.detectScroll) {\n      this.nearestScrollableContainer = getNearestScrollableContainer(\n        this.excalidrawContainerRef.current!,\n      );\n      this.nearestScrollableContainer.addEventListener(\n        EVENT.SCROLL,\n        this.onScroll,\n      );\n    }\n    window.addEventListener(EVENT.RESIZE, this.onResize, false);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.addEventListener(EVENT.BLUR, this.onBlur, false);\n    this.excalidrawContainerRef.current?.addEventListener(\n      EVENT.DRAG_OVER,\n      this.disableEvent,\n      false,\n    );\n    this.excalidrawContainerRef.current?.addEventListener(\n      EVENT.DROP,\n      this.disableEvent,\n      false,\n    );\n  }\n\n  componentDidUpdate(prevProps: AppProps, prevState: AppState) {\n    if (\n      !this.state.showWelcomeScreen &&\n      !this.scene.getElementsIncludingDeleted().length\n    ) {\n      this.setState({ showWelcomeScreen: true });\n    }\n\n    if (\n      this.excalidrawContainerRef.current &&\n      prevProps.UIOptions.dockedSidebarBreakpoint !==\n        this.props.UIOptions.dockedSidebarBreakpoint\n    ) {\n      this.refreshDeviceState(this.excalidrawContainerRef.current);\n    }\n\n    if (\n      prevState.scrollX !== this.state.scrollX ||\n      prevState.scrollY !== this.state.scrollY\n    ) {\n      this.props?.onScrollChange?.(this.state.scrollX, this.state.scrollY);\n    }\n\n    if (\n      Object.keys(this.state.selectedElementIds).length &&\n      isEraserActive(this.state)\n    ) {\n      this.setState({\n        activeTool: updateActiveTool(this.state, { type: \"selection\" }),\n      });\n    }\n    if (\n      this.state.activeTool.type === \"eraser\" &&\n      prevState.theme !== this.state.theme\n    ) {\n      setEraserCursor(this.canvas, this.state.theme);\n    }\n    // Hide hyperlink popup if shown when element type is not selection\n    if (\n      prevState.activeTool.type === \"selection\" &&\n      this.state.activeTool.type !== \"selection\" &&\n      this.state.showHyperlinkPopup\n    ) {\n      this.setState({ showHyperlinkPopup: false });\n    }\n    if (prevProps.langCode !== this.props.langCode) {\n      this.updateLanguage();\n    }\n\n    if (prevProps.viewModeEnabled !== this.props.viewModeEnabled) {\n      this.setState({ viewModeEnabled: !!this.props.viewModeEnabled });\n    }\n\n    if (prevState.viewModeEnabled !== this.state.viewModeEnabled) {\n      this.addEventListeners();\n      this.deselectElements();\n    }\n\n    if (prevProps.zenModeEnabled !== this.props.zenModeEnabled) {\n      this.setState({ zenModeEnabled: !!this.props.zenModeEnabled });\n    }\n\n    if (prevProps.theme !== this.props.theme && this.props.theme) {\n      this.setState({ theme: this.props.theme });\n    }\n\n    if (prevProps.gridModeEnabled !== this.props.gridModeEnabled) {\n      this.setState({\n        gridSize: this.props.gridModeEnabled ? GRID_SIZE : null,\n      });\n    }\n\n    if (this.props.name && prevProps.name !== this.props.name) {\n      this.setState({\n        name: this.props.name,\n      });\n    }\n\n    this.excalidrawContainerRef.current?.classList.toggle(\n      \"theme--dark\",\n      this.state.theme === \"dark\",\n    );\n\n    if (\n      this.state.editingLinearElement &&\n      !this.state.selectedElementIds[this.state.editingLinearElement.elementId]\n    ) {\n      // defer so that the commitToHistory flag isn't reset via current update\n      setTimeout(() => {\n        // execute only if the condition still holds when the deferred callback\n        // executes (it can be scheduled multiple times depending on how\n        // many times the component renders)\n        this.state.editingLinearElement &&\n          this.actionManager.executeAction(actionFinalize);\n      });\n    }\n\n    // failsafe in case the state is being updated in incorrect order resulting\n    // in the editingElement being now a deleted element\n    if (this.state.editingElement?.isDeleted) {\n      this.setState({ editingElement: null });\n    }\n\n    if (\n      this.state.selectedLinearElement &&\n      !this.state.selectedElementIds[this.state.selectedLinearElement.elementId]\n    ) {\n      // To make sure `selectedLinearElement` is in sync with `selectedElementIds`, however this shouldn't be needed once\n      // we have a single API to update `selectedElementIds`\n      this.setState({ selectedLinearElement: null });\n    }\n\n    const { multiElement } = prevState;\n    if (\n      prevState.activeTool !== this.state.activeTool &&\n      multiElement != null &&\n      isBindingEnabled(this.state) &&\n      isBindingElement(multiElement, false)\n    ) {\n      maybeBindLinearElement(\n        multiElement,\n        this.state,\n        this.scene,\n        tupleToCoors(\n          LinearElementEditor.getPointAtIndexGlobalCoordinates(\n            multiElement,\n            -1,\n          ),\n        ),\n      );\n    }\n    this.renderScene();\n    this.history.record(this.state, this.scene.getElementsIncludingDeleted());\n\n    // Do not notify consumers if we're still loading the scene. Among other\n    // potential issues, this fixes a case where the tab isn't focused during\n    // init, which would trigger onChange with empty elements, which would then\n    // override whatever is in localStorage currently.\n    if (!this.state.isLoading) {\n      this.props.onChange?.(\n        this.scene.getElementsIncludingDeleted(),\n        this.state,\n        this.files,\n      );\n    }\n  }\n\n  private renderScene = () => {\n    const cursorButton: {\n      [id: string]: string | undefined;\n    } = {};\n    const pointerViewportCoords: RenderConfig[\"remotePointerViewportCoords\"] =\n      {};\n    const remoteSelectedElementIds: RenderConfig[\"remoteSelectedElementIds\"] =\n      {};\n    const pointerUsernames: { [id: string]: string } = {};\n    const pointerUserStates: { [id: string]: string } = {};\n    this.state.collaborators.forEach((user, socketId) => {\n      if (user.selectedElementIds) {\n        for (const id of Object.keys(user.selectedElementIds)) {\n          if (!(id in remoteSelectedElementIds)) {\n            remoteSelectedElementIds[id] = [];\n          }\n          remoteSelectedElementIds[id].push(socketId);\n        }\n      }\n      if (!user.pointer) {\n        return;\n      }\n      if (user.username) {\n        pointerUsernames[socketId] = user.username;\n      }\n      if (user.userState) {\n        pointerUserStates[socketId] = user.userState;\n      }\n      pointerViewportCoords[socketId] = sceneCoordsToViewportCoords(\n        {\n          sceneX: user.pointer.x,\n          sceneY: user.pointer.y,\n        },\n        this.state,\n      );\n      cursorButton[socketId] = user.button;\n    });\n\n    const renderingElements = this.scene\n      .getNonDeletedElements()\n      .filter((element) => {\n        if (isImageElement(element)) {\n          if (\n            // not placed on canvas yet (but in elements array)\n            this.state.pendingImageElementId === element.id\n          ) {\n            return false;\n          }\n        }\n        // don't render text element that's being currently edited (it's\n        // rendered on remote only)\n        return (\n          !this.state.editingElement ||\n          this.state.editingElement.type !== \"text\" ||\n          element.id !== this.state.editingElement.id\n        );\n      });\n\n    const selectionColor = getComputedStyle(\n      document.querySelector(\".excalidraw\")!,\n    ).getPropertyValue(\"--color-selection\");\n\n    renderScene(\n      {\n        elements: renderingElements,\n        appState: this.state,\n        scale: window.devicePixelRatio,\n        rc: this.rc!,\n        canvas: this.canvas!,\n        renderConfig: {\n          selectionColor,\n          scrollX: this.state.scrollX,\n          scrollY: this.state.scrollY,\n          viewBackgroundColor: this.state.viewBackgroundColor,\n          zoom: this.state.zoom,\n          remotePointerViewportCoords: pointerViewportCoords,\n          remotePointerButton: cursorButton,\n          remoteSelectedElementIds,\n          remotePointerUsernames: pointerUsernames,\n          remotePointerUserStates: pointerUserStates,\n          shouldCacheIgnoreZoom: this.state.shouldCacheIgnoreZoom,\n          theme: this.state.theme,\n          imageCache: this.imageCache,\n          isExporting: false,\n          renderScrollbars: false,\n        },\n        callback: ({ atLeastOneVisibleElement, scrollBars }) => {\n          if (scrollBars) {\n            currentScrollBars = scrollBars;\n          }\n          const scrolledOutside =\n            // hide when editing text\n            isTextElement(this.state.editingElement)\n              ? false\n              : !atLeastOneVisibleElement && renderingElements.length > 0;\n          if (this.state.scrolledOutside !== scrolledOutside) {\n            this.setState({ scrolledOutside });\n          }\n\n          this.scheduleImageRefresh();\n        },\n      },\n      THROTTLE_NEXT_RENDER && window.EXCALIDRAW_THROTTLE_RENDER === true,\n    );\n\n    if (!THROTTLE_NEXT_RENDER) {\n      THROTTLE_NEXT_RENDER = true;\n    }\n  };\n\n  private onScroll = debounce(() => {\n    const { offsetTop, offsetLeft } = this.getCanvasOffsets();\n    this.setState((state) => {\n      if (state.offsetLeft === offsetLeft && state.offsetTop === offsetTop) {\n        return null;\n      }\n      return { offsetTop, offsetLeft };\n    });\n  }, SCROLL_TIMEOUT);\n\n  // Copy/paste\n\n  private onCut = withBatchedUpdates((event: ClipboardEvent) => {\n    const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(\n      document.activeElement,\n    );\n    if (!isExcalidrawActive || isWritableElement(event.target)) {\n      return;\n    }\n    this.cutAll();\n    event.preventDefault();\n    event.stopPropagation();\n  });\n\n  private onCopy = withBatchedUpdates((event: ClipboardEvent) => {\n    const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(\n      document.activeElement,\n    );\n    if (!isExcalidrawActive || isWritableElement(event.target)) {\n      return;\n    }\n    this.copyAll();\n    event.preventDefault();\n    event.stopPropagation();\n  });\n\n  private cutAll = () => {\n    this.actionManager.executeAction(actionCut, \"keyboard\");\n  };\n\n  private copyAll = () => {\n    this.actionManager.executeAction(actionCopy, \"keyboard\");\n  };\n\n  private static resetTapTwice() {\n    didTapTwice = false;\n  }\n\n  private onTapStart = (event: TouchEvent) => {\n    // fix for Apple Pencil Scribble\n    // On Android, preventing the event would disable contextMenu on tap-hold\n    if (!isAndroid) {\n      event.preventDefault();\n    }\n\n    if (!didTapTwice) {\n      didTapTwice = true;\n      clearTimeout(tappedTwiceTimer);\n      tappedTwiceTimer = window.setTimeout(\n        App.resetTapTwice,\n        TAP_TWICE_TIMEOUT,\n      );\n      return;\n    }\n    // insert text only if we tapped twice with a single finger\n    // event.touches.length === 1 will also prevent inserting text when user's zooming\n    if (didTapTwice && event.touches.length === 1) {\n      const [touch] = event.touches;\n      // @ts-ignore\n      this.handleCanvasDoubleClick({\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n      });\n      didTapTwice = false;\n      clearTimeout(tappedTwiceTimer);\n    }\n    if (isAndroid) {\n      event.preventDefault();\n    }\n\n    if (event.touches.length === 2) {\n      this.setState({\n        selectedElementIds: makeNextSelectedElementIds({}, this.state),\n      });\n    }\n  };\n\n  private onTapEnd = (event: TouchEvent) => {\n    this.resetContextMenuTimer();\n    if (event.touches.length > 0) {\n      this.setState({\n        previousSelectedElementIds: {},\n        selectedElementIds: makeNextSelectedElementIds(\n          this.state.previousSelectedElementIds,\n          this.state,\n        ),\n      });\n    } else {\n      gesture.pointers.clear();\n    }\n  };\n\n  public pasteFromClipboard = withBatchedUpdates(\n    async (event: ClipboardEvent | null) => {\n      const isPlainPaste = !!(IS_PLAIN_PASTE && event);\n\n      // #686\n      const target = document.activeElement;\n      const isExcalidrawActive =\n        this.excalidrawContainerRef.current?.contains(target);\n      if (event && !isExcalidrawActive) {\n        return;\n      }\n\n      const elementUnderCursor = document.elementFromPoint(\n        this.lastViewportPosition.x,\n        this.lastViewportPosition.y,\n      );\n      if (\n        event &&\n        (!(elementUnderCursor instanceof HTMLCanvasElement) ||\n          isWritableElement(target))\n      ) {\n        return;\n      }\n\n      // must be called in the same frame (thus before any awaits) as the paste\n      // event else some browsers (FF...) will clear the clipboardData\n      // (something something security)\n      let file = event?.clipboardData?.files[0];\n\n      const data = await parseClipboard(event, isPlainPaste);\n\n      if (!file && data.text && !isPlainPaste) {\n        const string = data.text.trim();\n        if (string.startsWith(\"<svg\") && string.endsWith(\"</svg>\")) {\n          // ignore SVG validation/normalization which will be done during image\n          // initialization\n          file = SVGStringToFile(string);\n        }\n      }\n\n      // prefer spreadsheet data over image file (MS Office/Libre Office)\n      if (isSupportedImageFile(file) && !data.spreadsheet) {\n        const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n          {\n            clientX: this.lastViewportPosition.x,\n            clientY: this.lastViewportPosition.y,\n          },\n          this.state,\n        );\n\n        const imageElement = this.createImageElement({ sceneX, sceneY });\n        this.insertImageElement(imageElement, file);\n        this.initializeImageDimensions(imageElement);\n        this.setState({\n          selectedElementIds: makeNextSelectedElementIds(\n            {\n              [imageElement.id]: true,\n            },\n            this.state,\n          ),\n        });\n\n        return;\n      }\n\n      if (this.props.onPaste) {\n        try {\n          if ((await this.props.onPaste(data, event)) === false) {\n            return;\n          }\n        } catch (error: any) {\n          console.error(error);\n        }\n      }\n\n      if (data.errorMessage) {\n        this.setState({ errorMessage: data.errorMessage });\n      } else if (data.spreadsheet && !isPlainPaste) {\n        this.setState({\n          pasteDialog: {\n            data: data.spreadsheet,\n            shown: true,\n          },\n        });\n      } else if (data.elements) {\n        // TODO remove formatting from elements if isPlainPaste\n        this.addElementsFromPasteOrLibrary({\n          elements: data.elements,\n          files: data.files || null,\n          position: \"cursor\",\n          retainSeed: isPlainPaste,\n        });\n      } else if (data.text) {\n        this.addTextFromPaste(data.text, isPlainPaste);\n      }\n      this.setActiveTool({ type: \"selection\" });\n      event?.preventDefault();\n    },\n  );\n\n  private addElementsFromPasteOrLibrary = (opts: {\n    elements: readonly ExcalidrawElement[];\n    files: BinaryFiles | null;\n    position: { clientX: number; clientY: number } | \"cursor\" | \"center\";\n    retainSeed?: boolean;\n  }) => {\n    const elements = restoreElements(opts.elements, null);\n    const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n\n    const elementsCenterX = distance(minX, maxX) / 2;\n    const elementsCenterY = distance(minY, maxY) / 2;\n\n    const clientX =\n      typeof opts.position === \"object\"\n        ? opts.position.clientX\n        : opts.position === \"cursor\"\n        ? this.lastViewportPosition.x\n        : this.state.width / 2 + this.state.offsetLeft;\n    const clientY =\n      typeof opts.position === \"object\"\n        ? opts.position.clientY\n        : opts.position === \"cursor\"\n        ? this.lastViewportPosition.y\n        : this.state.height / 2 + this.state.offsetTop;\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX, clientY },\n      this.state,\n    );\n\n    const dx = x - elementsCenterX;\n    const dy = y - elementsCenterY;\n\n    const [gridX, gridY] = getGridPoint(dx, dy, this.state.gridSize);\n\n    const newElements = duplicateElements(\n      elements.map((element) => {\n        return newElementWith(element, {\n          x: element.x + gridX - minX,\n          y: element.y + gridY - minY,\n        });\n      }),\n      {\n        randomizeSeed: !opts.retainSeed,\n      },\n    );\n\n    const nextElements = [\n      ...this.scene.getElementsIncludingDeleted(),\n      ...newElements,\n    ];\n\n    this.scene.replaceAllElements(nextElements);\n\n    newElements.forEach((newElement) => {\n      if (isTextElement(newElement) && isBoundToContainer(newElement)) {\n        const container = getContainerElement(newElement);\n        redrawTextBoundingBox(newElement, container);\n      }\n    });\n\n    if (opts.files) {\n      this.files = { ...this.files, ...opts.files };\n    }\n\n    this.history.resumeRecording();\n\n    const nextElementsToSelect =\n      excludeElementsInFramesFromSelection(newElements);\n\n    this.setState(\n      selectGroupsForSelectedElements(\n        {\n          ...this.state,\n          // keep sidebar (presumably the library) open if it's docked and\n          // can fit.\n          //\n          // Note, we should close the sidebar only if we're dropping items\n          // from library, not when pasting from clipboard. Alas.\n          openSidebar:\n            this.state.openSidebar &&\n            this.device.canDeviceFitSidebar &&\n            jotaiStore.get(isSidebarDockedAtom)\n              ? this.state.openSidebar\n              : null,\n          selectedElementIds: nextElementsToSelect.reduce(\n            (acc: Record<ExcalidrawElement[\"id\"], true>, element) => {\n              if (!isBoundToContainer(element)) {\n                acc[element.id] = true;\n              }\n              return acc;\n            },\n            {},\n          ),\n          selectedGroupIds: {},\n        },\n        this.scene.getNonDeletedElements(),\n        this.state,\n        this,\n      ),\n      () => {\n        if (opts.files) {\n          this.addNewImagesToImageCache();\n        }\n      },\n    );\n    this.setActiveTool({ type: \"selection\" });\n  };\n\n  private addTextFromPaste(text: string, isPlainPaste = false) {\n    const { x, y } = viewportCoordsToSceneCoords(\n      {\n        clientX: this.lastViewportPosition.x,\n        clientY: this.lastViewportPosition.y,\n      },\n      this.state,\n    );\n\n    const textElementProps = {\n      x,\n      y,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roundness: null,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      text,\n      fontSize: this.state.currentItemFontSize,\n      fontFamily: this.state.currentItemFontFamily,\n      textAlign: this.state.currentItemTextAlign,\n      verticalAlign: DEFAULT_VERTICAL_ALIGN,\n      locked: false,\n    };\n\n    const LINE_GAP = 10;\n    let currentY = y;\n\n    const lines = isPlainPaste ? [text] : text.split(\"\\n\");\n    const textElements = lines.reduce(\n      (acc: ExcalidrawTextElement[], line, idx) => {\n        const text = line.trim();\n\n        const lineHeight = getDefaultLineHeight(textElementProps.fontFamily);\n        if (text.length) {\n          const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n            x,\n            y: currentY,\n          });\n\n          const element = newTextElement({\n            ...textElementProps,\n            x,\n            y: currentY,\n            text,\n            lineHeight,\n            frameId: topLayerFrame ? topLayerFrame.id : null,\n          });\n          acc.push(element);\n          currentY += element.height + LINE_GAP;\n        } else {\n          const prevLine = lines[idx - 1]?.trim();\n          // add paragraph only if previous line was not empty, IOW don't add\n          // more than one empty line\n          if (prevLine) {\n            currentY +=\n              getLineHeightInPx(textElementProps.fontSize, lineHeight) +\n              LINE_GAP;\n          }\n        }\n\n        return acc;\n      },\n      [],\n    );\n\n    if (textElements.length === 0) {\n      return;\n    }\n\n    const frameId = textElements[0].frameId;\n\n    if (frameId) {\n      this.scene.insertElementsAtIndex(\n        textElements,\n        this.scene.getElementIndex(frameId),\n      );\n    } else {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        ...textElements,\n      ]);\n    }\n\n    this.setState({\n      selectedElementIds: makeNextSelectedElementIds(\n        Object.fromEntries(textElements.map((el) => [el.id, true])),\n        this.state,\n      ),\n    });\n\n    if (\n      !isPlainPaste &&\n      textElements.length > 1 &&\n      PLAIN_PASTE_TOAST_SHOWN === false &&\n      !this.device.isMobile\n    ) {\n      this.setToast({\n        message: t(\"toast.pasteAsSingleElement\", {\n          shortcut: getShortcutKey(\"CtrlOrCmd+Shift+V\"),\n        }),\n        duration: 5000,\n      });\n      PLAIN_PASTE_TOAST_SHOWN = true;\n    }\n\n    this.history.resumeRecording();\n  }\n\n  setAppState: React.Component<any, AppState>[\"setState\"] = (\n    state,\n    callback,\n  ) => {\n    this.setState(state, callback);\n  };\n\n  removePointer = (event: React.PointerEvent<HTMLElement> | PointerEvent) => {\n    if (touchTimeout) {\n      this.resetContextMenuTimer();\n    }\n\n    gesture.pointers.delete(event.pointerId);\n  };\n\n  toggleLock = (source: \"keyboard\" | \"ui\" = \"ui\") => {\n    if (!this.state.activeTool.locked) {\n      trackEvent(\n        \"toolbar\",\n        \"toggleLock\",\n        `${source} (${this.device.isMobile ? \"mobile\" : \"desktop\"})`,\n      );\n    }\n    this.setState((prevState) => {\n      return {\n        activeTool: {\n          ...prevState.activeTool,\n          ...updateActiveTool(\n            this.state,\n            prevState.activeTool.locked\n              ? { type: \"selection\" }\n              : prevState.activeTool,\n          ),\n          locked: !prevState.activeTool.locked,\n        },\n      };\n    });\n  };\n\n  updateFrameRendering = (\n    opts:\n      | Partial<AppState[\"frameRendering\"]>\n      | ((\n          prevState: AppState[\"frameRendering\"],\n        ) => Partial<AppState[\"frameRendering\"]>),\n  ) => {\n    this.setState((prevState) => {\n      const next =\n        typeof opts === \"function\" ? opts(prevState.frameRendering) : opts;\n      return {\n        frameRendering: {\n          enabled: next?.enabled ?? prevState.frameRendering.enabled,\n          clip: next?.clip ?? prevState.frameRendering.clip,\n          name: next?.name ?? prevState.frameRendering.name,\n          outline: next?.outline ?? prevState.frameRendering.outline,\n        },\n      };\n    });\n  };\n\n  togglePenMode = () => {\n    this.setState((prevState) => {\n      return {\n        penMode: !prevState.penMode,\n      };\n    });\n  };\n\n  onHandToolToggle = () => {\n    this.actionManager.executeAction(actionToggleHandTool);\n  };\n\n  /**\n   * Zooms on canvas viewport center\n   */\n  zoomCanvas = (\n    /** decimal fraction between 0.1 (10% zoom) and 30 (3000% zoom) */\n    value: number,\n  ) => {\n    this.setState({\n      ...getStateForZoom(\n        {\n          viewportX: this.state.width / 2 + this.state.offsetLeft,\n          viewportY: this.state.height / 2 + this.state.offsetTop,\n          nextZoom: getNormalizedZoom(value),\n        },\n        this.state,\n      ),\n    });\n  };\n\n  private cancelInProgresAnimation: (() => void) | null = null;\n\n  scrollToContent = (\n    target:\n      | ExcalidrawElement\n      | readonly ExcalidrawElement[] = this.scene.getNonDeletedElements(),\n    opts?:\n      | {\n          fitToContent?: boolean;\n          fitToViewport?: never;\n          viewportZoomFactor?: never;\n          animate?: boolean;\n          duration?: number;\n        }\n      | {\n          fitToContent?: never;\n          fitToViewport?: boolean;\n          /** when fitToViewport=true, how much screen should the content cover,\n           * between 0.1 (10%) and 1 (100%)\n           */\n          viewportZoomFactor?: number;\n          animate?: boolean;\n          duration?: number;\n        },\n  ) => {\n    this.cancelInProgresAnimation?.();\n\n    // convert provided target into ExcalidrawElement[] if necessary\n    const targetElements = Array.isArray(target) ? target : [target];\n\n    let zoom = this.state.zoom;\n    let scrollX = this.state.scrollX;\n    let scrollY = this.state.scrollY;\n\n    if (opts?.fitToContent || opts?.fitToViewport) {\n      const { appState } = zoomToFit({\n        targetElements,\n        appState: this.state,\n        fitToViewport: !!opts?.fitToViewport,\n        viewportZoomFactor: opts?.viewportZoomFactor,\n      });\n      zoom = appState.zoom;\n      scrollX = appState.scrollX;\n      scrollY = appState.scrollY;\n    } else {\n      // compute only the viewport location, without any zoom adjustment\n      const scroll = calculateScrollCenter(\n        targetElements,\n        this.state,\n        this.canvas,\n      );\n      scrollX = scroll.scrollX;\n      scrollY = scroll.scrollY;\n    }\n\n    // when animating, we use RequestAnimationFrame to prevent the animation\n    // from slowing down other processes\n    if (opts?.animate) {\n      const origScrollX = this.state.scrollX;\n      const origScrollY = this.state.scrollY;\n      const origZoom = this.state.zoom.value;\n\n      const cancel = easeToValuesRAF({\n        fromValues: {\n          scrollX: origScrollX,\n          scrollY: origScrollY,\n          zoom: origZoom,\n        },\n        toValues: { scrollX, scrollY, zoom: zoom.value },\n        interpolateValue: (from, to, progress, key) => {\n          // for zoom, use different easing\n          if (key === \"zoom\") {\n            return from * Math.pow(to / from, easeOut(progress));\n          }\n          // handle using default\n          return undefined;\n        },\n        onStep: ({ scrollX, scrollY, zoom }) => {\n          this.setState({\n            scrollX,\n            scrollY,\n            zoom: { value: zoom },\n          });\n        },\n        onStart: () => {\n          this.setState({ shouldCacheIgnoreZoom: true });\n        },\n        onEnd: () => {\n          this.setState({ shouldCacheIgnoreZoom: false });\n        },\n        onCancel: () => {\n          this.setState({ shouldCacheIgnoreZoom: false });\n        },\n        duration: opts?.duration ?? 500,\n      });\n\n      this.cancelInProgresAnimation = () => {\n        cancel();\n        this.cancelInProgresAnimation = null;\n      };\n    } else {\n      this.setState({ scrollX, scrollY, zoom });\n    }\n  };\n\n  /** use when changing scrollX/scrollY/zoom based on user interaction */\n  private translateCanvas: React.Component<any, AppState>[\"setState\"] = (\n    state,\n  ) => {\n    this.cancelInProgresAnimation?.();\n    this.setState(state);\n  };\n\n  setToast = (\n    toast: {\n      message: string;\n      closable?: boolean;\n      duration?: number;\n    } | null,\n  ) => {\n    this.setState({ toast });\n  };\n\n  restoreFileFromShare = async () => {\n    try {\n      const webShareTargetCache = await caches.open(\"web-share-target\");\n\n      const response = await webShareTargetCache.match(\"shared-file\");\n      if (response) {\n        const blob = await response.blob();\n        const file = new File([blob], blob.name || \"\", { type: blob.type });\n        this.loadFileToCanvas(file, null);\n        await webShareTargetCache.delete(\"shared-file\");\n        window.history.replaceState(null, APP_NAME, window.location.pathname);\n      }\n    } catch (error: any) {\n      this.setState({ errorMessage: error.message });\n    }\n  };\n\n  /** adds supplied files to existing files in the appState */\n  public addFiles: ExcalidrawImperativeAPI[\"addFiles\"] = withBatchedUpdates(\n    (files) => {\n      const filesMap = files.reduce((acc, fileData) => {\n        acc.set(fileData.id, fileData);\n        return acc;\n      }, new Map<FileId, BinaryFileData>());\n\n      this.files = { ...this.files, ...Object.fromEntries(filesMap) };\n\n      this.scene.getNonDeletedElements().forEach((element) => {\n        if (\n          isInitializedImageElement(element) &&\n          filesMap.has(element.fileId)\n        ) {\n          this.imageCache.delete(element.fileId);\n          invalidateShapeForElement(element);\n        }\n      });\n      this.scene.informMutation();\n\n      this.addNewImagesToImageCache();\n    },\n  );\n\n  public updateScene = withBatchedUpdates(\n    <K extends keyof AppState>(sceneData: {\n      elements?: SceneData[\"elements\"];\n      appState?: Pick<AppState, K> | null;\n      collaborators?: SceneData[\"collaborators\"];\n      commitToHistory?: SceneData[\"commitToHistory\"];\n    }) => {\n      if (sceneData.commitToHistory) {\n        this.history.resumeRecording();\n      }\n\n      if (sceneData.appState) {\n        this.setState(sceneData.appState);\n      }\n\n      if (sceneData.elements) {\n        this.scene.replaceAllElements(sceneData.elements);\n      }\n\n      if (sceneData.collaborators) {\n        this.setState({ collaborators: sceneData.collaborators });\n      }\n    },\n  );\n\n  private onSceneUpdated = () => {\n    this.setState({});\n  };\n\n  /**\n   * @returns whether the menu was toggled on or off\n   */\n  public toggleSidebar = ({\n    name,\n    tab,\n    force,\n  }: {\n    name: SidebarName;\n    tab?: SidebarTabName;\n    force?: boolean;\n  }): boolean => {\n    let nextName;\n    if (force === undefined) {\n      nextName = this.state.openSidebar?.name === name ? null : name;\n    } else {\n      nextName = force ? name : null;\n    }\n    this.setState({ openSidebar: nextName ? { name: nextName, tab } : null });\n\n    return !!nextName;\n  };\n\n  private updateCurrentCursorPosition = withBatchedUpdates(\n    (event: MouseEvent) => {\n      this.lastViewportPosition.x = event.clientX;\n      this.lastViewportPosition.y = event.clientY;\n    },\n  );\n\n  // Input handling\n  private onKeyDown = withBatchedUpdates(\n    (event: React.KeyboardEvent | KeyboardEvent) => {\n      // normalize `event.key` when CapsLock is pressed #2372\n\n      if (\n        \"Proxy\" in window &&\n        ((!event.shiftKey && /^[A-Z]$/.test(event.key)) ||\n          (event.shiftKey && /^[a-z]$/.test(event.key)))\n      ) {\n        event = new Proxy(event, {\n          get(ev: any, prop) {\n            const value = ev[prop];\n            if (typeof value === \"function\") {\n              // fix for Proxies hijacking `this`\n              return value.bind(ev);\n            }\n            return prop === \"key\"\n              ? // CapsLock inverts capitalization based on ShiftKey, so invert\n                // it back\n                event.shiftKey\n                ? ev.key.toUpperCase()\n                : ev.key.toLowerCase()\n              : value;\n          },\n        });\n      }\n\n      if (event[KEYS.CTRL_OR_CMD] && event.key.toLowerCase() === KEYS.V) {\n        IS_PLAIN_PASTE = event.shiftKey;\n        clearTimeout(IS_PLAIN_PASTE_TIMER);\n        // reset (100ms to be safe that we it runs after the ensuing\n        // paste event). Though, technically unnecessary to reset since we\n        // (re)set the flag before each paste event.\n        IS_PLAIN_PASTE_TIMER = window.setTimeout(() => {\n          IS_PLAIN_PASTE = false;\n        }, 100);\n      }\n\n      // prevent browser zoom in input fields\n      if (event[KEYS.CTRL_OR_CMD] && isWritableElement(event.target)) {\n        if (event.code === CODES.MINUS || event.code === CODES.EQUAL) {\n          event.preventDefault();\n          return;\n        }\n      }\n\n      // bail if\n      if (\n        // inside an input\n        (isWritableElement(event.target) &&\n          // unless pressing escape (finalize action)\n          event.key !== KEYS.ESCAPE) ||\n        // or unless using arrows (to move between buttons)\n        (isArrowKey(event.key) && isInputLike(event.target))\n      ) {\n        return;\n      }\n\n      if (event.key === KEYS.QUESTION_MARK) {\n        this.setState({\n          openDialog: \"help\",\n        });\n        return;\n      } else if (\n        event.key.toLowerCase() === KEYS.E &&\n        event.shiftKey &&\n        event[KEYS.CTRL_OR_CMD]\n      ) {\n        event.preventDefault();\n        this.setState({ openDialog: \"imageExport\" });\n        return;\n      }\n\n      if (event.key === KEYS.PAGE_UP || event.key === KEYS.PAGE_DOWN) {\n        let offset =\n          (event.shiftKey ? this.state.width : this.state.height) /\n          this.state.zoom.value;\n        if (event.key === KEYS.PAGE_DOWN) {\n          offset = -offset;\n        }\n        if (event.shiftKey) {\n          this.translateCanvas((state) => ({\n            scrollX: state.scrollX + offset,\n          }));\n        } else {\n          this.translateCanvas((state) => ({\n            scrollY: state.scrollY + offset,\n          }));\n        }\n      }\n\n      if (this.actionManager.handleKeyDown(event)) {\n        return;\n      }\n\n      if (this.state.viewModeEnabled) {\n        return;\n      }\n\n      if (event[KEYS.CTRL_OR_CMD] && this.state.isBindingEnabled) {\n        this.setState({ isBindingEnabled: false });\n      }\n\n      if (isArrowKey(event.key)) {\n        const step =\n          (this.state.gridSize &&\n            (event.shiftKey\n              ? ELEMENT_TRANSLATE_AMOUNT\n              : this.state.gridSize)) ||\n          (event.shiftKey\n            ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n            : ELEMENT_TRANSLATE_AMOUNT);\n\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (event.key === KEYS.ARROW_LEFT) {\n          offsetX = -step;\n        } else if (event.key === KEYS.ARROW_RIGHT) {\n          offsetX = step;\n        } else if (event.key === KEYS.ARROW_UP) {\n          offsetY = -step;\n        } else if (event.key === KEYS.ARROW_DOWN) {\n          offsetY = step;\n        }\n\n        const selectedElements = this.scene.getSelectedElements({\n          selectedElementIds: this.state.selectedElementIds,\n          includeBoundTextElement: true,\n          includeElementsInFrames: true,\n        });\n\n        selectedElements.forEach((element) => {\n          mutateElement(element, {\n            x: element.x + offsetX,\n            y: element.y + offsetY,\n          });\n\n          updateBoundElements(element, {\n            simultaneouslyUpdated: selectedElements,\n          });\n        });\n\n        this.maybeSuggestBindingForAll(selectedElements);\n\n        event.preventDefault();\n      } else if (event.key === KEYS.ENTER) {\n        const selectedElements = this.scene.getSelectedElements(this.state);\n        if (selectedElements.length === 1) {\n          const selectedElement = selectedElements[0];\n          if (event[KEYS.CTRL_OR_CMD]) {\n            if (isLinearElement(selectedElement)) {\n              if (\n                !this.state.editingLinearElement ||\n                this.state.editingLinearElement.elementId !==\n                  selectedElements[0].id\n              ) {\n                this.history.resumeRecording();\n                this.setState({\n                  editingLinearElement: new LinearElementEditor(\n                    selectedElement,\n                    this.scene,\n                  ),\n                });\n              }\n            }\n          } else if (\n            isTextElement(selectedElement) ||\n            isValidTextContainer(selectedElement)\n          ) {\n            let container;\n            if (!isTextElement(selectedElement)) {\n              container = selectedElement as ExcalidrawTextContainer;\n            }\n            const midPoint = getContainerCenter(selectedElement, this.state);\n            const sceneX = midPoint.x;\n            const sceneY = midPoint.y;\n            this.startTextEditing({\n              sceneX,\n              sceneY,\n              container,\n            });\n            event.preventDefault();\n            return;\n          } else if (isFrameElement(selectedElement)) {\n            this.setState({\n              editingFrame: selectedElement.id,\n            });\n          }\n        }\n      } else if (\n        !event.ctrlKey &&\n        !event.altKey &&\n        !event.metaKey &&\n        this.state.draggingElement === null\n      ) {\n        const shape = findShapeByKey(event.key);\n        if (shape) {\n          if (this.state.activeTool.type !== shape) {\n            trackEvent(\n              \"toolbar\",\n              shape,\n              `keyboard (${this.device.isMobile ? \"mobile\" : \"desktop\"})`,\n            );\n          }\n          this.setActiveTool({ type: shape });\n          event.stopPropagation();\n        } else if (event.key === KEYS.Q) {\n          this.toggleLock(\"keyboard\");\n          event.stopPropagation();\n        }\n      }\n      if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {\n        isHoldingSpace = true;\n        setCursor(this.canvas, CURSOR_TYPE.GRAB);\n        event.preventDefault();\n      }\n\n      if (\n        (event.key === KEYS.G || event.key === KEYS.S) &&\n        !event.altKey &&\n        !event[KEYS.CTRL_OR_CMD]\n      ) {\n        const selectedElements = this.scene.getSelectedElements(this.state);\n        if (\n          this.state.activeTool.type === \"selection\" &&\n          !selectedElements.length\n        ) {\n          return;\n        }\n\n        if (\n          event.key === KEYS.G &&\n          (hasBackground(this.state.activeTool.type) ||\n            selectedElements.some((element) => hasBackground(element.type)))\n        ) {\n          this.setState({ openPopup: \"elementBackground\" });\n          event.stopPropagation();\n        }\n        if (event.key === KEYS.S) {\n          this.setState({ openPopup: \"elementStroke\" });\n          event.stopPropagation();\n        }\n      }\n\n      if (\n        event[KEYS.CTRL_OR_CMD] &&\n        (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE)\n      ) {\n        jotaiStore.set(activeConfirmDialogAtom, \"clearCanvas\");\n      }\n\n      // eye dropper\n      // -----------------------------------------------------------------------\n      const lowerCased = event.key.toLocaleLowerCase();\n      const isPickingStroke = lowerCased === KEYS.S && event.shiftKey;\n      const isPickingBackground =\n        event.key === KEYS.I || (lowerCased === KEYS.G && event.shiftKey);\n\n      if (isPickingStroke || isPickingBackground) {\n        this.openEyeDropper({\n          type: isPickingStroke ? \"stroke\" : \"background\",\n        });\n      }\n      // -----------------------------------------------------------------------\n    },\n  );\n\n  private onWheel = withBatchedUpdates((event: WheelEvent) => {\n    // prevent browser pinch zoom on DOM elements\n    if (!(event.target instanceof HTMLCanvasElement) && event.ctrlKey) {\n      event.preventDefault();\n    }\n  });\n\n  private onKeyUp = withBatchedUpdates((event: KeyboardEvent) => {\n    if (event.key === KEYS.SPACE) {\n      if (this.state.viewModeEnabled) {\n        setCursor(this.canvas, CURSOR_TYPE.GRAB);\n      } else if (this.state.activeTool.type === \"selection\") {\n        resetCursor(this.canvas);\n      } else {\n        setCursorForShape(this.canvas, this.state);\n        this.setState({\n          selectedElementIds: makeNextSelectedElementIds({}, this.state),\n          selectedGroupIds: {},\n          editingGroupId: null,\n        });\n      }\n      isHoldingSpace = false;\n    }\n    if (!event[KEYS.CTRL_OR_CMD] && !this.state.isBindingEnabled) {\n      this.setState({ isBindingEnabled: true });\n    }\n    if (isArrowKey(event.key)) {\n      const selectedElements = this.scene.getSelectedElements(this.state);\n      isBindingEnabled(this.state)\n        ? bindOrUnbindSelectedElements(selectedElements)\n        : unbindLinearElements(selectedElements);\n      this.setState({ suggestedBindings: [] });\n    }\n  });\n\n  private setActiveTool = (\n    tool:\n      | { type: typeof SHAPES[number][\"value\"] | \"eraser\" | \"hand\" | \"frame\" }\n      | { type: \"custom\"; customType: string },\n  ) => {\n    const nextActiveTool = updateActiveTool(this.state, tool);\n    if (nextActiveTool.type === \"hand\") {\n      setCursor(this.canvas, CURSOR_TYPE.GRAB);\n    } else if (!isHoldingSpace) {\n      setCursorForShape(this.canvas, this.state);\n    }\n    if (isToolIcon(document.activeElement)) {\n      this.focusContainer();\n    }\n    if (!isLinearElementType(nextActiveTool.type)) {\n      this.setState({ suggestedBindings: [] });\n    }\n    if (nextActiveTool.type === \"image\") {\n      this.onImageAction();\n    }\n    if (nextActiveTool.type !== \"selection\") {\n      this.setState({\n        activeTool: nextActiveTool,\n        selectedElementIds: makeNextSelectedElementIds({}, this.state),\n        selectedGroupIds: {},\n        editingGroupId: null,\n      });\n    } else {\n      this.setState({ activeTool: nextActiveTool });\n    }\n  };\n\n  private setCursor = (cursor: string) => {\n    setCursor(this.canvas, cursor);\n  };\n\n  private resetCursor = () => {\n    resetCursor(this.canvas);\n  };\n  /**\n   * returns whether user is making a gesture with >= 2 fingers (points)\n   * on o touch screen (not on a trackpad). Currently only relates to Darwin\n   * (iOS/iPadOS,MacOS), but may work on other devices in the future if\n   * GestureEvent is standardized.\n   */\n  private isTouchScreenMultiTouchGesture = () => {\n    // we don't want to deselect when using trackpad, and multi-point gestures\n    // only work on touch screens, so checking for >= pointers means we're on a\n    // touchscreen\n    return gesture.pointers.size >= 2;\n  };\n\n  // fires only on Safari\n  private onGestureStart = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n\n    // we only want to deselect on touch screens because user may have selected\n    // elements by mistake while zooming\n    if (this.isTouchScreenMultiTouchGesture()) {\n      this.setState({\n        selectedElementIds: makeNextSelectedElementIds({}, this.state),\n      });\n    }\n    gesture.initialScale = this.state.zoom.value;\n  });\n\n  // fires only on Safari\n  private onGestureChange = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n\n    // onGestureChange only has zoom factor but not the center.\n    // If we're on iPad or iPhone, then we recognize multi-touch and will\n    // zoom in at the right location in the touchmove handler\n    // (handleCanvasPointerMove).\n    //\n    // On Macbook trackpad, we don't have those events so will zoom in at the\n    // current location instead.\n    //\n    // As such, bail from this handler on touch devices.\n    if (this.isTouchScreenMultiTouchGesture()) {\n      return;\n    }\n\n    const initialScale = gesture.initialScale;\n    if (initialScale) {\n      this.setState((state) => ({\n        ...getStateForZoom(\n          {\n            viewportX: this.lastViewportPosition.x,\n            viewportY: this.lastViewportPosition.y,\n            nextZoom: getNormalizedZoom(initialScale * event.scale),\n          },\n          state,\n        ),\n      }));\n    }\n  });\n\n  // fires only on Safari\n  private onGestureEnd = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n    // reselect elements only on touch screens (see onGestureStart)\n    if (this.isTouchScreenMultiTouchGesture()) {\n      this.setState({\n        previousSelectedElementIds: {},\n        selectedElementIds: makeNextSelectedElementIds(\n          this.state.previousSelectedElementIds,\n          this.state,\n        ),\n      });\n    }\n    gesture.initialScale = null;\n  });\n\n  private handleTextWysiwyg(\n    element: ExcalidrawTextElement,\n    {\n      isExistingElement = false,\n    }: {\n      isExistingElement?: boolean;\n    },\n  ) {\n    const updateElement = (\n      text: string,\n      originalText: string,\n      isDeleted: boolean,\n    ) => {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted().map((_element) => {\n          if (_element.id === element.id && isTextElement(_element)) {\n            return updateTextElement(_element, {\n              text,\n              isDeleted,\n              originalText,\n            });\n          }\n          return _element;\n        }),\n      ]);\n    };\n\n    textWysiwyg({\n      id: element.id,\n      canvas: this.canvas,\n      getViewportCoords: (x, y) => {\n        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n          {\n            sceneX: x,\n            sceneY: y,\n          },\n          this.state,\n        );\n        return [\n          viewportX - this.state.offsetLeft,\n          viewportY - this.state.offsetTop,\n        ];\n      },\n      onChange: withBatchedUpdates((text) => {\n        updateElement(text, text, false);\n        if (isNonDeletedElement(element)) {\n          updateBoundElements(element);\n        }\n      }),\n      onSubmit: withBatchedUpdates(({ text, viaKeyboard, originalText }) => {\n        const isDeleted = !text.trim();\n        updateElement(text, originalText, isDeleted);\n        // select the created text element only if submitting via keyboard\n        // (when submitting via click it should act as signal to deselect)\n        if (!isDeleted && viaKeyboard) {\n          const elementIdToSelect = element.containerId\n            ? element.containerId\n            : element.id;\n          this.setState((prevState) => ({\n            selectedElementIds: makeNextSelectedElementIds(\n              {\n                ...prevState.selectedElementIds,\n                [elementIdToSelect]: true,\n              },\n              prevState,\n            ),\n          }));\n        }\n        if (isDeleted) {\n          fixBindingsAfterDeletion(this.scene.getNonDeletedElements(), [\n            element,\n          ]);\n        }\n        if (!isDeleted || isExistingElement) {\n          this.history.resumeRecording();\n        }\n\n        this.setState({\n          draggingElement: null,\n          editingElement: null,\n        });\n        if (this.state.activeTool.locked) {\n          setCursorForShape(this.canvas, this.state);\n        }\n\n        this.focusContainer();\n      }),\n      element,\n      excalidrawContainer: this.excalidrawContainerRef.current,\n      app: this,\n    });\n    // deselect all other elements when inserting text\n    this.deselectElements();\n\n    // do an initial update to re-initialize element position since we were\n    // modifying element's x/y for sake of editor (case: syncing to remote)\n    updateElement(element.text, element.originalText, false);\n  }\n\n  private deselectElements() {\n    this.setState({\n      selectedElementIds: makeNextSelectedElementIds({}, this.state),\n      selectedGroupIds: {},\n      editingGroupId: null,\n    });\n  }\n\n  private getTextElementAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawTextElement> | null {\n    const element = this.getElementAtPosition(x, y, {\n      includeBoundTextElement: true,\n    });\n    if (element && isTextElement(element) && !element.isDeleted) {\n      return element;\n    }\n    return null;\n  }\n\n  private getElementAtPosition(\n    x: number,\n    y: number,\n    opts?: {\n      /** if true, returns the first selected element (with highest z-index)\n        of all hit elements */\n      preferSelected?: boolean;\n      includeBoundTextElement?: boolean;\n      includeLockedElements?: boolean;\n    },\n  ): NonDeleted<ExcalidrawElement> | null {\n    const allHitElements = this.getElementsAtPosition(\n      x,\n      y,\n      opts?.includeBoundTextElement,\n      opts?.includeLockedElements,\n    );\n    if (allHitElements.length > 1) {\n      if (opts?.preferSelected) {\n        for (let index = allHitElements.length - 1; index > -1; index--) {\n          if (this.state.selectedElementIds[allHitElements[index].id]) {\n            return allHitElements[index];\n          }\n        }\n      }\n      const elementWithHighestZIndex =\n        allHitElements[allHitElements.length - 1];\n      // If we're hitting element with highest z-index only on its bounding box\n      // while also hitting other element figure, the latter should be considered.\n      return isHittingElementBoundingBoxWithoutHittingElement(\n        elementWithHighestZIndex,\n        this.state,\n        this.frameNameBoundsCache,\n        x,\n        y,\n      )\n        ? allHitElements[allHitElements.length - 2]\n        : elementWithHighestZIndex;\n    }\n    if (allHitElements.length === 1) {\n      return allHitElements[0];\n    }\n    return null;\n  }\n\n  private getElementsAtPosition(\n    x: number,\n    y: number,\n    includeBoundTextElement: boolean = false,\n    includeLockedElements: boolean = false,\n  ): NonDeleted<ExcalidrawElement>[] {\n    const elements =\n      includeBoundTextElement && includeLockedElements\n        ? this.scene.getNonDeletedElements()\n        : this.scene\n            .getNonDeletedElements()\n            .filter(\n              (element) =>\n                (includeLockedElements || !element.locked) &&\n                (includeBoundTextElement ||\n                  !(isTextElement(element) && element.containerId)),\n            );\n\n    return getElementsAtPosition(elements, (element) =>\n      hitTest(element, this.state, this.frameNameBoundsCache, x, y),\n    ).filter((element) => {\n      // hitting a frame's element from outside the frame is not considered a hit\n      const containingFrame = getContainingFrame(element);\n      return containingFrame &&\n        this.state.frameRendering.enabled &&\n        this.state.frameRendering.clip\n        ? isCursorInFrame({ x, y }, containingFrame)\n        : true;\n    });\n  }\n\n  private startTextEditing = ({\n    sceneX,\n    sceneY,\n    insertAtParentCenter = true,\n    container,\n  }: {\n    /** X position to insert text at */\n    sceneX: number;\n    /** Y position to insert text at */\n    sceneY: number;\n    /** whether to attempt to insert at element center if applicable */\n    insertAtParentCenter?: boolean;\n    container?: ExcalidrawTextContainer | null;\n  }) => {\n    let shouldBindToContainer = false;\n\n    let parentCenterPosition =\n      insertAtParentCenter &&\n      this.getTextWysiwygSnappedToCenterPosition(\n        sceneX,\n        sceneY,\n        this.state,\n        container,\n      );\n    if (container && parentCenterPosition) {\n      const boundTextElementToContainer = getBoundTextElement(container);\n      if (!boundTextElementToContainer) {\n        shouldBindToContainer = true;\n      }\n    }\n    let existingTextElement: NonDeleted<ExcalidrawTextElement> | null = null;\n\n    const selectedElements = this.scene.getSelectedElements(this.state);\n\n    if (selectedElements.length === 1) {\n      if (isTextElement(selectedElements[0])) {\n        existingTextElement = selectedElements[0];\n      } else if (container) {\n        existingTextElement = getBoundTextElement(selectedElements[0]);\n      } else {\n        existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);\n      }\n    } else {\n      existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);\n    }\n\n    const fontFamily =\n      existingTextElement?.fontFamily || this.state.currentItemFontFamily;\n\n    const lineHeight =\n      existingTextElement?.lineHeight || getDefaultLineHeight(fontFamily);\n    const fontSize = this.state.currentItemFontSize;\n\n    if (\n      !existingTextElement &&\n      shouldBindToContainer &&\n      container &&\n      !isArrowElement(container)\n    ) {\n      const fontString = {\n        fontSize,\n        fontFamily,\n      };\n      const minWidth = getApproxMinLineWidth(\n        getFontString(fontString),\n        lineHeight,\n      );\n      const minHeight = getApproxMinLineHeight(fontSize, lineHeight);\n      const containerDims = getContainerDims(container);\n      const newHeight = Math.max(containerDims.height, minHeight);\n      const newWidth = Math.max(containerDims.width, minWidth);\n      mutateElement(container, { height: newHeight, width: newWidth });\n      sceneX = container.x + newWidth / 2;\n      sceneY = container.y + newHeight / 2;\n      if (parentCenterPosition) {\n        parentCenterPosition = this.getTextWysiwygSnappedToCenterPosition(\n          sceneX,\n          sceneY,\n          this.state,\n          container,\n        );\n      }\n    }\n\n    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n      x: sceneX,\n      y: sceneY,\n    });\n\n    const element = existingTextElement\n      ? existingTextElement\n      : newTextElement({\n          x: parentCenterPosition\n            ? parentCenterPosition.elementCenterX\n            : sceneX,\n          y: parentCenterPosition\n            ? parentCenterPosition.elementCenterY\n            : sceneY,\n          strokeColor: this.state.currentItemStrokeColor,\n          backgroundColor: this.state.currentItemBackgroundColor,\n          fillStyle: this.state.currentItemFillStyle,\n          strokeWidth: this.state.currentItemStrokeWidth,\n          strokeStyle: this.state.currentItemStrokeStyle,\n          roughness: this.state.currentItemRoughness,\n          opacity: this.state.currentItemOpacity,\n          text: \"\",\n          fontSize,\n          fontFamily,\n          textAlign: parentCenterPosition\n            ? \"center\"\n            : this.state.currentItemTextAlign,\n          verticalAlign: parentCenterPosition\n            ? VERTICAL_ALIGN.MIDDLE\n            : DEFAULT_VERTICAL_ALIGN,\n          containerId: shouldBindToContainer ? container?.id : undefined,\n          groupIds: container?.groupIds ?? [],\n          lineHeight,\n          angle: container?.angle ?? 0,\n          frameId: topLayerFrame ? topLayerFrame.id : null,\n        });\n\n    if (!existingTextElement && shouldBindToContainer && container) {\n      mutateElement(container, {\n        boundElements: (container.boundElements || []).concat({\n          type: \"text\",\n          id: element.id,\n        }),\n      });\n    }\n    this.setState({ editingElement: element });\n\n    if (!existingTextElement) {\n      if (container && shouldBindToContainer) {\n        const containerIndex = this.scene.getElementIndex(container.id);\n        this.scene.insertElementAtIndex(element, containerIndex + 1);\n      } else {\n        this.scene.addNewElement(element);\n      }\n    }\n\n    this.setState({\n      editingElement: element,\n    });\n\n    this.handleTextWysiwyg(element, {\n      isExistingElement: !!existingTextElement,\n    });\n  };\n\n  private handleCanvasDoubleClick = (\n    event: React.MouseEvent<HTMLCanvasElement>,\n  ) => {\n    // case: double-clicking with arrow/line tool selected would both create\n    // text and enter multiElement mode\n    if (this.state.multiElement) {\n      return;\n    }\n    // we should only be able to double click when mode is selection\n    if (this.state.activeTool.type !== \"selection\") {\n      return;\n    }\n\n    const selectedElements = this.scene.getSelectedElements(this.state);\n\n    if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n      if (\n        event[KEYS.CTRL_OR_CMD] &&\n        (!this.state.editingLinearElement ||\n          this.state.editingLinearElement.elementId !== selectedElements[0].id)\n      ) {\n        this.history.resumeRecording();\n        this.setState({\n          editingLinearElement: new LinearElementEditor(\n            selectedElements[0],\n            this.scene,\n          ),\n        });\n        return;\n      } else if (\n        this.state.editingLinearElement &&\n        this.state.editingLinearElement.elementId === selectedElements[0].id\n      ) {\n        return;\n      }\n    }\n\n    resetCursor(this.canvas);\n\n    let { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n    );\n\n    const selectedGroupIds = getSelectedGroupIds(this.state);\n\n    if (selectedGroupIds.length > 0) {\n      const hitElement = this.getElementAtPosition(sceneX, sceneY);\n\n      const selectedGroupId =\n        hitElement &&\n        getSelectedGroupIdForElement(hitElement, this.state.selectedGroupIds);\n\n      if (selectedGroupId) {\n        this.setState((prevState) =>\n          selectGroupsForSelectedElements(\n            {\n              ...prevState,\n              editingGroupId: selectedGroupId,\n              selectedElementIds: { [hitElement!.id]: true },\n              selectedGroupIds: {},\n            },\n            this.scene.getNonDeletedElements(),\n            prevState,\n            this,\n          ),\n        );\n        return;\n      }\n    }\n\n    resetCursor(this.canvas);\n    if (!event[KEYS.CTRL_OR_CMD] && !this.state.viewModeEnabled) {\n      const container = getTextBindableContainerAtPosition(\n        this.scene.getNonDeletedElements(),\n        this.state,\n        sceneX,\n        sceneY,\n      );\n      if (container) {\n        if (\n          hasBoundTextElement(container) ||\n          !isTransparent(container.backgroundColor) ||\n          isHittingElementNotConsideringBoundingBox(\n            container,\n            this.state,\n            this.frameNameBoundsCache,\n            [sceneX, sceneY],\n          )\n        ) {\n          const midPoint = getContainerCenter(container, this.state);\n\n          sceneX = midPoint.x;\n          sceneY = midPoint.y;\n        }\n      }\n      this.startTextEditing({\n        sceneX,\n        sceneY,\n        insertAtParentCenter: !event.altKey,\n        container,\n      });\n    }\n  };\n\n  private getElementLinkAtPosition = (\n    scenePointer: Readonly<{ x: number; y: number }>,\n    hitElement: NonDeletedExcalidrawElement | null,\n  ): ExcalidrawElement | undefined => {\n    // Reversing so we traverse the elements in decreasing order\n    // of z-index\n    const elements = this.scene.getNonDeletedElements().slice().reverse();\n    let hitElementIndex = Infinity;\n\n    return elements.find((element, index) => {\n      if (hitElement && element.id === hitElement.id) {\n        hitElementIndex = index;\n      }\n      return (\n        element.link &&\n        index <= hitElementIndex &&\n        isPointHittingLinkIcon(\n          element,\n          this.state,\n          [scenePointer.x, scenePointer.y],\n          this.device.isMobile,\n        )\n      );\n    });\n  };\n\n  private redirectToLink = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    isTouchScreen: boolean,\n  ) => {\n    const draggedDistance = distance2d(\n      this.lastPointerDown!.clientX,\n      this.lastPointerDown!.clientY,\n      this.lastPointerUp!.clientX,\n      this.lastPointerUp!.clientY,\n    );\n    if (\n      !this.hitLinkElement ||\n      // For touch screen allow dragging threshold else strict check\n      (isTouchScreen && draggedDistance > DRAGGING_THRESHOLD) ||\n      (!isTouchScreen && draggedDistance !== 0)\n    ) {\n      return;\n    }\n    const lastPointerDownCoords = viewportCoordsToSceneCoords(\n      this.lastPointerDown!,\n      this.state,\n    );\n    const lastPointerDownHittingLinkIcon = isPointHittingLinkIcon(\n      this.hitLinkElement,\n      this.state,\n      [lastPointerDownCoords.x, lastPointerDownCoords.y],\n      this.device.isMobile,\n    );\n    const lastPointerUpCoords = viewportCoordsToSceneCoords(\n      this.lastPointerUp!,\n      this.state,\n    );\n    const lastPointerUpHittingLinkIcon = isPointHittingLinkIcon(\n      this.hitLinkElement,\n      this.state,\n      [lastPointerUpCoords.x, lastPointerUpCoords.y],\n      this.device.isMobile,\n    );\n    if (lastPointerDownHittingLinkIcon && lastPointerUpHittingLinkIcon) {\n      let url = this.hitLinkElement.link;\n      if (url) {\n        url = normalizeLink(url);\n        let customEvent;\n        if (this.props.onLinkOpen) {\n          customEvent = wrapEvent(EVENT.EXCALIDRAW_LINK, event.nativeEvent);\n          this.props.onLinkOpen(\n            {\n              ...this.hitLinkElement,\n              link: url,\n            },\n            customEvent,\n          );\n        }\n        if (!customEvent?.defaultPrevented) {\n          const target = isLocalLink(url) ? \"_self\" : \"_blank\";\n          const newWindow = window.open(undefined, target);\n          // https://mathiasbynens.github.io/rel-noopener/\n          if (newWindow) {\n            newWindow.opener = null;\n            newWindow.location = url;\n          }\n        }\n      }\n    }\n  };\n\n  private getTopLayerFrameAtSceneCoords = (sceneCoords: {\n    x: number;\n    y: number;\n  }) => {\n    const frames = this.scene\n      .getNonDeletedFrames()\n      .filter((frame) =>\n        isCursorInFrame(sceneCoords, frame as ExcalidrawFrameElement),\n      );\n\n    return frames.length ? frames[frames.length - 1] : null;\n  };\n\n  private handleCanvasPointerMove = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    this.savePointer(event.clientX, event.clientY, this.state.cursorButton);\n\n    if (gesture.pointers.has(event.pointerId)) {\n      gesture.pointers.set(event.pointerId, {\n        x: event.clientX,\n        y: event.clientY,\n      });\n    }\n\n    const initialScale = gesture.initialScale;\n    if (\n      gesture.pointers.size === 2 &&\n      gesture.lastCenter &&\n      initialScale &&\n      gesture.initialDistance\n    ) {\n      const center = getCenter(gesture.pointers);\n      const deltaX = center.x - gesture.lastCenter.x;\n      const deltaY = center.y - gesture.lastCenter.y;\n      gesture.lastCenter = center;\n\n      const distance = getDistance(Array.from(gesture.pointers.values()));\n      const scaleFactor =\n        this.state.activeTool.type === \"freedraw\" && this.state.penMode\n          ? 1\n          : distance / gesture.initialDistance;\n\n      const nextZoom = scaleFactor\n        ? getNormalizedZoom(initialScale * scaleFactor)\n        : this.state.zoom.value;\n\n      this.setState((state) => {\n        const zoomState = getStateForZoom(\n          {\n            viewportX: center.x,\n            viewportY: center.y,\n            nextZoom,\n          },\n          state,\n        );\n\n        this.translateCanvas({\n          zoom: zoomState.zoom,\n          scrollX: zoomState.scrollX + deltaX / nextZoom,\n          scrollY: zoomState.scrollY + deltaY / nextZoom,\n          shouldCacheIgnoreZoom: true,\n        });\n      });\n      this.resetShouldCacheIgnoreZoomDebounced();\n    } else {\n      gesture.lastCenter =\n        gesture.initialDistance =\n        gesture.initialScale =\n          null;\n    }\n\n    if (\n      isHoldingSpace ||\n      isPanning ||\n      isDraggingScrollBar ||\n      isHandToolActive(this.state)\n    ) {\n      return;\n    }\n\n    const isPointerOverScrollBars = isOverScrollBars(\n      currentScrollBars,\n      event.clientX - this.state.offsetLeft,\n      event.clientY - this.state.offsetTop,\n    );\n    const isOverScrollBar = isPointerOverScrollBars.isOverEither;\n    if (!this.state.draggingElement && !this.state.multiElement) {\n      if (isOverScrollBar) {\n        resetCursor(this.canvas);\n      } else {\n        setCursorForShape(this.canvas, this.state);\n      }\n    }\n\n    const scenePointer = viewportCoordsToSceneCoords(event, this.state);\n    const { x: scenePointerX, y: scenePointerY } = scenePointer;\n\n    if (\n      this.state.editingLinearElement &&\n      !this.state.editingLinearElement.isDragging\n    ) {\n      const editingLinearElement = LinearElementEditor.handlePointerMove(\n        event,\n        scenePointerX,\n        scenePointerY,\n        this.state,\n      );\n\n      if (\n        editingLinearElement &&\n        editingLinearElement !== this.state.editingLinearElement\n      ) {\n        // Since we are reading from previous state which is not possible with\n        // automatic batching in React 18 hence using flush sync to synchronously\n        // update the state. Check https://github.com/excalidraw/excalidraw/pull/5508 for more details.\n        flushSync(() => {\n          this.setState({\n            editingLinearElement,\n          });\n        });\n      }\n      if (editingLinearElement?.lastUncommittedPoint != null) {\n        this.maybeSuggestBindingAtCursor(scenePointer);\n      } else {\n        // causes stack overflow if not sync\n        flushSync(() => {\n          this.setState({ suggestedBindings: [] });\n        });\n      }\n    }\n\n    if (isBindingElementType(this.state.activeTool.type)) {\n      // Hovering with a selected tool or creating new linear element via click\n      // and point\n      const { draggingElement } = this.state;\n      if (isBindingElement(draggingElement, false)) {\n        this.maybeSuggestBindingsForLinearElementAtCoords(\n          draggingElement,\n          [scenePointer],\n          this.state.startBoundElement,\n        );\n      } else {\n        this.maybeSuggestBindingAtCursor(scenePointer);\n      }\n    }\n\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n      const { x: rx, y: ry } = multiElement;\n\n      const { points, lastCommittedPoint } = multiElement;\n      const lastPoint = points[points.length - 1];\n\n      setCursorForShape(this.canvas, this.state);\n\n      if (lastPoint === lastCommittedPoint) {\n        // if we haven't yet created a temp point and we're beyond commit-zone\n        // threshold, add a point\n        if (\n          distance2d(\n            scenePointerX - rx,\n            scenePointerY - ry,\n            lastPoint[0],\n            lastPoint[1],\n          ) >= LINE_CONFIRM_THRESHOLD\n        ) {\n          mutateElement(multiElement, {\n            points: [...points, [scenePointerX - rx, scenePointerY - ry]],\n          });\n        } else {\n          setCursor(this.canvas, CURSOR_TYPE.POINTER);\n          // in this branch, we're inside the commit zone, and no uncommitted\n          // point exists. Thus do nothing (don't add/remove points).\n        }\n      } else if (\n        points.length > 2 &&\n        lastCommittedPoint &&\n        distance2d(\n          scenePointerX - rx,\n          scenePointerY - ry,\n          lastCommittedPoint[0],\n          lastCommittedPoint[1],\n        ) < LINE_CONFIRM_THRESHOLD\n      ) {\n        setCursor(this.canvas, CURSOR_TYPE.POINTER);\n        mutateElement(multiElement, {\n          points: points.slice(0, -1),\n        });\n      } else {\n        const [gridX, gridY] = getGridPoint(\n          scenePointerX,\n          scenePointerY,\n          this.state.gridSize,\n        );\n\n        const [lastCommittedX, lastCommittedY] =\n          multiElement?.lastCommittedPoint ?? [0, 0];\n\n        let dxFromLastCommitted = gridX - rx - lastCommittedX;\n        let dyFromLastCommitted = gridY - ry - lastCommittedY;\n\n        if (shouldRotateWithDiscreteAngle(event)) {\n          ({ width: dxFromLastCommitted, height: dyFromLastCommitted } =\n            getLockedLinearCursorAlignSize(\n              // actual coordinate of the last committed point\n              lastCommittedX + rx,\n              lastCommittedY + ry,\n              // cursor-grid coordinate\n              gridX,\n              gridY,\n            ));\n        }\n\n        if (isPathALoop(points, this.state.zoom.value)) {\n          setCursor(this.canvas, CURSOR_TYPE.POINTER);\n        }\n        // update last uncommitted point\n        mutateElement(multiElement, {\n          points: [\n            ...points.slice(0, -1),\n            [\n              lastCommittedX + dxFromLastCommitted,\n              lastCommittedY + dyFromLastCommitted,\n            ],\n          ],\n        });\n      }\n\n      return;\n    }\n\n    const hasDeselectedButton = Boolean(event.buttons);\n    if (\n      hasDeselectedButton ||\n      (this.state.activeTool.type !== \"selection\" &&\n        this.state.activeTool.type !== \"text\" &&\n        this.state.activeTool.type !== \"eraser\")\n    ) {\n      return;\n    }\n\n    const elements = this.scene.getNonDeletedElements();\n\n    const selectedElements = this.scene.getSelectedElements(this.state);\n    if (\n      selectedElements.length === 1 &&\n      !isOverScrollBar &&\n      !this.state.editingLinearElement\n    ) {\n      const elementWithTransformHandleType = getElementWithTransformHandleType(\n        elements,\n        this.state,\n        scenePointerX,\n        scenePointerY,\n        this.state.zoom,\n        event.pointerType,\n      );\n      if (\n        elementWithTransformHandleType &&\n        elementWithTransformHandleType.transformHandleType\n      ) {\n        setCursor(\n          this.canvas,\n          getCursorForResizingElement(elementWithTransformHandleType),\n        );\n        return;\n      }\n    } else if (selectedElements.length > 1 && !isOverScrollBar) {\n      const transformHandleType = getTransformHandleTypeFromCoords(\n        getCommonBounds(selectedElements),\n        scenePointerX,\n        scenePointerY,\n        this.state.zoom,\n        event.pointerType,\n      );\n      if (transformHandleType) {\n        setCursor(\n          this.canvas,\n          getCursorForResizingElement({\n            transformHandleType,\n          }),\n        );\n        return;\n      }\n    }\n\n    const hitElement = this.getElementAtPosition(\n      scenePointer.x,\n      scenePointer.y,\n    );\n    this.hitLinkElement = this.getElementLinkAtPosition(\n      scenePointer,\n      hitElement,\n    );\n    if (isEraserActive(this.state)) {\n      return;\n    }\n    if (\n      this.hitLinkElement &&\n      !this.state.selectedElementIds[this.hitLinkElement.id]\n    ) {\n      setCursor(this.canvas, CURSOR_TYPE.POINTER);\n      showHyperlinkTooltip(this.hitLinkElement, this.state);\n    } else {\n      hideHyperlinkToolip();\n      if (\n        hitElement &&\n        hitElement.link &&\n        this.state.selectedElementIds[hitElement.id] &&\n        !this.state.contextMenu &&\n        !this.state.showHyperlinkPopup\n      ) {\n        this.setState({ showHyperlinkPopup: \"info\" });\n      } else if (this.state.activeTool.type === \"text\") {\n        setCursor(\n          this.canvas,\n          isTextElement(hitElement) ? CURSOR_TYPE.TEXT : CURSOR_TYPE.CROSSHAIR,\n        );\n      } else if (this.state.viewModeEnabled) {\n        setCursor(this.canvas, CURSOR_TYPE.GRAB);\n      } else if (isOverScrollBar) {\n        setCursor(this.canvas, CURSOR_TYPE.AUTO);\n      } else if (this.state.selectedLinearElement) {\n        this.handleHoverSelectedLinearElement(\n          this.state.selectedLinearElement,\n          scenePointerX,\n          scenePointerY,\n        );\n      } else if (\n        // if using cmd/ctrl, we're not dragging\n        !event[KEYS.CTRL_OR_CMD]\n      ) {\n        if (\n          (hitElement ||\n            this.isHittingCommonBoundingBoxOfSelectedElements(\n              scenePointer,\n              selectedElements,\n            )) &&\n          !hitElement?.locked\n        ) {\n          setCursor(this.canvas, CURSOR_TYPE.MOVE);\n        }\n      } else {\n        setCursor(this.canvas, CURSOR_TYPE.AUTO);\n      }\n    }\n  };\n\n  private handleEraser = (\n    event: PointerEvent,\n    pointerDownState: PointerDownState,\n    scenePointer: { x: number; y: number },\n  ) => {\n    const updateElementIds = (elements: ExcalidrawElement[]) => {\n      elements.forEach((element) => {\n        if (element.locked) {\n          return;\n        }\n\n        idsToUpdate.push(element.id);\n        if (event.altKey) {\n          if (\n            pointerDownState.elementIdsToErase[element.id] &&\n            pointerDownState.elementIdsToErase[element.id].erase\n          ) {\n            pointerDownState.elementIdsToErase[element.id].erase = false;\n          }\n        } else if (!pointerDownState.elementIdsToErase[element.id]) {\n          pointerDownState.elementIdsToErase[element.id] = {\n            erase: true,\n            opacity: element.opacity,\n          };\n        }\n      });\n    };\n\n    const idsToUpdate: Array<string> = [];\n\n    const distance = distance2d(\n      pointerDownState.lastCoords.x,\n      pointerDownState.lastCoords.y,\n      scenePointer.x,\n      scenePointer.y,\n    );\n    const threshold = 10 / this.state.zoom.value;\n    const point = { ...pointerDownState.lastCoords };\n    let samplingInterval = 0;\n    while (samplingInterval <= distance) {\n      const hitElements = this.getElementsAtPosition(point.x, point.y);\n      updateElementIds(hitElements);\n\n      // Exit since we reached current point\n      if (samplingInterval === distance) {\n        break;\n      }\n\n      // Calculate next point in the line at a distance of sampling interval\n      samplingInterval = Math.min(samplingInterval + threshold, distance);\n\n      const distanceRatio = samplingInterval / distance;\n      const nextX =\n        (1 - distanceRatio) * point.x + distanceRatio * scenePointer.x;\n      const nextY =\n        (1 - distanceRatio) * point.y + distanceRatio * scenePointer.y;\n      point.x = nextX;\n      point.y = nextY;\n    }\n\n    const elements = this.scene.getElementsIncludingDeleted().map((ele) => {\n      const id =\n        isBoundToContainer(ele) && idsToUpdate.includes(ele.containerId)\n          ? ele.containerId\n          : ele.id;\n      if (idsToUpdate.includes(id)) {\n        if (event.altKey) {\n          if (\n            pointerDownState.elementIdsToErase[id] &&\n            pointerDownState.elementIdsToErase[id].erase === false\n          ) {\n            return newElementWith(ele, {\n              opacity: pointerDownState.elementIdsToErase[id].opacity,\n            });\n          }\n        } else {\n          return newElementWith(ele, {\n            opacity: ELEMENT_READY_TO_ERASE_OPACITY,\n          });\n        }\n      }\n      return ele;\n    });\n\n    this.scene.replaceAllElements(elements);\n\n    pointerDownState.lastCoords.x = scenePointer.x;\n    pointerDownState.lastCoords.y = scenePointer.y;\n  };\n  // set touch moving for mobile context menu\n  private handleTouchMove = (event: React.TouchEvent<HTMLCanvasElement>) => {\n    invalidateContextMenu = true;\n  };\n\n  handleHoverSelectedLinearElement(\n    linearElementEditor: LinearElementEditor,\n    scenePointerX: number,\n    scenePointerY: number,\n  ) {\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n    );\n\n    const boundTextElement = getBoundTextElement(element);\n\n    if (!element) {\n      return;\n    }\n    if (this.state.selectedLinearElement) {\n      let hoverPointIndex = -1;\n      let segmentMidPointHoveredCoords = null;\n      if (\n        isHittingElementNotConsideringBoundingBox(\n          element,\n          this.state,\n          this.frameNameBoundsCache,\n          [scenePointerX, scenePointerY],\n        )\n      ) {\n        hoverPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n          element,\n          this.state.zoom,\n          scenePointerX,\n          scenePointerY,\n        );\n        segmentMidPointHoveredCoords =\n          LinearElementEditor.getSegmentMidpointHitCoords(\n            linearElementEditor,\n            { x: scenePointerX, y: scenePointerY },\n            this.state,\n          );\n\n        if (hoverPointIndex >= 0 || segmentMidPointHoveredCoords) {\n          setCursor(this.canvas, CURSOR_TYPE.POINTER);\n        } else {\n          setCursor(this.canvas, CURSOR_TYPE.MOVE);\n        }\n      } else if (\n        shouldShowBoundingBox([element], this.state) &&\n        isHittingElementBoundingBoxWithoutHittingElement(\n          element,\n          this.state,\n          this.frameNameBoundsCache,\n          scenePointerX,\n          scenePointerY,\n        )\n      ) {\n        setCursor(this.canvas, CURSOR_TYPE.MOVE);\n      } else if (\n        boundTextElement &&\n        hitTest(\n          boundTextElement,\n          this.state,\n          this.frameNameBoundsCache,\n          scenePointerX,\n          scenePointerY,\n        )\n      ) {\n        setCursor(this.canvas, CURSOR_TYPE.MOVE);\n      }\n\n      if (\n        this.state.selectedLinearElement.hoverPointIndex !== hoverPointIndex\n      ) {\n        this.setState({\n          selectedLinearElement: {\n            ...this.state.selectedLinearElement,\n            hoverPointIndex,\n          },\n        });\n      }\n\n      if (\n        !LinearElementEditor.arePointsEqual(\n          this.state.selectedLinearElement.segmentMidPointHoveredCoords,\n          segmentMidPointHoveredCoords,\n        )\n      ) {\n        this.setState({\n          selectedLinearElement: {\n            ...this.state.selectedLinearElement,\n            segmentMidPointHoveredCoords,\n          },\n        });\n      }\n    } else {\n      setCursor(this.canvas, CURSOR_TYPE.AUTO);\n    }\n  }\n  private handleCanvasPointerDown = (\n    event: React.PointerEvent<HTMLElement>,\n  ) => {\n    // since contextMenu options are potentially evaluated on each render,\n    // and an contextMenu action may depend on selection state, we must\n    // close the contextMenu before we update the selection on pointerDown\n    // (e.g. resetting selection)\n    if (this.state.contextMenu) {\n      this.setState({ contextMenu: null });\n    }\n\n    this.updateGestureOnPointerDown(event);\n\n    // if dragging element is freedraw and another pointerdown event occurs\n    // a second finger is on the screen\n    // discard the freedraw element if it is very short because it is likely\n    // just a spike, otherwise finalize the freedraw element when the second\n    // finger is lifted\n    if (\n      event.pointerType === \"touch\" &&\n      this.state.draggingElement &&\n      this.state.draggingElement.type === \"freedraw\"\n    ) {\n      const element = this.state.draggingElement as ExcalidrawFreeDrawElement;\n      this.updateScene({\n        ...(element.points.length < 10\n          ? {\n              elements: this.scene\n                .getElementsIncludingDeleted()\n                .filter((el) => el.id !== element.id),\n            }\n          : {}),\n        appState: {\n          draggingElement: null,\n          editingElement: null,\n          startBoundElement: null,\n          suggestedBindings: [],\n          selectedElementIds: makeNextSelectedElementIds(\n            Object.keys(this.state.selectedElementIds)\n              .filter((key) => key !== element.id)\n              .reduce((obj: { [id: string]: true }, key) => {\n                obj[key] = this.state.selectedElementIds[key];\n                return obj;\n              }, {}),\n            this.state,\n          ),\n        },\n      });\n      return;\n    }\n\n    // remove any active selection when we start to interact with canvas\n    // (mainly, we care about removing selection outside the component which\n    //  would prevent our copy handling otherwise)\n    const selection = document.getSelection();\n    if (selection?.anchorNode) {\n      selection.removeAllRanges();\n    }\n    this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(event);\n    this.maybeCleanupAfterMissingPointerUp(event);\n\n    //fires only once, if pen is detected, penMode is enabled\n    //the user can disable this by toggling the penMode button\n    if (!this.state.penDetected && event.pointerType === \"pen\") {\n      this.setState((prevState) => {\n        return {\n          penMode: true,\n          penDetected: true,\n        };\n      });\n    }\n\n    if (\n      !this.device.isTouchScreen &&\n      [\"pen\", \"touch\"].includes(event.pointerType)\n    ) {\n      this.device = updateObject(this.device, { isTouchScreen: true });\n    }\n\n    if (isPanning) {\n      return;\n    }\n\n    this.lastPointerDown = event;\n    this.setState({\n      lastPointerDownWith: event.pointerType,\n      cursorButton: \"down\",\n    });\n    this.savePointer(event.clientX, event.clientY, \"down\");\n\n    if (this.handleCanvasPanUsingWheelOrSpaceDrag(event)) {\n      return;\n    }\n\n    // only handle left mouse button or touch\n    if (\n      event.button !== POINTER_BUTTON.MAIN &&\n      event.button !== POINTER_BUTTON.TOUCH\n    ) {\n      return;\n    }\n\n    // don't select while panning\n    if (gesture.pointers.size > 1) {\n      return;\n    }\n\n    // State for the duration of a pointer interaction, which starts with a\n    // pointerDown event, ends with a pointerUp event (or another pointerDown)\n    const pointerDownState = this.initialPointerDownState(event);\n\n    this.setState({\n      selectedElementsAreBeingDragged: false,\n    });\n\n    if (this.handleDraggingScrollBar(event, pointerDownState)) {\n      return;\n    }\n\n    this.clearSelectionIfNotUsingSelection();\n    this.updateBindingEnabledOnPointerMove(event);\n\n    if (this.handleSelectionOnPointerDown(event, pointerDownState)) {\n      return;\n    }\n\n    const allowOnPointerDown =\n      !this.state.penMode ||\n      event.pointerType !== \"touch\" ||\n      this.state.activeTool.type === \"selection\" ||\n      this.state.activeTool.type === \"text\" ||\n      this.state.activeTool.type === \"image\";\n\n    if (!allowOnPointerDown) {\n      return;\n    }\n\n    if (this.state.activeTool.type === \"text\") {\n      this.handleTextOnPointerDown(event, pointerDownState);\n      return;\n    } else if (\n      this.state.activeTool.type === \"arrow\" ||\n      this.state.activeTool.type === \"line\"\n    ) {\n      this.handleLinearElementOnPointerDown(\n        event,\n        this.state.activeTool.type,\n        pointerDownState,\n      );\n    } else if (this.state.activeTool.type === \"image\") {\n      // reset image preview on pointerdown\n      setCursor(this.canvas, CURSOR_TYPE.CROSSHAIR);\n\n      // retrieve the latest element as the state may be stale\n      const pendingImageElement =\n        this.state.pendingImageElementId &&\n        this.scene.getElement(this.state.pendingImageElementId);\n\n      if (!pendingImageElement) {\n        return;\n      }\n\n      this.setState({\n        draggingElement: pendingImageElement,\n        editingElement: pendingImageElement,\n        pendingImageElementId: null,\n        multiElement: null,\n      });\n\n      const { x, y } = viewportCoordsToSceneCoords(event, this.state);\n      mutateElement(pendingImageElement, {\n        x,\n        y,\n      });\n    } else if (this.state.activeTool.type === \"freedraw\") {\n      this.handleFreeDrawElementOnPointerDown(\n        event,\n        this.state.activeTool.type,\n        pointerDownState,\n      );\n    } else if (this.state.activeTool.type === \"custom\") {\n      setCursor(this.canvas, CURSOR_TYPE.AUTO);\n    } else if (this.state.activeTool.type === \"frame\") {\n      this.createFrameElementOnPointerDown(pointerDownState);\n    } else if (\n      this.state.activeTool.type !== \"eraser\" &&\n      this.state.activeTool.type !== \"hand\"\n    ) {\n      this.createGenericElementOnPointerDown(\n        this.state.activeTool.type,\n        pointerDownState,\n      );\n    }\n\n    this.props?.onPointerDown?.(this.state.activeTool, pointerDownState);\n\n    const onPointerMove =\n      this.onPointerMoveFromPointerDownHandler(pointerDownState);\n\n    const onPointerUp =\n      this.onPointerUpFromPointerDownHandler(pointerDownState);\n\n    const onKeyDown = this.onKeyDownFromPointerDownHandler(pointerDownState);\n    const onKeyUp = this.onKeyUpFromPointerDownHandler(pointerDownState);\n\n    lastPointerUp = onPointerUp;\n\n    if (!this.state.viewModeEnabled) {\n      window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n      window.addEventListener(EVENT.KEYDOWN, onKeyDown);\n      window.addEventListener(EVENT.KEYUP, onKeyUp);\n      pointerDownState.eventListeners.onMove = onPointerMove;\n      pointerDownState.eventListeners.onUp = onPointerUp;\n      pointerDownState.eventListeners.onKeyUp = onKeyUp;\n      pointerDownState.eventListeners.onKeyDown = onKeyDown;\n    }\n  };\n\n  private handleCanvasPointerUp = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    this.lastPointerUp = event;\n\n    if (this.device.isTouchScreen) {\n      const scenePointer = viewportCoordsToSceneCoords(\n        { clientX: event.clientX, clientY: event.clientY },\n        this.state,\n      );\n      const hitElement = this.getElementAtPosition(\n        scenePointer.x,\n        scenePointer.y,\n      );\n      this.hitLinkElement = this.getElementLinkAtPosition(\n        scenePointer,\n        hitElement,\n      );\n    }\n    if (\n      this.hitLinkElement &&\n      !this.state.selectedElementIds[this.hitLinkElement.id]\n    ) {\n      this.redirectToLink(event, this.device.isTouchScreen);\n    }\n\n    this.removePointer(event);\n  };\n\n  private maybeOpenContextMenuAfterPointerDownOnTouchDevices = (\n    event: React.PointerEvent<HTMLElement>,\n  ): void => {\n    // deal with opening context menu on touch devices\n    if (event.pointerType === \"touch\") {\n      invalidateContextMenu = false;\n\n      if (touchTimeout) {\n        // If there's already a touchTimeout, this means that there's another\n        // touch down and we are doing another touch, so we shouldn't open the\n        // context menu.\n        invalidateContextMenu = true;\n      } else {\n        // open the context menu with the first touch's clientX and clientY\n        // if the touch is not moving\n        touchTimeout = window.setTimeout(() => {\n          touchTimeout = 0;\n          if (!invalidateContextMenu) {\n            this.handleCanvasContextMenu(event);\n          }\n        }, TOUCH_CTX_MENU_TIMEOUT);\n      }\n    }\n  };\n\n  private resetContextMenuTimer = () => {\n    clearTimeout(touchTimeout);\n    touchTimeout = 0;\n    invalidateContextMenu = false;\n  };\n\n  private maybeCleanupAfterMissingPointerUp(\n    event: React.PointerEvent<HTMLElement>,\n  ): void {\n    if (lastPointerUp !== null) {\n      // Unfortunately, sometimes we don't get a pointerup after a pointerdown,\n      // this can happen when a contextual menu or alert is triggered. In order to avoid\n      // being in a weird state, we clean up on the next pointerdown\n      lastPointerUp(event);\n    }\n  }\n\n  // Returns whether the event is a panning\n  private handleCanvasPanUsingWheelOrSpaceDrag = (\n    event: React.PointerEvent<HTMLElement>,\n  ): boolean => {\n    if (\n      !(\n        gesture.pointers.size <= 1 &&\n        (event.button === POINTER_BUTTON.WHEEL ||\n          (event.button === POINTER_BUTTON.MAIN && isHoldingSpace) ||\n          isHandToolActive(this.state) ||\n          this.state.viewModeEnabled)\n      ) ||\n      isTextElement(this.state.editingElement)\n    ) {\n      return false;\n    }\n    isPanning = true;\n    event.preventDefault();\n\n    let nextPastePrevented = false;\n    const isLinux = /Linux/.test(window.navigator.platform);\n\n    setCursor(this.canvas, CURSOR_TYPE.GRABBING);\n    let { clientX: lastX, clientY: lastY } = event;\n    const onPointerMove = withBatchedUpdatesThrottled((event: PointerEvent) => {\n      const deltaX = lastX - event.clientX;\n      const deltaY = lastY - event.clientY;\n      lastX = event.clientX;\n      lastY = event.clientY;\n\n      /*\n       * Prevent paste event if we move while middle clicking on Linux.\n       * See issue #1383.\n       */\n      if (\n        isLinux &&\n        !nextPastePrevented &&\n        (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1)\n      ) {\n        nextPastePrevented = true;\n\n        /* Prevent the next paste event */\n        const preventNextPaste = (event: ClipboardEvent) => {\n          document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n          event.stopPropagation();\n        };\n\n        /*\n         * Reenable next paste in case of disabled middle click paste for\n         * any reason:\n         * - right click paste\n         * - empty clipboard\n         */\n        const enableNextPaste = () => {\n          setTimeout(() => {\n            document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n            window.removeEventListener(EVENT.POINTER_UP, enableNextPaste);\n          }, 100);\n        };\n\n        document.body.addEventListener(EVENT.PASTE, preventNextPaste);\n        window.addEventListener(EVENT.POINTER_UP, enableNextPaste);\n      }\n\n      this.translateCanvas({\n        scrollX: this.state.scrollX - deltaX / this.state.zoom.value,\n        scrollY: this.state.scrollY - deltaY / this.state.zoom.value,\n      });\n    });\n    const teardown = withBatchedUpdates(\n      (lastPointerUp = () => {\n        lastPointerUp = null;\n        isPanning = false;\n        if (!isHoldingSpace) {\n          if (this.state.viewModeEnabled) {\n            setCursor(this.canvas, CURSOR_TYPE.GRAB);\n          } else {\n            setCursorForShape(this.canvas, this.state);\n          }\n        }\n        this.setState({\n          cursorButton: \"up\",\n        });\n        this.savePointer(event.clientX, event.clientY, \"up\");\n        window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n        window.removeEventListener(EVENT.POINTER_UP, teardown);\n        window.removeEventListener(EVENT.BLUR, teardown);\n        onPointerMove.flush();\n      }),\n    );\n    window.addEventListener(EVENT.BLUR, teardown);\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove, {\n      passive: true,\n    });\n    window.addEventListener(EVENT.POINTER_UP, teardown);\n    return true;\n  };\n\n  private updateGestureOnPointerDown(\n    event: React.PointerEvent<HTMLElement>,\n  ): void {\n    gesture.pointers.set(event.pointerId, {\n      x: event.clientX,\n      y: event.clientY,\n    });\n\n    if (gesture.pointers.size === 2) {\n      gesture.lastCenter = getCenter(gesture.pointers);\n      gesture.initialScale = this.state.zoom.value;\n      gesture.initialDistance = getDistance(\n        Array.from(gesture.pointers.values()),\n      );\n    }\n  }\n\n  private initialPointerDownState(\n    event: React.PointerEvent<HTMLElement>,\n  ): PointerDownState {\n    const origin = viewportCoordsToSceneCoords(event, this.state);\n    const selectedElements = this.scene.getSelectedElements(this.state);\n    const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);\n\n    return {\n      origin,\n      withCmdOrCtrl: event[KEYS.CTRL_OR_CMD],\n      originInGrid: tupleToCoors(\n        getGridPoint(origin.x, origin.y, this.state.gridSize),\n      ),\n      scrollbars: isOverScrollBars(\n        currentScrollBars,\n        event.clientX - this.state.offsetLeft,\n        event.clientY - this.state.offsetTop,\n      ),\n      // we need to duplicate because we'll be updating this state\n      lastCoords: { ...origin },\n      originalElements: this.scene\n        .getNonDeletedElements()\n        .reduce((acc, element) => {\n          acc.set(element.id, deepCopyElement(element));\n          return acc;\n        }, new Map() as PointerDownState[\"originalElements\"]),\n      resize: {\n        handleType: false,\n        isResizing: false,\n        offset: { x: 0, y: 0 },\n        arrowDirection: \"origin\",\n        center: { x: (maxX + minX) / 2, y: (maxY + minY) / 2 },\n      },\n      hit: {\n        element: null,\n        allHitElements: [],\n        wasAddedToSelection: false,\n        hasBeenDuplicated: false,\n        hasHitCommonBoundingBoxOfSelectedElements:\n          this.isHittingCommonBoundingBoxOfSelectedElements(\n            origin,\n            selectedElements,\n          ),\n      },\n      drag: {\n        hasOccurred: false,\n        offset: null,\n      },\n      eventListeners: {\n        onMove: null,\n        onUp: null,\n        onKeyUp: null,\n        onKeyDown: null,\n      },\n      boxSelection: {\n        hasOccurred: false,\n      },\n      elementIdsToErase: {},\n    };\n  }\n\n  // Returns whether the event is a dragging a scrollbar\n  private handleDraggingScrollBar(\n    event: React.PointerEvent<HTMLElement>,\n    pointerDownState: PointerDownState,\n  ): boolean {\n    if (\n      !(pointerDownState.scrollbars.isOverEither && !this.state.multiElement)\n    ) {\n      return false;\n    }\n    isDraggingScrollBar = true;\n    pointerDownState.lastCoords.x = event.clientX;\n    pointerDownState.lastCoords.y = event.clientY;\n    const onPointerMove = withBatchedUpdatesThrottled((event: PointerEvent) => {\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      this.handlePointerMoveOverScrollbars(event, pointerDownState);\n    });\n\n    const onPointerUp = withBatchedUpdates(() => {\n      isDraggingScrollBar = false;\n      setCursorForShape(this.canvas, this.state);\n      lastPointerUp = null;\n      this.setState({\n        cursorButton: \"up\",\n      });\n      this.savePointer(event.clientX, event.clientY, \"up\");\n      window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.removeEventListener(EVENT.POINTER_UP, onPointerUp);\n      onPointerMove.flush();\n    });\n\n    lastPointerUp = onPointerUp;\n\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n    window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n    return true;\n  }\n\n  private clearSelectionIfNotUsingSelection = (): void => {\n    if (this.state.activeTool.type !== \"selection\") {\n      this.setState({\n        selectedElementIds: makeNextSelectedElementIds({}, this.state),\n        selectedGroupIds: {},\n        editingGroupId: null,\n      });\n    }\n  };\n\n  /**\n   * @returns whether the pointer event has been completely handled\n   */\n  private handleSelectionOnPointerDown = (\n    event: React.PointerEvent<HTMLElement>,\n    pointerDownState: PointerDownState,\n  ): boolean => {\n    if (this.state.activeTool.type === \"selection\") {\n      const elements = this.scene.getNonDeletedElements();\n      const selectedElements = this.scene.getSelectedElements(this.state);\n      if (selectedElements.length === 1 && !this.state.editingLinearElement) {\n        const elementWithTransformHandleType =\n          getElementWithTransformHandleType(\n            elements,\n            this.state,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n            this.state.zoom,\n            event.pointerType,\n          );\n        if (elementWithTransformHandleType != null) {\n          this.setState({\n            resizingElement: elementWithTransformHandleType.element,\n          });\n          pointerDownState.resize.handleType =\n            elementWithTransformHandleType.transformHandleType;\n        }\n      } else if (selectedElements.length > 1) {\n        pointerDownState.resize.handleType = getTransformHandleTypeFromCoords(\n          getCommonBounds(selectedElements),\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n          this.state.zoom,\n          event.pointerType,\n        );\n      }\n      if (pointerDownState.resize.handleType) {\n        pointerDownState.resize.isResizing = true;\n        pointerDownState.resize.offset = tupleToCoors(\n          getResizeOffsetXY(\n            pointerDownState.resize.handleType,\n            selectedElements,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ),\n        );\n        if (\n          selectedElements.length === 1 &&\n          isLinearElement(selectedElements[0]) &&\n          selectedElements[0].points.length === 2\n        ) {\n          pointerDownState.resize.arrowDirection = getResizeArrowDirection(\n            pointerDownState.resize.handleType,\n            selectedElements[0],\n          );\n        }\n      } else {\n        if (this.state.selectedLinearElement) {\n          const linearElementEditor =\n            this.state.editingLinearElement || this.state.selectedLinearElement;\n          const ret = LinearElementEditor.handlePointerDown(\n            event,\n            this.state,\n            this.history,\n            pointerDownState.origin,\n            linearElementEditor,\n          );\n          if (ret.hitElement) {\n            pointerDownState.hit.element = ret.hitElement;\n          }\n          if (ret.linearElementEditor) {\n            this.setState({ selectedLinearElement: ret.linearElementEditor });\n\n            if (this.state.editingLinearElement) {\n              this.setState({ editingLinearElement: ret.linearElementEditor });\n            }\n          }\n          if (ret.didAddPoint) {\n            return true;\n          }\n        }\n        // hitElement may already be set above, so check first\n        pointerDownState.hit.element =\n          pointerDownState.hit.element ??\n          this.getElementAtPosition(\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          );\n\n        if (pointerDownState.hit.element) {\n          // Early return if pointer is hitting link icon\n          const hitLinkElement = this.getElementLinkAtPosition(\n            {\n              x: pointerDownState.origin.x,\n              y: pointerDownState.origin.y,\n            },\n            pointerDownState.hit.element,\n          );\n          if (hitLinkElement) {\n            return false;\n          }\n        }\n\n        // For overlapped elements one position may hit\n        // multiple elements\n        pointerDownState.hit.allHitElements = this.getElementsAtPosition(\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n        );\n\n        const hitElement = pointerDownState.hit.element;\n        const someHitElementIsSelected =\n          pointerDownState.hit.allHitElements.some((element) =>\n            this.isASelectedElement(element),\n          );\n        if (\n          (hitElement === null || !someHitElementIsSelected) &&\n          !event.shiftKey &&\n          !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n        ) {\n          this.clearSelection(hitElement);\n        }\n\n        if (this.state.editingLinearElement) {\n          this.setState({\n            selectedElementIds: makeNextSelectedElementIds(\n              {\n                [this.state.editingLinearElement.elementId]: true,\n              },\n              this.state,\n            ),\n          });\n          // If we click on something\n        } else if (hitElement != null) {\n          // on CMD/CTRL, drill down to hit element regardless of groups etc.\n          if (event[KEYS.CTRL_OR_CMD]) {\n            if (!this.state.selectedElementIds[hitElement.id]) {\n              pointerDownState.hit.wasAddedToSelection = true;\n            }\n            this.setState((prevState) => ({\n              ...editGroupForSelectedElement(prevState, hitElement),\n              previousSelectedElementIds: this.state.selectedElementIds,\n            }));\n            // mark as not completely handled so as to allow dragging etc.\n            return false;\n          }\n\n          // deselect if item is selected\n          // if shift is not clicked, this will always return true\n          // otherwise, it will trigger selection based on current\n          // state of the box\n          if (!this.state.selectedElementIds[hitElement.id]) {\n            // if we are currently editing a group, exiting editing mode and deselect the group.\n            if (\n              this.state.editingGroupId &&\n              !isElementInGroup(hitElement, this.state.editingGroupId)\n            ) {\n              this.setState({\n                selectedElementIds: makeNextSelectedElementIds({}, this.state),\n                selectedGroupIds: {},\n                editingGroupId: null,\n              });\n            }\n\n            // Add hit element to selection. At this point if we're not holding\n            // SHIFT the previously selected element(s) were deselected above\n            // (make sure you use setState updater to use latest state)\n            // With shift-selection, we want to make sure that frames and their containing\n            // elements are not selected at the same time.\n            if (\n              !someHitElementIsSelected &&\n              !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n            ) {\n              this.setState((prevState) => {\n                const nextSelectedElementIds: { [id: string]: true } = {\n                  ...prevState.selectedElementIds,\n                  [hitElement.id]: true,\n                };\n\n                const previouslySelectedElements: ExcalidrawElement[] = [];\n\n                Object.keys(prevState.selectedElementIds).forEach((id) => {\n                  const element = this.scene.getElement(id);\n                  element && previouslySelectedElements.push(element);\n                });\n\n                // if hitElement is frame, deselect all of its elements if they are selected\n                if (hitElement.type === \"frame\") {\n                  getFrameElements(\n                    previouslySelectedElements,\n                    hitElement.id,\n                  ).forEach((element) => {\n                    delete nextSelectedElementIds[element.id];\n                  });\n                } else if (hitElement.frameId) {\n                  // if hitElement is in a frame and its frame has been selected\n                  // disable selection for the given element\n                  if (nextSelectedElementIds[hitElement.frameId]) {\n                    delete nextSelectedElementIds[hitElement.id];\n                  }\n                } else {\n                  // hitElement is neither a frame nor an element in a frame\n                  // but since hitElement could be in a group with some frames\n                  // this means selecting hitElement will have the frames selected as well\n                  // because we want to keep the invariant:\n                  // - frames and their elements are not selected at the same time\n                  // we deselect elements in those frames that were previously selected\n\n                  const groupIds = hitElement.groupIds;\n                  const framesInGroups = new Set(\n                    groupIds\n                      .flatMap((gid) =>\n                        getElementsInGroup(\n                          this.scene.getNonDeletedElements(),\n                          gid,\n                        ),\n                      )\n                      .filter((element) => element.type === \"frame\")\n                      .map((frame) => frame.id),\n                  );\n\n                  if (framesInGroups.size > 0) {\n                    previouslySelectedElements.forEach((element) => {\n                      if (\n                        element.frameId &&\n                        framesInGroups.has(element.frameId)\n                      ) {\n                        // deselect element and groups containing the element\n                        delete nextSelectedElementIds[element.id];\n                        element.groupIds\n                          .flatMap((gid) =>\n                            getElementsInGroup(\n                              this.scene.getNonDeletedElements(),\n                              gid,\n                            ),\n                          )\n                          .forEach((element) => {\n                            delete nextSelectedElementIds[element.id];\n                          });\n                      }\n                    });\n                  }\n                }\n\n                return selectGroupsForSelectedElements(\n                  {\n                    ...prevState,\n                    selectedElementIds: nextSelectedElementIds,\n                    showHyperlinkPopup: hitElement.link ? \"info\" : false,\n                  },\n                  this.scene.getNonDeletedElements(),\n                  prevState,\n                  this,\n                );\n              });\n              pointerDownState.hit.wasAddedToSelection = true;\n            }\n          }\n        }\n\n        this.setState({\n          previousSelectedElementIds: this.state.selectedElementIds,\n        });\n      }\n    }\n    return false;\n  };\n\n  private isASelectedElement(hitElement: ExcalidrawElement | null): boolean {\n    return hitElement != null && this.state.selectedElementIds[hitElement.id];\n  }\n\n  private isHittingCommonBoundingBoxOfSelectedElements(\n    point: Readonly<{ x: number; y: number }>,\n    selectedElements: readonly ExcalidrawElement[],\n  ): boolean {\n    if (selectedElements.length < 2) {\n      return false;\n    }\n\n    // How many pixels off the shape boundary we still consider a hit\n    const threshold = 10 / this.state.zoom.value;\n    const [x1, y1, x2, y2] = getCommonBounds(selectedElements);\n    return (\n      point.x > x1 - threshold &&\n      point.x < x2 + threshold &&\n      point.y > y1 - threshold &&\n      point.y < y2 + threshold\n    );\n  }\n\n  private handleTextOnPointerDown = (\n    event: React.PointerEvent<HTMLElement>,\n    pointerDownState: PointerDownState,\n  ): void => {\n    // if we're currently still editing text, clicking outside\n    // should only finalize it, not create another (irrespective\n    // of state.activeTool.locked)\n    if (isTextElement(this.state.editingElement)) {\n      return;\n    }\n    let sceneX = pointerDownState.origin.x;\n    let sceneY = pointerDownState.origin.y;\n\n    const element = this.getElementAtPosition(sceneX, sceneY, {\n      includeBoundTextElement: true,\n    });\n\n    let container = getTextBindableContainerAtPosition(\n      this.scene.getNonDeletedElements(),\n      this.state,\n      sceneX,\n      sceneY,\n    );\n\n    if (hasBoundTextElement(element)) {\n      container = element as ExcalidrawTextContainer;\n      sceneX = element.x + element.width / 2;\n      sceneY = element.y + element.height / 2;\n    }\n    this.startTextEditing({\n      sceneX,\n      sceneY,\n      insertAtParentCenter: !event.altKey,\n      container,\n    });\n\n    resetCursor(this.canvas);\n    if (!this.state.activeTool.locked) {\n      this.setState({\n        activeTool: updateActiveTool(this.state, { type: \"selection\" }),\n      });\n    }\n  };\n\n  private handleFreeDrawElementOnPointerDown = (\n    event: React.PointerEvent<HTMLElement>,\n    elementType: ExcalidrawFreeDrawElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ) => {\n    // Begin a mark capture. This does not have to update state yet.\n    const [gridX, gridY] = getGridPoint(\n      pointerDownState.origin.x,\n      pointerDownState.origin.y,\n      null,\n    );\n\n    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n      x: gridX,\n      y: gridY,\n    });\n\n    const element = newFreeDrawElement({\n      type: elementType,\n      x: gridX,\n      y: gridY,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      roundness: null,\n      simulatePressure: event.pressure === 0.5,\n      locked: false,\n      frameId: topLayerFrame ? topLayerFrame.id : null,\n    });\n\n    this.setState((prevState) => {\n      const nextSelectedElementIds = {\n        ...prevState.selectedElementIds,\n      };\n      delete nextSelectedElementIds[element.id];\n      return {\n        selectedElementIds: makeNextSelectedElementIds(\n          nextSelectedElementIds,\n          prevState,\n        ),\n      };\n    });\n\n    const pressures = element.simulatePressure\n      ? element.pressures\n      : [...element.pressures, event.pressure];\n\n    mutateElement(element, {\n      points: [[0, 0]],\n      pressures,\n    });\n\n    const boundElement = getHoveredElementForBinding(\n      pointerDownState.origin,\n      this.scene,\n    );\n    this.scene.addNewElement(element);\n    this.setState({\n      draggingElement: element,\n      editingElement: element,\n      startBoundElement: boundElement,\n      suggestedBindings: [],\n    });\n  };\n\n  private createImageElement = ({\n    sceneX,\n    sceneY,\n  }: {\n    sceneX: number;\n    sceneY: number;\n  }) => {\n    const [gridX, gridY] = getGridPoint(sceneX, sceneY, this.state.gridSize);\n\n    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n      x: gridX,\n      y: gridY,\n    });\n\n    const element = newImageElement({\n      type: \"image\",\n      x: gridX,\n      y: gridY,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      roundness: null,\n      opacity: this.state.currentItemOpacity,\n      locked: false,\n      frameId: topLayerFrame ? topLayerFrame.id : null,\n    });\n\n    return element;\n  };\n\n  private handleLinearElementOnPointerDown = (\n    event: React.PointerEvent<HTMLElement>,\n    elementType: ExcalidrawLinearElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ): void => {\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n\n      // finalize if completing a loop\n      if (\n        multiElement.type === \"line\" &&\n        isPathALoop(multiElement.points, this.state.zoom.value)\n      ) {\n        mutateElement(multiElement, {\n          lastCommittedPoint:\n            multiElement.points[multiElement.points.length - 1],\n        });\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      const { x: rx, y: ry, lastCommittedPoint } = multiElement;\n\n      // clicking inside commit zone  finalize arrow\n      if (\n        multiElement.points.length > 1 &&\n        lastCommittedPoint &&\n        distance2d(\n          pointerDownState.origin.x - rx,\n          pointerDownState.origin.y - ry,\n          lastCommittedPoint[0],\n          lastCommittedPoint[1],\n        ) < LINE_CONFIRM_THRESHOLD\n      ) {\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      this.setState((prevState) => ({\n        selectedElementIds: makeNextSelectedElementIds(\n          {\n            ...prevState.selectedElementIds,\n            [multiElement.id]: true,\n          },\n          prevState,\n        ),\n      }));\n      // clicking outside commit zone  update reference for last committed\n      // point\n      mutateElement(multiElement, {\n        lastCommittedPoint: multiElement.points[multiElement.points.length - 1],\n      });\n      setCursor(this.canvas, CURSOR_TYPE.POINTER);\n    } else {\n      const [gridX, gridY] = getGridPoint(\n        pointerDownState.origin.x,\n        pointerDownState.origin.y,\n        this.state.gridSize,\n      );\n\n      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n        x: gridX,\n        y: gridY,\n      });\n\n      /* If arrow is pre-arrowheads, it will have undefined for both start and end arrowheads.\n      If so, we want it to be null for start and \"arrow\" for end. If the linear item is not\n      an arrow, we want it to be null for both. Otherwise, we want it to use the\n      values from appState. */\n\n      const { currentItemStartArrowhead, currentItemEndArrowhead } = this.state;\n      const [startArrowhead, endArrowhead] =\n        elementType === \"arrow\"\n          ? [currentItemStartArrowhead, currentItemEndArrowhead]\n          : [null, null];\n\n      const element = newLinearElement({\n        type: elementType,\n        x: gridX,\n        y: gridY,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        strokeStyle: this.state.currentItemStrokeStyle,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n        roundness:\n          this.state.currentItemRoundness === \"round\"\n            ? { type: ROUNDNESS.PROPORTIONAL_RADIUS }\n            : null,\n        startArrowhead,\n        endArrowhead,\n        locked: false,\n        frameId: topLayerFrame ? topLayerFrame.id : null,\n      });\n      this.setState((prevState) => {\n        const nextSelectedElementIds = {\n          ...prevState.selectedElementIds,\n        };\n        delete nextSelectedElementIds[element.id];\n        return {\n          selectedElementIds: makeNextSelectedElementIds(\n            nextSelectedElementIds,\n            prevState,\n          ),\n        };\n      });\n      mutateElement(element, {\n        points: [...element.points, [0, 0]],\n      });\n      const boundElement = getHoveredElementForBinding(\n        pointerDownState.origin,\n        this.scene,\n      );\n\n      this.scene.addNewElement(element);\n      this.setState({\n        draggingElement: element,\n        editingElement: element,\n        startBoundElement: boundElement,\n        suggestedBindings: [],\n      });\n    }\n  };\n\n  private createGenericElementOnPointerDown = (\n    elementType: ExcalidrawGenericElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ): void => {\n    const [gridX, gridY] = getGridPoint(\n      pointerDownState.origin.x,\n      pointerDownState.origin.y,\n      this.state.gridSize,\n    );\n\n    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n      x: gridX,\n      y: gridY,\n    });\n\n    const element = newElement({\n      type: elementType,\n      x: gridX,\n      y: gridY,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      roundness:\n        this.state.currentItemRoundness === \"round\"\n          ? {\n              type: isUsingAdaptiveRadius(elementType)\n                ? ROUNDNESS.ADAPTIVE_RADIUS\n                : ROUNDNESS.PROPORTIONAL_RADIUS,\n            }\n          : null,\n      locked: false,\n      frameId: topLayerFrame ? topLayerFrame.id : null,\n    });\n\n    if (element.type === \"selection\") {\n      this.setState({\n        selectionElement: element,\n        draggingElement: element,\n      });\n    } else {\n      this.scene.addNewElement(element);\n      this.setState({\n        multiElement: null,\n        draggingElement: element,\n        editingElement: element,\n      });\n    }\n  };\n\n  private createFrameElementOnPointerDown = (\n    pointerDownState: PointerDownState,\n  ): void => {\n    const [gridX, gridY] = getGridPoint(\n      pointerDownState.origin.x,\n      pointerDownState.origin.y,\n      this.state.gridSize,\n    );\n\n    const frame = newFrameElement({\n      x: gridX,\n      y: gridY,\n      opacity: this.state.currentItemOpacity,\n      locked: false,\n      ...FRAME_STYLE,\n    });\n\n    this.scene.replaceAllElements([\n      ...this.scene.getElementsIncludingDeleted(),\n      frame,\n    ]);\n\n    this.setState({\n      multiElement: null,\n      draggingElement: frame,\n      editingElement: frame,\n    });\n  };\n\n  private onKeyDownFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: KeyboardEvent) => void {\n    return withBatchedUpdates((event: KeyboardEvent) => {\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  private onKeyUpFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: KeyboardEvent) => void {\n    return withBatchedUpdates((event: KeyboardEvent) => {\n      // Prevents focus from escaping excalidraw tab\n      event.key === KEYS.ALT && event.preventDefault();\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  private onPointerMoveFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ) {\n    return withBatchedUpdatesThrottled((event: PointerEvent) => {\n      // We need to initialize dragOffsetXY only after we've updated\n      // `state.selectedElementIds` on pointerDown. Doing it here in pointerMove\n      // event handler should hopefully ensure we're already working with\n      // the updated state.\n      if (pointerDownState.drag.offset === null) {\n        pointerDownState.drag.offset = tupleToCoors(\n          getDragOffsetXY(\n            this.scene.getSelectedElements(this.state),\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ),\n        );\n      }\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      if (this.handlePointerMoveOverScrollbars(event, pointerDownState)) {\n        return;\n      }\n\n      const pointerCoords = viewportCoordsToSceneCoords(event, this.state);\n\n      if (isEraserActive(this.state)) {\n        this.handleEraser(event, pointerDownState, pointerCoords);\n        return;\n      }\n\n      const [gridX, gridY] = getGridPoint(\n        pointerCoords.x,\n        pointerCoords.y,\n        this.state.gridSize,\n      );\n\n      // for arrows/lines, don't start dragging until a given threshold\n      // to ensure we don't create a 2-point arrow by mistake when\n      // user clicks mouse in a way that it moves a tiny bit (thus\n      // triggering pointermove)\n      if (\n        !pointerDownState.drag.hasOccurred &&\n        (this.state.activeTool.type === \"arrow\" ||\n          this.state.activeTool.type === \"line\")\n      ) {\n        if (\n          distance2d(\n            pointerCoords.x,\n            pointerCoords.y,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ) < DRAGGING_THRESHOLD\n        ) {\n          return;\n        }\n      }\n      if (pointerDownState.resize.isResizing) {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        if (this.maybeHandleResize(pointerDownState, event)) {\n          return true;\n        }\n      }\n\n      if (this.state.selectedLinearElement) {\n        const linearElementEditor =\n          this.state.editingLinearElement || this.state.selectedLinearElement;\n\n        if (\n          LinearElementEditor.shouldAddMidpoint(\n            this.state.selectedLinearElement,\n            pointerCoords,\n            this.state,\n          )\n        ) {\n          const ret = LinearElementEditor.addMidpoint(\n            this.state.selectedLinearElement,\n            pointerCoords,\n            this.state,\n          );\n          if (!ret) {\n            return;\n          }\n\n          // Since we are reading from previous state which is not possible with\n          // automatic batching in React 18 hence using flush sync to synchronously\n          // update the state. Check https://github.com/excalidraw/excalidraw/pull/5508 for more details.\n\n          flushSync(() => {\n            if (this.state.selectedLinearElement) {\n              this.setState({\n                selectedLinearElement: {\n                  ...this.state.selectedLinearElement,\n                  pointerDownState: ret.pointerDownState,\n                  selectedPointsIndices: ret.selectedPointsIndices,\n                },\n              });\n            }\n            if (this.state.editingLinearElement) {\n              this.setState({\n                editingLinearElement: {\n                  ...this.state.editingLinearElement,\n                  pointerDownState: ret.pointerDownState,\n                  selectedPointsIndices: ret.selectedPointsIndices,\n                },\n              });\n            }\n          });\n\n          return;\n        } else if (\n          linearElementEditor.pointerDownState.segmentMidpoint.value !== null &&\n          !linearElementEditor.pointerDownState.segmentMidpoint.added\n        ) {\n          return;\n        }\n\n        const didDrag = LinearElementEditor.handlePointDragging(\n          event,\n          this.state,\n          pointerCoords.x,\n          pointerCoords.y,\n          (element, pointsSceneCoords) => {\n            this.maybeSuggestBindingsForLinearElementAtCoords(\n              element,\n              pointsSceneCoords,\n            );\n          },\n          linearElementEditor,\n        );\n        if (didDrag) {\n          pointerDownState.lastCoords.x = pointerCoords.x;\n          pointerDownState.lastCoords.y = pointerCoords.y;\n          pointerDownState.drag.hasOccurred = true;\n          if (\n            this.state.editingLinearElement &&\n            !this.state.editingLinearElement.isDragging\n          ) {\n            this.setState({\n              editingLinearElement: {\n                ...this.state.editingLinearElement,\n                isDragging: true,\n              },\n            });\n          }\n          if (!this.state.selectedLinearElement.isDragging) {\n            this.setState({\n              selectedLinearElement: {\n                ...this.state.selectedLinearElement,\n                isDragging: true,\n              },\n            });\n          }\n          return;\n        }\n      }\n\n      const hasHitASelectedElement = pointerDownState.hit.allHitElements.some(\n        (element) => this.isASelectedElement(element),\n      );\n\n      const isSelectingPointsInLineEditor =\n        this.state.editingLinearElement &&\n        event.shiftKey &&\n        this.state.editingLinearElement.elementId ===\n          pointerDownState.hit.element?.id;\n      if (\n        (hasHitASelectedElement ||\n          pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) &&\n        !isSelectingPointsInLineEditor\n      ) {\n        const selectedElements = this.scene.getSelectedElements(this.state);\n\n        if (selectedElements.every((element) => element.locked)) {\n          return;\n        }\n\n        const selectedElementsHasAFrame = selectedElements.find((e) =>\n          isFrameElement(e),\n        );\n        const topLayerFrame = this.getTopLayerFrameAtSceneCoords(pointerCoords);\n        this.setState({\n          frameToHighlight:\n            topLayerFrame && !selectedElementsHasAFrame ? topLayerFrame : null,\n        });\n\n        // Marking that click was used for dragging to check\n        // if elements should be deselected on pointerup\n        pointerDownState.drag.hasOccurred = true;\n        this.setState({\n          selectedElementsAreBeingDragged: true,\n        });\n        // prevent dragging even if we're no longer holding cmd/ctrl otherwise\n        // it would have weird results (stuff jumping all over the screen)\n        // Checking for editingElement to avoid jump while editing on mobile #6503\n        if (\n          selectedElements.length > 0 &&\n          !pointerDownState.withCmdOrCtrl &&\n          !this.state.editingElement\n        ) {\n          const [dragX, dragY] = getGridPoint(\n            pointerCoords.x - pointerDownState.drag.offset.x,\n            pointerCoords.y - pointerDownState.drag.offset.y,\n            this.state.gridSize,\n          );\n\n          const [dragDistanceX, dragDistanceY] = [\n            Math.abs(pointerCoords.x - pointerDownState.origin.x),\n            Math.abs(pointerCoords.y - pointerDownState.origin.y),\n          ];\n\n          // We only drag in one direction if shift is pressed\n          const lockDirection = event.shiftKey;\n          // when we're editing the name of a frame, we want the user to be\n          // able to select and interact with the text input\n          !this.state.editingFrame &&\n            dragSelectedElements(\n              pointerDownState,\n              selectedElements,\n              dragX,\n              dragY,\n              lockDirection,\n              dragDistanceX,\n              dragDistanceY,\n              this.state,\n              this.scene,\n            );\n          this.maybeSuggestBindingForAll(selectedElements);\n\n          // We duplicate the selected element if alt is pressed on pointer move\n          if (event.altKey && !pointerDownState.hit.hasBeenDuplicated) {\n            // Move the currently selected elements to the top of the z index stack, and\n            // put the duplicates where the selected elements used to be.\n            // (the origin point where the dragging started)\n\n            pointerDownState.hit.hasBeenDuplicated = true;\n\n            const nextElements = [];\n            const elementsToAppend = [];\n            const groupIdMap = new Map();\n            const oldIdToDuplicatedId = new Map();\n            const hitElement = pointerDownState.hit.element;\n            const selectedElementIds = new Set(\n              this.scene\n                .getSelectedElements({\n                  selectedElementIds: this.state.selectedElementIds,\n                  includeBoundTextElement: true,\n                  includeElementsInFrames: true,\n                })\n                .map((element) => element.id),\n            );\n\n            const elements = this.scene.getNonDeletedElements();\n\n            for (const element of elements) {\n              if (\n                selectedElementIds.has(element.id) ||\n                // case: the state.selectedElementIds might not have been\n                // updated yet by the time this mousemove event is fired\n                (element.id === hitElement?.id &&\n                  pointerDownState.hit.wasAddedToSelection)\n              ) {\n                const duplicatedElement = duplicateElement(\n                  this.state.editingGroupId,\n                  groupIdMap,\n                  element,\n                );\n                const [originDragX, originDragY] = getGridPoint(\n                  pointerDownState.origin.x - pointerDownState.drag.offset.x,\n                  pointerDownState.origin.y - pointerDownState.drag.offset.y,\n                  this.state.gridSize,\n                );\n                mutateElement(duplicatedElement, {\n                  x: duplicatedElement.x + (originDragX - dragX),\n                  y: duplicatedElement.y + (originDragY - dragY),\n                });\n                nextElements.push(duplicatedElement);\n                elementsToAppend.push(element);\n                oldIdToDuplicatedId.set(element.id, duplicatedElement.id);\n              } else {\n                nextElements.push(element);\n              }\n            }\n            const nextSceneElements = [...nextElements, ...elementsToAppend];\n            bindTextToShapeAfterDuplication(\n              nextElements,\n              elementsToAppend,\n              oldIdToDuplicatedId,\n            );\n            fixBindingsAfterDuplication(\n              nextSceneElements,\n              elementsToAppend,\n              oldIdToDuplicatedId,\n              \"duplicatesServeAsOld\",\n            );\n            bindElementsToFramesAfterDuplication(\n              nextSceneElements,\n              elementsToAppend,\n              oldIdToDuplicatedId,\n            );\n            this.scene.replaceAllElements(nextSceneElements);\n          }\n          return;\n        }\n      }\n\n      // It is very important to read this.state within each move event,\n      // otherwise we would read a stale one!\n      const draggingElement = this.state.draggingElement;\n      if (!draggingElement) {\n        return;\n      }\n\n      if (draggingElement.type === \"freedraw\") {\n        const points = draggingElement.points;\n        const dx = pointerCoords.x - draggingElement.x;\n        const dy = pointerCoords.y - draggingElement.y;\n\n        const lastPoint = points.length > 0 && points[points.length - 1];\n        const discardPoint =\n          lastPoint && lastPoint[0] === dx && lastPoint[1] === dy;\n\n        if (!discardPoint) {\n          const pressures = draggingElement.simulatePressure\n            ? draggingElement.pressures\n            : [...draggingElement.pressures, event.pressure];\n\n          mutateElement(draggingElement, {\n            points: [...points, [dx, dy]],\n            pressures,\n          });\n        }\n      } else if (isLinearElement(draggingElement)) {\n        pointerDownState.drag.hasOccurred = true;\n        this.setState({\n          selectedElementsAreBeingDragged: true,\n        });\n        const points = draggingElement.points;\n        let dx = gridX - draggingElement.x;\n        let dy = gridY - draggingElement.y;\n\n        if (shouldRotateWithDiscreteAngle(event) && points.length === 2) {\n          ({ width: dx, height: dy } = getLockedLinearCursorAlignSize(\n            draggingElement.x,\n            draggingElement.y,\n            pointerCoords.x,\n            pointerCoords.y,\n          ));\n        }\n\n        if (points.length === 1) {\n          mutateElement(draggingElement, {\n            points: [...points, [dx, dy]],\n          });\n        } else if (points.length === 2) {\n          mutateElement(draggingElement, {\n            points: [...points.slice(0, -1), [dx, dy]],\n          });\n        }\n\n        if (isBindingElement(draggingElement, false)) {\n          // When creating a linear element by dragging\n          this.maybeSuggestBindingsForLinearElementAtCoords(\n            draggingElement,\n            [pointerCoords],\n            this.state.startBoundElement,\n          );\n        }\n      } else {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        this.maybeDragNewGenericElement(pointerDownState, event);\n      }\n\n      if (this.state.activeTool.type === \"selection\") {\n        pointerDownState.boxSelection.hasOccurred = true;\n\n        const elements = this.scene.getNonDeletedElements();\n        if (\n          !event.shiftKey &&\n          // allows for box-selecting points (without shift)\n          !this.state.editingLinearElement &&\n          isSomeElementSelected(elements, this.state)\n        ) {\n          if (pointerDownState.withCmdOrCtrl && pointerDownState.hit.element) {\n            this.setState((prevState) =>\n              selectGroupsForSelectedElements(\n                {\n                  ...prevState,\n                  selectedElementIds: {\n                    [pointerDownState.hit.element!.id]: true,\n                  },\n                },\n                this.scene.getNonDeletedElements(),\n                prevState,\n                this,\n              ),\n            );\n          }\n        }\n        // box-select line editor points\n        if (this.state.editingLinearElement) {\n          LinearElementEditor.handleBoxSelection(\n            event,\n            this.state,\n            this.setState.bind(this),\n          );\n          // regular box-select\n        } else {\n          const elementsWithinSelection = getElementsWithinSelection(\n            elements,\n            draggingElement,\n          );\n          this.setState((prevState) => {\n            const nextSelectedElementIds = elementsWithinSelection.reduce(\n              (acc: Record<ExcalidrawElement[\"id\"], true>, element) => {\n                acc[element.id] = true;\n                return acc;\n              },\n              {},\n            );\n\n            if (pointerDownState.hit.element) {\n              // if using ctrl/cmd, select the hitElement only if we\n              // haven't box-selected anything else\n              if (!elementsWithinSelection.length) {\n                nextSelectedElementIds[pointerDownState.hit.element.id] = true;\n              } else {\n                delete nextSelectedElementIds[pointerDownState.hit.element.id];\n              }\n            }\n\n            return selectGroupsForSelectedElements(\n              {\n                ...prevState,\n                selectedElementIds: nextSelectedElementIds,\n                showHyperlinkPopup:\n                  elementsWithinSelection.length === 1 &&\n                  elementsWithinSelection[0].link\n                    ? \"info\"\n                    : false,\n                // select linear element only when we haven't box-selected anything else\n                selectedLinearElement:\n                  elementsWithinSelection.length === 1 &&\n                  isLinearElement(elementsWithinSelection[0])\n                    ? new LinearElementEditor(\n                        elementsWithinSelection[0],\n                        this.scene,\n                      )\n                    : null,\n              },\n              this.scene.getNonDeletedElements(),\n              prevState,\n              this,\n            );\n          });\n        }\n      }\n    });\n  }\n\n  // Returns whether the pointer move happened over either scrollbar\n  private handlePointerMoveOverScrollbars(\n    event: PointerEvent,\n    pointerDownState: PointerDownState,\n  ): boolean {\n    if (pointerDownState.scrollbars.isOverHorizontal) {\n      const x = event.clientX;\n      const dx = x - pointerDownState.lastCoords.x;\n      this.translateCanvas({\n        scrollX: this.state.scrollX - dx / this.state.zoom.value,\n      });\n      pointerDownState.lastCoords.x = x;\n      return true;\n    }\n\n    if (pointerDownState.scrollbars.isOverVertical) {\n      const y = event.clientY;\n      const dy = y - pointerDownState.lastCoords.y;\n      this.translateCanvas({\n        scrollY: this.state.scrollY - dy / this.state.zoom.value,\n      });\n      pointerDownState.lastCoords.y = y;\n      return true;\n    }\n    return false;\n  }\n\n  private onPointerUpFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: PointerEvent) => void {\n    return withBatchedUpdates((childEvent: PointerEvent) => {\n      if (pointerDownState.eventListeners.onMove) {\n        pointerDownState.eventListeners.onMove.flush();\n      }\n\n      const {\n        draggingElement,\n        resizingElement,\n        multiElement,\n        activeTool,\n        isResizing,\n        isRotating,\n      } = this.state;\n      this.setState({\n        isResizing: false,\n        isRotating: false,\n        resizingElement: null,\n        selectionElement: null,\n        frameToHighlight: null,\n        elementsToHighlight: null,\n        cursorButton: \"up\",\n        // text elements are reset on finalize, and resetting on pointerup\n        // may cause issues with double taps\n        editingElement:\n          multiElement || isTextElement(this.state.editingElement)\n            ? this.state.editingElement\n            : null,\n      });\n\n      this.savePointer(childEvent.clientX, childEvent.clientY, \"up\");\n\n      this.setState({\n        selectedElementsAreBeingDragged: false,\n      });\n\n      // Handle end of dragging a point of a linear element, might close a loop\n      // and sets binding element\n      if (this.state.editingLinearElement) {\n        if (\n          !pointerDownState.boxSelection.hasOccurred &&\n          pointerDownState.hit?.element?.id !==\n            this.state.editingLinearElement.elementId\n        ) {\n          this.actionManager.executeAction(actionFinalize);\n        } else {\n          const editingLinearElement = LinearElementEditor.handlePointerUp(\n            childEvent,\n            this.state.editingLinearElement,\n            this.state,\n          );\n          if (editingLinearElement !== this.state.editingLinearElement) {\n            this.setState({\n              editingLinearElement,\n              suggestedBindings: [],\n            });\n          }\n        }\n      } else if (this.state.selectedLinearElement) {\n        if (\n          pointerDownState.hit?.element?.id !==\n          this.state.selectedLinearElement.elementId\n        ) {\n          const selectedELements = this.scene.getSelectedElements(this.state);\n          // set selectedLinearElement to null if there is more than one element selected since we don't want to show linear element handles\n          if (selectedELements.length > 1) {\n            this.setState({ selectedLinearElement: null });\n          }\n        } else {\n          const linearElementEditor = LinearElementEditor.handlePointerUp(\n            childEvent,\n            this.state.selectedLinearElement,\n            this.state,\n          );\n\n          const { startBindingElement, endBindingElement } =\n            linearElementEditor;\n          const element = this.scene.getElement(linearElementEditor.elementId);\n          if (isBindingElement(element)) {\n            bindOrUnbindLinearElement(\n              element,\n              startBindingElement,\n              endBindingElement,\n            );\n          }\n\n          if (linearElementEditor !== this.state.selectedLinearElement) {\n            this.setState({\n              selectedLinearElement: {\n                ...linearElementEditor,\n                selectedPointsIndices: null,\n              },\n              suggestedBindings: [],\n            });\n          }\n        }\n      }\n\n      lastPointerUp = null;\n\n      window.removeEventListener(\n        EVENT.POINTER_MOVE,\n        pointerDownState.eventListeners.onMove!,\n      );\n      window.removeEventListener(\n        EVENT.POINTER_UP,\n        pointerDownState.eventListeners.onUp!,\n      );\n      window.removeEventListener(\n        EVENT.KEYDOWN,\n        pointerDownState.eventListeners.onKeyDown!,\n      );\n      window.removeEventListener(\n        EVENT.KEYUP,\n        pointerDownState.eventListeners.onKeyUp!,\n      );\n\n      if (this.state.pendingImageElementId) {\n        this.setState({ pendingImageElementId: null });\n      }\n\n      if (draggingElement?.type === \"freedraw\") {\n        const pointerCoords = viewportCoordsToSceneCoords(\n          childEvent,\n          this.state,\n        );\n\n        const points = draggingElement.points;\n        let dx = pointerCoords.x - draggingElement.x;\n        let dy = pointerCoords.y - draggingElement.y;\n\n        // Allows dots to avoid being flagged as infinitely small\n        if (dx === points[0][0] && dy === points[0][1]) {\n          dy += 0.0001;\n          dx += 0.0001;\n        }\n\n        const pressures = draggingElement.simulatePressure\n          ? []\n          : [...draggingElement.pressures, childEvent.pressure];\n\n        mutateElement(draggingElement, {\n          points: [...points, [dx, dy]],\n          pressures,\n          lastCommittedPoint: [dx, dy],\n        });\n\n        this.actionManager.executeAction(actionFinalize);\n\n        return;\n      }\n      if (isImageElement(draggingElement)) {\n        const imageElement = draggingElement;\n        try {\n          this.initializeImageDimensions(imageElement);\n          this.setState(\n            {\n              selectedElementIds: makeNextSelectedElementIds(\n                { [imageElement.id]: true },\n                this.state,\n              ),\n            },\n            () => {\n              this.actionManager.executeAction(actionFinalize);\n            },\n          );\n        } catch (error: any) {\n          console.error(error);\n          this.scene.replaceAllElements(\n            this.scene\n              .getElementsIncludingDeleted()\n              .filter((el) => el.id !== imageElement.id),\n          );\n          this.actionManager.executeAction(actionFinalize);\n        }\n        return;\n      }\n\n      if (isLinearElement(draggingElement)) {\n        if (draggingElement!.points.length > 1) {\n          this.history.resumeRecording();\n        }\n        const pointerCoords = viewportCoordsToSceneCoords(\n          childEvent,\n          this.state,\n        );\n\n        if (\n          !pointerDownState.drag.hasOccurred &&\n          draggingElement &&\n          !multiElement\n        ) {\n          mutateElement(draggingElement, {\n            points: [\n              ...draggingElement.points,\n              [\n                pointerCoords.x - draggingElement.x,\n                pointerCoords.y - draggingElement.y,\n              ],\n            ],\n          });\n          this.setState({\n            multiElement: draggingElement,\n            editingElement: this.state.draggingElement,\n          });\n        } else if (pointerDownState.drag.hasOccurred && !multiElement) {\n          if (\n            isBindingEnabled(this.state) &&\n            isBindingElement(draggingElement, false)\n          ) {\n            maybeBindLinearElement(\n              draggingElement,\n              this.state,\n              this.scene,\n              pointerCoords,\n            );\n          }\n          this.setState({ suggestedBindings: [], startBoundElement: null });\n          if (!activeTool.locked) {\n            resetCursor(this.canvas);\n            this.setState((prevState) => ({\n              draggingElement: null,\n              activeTool: updateActiveTool(this.state, {\n                type: \"selection\",\n              }),\n              selectedElementIds: makeNextSelectedElementIds(\n                {\n                  ...prevState.selectedElementIds,\n                  [draggingElement.id]: true,\n                },\n                prevState,\n              ),\n              selectedLinearElement: new LinearElementEditor(\n                draggingElement,\n                this.scene,\n              ),\n            }));\n          } else {\n            this.setState((prevState) => ({\n              draggingElement: null,\n            }));\n          }\n        }\n        return;\n      }\n\n      if (\n        activeTool.type !== \"selection\" &&\n        draggingElement &&\n        isInvisiblySmallElement(draggingElement)\n      ) {\n        // remove invisible element which was added in onPointerDown\n        this.scene.replaceAllElements(\n          this.scene.getElementsIncludingDeleted().slice(0, -1),\n        );\n        this.setState({\n          draggingElement: null,\n        });\n        return;\n      }\n\n      if (draggingElement) {\n        if (pointerDownState.drag.hasOccurred) {\n          const sceneCoords = viewportCoordsToSceneCoords(\n            childEvent,\n            this.state,\n          );\n\n          // when editing the points of a linear element, we check if the\n          // linear element still is in the frame afterwards\n          // if not, the linear element will be removed from its frame (if any)\n          if (\n            this.state.selectedLinearElement &&\n            this.state.selectedLinearElement.isDragging\n          ) {\n            const linearElement = this.scene.getElement(\n              this.state.selectedLinearElement.elementId,\n            );\n\n            if (linearElement?.frameId) {\n              const frame = getContainingFrame(linearElement);\n\n              if (frame && linearElement) {\n                if (!elementOverlapsWithFrame(linearElement, frame)) {\n                  // remove the linear element from all groups\n                  // before removing it from the frame as well\n                  mutateElement(linearElement, {\n                    groupIds: [],\n                  });\n\n                  this.scene.replaceAllElements(\n                    removeElementsFromFrame(\n                      this.scene.getElementsIncludingDeleted(),\n                      [linearElement],\n                      this.state,\n                    ),\n                  );\n                }\n              }\n            }\n          } else {\n            // update the relationships between selected elements and frames\n            const topLayerFrame =\n              this.getTopLayerFrameAtSceneCoords(sceneCoords);\n\n            const selectedElements = this.scene.getSelectedElements(this.state);\n            let nextElements = this.scene.getElementsIncludingDeleted();\n\n            const updateGroupIdsAfterEditingGroup = (\n              elements: ExcalidrawElement[],\n            ) => {\n              if (elements.length > 0) {\n                for (const element of elements) {\n                  const index = element.groupIds.indexOf(\n                    this.state.editingGroupId!,\n                  );\n\n                  mutateElement(\n                    element,\n                    {\n                      groupIds: element.groupIds.slice(0, index),\n                    },\n                    false,\n                  );\n                }\n\n                nextElements.forEach((element) => {\n                  if (\n                    element.groupIds.length &&\n                    getElementsInGroup(\n                      nextElements,\n                      element.groupIds[element.groupIds.length - 1],\n                    ).length < 2\n                  ) {\n                    mutateElement(\n                      element,\n                      {\n                        groupIds: [],\n                      },\n                      false,\n                    );\n                  }\n                });\n\n                this.setState({\n                  editingGroupId: null,\n                });\n              }\n            };\n\n            if (\n              topLayerFrame &&\n              !this.state.selectedElementIds[topLayerFrame.id]\n            ) {\n              const elementsToAdd = selectedElements.filter(\n                (element) =>\n                  element.frameId !== topLayerFrame.id &&\n                  isElementInFrame(element, nextElements, this.state),\n              );\n\n              if (this.state.editingGroupId) {\n                updateGroupIdsAfterEditingGroup(elementsToAdd);\n              }\n\n              nextElements = addElementsToFrame(\n                nextElements,\n                elementsToAdd,\n                topLayerFrame,\n              );\n            } else if (!topLayerFrame) {\n              if (this.state.editingGroupId) {\n                const elementsToRemove = selectedElements.filter(\n                  (element) =>\n                    element.frameId &&\n                    !isElementInFrame(element, nextElements, this.state),\n                );\n\n                updateGroupIdsAfterEditingGroup(elementsToRemove);\n              }\n            }\n\n            nextElements = updateFrameMembershipOfSelectedElements(\n              this.scene.getElementsIncludingDeleted(),\n              this.state,\n              this,\n            );\n\n            this.scene.replaceAllElements(nextElements);\n          }\n        }\n\n        if (draggingElement.type === \"frame\") {\n          const elementsInsideFrame = getElementsInNewFrame(\n            this.scene.getElementsIncludingDeleted(),\n            draggingElement,\n          );\n\n          this.scene.replaceAllElements(\n            addElementsToFrame(\n              this.scene.getElementsIncludingDeleted(),\n              elementsInsideFrame,\n              draggingElement,\n            ),\n          );\n        }\n\n        mutateElement(\n          draggingElement,\n          getNormalizedDimensions(draggingElement),\n        );\n      }\n\n      if (resizingElement) {\n        this.history.resumeRecording();\n      }\n\n      if (resizingElement && isInvisiblySmallElement(resizingElement)) {\n        this.scene.replaceAllElements(\n          this.scene\n            .getElementsIncludingDeleted()\n            .filter((el) => el.id !== resizingElement.id),\n        );\n      }\n\n      // handle frame membership for resizing frames and/or selected elements\n      if (pointerDownState.resize.isResizing) {\n        let nextElements = updateFrameMembershipOfSelectedElements(\n          this.scene.getElementsIncludingDeleted(),\n          this.state,\n          this,\n        );\n\n        const selectedFrames = this.scene\n          .getSelectedElements(this.state)\n          .filter(\n            (element) => element.type === \"frame\",\n          ) as ExcalidrawFrameElement[];\n\n        for (const frame of selectedFrames) {\n          nextElements = replaceAllElementsInFrame(\n            nextElements,\n            getElementsInResizingFrame(\n              this.scene.getElementsIncludingDeleted(),\n              frame,\n              this.state,\n            ),\n            frame,\n            this.state,\n          );\n        }\n\n        this.scene.replaceAllElements(nextElements);\n      }\n\n      // Code below handles selection when element(s) weren't\n      // drag or added to selection on pointer down phase.\n      const hitElement = pointerDownState.hit.element;\n      if (\n        this.state.selectedLinearElement?.elementId !== hitElement?.id &&\n        isLinearElement(hitElement)\n      ) {\n        const selectedELements = this.scene.getSelectedElements(this.state);\n        // set selectedLinearElement when no other element selected except\n        // the one we've hit\n        if (selectedELements.length === 1) {\n          this.setState({\n            selectedLinearElement: new LinearElementEditor(\n              hitElement,\n              this.scene,\n            ),\n          });\n        }\n      }\n      if (isEraserActive(this.state)) {\n        const draggedDistance = distance2d(\n          this.lastPointerDown!.clientX,\n          this.lastPointerDown!.clientY,\n          this.lastPointerUp!.clientX,\n          this.lastPointerUp!.clientY,\n        );\n\n        if (draggedDistance === 0) {\n          const scenePointer = viewportCoordsToSceneCoords(\n            {\n              clientX: this.lastPointerUp!.clientX,\n              clientY: this.lastPointerUp!.clientY,\n            },\n            this.state,\n          );\n          const hitElements = this.getElementsAtPosition(\n            scenePointer.x,\n            scenePointer.y,\n          );\n          hitElements.forEach(\n            (hitElement) =>\n              (pointerDownState.elementIdsToErase[hitElement.id] = {\n                erase: true,\n                opacity: hitElement.opacity,\n              }),\n          );\n        }\n        this.eraseElements(pointerDownState);\n        return;\n      } else if (Object.keys(pointerDownState.elementIdsToErase).length) {\n        this.restoreReadyToEraseElements(pointerDownState);\n      }\n\n      if (\n        hitElement &&\n        !pointerDownState.drag.hasOccurred &&\n        !pointerDownState.hit.wasAddedToSelection &&\n        // if we're editing a line, pointerup shouldn't switch selection if\n        // box selected\n        (!this.state.editingLinearElement ||\n          !pointerDownState.boxSelection.hasOccurred)\n      ) {\n        // when inside line editor, shift selects points instead\n        if (childEvent.shiftKey && !this.state.editingLinearElement) {\n          if (this.state.selectedElementIds[hitElement.id]) {\n            if (isSelectedViaGroup(this.state, hitElement)) {\n              this.setState((_prevState) => {\n                const nextSelectedElementIds = {\n                  ..._prevState.selectedElementIds,\n                };\n\n                // We want to unselect all groups hitElement is part of\n                // as well as all elements that are part of the groups\n                // hitElement is part of\n                for (const groupedElement of hitElement.groupIds.flatMap(\n                  (groupId) =>\n                    getElementsInGroup(\n                      this.scene.getNonDeletedElements(),\n                      groupId,\n                    ),\n                )) {\n                  delete nextSelectedElementIds[groupedElement.id];\n                }\n\n                return {\n                  selectedGroupIds: {\n                    ..._prevState.selectedElementIds,\n                    ...hitElement.groupIds\n                      .map((gId) => ({ [gId]: false }))\n                      .reduce((prev, acc) => ({ ...prev, ...acc }), {}),\n                  },\n                  selectedElementIds: makeNextSelectedElementIds(\n                    nextSelectedElementIds,\n                    _prevState,\n                  ),\n                };\n              });\n              // if not gragging a linear element point (outside editor)\n            } else if (!this.state.selectedLinearElement?.isDragging) {\n              // remove element from selection while\n              // keeping prev elements selected\n\n              this.setState((prevState) => {\n                const newSelectedElementIds = {\n                  ...prevState.selectedElementIds,\n                };\n                delete newSelectedElementIds[hitElement!.id];\n                const newSelectedElements = getSelectedElements(\n                  this.scene.getNonDeletedElements(),\n                  { selectedElementIds: newSelectedElementIds },\n                );\n\n                return selectGroupsForSelectedElements(\n                  {\n                    ...prevState,\n                    selectedElementIds: newSelectedElementIds,\n                    // set selectedLinearElement only if thats the only element selected\n                    selectedLinearElement:\n                      newSelectedElements.length === 1 &&\n                      isLinearElement(newSelectedElements[0])\n                        ? new LinearElementEditor(\n                            newSelectedElements[0],\n                            this.scene,\n                          )\n                        : prevState.selectedLinearElement,\n                  },\n                  this.scene.getNonDeletedElements(),\n                  prevState,\n                  this,\n                );\n              });\n            }\n          } else if (\n            hitElement.frameId &&\n            this.state.selectedElementIds[hitElement.frameId]\n          ) {\n            // when hitElement is part of a selected frame, deselect the frame\n            // to avoid frame and containing elements selected simultaneously\n            this.setState((prevState) => {\n              const nextSelectedElementIds: {\n                [id: string]: true;\n              } = {\n                ...prevState.selectedElementIds,\n                [hitElement.id]: true,\n              };\n              // deselect the frame\n              delete nextSelectedElementIds[hitElement.frameId!];\n\n              // deselect groups containing the frame\n              (this.scene.getElement(hitElement.frameId!)?.groupIds ?? [])\n                .flatMap((gid) =>\n                  getElementsInGroup(this.scene.getNonDeletedElements(), gid),\n                )\n                .forEach((element) => {\n                  delete nextSelectedElementIds[element.id];\n                });\n\n              return selectGroupsForSelectedElements(\n                {\n                  ...prevState,\n                  selectedElementIds: nextSelectedElementIds,\n                  showHyperlinkPopup: hitElement.link ? \"info\" : false,\n                },\n                this.scene.getNonDeletedElements(),\n                prevState,\n                this,\n              );\n            });\n          } else {\n            // add element to selection while keeping prev elements selected\n            this.setState((_prevState) => ({\n              selectedElementIds: makeNextSelectedElementIds(\n                {\n                  ..._prevState.selectedElementIds,\n                  [hitElement!.id]: true,\n                },\n                _prevState,\n              ),\n            }));\n          }\n        } else {\n          this.setState((prevState) => ({\n            ...selectGroupsForSelectedElements(\n              {\n                ...prevState,\n                selectedElementIds: { [hitElement.id]: true },\n                selectedLinearElement:\n                  isLinearElement(hitElement) &&\n                  // Don't set `selectedLinearElement` if its same as the hitElement, this is mainly to prevent resetting the `hoverPointIndex` to -1.\n                  // Future we should update the API to take care of setting the correct `hoverPointIndex` when initialized\n                  prevState.selectedLinearElement?.elementId !== hitElement.id\n                    ? new LinearElementEditor(hitElement, this.scene)\n                    : prevState.selectedLinearElement,\n              },\n              this.scene.getNonDeletedElements(),\n              prevState,\n              this,\n            ),\n          }));\n        }\n      }\n\n      if (\n        !pointerDownState.drag.hasOccurred &&\n        !this.state.isResizing &&\n        ((hitElement &&\n          isHittingElementBoundingBoxWithoutHittingElement(\n            hitElement,\n            this.state,\n            this.frameNameBoundsCache,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          )) ||\n          (!hitElement &&\n            pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements))\n      ) {\n        if (this.state.editingLinearElement) {\n          this.setState({ editingLinearElement: null });\n        } else {\n          // Deselect selected elements\n          this.setState({\n            selectedElementIds: makeNextSelectedElementIds({}, this.state),\n            selectedGroupIds: {},\n            editingGroupId: null,\n          });\n        }\n        return;\n      }\n\n      if (\n        !activeTool.locked &&\n        activeTool.type !== \"freedraw\" &&\n        draggingElement &&\n        draggingElement.type !== \"selection\"\n      ) {\n        this.setState((prevState) => ({\n          selectedElementIds: makeNextSelectedElementIds(\n            {\n              ...prevState.selectedElementIds,\n              [draggingElement.id]: true,\n            },\n            prevState,\n          ),\n        }));\n      }\n\n      if (\n        activeTool.type !== \"selection\" ||\n        isSomeElementSelected(this.scene.getNonDeletedElements(), this.state)\n      ) {\n        this.history.resumeRecording();\n      }\n\n      if (pointerDownState.drag.hasOccurred || isResizing || isRotating) {\n        (isBindingEnabled(this.state)\n          ? bindOrUnbindSelectedElements\n          : unbindLinearElements)(this.scene.getSelectedElements(this.state));\n      }\n\n      if (!activeTool.locked && activeTool.type !== \"freedraw\") {\n        resetCursor(this.canvas);\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: [],\n          activeTool: updateActiveTool(this.state, { type: \"selection\" }),\n        });\n      } else {\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: [],\n        });\n      }\n    });\n  }\n\n  private restoreReadyToEraseElements = (\n    pointerDownState: PointerDownState,\n  ) => {\n    const elements = this.scene.getElementsIncludingDeleted().map((ele) => {\n      if (\n        pointerDownState.elementIdsToErase[ele.id] &&\n        pointerDownState.elementIdsToErase[ele.id].erase\n      ) {\n        return newElementWith(ele, {\n          opacity: pointerDownState.elementIdsToErase[ele.id].opacity,\n        });\n      } else if (\n        isBoundToContainer(ele) &&\n        pointerDownState.elementIdsToErase[ele.containerId] &&\n        pointerDownState.elementIdsToErase[ele.containerId].erase\n      ) {\n        return newElementWith(ele, {\n          opacity: pointerDownState.elementIdsToErase[ele.containerId].opacity,\n        });\n      } else if (\n        ele.frameId &&\n        pointerDownState.elementIdsToErase[ele.frameId] &&\n        pointerDownState.elementIdsToErase[ele.frameId].erase\n      ) {\n        return newElementWith(ele, {\n          opacity: pointerDownState.elementIdsToErase[ele.frameId].opacity,\n        });\n      }\n      return ele;\n    });\n\n    this.scene.replaceAllElements(elements);\n  };\n\n  private eraseElements = (pointerDownState: PointerDownState) => {\n    const elements = this.scene.getElementsIncludingDeleted().map((ele) => {\n      if (\n        pointerDownState.elementIdsToErase[ele.id] &&\n        pointerDownState.elementIdsToErase[ele.id].erase\n      ) {\n        return newElementWith(ele, { isDeleted: true });\n      } else if (\n        isBoundToContainer(ele) &&\n        pointerDownState.elementIdsToErase[ele.containerId] &&\n        pointerDownState.elementIdsToErase[ele.containerId].erase\n      ) {\n        return newElementWith(ele, { isDeleted: true });\n      } else if (\n        ele.frameId &&\n        pointerDownState.elementIdsToErase[ele.frameId] &&\n        pointerDownState.elementIdsToErase[ele.frameId].erase\n      ) {\n        return newElementWith(ele, { isDeleted: true });\n      }\n      return ele;\n    });\n\n    this.history.resumeRecording();\n    this.scene.replaceAllElements(elements);\n  };\n\n  private initializeImage = async ({\n    imageFile,\n    imageElement: _imageElement,\n    showCursorImagePreview = false,\n  }: {\n    imageFile: File;\n    imageElement: ExcalidrawImageElement;\n    showCursorImagePreview?: boolean;\n  }) => {\n    // at this point this should be guaranteed image file, but we do this check\n    // to satisfy TS down the line\n    if (!isSupportedImageFile(imageFile)) {\n      throw new Error(t(\"errors.unsupportedFileType\"));\n    }\n    const mimeType = imageFile.type;\n\n    setCursor(this.canvas, \"wait\");\n\n    if (mimeType === MIME_TYPES.svg) {\n      try {\n        imageFile = SVGStringToFile(\n          await normalizeSVG(await imageFile.text()),\n          imageFile.name,\n        );\n      } catch (error: any) {\n        console.warn(error);\n        throw new Error(t(\"errors.svgImageInsertError\"));\n      }\n    }\n\n    // generate image id (by default the file digest) before any\n    // resizing/compression takes place to keep it more portable\n    const fileId = await ((this.props.generateIdForFile?.(\n      imageFile,\n    ) as Promise<FileId>) || generateIdFromFile(imageFile));\n\n    if (!fileId) {\n      console.warn(\n        \"Couldn't generate file id or the supplied `generateIdForFile` didn't resolve to one.\",\n      );\n      throw new Error(t(\"errors.imageInsertError\"));\n    }\n\n    const existingFileData = this.files[fileId];\n    if (!existingFileData?.dataURL) {\n      try {\n        imageFile = await resizeImageFile(imageFile, {\n          maxWidthOrHeight: DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT,\n        });\n      } catch (error: any) {\n        console.error(\"error trying to resing image file on insertion\", error);\n      }\n\n      if (imageFile.size > MAX_ALLOWED_FILE_BYTES) {\n        throw new Error(\n          t(\"errors.fileTooBig\", {\n            maxSize: `${Math.trunc(MAX_ALLOWED_FILE_BYTES / 1024 / 1024)}MB`,\n          }),\n        );\n      }\n    }\n\n    if (showCursorImagePreview) {\n      const dataURL = this.files[fileId]?.dataURL;\n      // optimization so that we don't unnecessarily resize the original\n      // full-size file for cursor preview\n      // (it's much faster to convert the resized dataURL to File)\n      const resizedFile = dataURL && dataURLToFile(dataURL);\n\n      this.setImagePreviewCursor(resizedFile || imageFile);\n    }\n\n    const dataURL =\n      this.files[fileId]?.dataURL || (await getDataURL(imageFile));\n\n    const imageElement = mutateElement(\n      _imageElement,\n      {\n        fileId,\n      },\n      false,\n    ) as NonDeleted<InitializedExcalidrawImageElement>;\n\n    return new Promise<NonDeleted<InitializedExcalidrawImageElement>>(\n      async (resolve, reject) => {\n        try {\n          this.files = {\n            ...this.files,\n            [fileId]: {\n              mimeType,\n              id: fileId,\n              dataURL,\n              created: Date.now(),\n              lastRetrieved: Date.now(),\n            },\n          };\n          const cachedImageData = this.imageCache.get(fileId);\n          if (!cachedImageData) {\n            this.addNewImagesToImageCache();\n            await this.updateImageCache([imageElement]);\n          }\n          if (cachedImageData?.image instanceof Promise) {\n            await cachedImageData.image;\n          }\n          if (\n            this.state.pendingImageElementId !== imageElement.id &&\n            this.state.draggingElement?.id !== imageElement.id\n          ) {\n            this.initializeImageDimensions(imageElement, true);\n          }\n          resolve(imageElement);\n        } catch (error: any) {\n          console.error(error);\n          reject(new Error(t(\"errors.imageInsertError\")));\n        } finally {\n          if (!showCursorImagePreview) {\n            resetCursor(this.canvas);\n          }\n        }\n      },\n    );\n  };\n\n  /**\n   * inserts image into elements array and rerenders\n   */\n  private insertImageElement = async (\n    imageElement: ExcalidrawImageElement,\n    imageFile: File,\n    showCursorImagePreview?: boolean,\n  ) => {\n    this.scene.addNewElement(imageElement);\n\n    try {\n      await this.initializeImage({\n        imageFile,\n        imageElement,\n        showCursorImagePreview,\n      });\n    } catch (error: any) {\n      mutateElement(imageElement, {\n        isDeleted: true,\n      });\n      this.actionManager.executeAction(actionFinalize);\n      this.setState({\n        errorMessage: error.message || t(\"errors.imageInsertError\"),\n      });\n    }\n  };\n\n  private setImagePreviewCursor = async (imageFile: File) => {\n    // mustn't be larger than 128 px\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Basic_User_Interface/Using_URL_values_for_the_cursor_property\n    const cursorImageSizePx = 96;\n\n    const imagePreview = await resizeImageFile(imageFile, {\n      maxWidthOrHeight: cursorImageSizePx,\n    });\n\n    let previewDataURL = await getDataURL(imagePreview);\n\n    // SVG cannot be resized via `resizeImageFile` so we resize by rendering to\n    // a small canvas\n    if (imageFile.type === MIME_TYPES.svg) {\n      const img = await loadHTMLImageElement(previewDataURL);\n\n      let height = Math.min(img.height, cursorImageSizePx);\n      let width = height * (img.width / img.height);\n\n      if (width > cursorImageSizePx) {\n        width = cursorImageSizePx;\n        height = width * (img.height / img.width);\n      }\n\n      const canvas = document.createElement(\"canvas\");\n      canvas.height = height;\n      canvas.width = width;\n      const context = canvas.getContext(\"2d\")!;\n\n      context.drawImage(img, 0, 0, width, height);\n\n      previewDataURL = canvas.toDataURL(MIME_TYPES.svg) as DataURL;\n    }\n\n    if (this.state.pendingImageElementId) {\n      setCursor(this.canvas, `url(${previewDataURL}) 4 4, auto`);\n    }\n  };\n\n  private onImageAction = async (\n    { insertOnCanvasDirectly } = { insertOnCanvasDirectly: false },\n  ) => {\n    try {\n      const clientX = this.state.width / 2 + this.state.offsetLeft;\n      const clientY = this.state.height / 2 + this.state.offsetTop;\n\n      const { x, y } = viewportCoordsToSceneCoords(\n        { clientX, clientY },\n        this.state,\n      );\n\n      const imageFile = await fileOpen({\n        description: \"Image\",\n        extensions: Object.keys(\n          IMAGE_MIME_TYPES,\n        ) as (keyof typeof IMAGE_MIME_TYPES)[],\n      });\n\n      const imageElement = this.createImageElement({\n        sceneX: x,\n        sceneY: y,\n      });\n\n      if (insertOnCanvasDirectly) {\n        this.insertImageElement(imageElement, imageFile);\n        this.initializeImageDimensions(imageElement);\n        this.setState(\n          {\n            selectedElementIds: makeNextSelectedElementIds(\n              { [imageElement.id]: true },\n              this.state,\n            ),\n          },\n          () => {\n            this.actionManager.executeAction(actionFinalize);\n          },\n        );\n      } else {\n        this.setState(\n          {\n            pendingImageElementId: imageElement.id,\n          },\n          () => {\n            this.insertImageElement(\n              imageElement,\n              imageFile,\n              /* showCursorImagePreview */ true,\n            );\n          },\n        );\n      }\n    } catch (error: any) {\n      if (error.name !== \"AbortError\") {\n        console.error(error);\n      } else {\n        console.warn(error);\n      }\n      this.setState(\n        {\n          pendingImageElementId: null,\n          editingElement: null,\n          activeTool: updateActiveTool(this.state, { type: \"selection\" }),\n        },\n        () => {\n          this.actionManager.executeAction(actionFinalize);\n        },\n      );\n    }\n  };\n\n  private initializeImageDimensions = (\n    imageElement: ExcalidrawImageElement,\n    forceNaturalSize = false,\n  ) => {\n    const image =\n      isInitializedImageElement(imageElement) &&\n      this.imageCache.get(imageElement.fileId)?.image;\n\n    if (!image || image instanceof Promise) {\n      if (\n        imageElement.width < DRAGGING_THRESHOLD / this.state.zoom.value &&\n        imageElement.height < DRAGGING_THRESHOLD / this.state.zoom.value\n      ) {\n        const placeholderSize = 100 / this.state.zoom.value;\n        mutateElement(imageElement, {\n          x: imageElement.x - placeholderSize / 2,\n          y: imageElement.y - placeholderSize / 2,\n          width: placeholderSize,\n          height: placeholderSize,\n        });\n      }\n\n      return;\n    }\n\n    if (\n      forceNaturalSize ||\n      // if user-created bounding box is below threshold, assume the\n      // intention was to click instead of drag, and use the image's\n      // intrinsic size\n      (imageElement.width < DRAGGING_THRESHOLD / this.state.zoom.value &&\n        imageElement.height < DRAGGING_THRESHOLD / this.state.zoom.value)\n    ) {\n      const minHeight = Math.max(this.state.height - 120, 160);\n      // max 65% of canvas height, clamped to <300px, vh - 120px>\n      const maxHeight = Math.min(\n        minHeight,\n        Math.floor(this.state.height * 0.5) / this.state.zoom.value,\n      );\n\n      const height = Math.min(image.naturalHeight, maxHeight);\n      const width = height * (image.naturalWidth / image.naturalHeight);\n\n      // add current imageElement width/height to account for previous centering\n      // of the placeholder image\n      const x = imageElement.x + imageElement.width / 2 - width / 2;\n      const y = imageElement.y + imageElement.height / 2 - height / 2;\n\n      mutateElement(imageElement, { x, y, width, height });\n    }\n  };\n\n  /** updates image cache, refreshing updated elements and/or setting status\n      to error for images that fail during <img> element creation */\n  private updateImageCache = async (\n    elements: readonly InitializedExcalidrawImageElement[],\n    files = this.files,\n  ) => {\n    const { updatedFiles, erroredFiles } = await _updateImageCache({\n      imageCache: this.imageCache,\n      fileIds: elements.map((element) => element.fileId),\n      files,\n    });\n    if (updatedFiles.size || erroredFiles.size) {\n      for (const element of elements) {\n        if (updatedFiles.has(element.fileId)) {\n          invalidateShapeForElement(element);\n        }\n      }\n    }\n    if (erroredFiles.size) {\n      this.scene.replaceAllElements(\n        this.scene.getElementsIncludingDeleted().map((element) => {\n          if (\n            isInitializedImageElement(element) &&\n            erroredFiles.has(element.fileId)\n          ) {\n            return newElementWith(element, {\n              status: \"error\",\n            });\n          }\n          return element;\n        }),\n      );\n    }\n\n    return { updatedFiles, erroredFiles };\n  };\n\n  /** adds new images to imageCache and re-renders if needed */\n  private addNewImagesToImageCache = async (\n    imageElements: InitializedExcalidrawImageElement[] = getInitializedImageElements(\n      this.scene.getNonDeletedElements(),\n    ),\n    files: BinaryFiles = this.files,\n  ) => {\n    const uncachedImageElements = imageElements.filter(\n      (element) => !element.isDeleted && !this.imageCache.has(element.fileId),\n    );\n\n    if (uncachedImageElements.length) {\n      const { updatedFiles } = await this.updateImageCache(\n        uncachedImageElements,\n        files,\n      );\n      if (updatedFiles.size) {\n        this.scene.informMutation();\n      }\n    }\n  };\n\n  /** generally you should use `addNewImagesToImageCache()` directly if you need\n   *  to render new images. This is just a failsafe  */\n  private scheduleImageRefresh = throttle(() => {\n    this.addNewImagesToImageCache();\n  }, IMAGE_RENDER_TIMEOUT);\n\n  private updateBindingEnabledOnPointerMove = (\n    event: React.PointerEvent<HTMLElement>,\n  ) => {\n    const shouldEnableBinding = shouldEnableBindingForPointerEvent(event);\n    if (this.state.isBindingEnabled !== shouldEnableBinding) {\n      this.setState({ isBindingEnabled: shouldEnableBinding });\n    }\n  };\n\n  private maybeSuggestBindingAtCursor = (pointerCoords: {\n    x: number;\n    y: number;\n  }): void => {\n    const hoveredBindableElement = getHoveredElementForBinding(\n      pointerCoords,\n      this.scene,\n    );\n    this.setState({\n      suggestedBindings:\n        hoveredBindableElement != null ? [hoveredBindableElement] : [],\n    });\n  };\n\n  private maybeSuggestBindingsForLinearElementAtCoords = (\n    linearElement: NonDeleted<ExcalidrawLinearElement>,\n    /** scene coords */\n    pointerCoords: {\n      x: number;\n      y: number;\n    }[],\n    // During line creation the start binding hasn't been written yet\n    // into `linearElement`\n    oppositeBindingBoundElement?: ExcalidrawBindableElement | null,\n  ): void => {\n    if (!pointerCoords.length) {\n      return;\n    }\n\n    const suggestedBindings = pointerCoords.reduce(\n      (acc: NonDeleted<ExcalidrawBindableElement>[], coords) => {\n        const hoveredBindableElement = getHoveredElementForBinding(\n          coords,\n          this.scene,\n        );\n        if (\n          hoveredBindableElement != null &&\n          !isLinearElementSimpleAndAlreadyBound(\n            linearElement,\n            oppositeBindingBoundElement?.id,\n            hoveredBindableElement,\n          )\n        ) {\n          acc.push(hoveredBindableElement);\n        }\n        return acc;\n      },\n      [],\n    );\n\n    this.setState({ suggestedBindings });\n  };\n\n  private maybeSuggestBindingForAll(\n    selectedElements: NonDeleted<ExcalidrawElement>[],\n  ): void {\n    const suggestedBindings = getEligibleElementsForBinding(selectedElements);\n    this.setState({ suggestedBindings });\n  }\n\n  private clearSelection(hitElement: ExcalidrawElement | null): void {\n    this.setState((prevState) => ({\n      selectedElementIds: makeNextSelectedElementIds({}, prevState),\n      selectedGroupIds: {},\n      // Continue editing the same group if the user selected a different\n      // element from it\n      editingGroupId:\n        prevState.editingGroupId &&\n        hitElement != null &&\n        isElementInGroup(hitElement, prevState.editingGroupId)\n          ? prevState.editingGroupId\n          : null,\n    }));\n    this.setState({\n      selectedElementIds: makeNextSelectedElementIds({}, this.state),\n      previousSelectedElementIds: this.state.selectedElementIds,\n    });\n  }\n\n  private handleCanvasRef = (canvas: HTMLCanvasElement) => {\n    // canvas is null when unmounting\n    if (canvas !== null) {\n      this.canvas = canvas;\n      this.rc = rough.canvas(this.canvas);\n\n      this.canvas.addEventListener(EVENT.WHEEL, this.handleWheel, {\n        passive: false,\n      });\n      this.canvas.addEventListener(EVENT.TOUCH_START, this.onTapStart);\n      this.canvas.addEventListener(EVENT.TOUCH_END, this.onTapEnd);\n    } else {\n      this.canvas?.removeEventListener(EVENT.WHEEL, this.handleWheel);\n      this.canvas?.removeEventListener(EVENT.TOUCH_START, this.onTapStart);\n      this.canvas?.removeEventListener(EVENT.TOUCH_END, this.onTapEnd);\n    }\n  };\n\n  private handleAppOnDrop = async (event: React.DragEvent<HTMLDivElement>) => {\n    // must be retrieved first, in the same frame\n    const { file, fileHandle } = await getFileFromEvent(event);\n\n    try {\n      if (isSupportedImageFile(file)) {\n        // first attempt to decode scene from the image if it's embedded\n        // ---------------------------------------------------------------------\n\n        if (file?.type === MIME_TYPES.png || file?.type === MIME_TYPES.svg) {\n          try {\n            const scene = await loadFromBlob(\n              file,\n              this.state,\n              this.scene.getElementsIncludingDeleted(),\n              fileHandle,\n            );\n            this.syncActionResult({\n              ...scene,\n              appState: {\n                ...(scene.appState || this.state),\n                isLoading: false,\n              },\n              replaceFiles: true,\n              commitToHistory: true,\n            });\n            return;\n          } catch (error: any) {\n            if (error.name !== \"EncodingError\") {\n              throw error;\n            }\n          }\n        }\n\n        // if no scene is embedded or we fail for whatever reason, fall back\n        // to importing as regular image\n        // ---------------------------------------------------------------------\n\n        const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n          event,\n          this.state,\n        );\n\n        const imageElement = this.createImageElement({ sceneX, sceneY });\n        this.insertImageElement(imageElement, file);\n        this.initializeImageDimensions(imageElement);\n        this.setState({\n          selectedElementIds: makeNextSelectedElementIds(\n            { [imageElement.id]: true },\n            this.state,\n          ),\n        });\n\n        return;\n      }\n    } catch (error: any) {\n      return this.setState({\n        isLoading: false,\n        errorMessage: error.message,\n      });\n    }\n\n    const libraryJSON = event.dataTransfer.getData(MIME_TYPES.excalidrawlib);\n    if (libraryJSON && typeof libraryJSON === \"string\") {\n      try {\n        const libraryItems = parseLibraryJSON(libraryJSON);\n        this.addElementsFromPasteOrLibrary({\n          elements: distributeLibraryItemsOnSquareGrid(libraryItems),\n          position: event,\n          files: null,\n        });\n      } catch (error: any) {\n        this.setState({ errorMessage: error.message });\n      }\n      return;\n    }\n\n    if (file) {\n      // atetmpt to parse an excalidraw/excalidrawlib file\n      await this.loadFileToCanvas(file, fileHandle);\n    }\n  };\n\n  loadFileToCanvas = async (\n    file: File,\n    fileHandle: FileSystemHandle | null,\n  ) => {\n    file = await normalizeFile(file);\n    try {\n      const ret = await loadSceneOrLibraryFromBlob(\n        file,\n        this.state,\n        this.scene.getElementsIncludingDeleted(),\n        fileHandle,\n      );\n      if (ret.type === MIME_TYPES.excalidraw) {\n        this.setState({ isLoading: true });\n        this.syncActionResult({\n          ...ret.data,\n          appState: {\n            ...(ret.data.appState || this.state),\n            isLoading: false,\n          },\n          replaceFiles: true,\n          commitToHistory: true,\n        });\n      } else if (ret.type === MIME_TYPES.excalidrawlib) {\n        await this.library\n          .updateLibrary({\n            libraryItems: file,\n            merge: true,\n            openLibraryMenu: true,\n          })\n          .catch((error) => {\n            console.error(error);\n            this.setState({ errorMessage: t(\"errors.importLibraryError\") });\n          });\n      }\n    } catch (error: any) {\n      this.setState({ isLoading: false, errorMessage: error.message });\n    }\n  };\n\n  private handleCanvasContextMenu = (\n    event: React.PointerEvent<HTMLElement>,\n  ) => {\n    event.preventDefault();\n\n    if (\n      (event.nativeEvent.pointerType === \"touch\" ||\n        (event.nativeEvent.pointerType === \"pen\" &&\n          // always allow if user uses a pen secondary button\n          event.button !== POINTER_BUTTON.SECONDARY)) &&\n      this.state.activeTool.type !== \"selection\"\n    ) {\n      return;\n    }\n\n    const { x, y } = viewportCoordsToSceneCoords(event, this.state);\n    const element = this.getElementAtPosition(x, y, {\n      preferSelected: true,\n      includeLockedElements: true,\n    });\n\n    const selectedElements = this.scene.getSelectedElements(this.state);\n    const isHittignCommonBoundBox =\n      this.isHittingCommonBoundingBoxOfSelectedElements(\n        { x, y },\n        selectedElements,\n      );\n\n    const type = element || isHittignCommonBoundBox ? \"element\" : \"canvas\";\n\n    const container = this.excalidrawContainerRef.current!;\n    const { top: offsetTop, left: offsetLeft } =\n      container.getBoundingClientRect();\n    const left = event.clientX - offsetLeft;\n    const top = event.clientY - offsetTop;\n\n    trackEvent(\"contextMenu\", \"openContextMenu\", type);\n\n    this.setState(\n      {\n        ...(element && !this.state.selectedElementIds[element.id]\n          ? selectGroupsForSelectedElements(\n              {\n                ...this.state,\n                selectedElementIds: { [element.id]: true },\n                selectedLinearElement: isLinearElement(element)\n                  ? new LinearElementEditor(element, this.scene)\n                  : null,\n              },\n              this.scene.getNonDeletedElements(),\n              this.state,\n              this,\n            )\n          : this.state),\n        showHyperlinkPopup: false,\n      },\n      () => {\n        this.setState({\n          contextMenu: { top, left, items: this.getContextMenuItems(type) },\n        });\n      },\n    );\n  };\n\n  private maybeDragNewGenericElement = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n  ): void => {\n    const draggingElement = this.state.draggingElement;\n    const pointerCoords = pointerDownState.lastCoords;\n    if (!draggingElement) {\n      return;\n    }\n    if (\n      draggingElement.type === \"selection\" &&\n      this.state.activeTool.type !== \"eraser\"\n    ) {\n      dragNewElement(\n        draggingElement,\n        this.state.activeTool.type,\n        pointerDownState.origin.x,\n        pointerDownState.origin.y,\n        pointerCoords.x,\n        pointerCoords.y,\n        distance(pointerDownState.origin.x, pointerCoords.x),\n        distance(pointerDownState.origin.y, pointerCoords.y),\n        shouldMaintainAspectRatio(event),\n        shouldResizeFromCenter(event),\n      );\n    } else {\n      const [gridX, gridY] = getGridPoint(\n        pointerCoords.x,\n        pointerCoords.y,\n        this.state.gridSize,\n      );\n\n      const image =\n        isInitializedImageElement(draggingElement) &&\n        this.imageCache.get(draggingElement.fileId)?.image;\n      const aspectRatio =\n        image && !(image instanceof Promise)\n          ? image.width / image.height\n          : null;\n\n      dragNewElement(\n        draggingElement,\n        this.state.activeTool.type,\n        pointerDownState.originInGrid.x,\n        pointerDownState.originInGrid.y,\n        gridX,\n        gridY,\n        distance(pointerDownState.originInGrid.x, gridX),\n        distance(pointerDownState.originInGrid.y, gridY),\n        isImageElement(draggingElement)\n          ? !shouldMaintainAspectRatio(event)\n          : shouldMaintainAspectRatio(event),\n        shouldResizeFromCenter(event),\n        aspectRatio,\n      );\n\n      this.maybeSuggestBindingForAll([draggingElement]);\n\n      // highlight elements that are to be added to frames on frames creation\n      if (this.state.activeTool.type === \"frame\") {\n        this.setState({\n          elementsToHighlight: getElementsInResizingFrame(\n            this.scene.getNonDeletedElements(),\n            draggingElement as ExcalidrawFrameElement,\n            this.state,\n          ),\n        });\n      }\n    }\n  };\n\n  private maybeHandleResize = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n  ): boolean => {\n    const selectedElements = this.scene.getSelectedElements(this.state);\n    const selectedFrames = selectedElements.filter(\n      (element) => element.type === \"frame\",\n    ) as ExcalidrawFrameElement[];\n\n    const transformHandleType = pointerDownState.resize.handleType;\n\n    if (selectedFrames.length > 0 && transformHandleType === \"rotation\") {\n      return false;\n    }\n\n    this.setState({\n      // TODO: rename this state field to \"isScaling\" to distinguish\n      // it from the generic \"isResizing\" which includes scaling and\n      // rotating\n      isResizing: transformHandleType && transformHandleType !== \"rotation\",\n      isRotating: transformHandleType === \"rotation\",\n    });\n    const pointerCoords = pointerDownState.lastCoords;\n    const [resizeX, resizeY] = getGridPoint(\n      pointerCoords.x - pointerDownState.resize.offset.x,\n      pointerCoords.y - pointerDownState.resize.offset.y,\n      this.state.gridSize,\n    );\n\n    const frameElementsOffsetsMap = new Map<\n      string,\n      {\n        x: number;\n        y: number;\n      }\n    >();\n\n    selectedFrames.forEach((frame) => {\n      const elementsInFrame = getFrameElements(\n        this.scene.getNonDeletedElements(),\n        frame.id,\n      );\n\n      elementsInFrame.forEach((element) => {\n        frameElementsOffsetsMap.set(frame.id + element.id, {\n          x: element.x - frame.x,\n          y: element.y - frame.y,\n        });\n      });\n    });\n\n    if (\n      transformElements(\n        pointerDownState,\n        transformHandleType,\n        selectedElements,\n        pointerDownState.resize.arrowDirection,\n        shouldRotateWithDiscreteAngle(event),\n        shouldResizeFromCenter(event),\n        selectedElements.length === 1 && isImageElement(selectedElements[0])\n          ? !shouldMaintainAspectRatio(event)\n          : shouldMaintainAspectRatio(event),\n        resizeX,\n        resizeY,\n        pointerDownState.resize.center.x,\n        pointerDownState.resize.center.y,\n      )\n    ) {\n      this.maybeSuggestBindingForAll(selectedElements);\n\n      const elementsToHighlight = new Set<ExcalidrawElement>();\n      selectedFrames.forEach((frame) => {\n        const elementsInFrame = getFrameElements(\n          this.scene.getNonDeletedElements(),\n          frame.id,\n        );\n\n        // keep elements' positions relative to their frames on frames resizing\n        if (transformHandleType) {\n          if (transformHandleType.includes(\"w\")) {\n            elementsInFrame.forEach((element) => {\n              mutateElement(element, {\n                x:\n                  frame.x +\n                  (frameElementsOffsetsMap.get(frame.id + element.id)?.x || 0),\n                y:\n                  frame.y +\n                  (frameElementsOffsetsMap.get(frame.id + element.id)?.y || 0),\n              });\n            });\n          }\n          if (transformHandleType.includes(\"n\")) {\n            elementsInFrame.forEach((element) => {\n              mutateElement(element, {\n                x:\n                  frame.x +\n                  (frameElementsOffsetsMap.get(frame.id + element.id)?.x || 0),\n                y:\n                  frame.y +\n                  (frameElementsOffsetsMap.get(frame.id + element.id)?.y || 0),\n              });\n            });\n          }\n        }\n\n        getElementsInResizingFrame(\n          this.scene.getNonDeletedElements(),\n          frame,\n          this.state,\n        ).forEach((element) => elementsToHighlight.add(element));\n      });\n\n      this.setState({\n        elementsToHighlight: [...elementsToHighlight],\n      });\n\n      return true;\n    }\n    return false;\n  };\n\n  private getContextMenuItems = (\n    type: \"canvas\" | \"element\",\n  ): ContextMenuItems => {\n    const options: ContextMenuItems = [];\n\n    options.push(actionCopyAsPng, actionCopyAsSvg);\n\n    // canvas contextMenu\n    // -------------------------------------------------------------------------\n\n    if (type === \"canvas\") {\n      if (this.state.viewModeEnabled) {\n        return [\n          ...options,\n          actionToggleGridMode,\n          actionToggleZenMode,\n          actionToggleViewMode,\n          actionToggleStats,\n        ];\n      }\n\n      return [\n        actionPaste,\n        CONTEXT_MENU_SEPARATOR,\n        actionCopyAsPng,\n        actionCopyAsSvg,\n        copyText,\n        CONTEXT_MENU_SEPARATOR,\n        actionSelectAll,\n        actionUnlockAllElements,\n        CONTEXT_MENU_SEPARATOR,\n        actionToggleGridMode,\n        actionToggleZenMode,\n        actionToggleViewMode,\n        actionToggleStats,\n      ];\n    }\n\n    // element contextMenu\n    // -------------------------------------------------------------------------\n\n    options.push(copyText);\n\n    if (this.state.viewModeEnabled) {\n      return [actionCopy, ...options];\n    }\n\n    return [\n      actionCut,\n      actionCopy,\n      actionPaste,\n      actionSelectAllElementsInFrame,\n      actionRemoveAllElementsFromFrame,\n      CONTEXT_MENU_SEPARATOR,\n      ...options,\n      CONTEXT_MENU_SEPARATOR,\n      actionCopyStyles,\n      actionPasteStyles,\n      CONTEXT_MENU_SEPARATOR,\n      actionGroup,\n      actionUnbindText,\n      actionBindText,\n      actionWrapTextInContainer,\n      actionUngroup,\n      CONTEXT_MENU_SEPARATOR,\n      actionAddToLibrary,\n      CONTEXT_MENU_SEPARATOR,\n      actionSendBackward,\n      actionBringForward,\n      actionSendToBack,\n      actionBringToFront,\n      CONTEXT_MENU_SEPARATOR,\n      actionFlipHorizontal,\n      actionFlipVertical,\n      CONTEXT_MENU_SEPARATOR,\n      actionToggleLinearEditor,\n      actionLink,\n      actionDuplicateSelection,\n      actionToggleElementLock,\n      CONTEXT_MENU_SEPARATOR,\n      actionDeleteSelected,\n    ];\n  };\n\n  private handleWheel = withBatchedUpdates(\n    (event: WheelEvent | React.WheelEvent<HTMLDivElement>) => {\n      event.preventDefault();\n      if (isPanning) {\n        return;\n      }\n\n      const { deltaX, deltaY } = event;\n      // note that event.ctrlKey is necessary to handle pinch zooming\n      if (event.metaKey || event.ctrlKey) {\n        const sign = Math.sign(deltaY);\n        const MAX_STEP = ZOOM_STEP * 100;\n        const absDelta = Math.abs(deltaY);\n        let delta = deltaY;\n        if (absDelta > MAX_STEP) {\n          delta = MAX_STEP * sign;\n        }\n\n        let newZoom = this.state.zoom.value - delta / 100;\n        // increase zoom steps the more zoomed-in we are (applies to >100% only)\n        newZoom +=\n          Math.log10(Math.max(1, this.state.zoom.value)) *\n          -sign *\n          // reduced amplification for small deltas (small movements on a trackpad)\n          Math.min(1, absDelta / 20);\n\n        this.translateCanvas((state) => ({\n          ...getStateForZoom(\n            {\n              viewportX: this.lastViewportPosition.x,\n              viewportY: this.lastViewportPosition.y,\n              nextZoom: getNormalizedZoom(newZoom),\n            },\n            state,\n          ),\n          shouldCacheIgnoreZoom: true,\n        }));\n        this.resetShouldCacheIgnoreZoomDebounced();\n        return;\n      }\n\n      // scroll horizontally when shift pressed\n      if (event.shiftKey) {\n        this.translateCanvas(({ zoom, scrollX }) => ({\n          // on Mac, shift+wheel tends to result in deltaX\n          scrollX: scrollX - (deltaY || deltaX) / zoom.value,\n        }));\n        return;\n      }\n\n      this.translateCanvas(({ zoom, scrollX, scrollY }) => ({\n        scrollX: scrollX - deltaX / zoom.value,\n        scrollY: scrollY - deltaY / zoom.value,\n      }));\n    },\n  );\n\n  private getTextWysiwygSnappedToCenterPosition(\n    x: number,\n    y: number,\n    appState: AppState,\n    container?: ExcalidrawTextContainer | null,\n  ) {\n    if (container) {\n      let elementCenterX = container.x + container.width / 2;\n      let elementCenterY = container.y + container.height / 2;\n\n      const elementCenter = getContainerCenter(container, appState);\n      if (elementCenter) {\n        elementCenterX = elementCenter.x;\n        elementCenterY = elementCenter.y;\n      }\n      const distanceToCenter = Math.hypot(\n        x - elementCenterX,\n        y - elementCenterY,\n      );\n      const isSnappedToCenter =\n        distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;\n      if (isSnappedToCenter) {\n        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n          { sceneX: elementCenterX, sceneY: elementCenterY },\n          appState,\n        );\n        return { viewportX, viewportY, elementCenterX, elementCenterY };\n      }\n    }\n  }\n\n  private savePointer = (x: number, y: number, button: \"up\" | \"down\") => {\n    if (!x || !y) {\n      return;\n    }\n    const pointer = viewportCoordsToSceneCoords(\n      { clientX: x, clientY: y },\n      this.state,\n    );\n\n    if (isNaN(pointer.x) || isNaN(pointer.y)) {\n      // sometimes the pointer goes off screen\n    }\n\n    this.props.onPointerUpdate?.({\n      pointer,\n      button,\n      pointersMap: gesture.pointers,\n    });\n  };\n\n  private resetShouldCacheIgnoreZoomDebounced = debounce(() => {\n    if (!this.unmounted) {\n      this.setState({ shouldCacheIgnoreZoom: false });\n    }\n  }, 300);\n\n  private updateDOMRect = (cb?: () => void) => {\n    if (this.excalidrawContainerRef?.current) {\n      const excalidrawContainer = this.excalidrawContainerRef.current;\n      const {\n        width,\n        height,\n        left: offsetLeft,\n        top: offsetTop,\n      } = excalidrawContainer.getBoundingClientRect();\n      const {\n        width: currentWidth,\n        height: currentHeight,\n        offsetTop: currentOffsetTop,\n        offsetLeft: currentOffsetLeft,\n      } = this.state;\n\n      if (\n        width === currentWidth &&\n        height === currentHeight &&\n        offsetLeft === currentOffsetLeft &&\n        offsetTop === currentOffsetTop\n      ) {\n        if (cb) {\n          cb();\n        }\n        return;\n      }\n\n      this.setState(\n        {\n          width,\n          height,\n          offsetLeft,\n          offsetTop,\n        },\n        () => {\n          cb && cb();\n        },\n      );\n    }\n  };\n\n  public refresh = () => {\n    this.setState({ ...this.getCanvasOffsets() });\n  };\n\n  private getCanvasOffsets(): Pick<AppState, \"offsetTop\" | \"offsetLeft\"> {\n    if (this.excalidrawContainerRef?.current) {\n      const excalidrawContainer = this.excalidrawContainerRef.current;\n      const { left, top } = excalidrawContainer.getBoundingClientRect();\n      return {\n        offsetLeft: left,\n        offsetTop: top,\n      };\n    }\n    return {\n      offsetLeft: 0,\n      offsetTop: 0,\n    };\n  }\n\n  private async updateLanguage() {\n    const currentLang =\n      languages.find((lang) => lang.code === this.props.langCode) ||\n      defaultLang;\n    await setLanguage(currentLang);\n    this.setAppState({});\n  }\n}\n\n// -----------------------------------------------------------------------------\n// TEST HOOKS\n// -----------------------------------------------------------------------------\n\ndeclare global {\n  interface Window {\n    h: {\n      elements: readonly ExcalidrawElement[];\n      state: AppState;\n      setState: React.Component<any, AppState>[\"setState\"];\n      app: InstanceType<typeof App>;\n      history: History;\n    };\n  }\n}\n\nif (\n  process.env.NODE_ENV === ENV.TEST ||\n  process.env.NODE_ENV === ENV.DEVELOPMENT\n) {\n  window.h = window.h || ({} as Window[\"h\"]);\n\n  Object.defineProperties(window.h, {\n    elements: {\n      configurable: true,\n      get() {\n        return this.app?.scene.getElementsIncludingDeleted();\n      },\n      set(elements: ExcalidrawElement[]) {\n        return this.app?.scene.replaceAllElements(elements);\n      },\n    },\n  });\n}\n\nexport default App;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}