{"ast":null,"code":"import { getCommonBounds, getElementAbsoluteCoords, isTextElement } from \"./element\";\nimport { isPointWithinBounds } from \"./math\";\nimport { getBoundTextElement, getContainerElement } from \"./element/textElement\";\nimport { arrayToMap, findIndex } from \"./utils\";\nimport { mutateElement } from \"./element/mutateElement\";\nimport { getElementsWithinSelection, getSelectedElements } from \"./scene\";\nimport { isFrameElement } from \"./element\";\nimport { moveOneRight } from \"./zindex\";\nimport { getElementsInGroup, selectGroupsFromGivenElements } from \"./groups\";\nimport Scene from \"./scene/Scene\";\nimport { getElementLineSegments } from \"./element/bounds\";\n\n// --------------------------- Frame State ------------------------------------\nexport const bindElementsToFramesAfterDuplication = (nextElements, oldElements, oldIdToDuplicatedId) => {\n  const nextElementMap = arrayToMap(nextElements);\n  for (const element of oldElements) {\n    if (element.frameId) {\n      // use its frameId to get the new frameId\n      const nextElementId = oldIdToDuplicatedId.get(element.id);\n      const nextFrameId = oldIdToDuplicatedId.get(element.frameId);\n      if (nextElementId) {\n        const nextElement = nextElementMap.get(nextElementId);\n        if (nextElement) {\n          mutateElement(nextElement, {\n            frameId: nextFrameId !== null && nextFrameId !== void 0 ? nextFrameId : element.frameId\n          }, false);\n        }\n      }\n    }\n  }\n};\n\n// --------------------------- Frame Geometry ---------------------------------\nclass Point {\n  constructor(x, y) {\n    this.x = void 0;\n    this.y = void 0;\n    this.x = x;\n    this.y = y;\n  }\n}\nclass LineSegment {\n  constructor(pointA, pointB) {\n    this.first = void 0;\n    this.second = void 0;\n    this.first = pointA;\n    this.second = pointB;\n  }\n  getBoundingBox() {\n    return [new Point(Math.min(this.first.x, this.second.x), Math.min(this.first.y, this.second.y)), new Point(Math.max(this.first.x, this.second.x), Math.max(this.first.y, this.second.y))];\n  }\n}\n\n// https://martin-thoma.com/how-to-check-if-two-line-segments-intersect/\nclass FrameGeometry {\n  static crossProduct(a, b) {\n    return a.x * b.y - b.x * a.y;\n  }\n  static doBoundingBoxesIntersect(a, b) {\n    return a[0].x <= b[1].x && a[1].x >= b[0].x && a[0].y <= b[1].y && a[1].y >= b[0].y;\n  }\n  static isPointOnLine(a, b) {\n    const aTmp = new LineSegment(new Point(0, 0), new Point(a.second.x - a.first.x, a.second.y - a.first.y));\n    const bTmp = new Point(b.x - a.first.x, b.y - a.first.y);\n    const r = this.crossProduct(aTmp.second, bTmp);\n    return Math.abs(r) < this.EPSILON;\n  }\n  static isPointRightOfLine(a, b) {\n    const aTmp = new LineSegment(new Point(0, 0), new Point(a.second.x - a.first.x, a.second.y - a.first.y));\n    const bTmp = new Point(b.x - a.first.x, b.y - a.first.y);\n    return this.crossProduct(aTmp.second, bTmp) < 0;\n  }\n  static lineSegmentTouchesOrCrossesLine(a, b) {\n    return this.isPointOnLine(a, b.first) || this.isPointOnLine(a, b.second) || (this.isPointRightOfLine(a, b.first) ? !this.isPointRightOfLine(a, b.second) : this.isPointRightOfLine(a, b.second));\n  }\n  static doLineSegmentsIntersect(a, b) {\n    const aSegment = new LineSegment(new Point(a[0][0], a[0][1]), new Point(a[1][0], a[1][1]));\n    const bSegment = new LineSegment(new Point(b[0][0], b[0][1]), new Point(b[1][0], b[1][1]));\n    const box1 = aSegment.getBoundingBox();\n    const box2 = bSegment.getBoundingBox();\n    return this.doBoundingBoxesIntersect(box1, box2) && this.lineSegmentTouchesOrCrossesLine(aSegment, bSegment) && this.lineSegmentTouchesOrCrossesLine(bSegment, aSegment);\n  }\n  static isElementIntersectingFrame(element, frame) {\n    const frameLineSegments = getElementLineSegments(frame);\n    const elementLineSegments = getElementLineSegments(element);\n    const intersecting = frameLineSegments.some(frameLineSegment => elementLineSegments.some(elementLineSegment => this.doLineSegmentsIntersect(frameLineSegment, elementLineSegment)));\n    return intersecting;\n  }\n}\nFrameGeometry.EPSILON = 0.000001;\nexport const getElementsCompletelyInFrame = (elements, frame) => omitGroupsContainingFrames(getElementsWithinSelection(elements, frame, false)).filter(element => element.type !== \"frame\" && !element.frameId || element.frameId === frame.id);\nexport const isElementContainingFrame = (elements, element, frame) => {\n  return getElementsWithinSelection(elements, element).some(e => e.id === frame.id);\n};\nexport const getElementsIntersectingFrame = (elements, frame) => elements.filter(element => FrameGeometry.isElementIntersectingFrame(element, frame));\nexport const elementsAreInFrameBounds = (elements, frame) => {\n  const [selectionX1, selectionY1, selectionX2, selectionY2] = getElementAbsoluteCoords(frame);\n  const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(elements);\n  return selectionX1 <= elementX1 && selectionY1 <= elementY1 && selectionX2 >= elementX2 && selectionY2 >= elementY2;\n};\nexport const elementOverlapsWithFrame = (element, frame) => {\n  return elementsAreInFrameBounds([element], frame) || FrameGeometry.isElementIntersectingFrame(element, frame) || isElementContainingFrame([frame], element, frame);\n};\nexport const isCursorInFrame = (cursorCoords, frame) => {\n  const [fx1, fy1, fx2, fy2] = getElementAbsoluteCoords(frame);\n  return isPointWithinBounds([fx1, fy1], [cursorCoords.x, cursorCoords.y], [fx2, fy2]);\n};\nexport const groupsAreAtLeastIntersectingTheFrame = (elements, groupIds, frame) => {\n  const elementsInGroup = groupIds.flatMap(groupId => getElementsInGroup(elements, groupId));\n  if (elementsInGroup.length === 0) {\n    return true;\n  }\n  return !!elementsInGroup.find(element => elementsAreInFrameBounds([element], frame) || FrameGeometry.isElementIntersectingFrame(element, frame));\n};\nexport const groupsAreCompletelyOutOfFrame = (elements, groupIds, frame) => {\n  const elementsInGroup = groupIds.flatMap(groupId => getElementsInGroup(elements, groupId));\n  if (elementsInGroup.length === 0) {\n    return true;\n  }\n  return elementsInGroup.find(element => elementsAreInFrameBounds([element], frame) || FrameGeometry.isElementIntersectingFrame(element, frame)) === undefined;\n};\n\n// --------------------------- Frame Utils ------------------------------------\n\n/**\n * Returns a map of frameId to frame elements. Includes empty frames.\n */\nexport const groupByFrames = elements => {\n  const frameElementsMap = new Map();\n  for (const element of elements) {\n    const frameId = isFrameElement(element) ? element.id : element.frameId;\n    if (frameId && !frameElementsMap.has(frameId)) {\n      frameElementsMap.set(frameId, getFrameElements(elements, frameId));\n    }\n  }\n  return frameElementsMap;\n};\nexport const getFrameElements = (allElements, frameId) => allElements.filter(element => element.frameId === frameId);\nexport const getElementsInResizingFrame = (allElements, frame, appState) => {\n  const prevElementsInFrame = getFrameElements(allElements, frame.id);\n  const nextElementsInFrame = new Set(prevElementsInFrame);\n  const elementsCompletelyInFrame = new Set([...getElementsCompletelyInFrame(allElements, frame), ...prevElementsInFrame.filter(element => isElementContainingFrame(allElements, element, frame))]);\n  const elementsNotCompletelyInFrame = prevElementsInFrame.filter(element => !elementsCompletelyInFrame.has(element));\n\n  // for elements that are completely in the frame\n  // if they are part of some groups, then those groups are still\n  // considered to belong to the frame\n  const groupsToKeep = new Set(Array.from(elementsCompletelyInFrame).flatMap(element => element.groupIds));\n  for (const element of elementsNotCompletelyInFrame) {\n    if (!FrameGeometry.isElementIntersectingFrame(element, frame)) {\n      if (element.groupIds.length === 0) {\n        nextElementsInFrame.delete(element);\n      }\n    } else if (element.groupIds.length > 0) {\n      // group element intersects with the frame, we should keep the groups\n      // that this element is part of\n      for (const id of element.groupIds) {\n        groupsToKeep.add(id);\n      }\n    }\n  }\n  for (const element of elementsNotCompletelyInFrame) {\n    if (element.groupIds.length > 0) {\n      let shouldRemoveElement = true;\n      for (const id of element.groupIds) {\n        if (groupsToKeep.has(id)) {\n          shouldRemoveElement = false;\n        }\n      }\n      if (shouldRemoveElement) {\n        nextElementsInFrame.delete(element);\n      }\n    }\n  }\n  const individualElementsCompletelyInFrame = Array.from(elementsCompletelyInFrame).filter(element => element.groupIds.length === 0);\n  for (const element of individualElementsCompletelyInFrame) {\n    nextElementsInFrame.add(element);\n  }\n  const newGroupElementsCompletelyInFrame = Array.from(elementsCompletelyInFrame).filter(element => element.groupIds.length > 0);\n  const groupIds = selectGroupsFromGivenElements(newGroupElementsCompletelyInFrame, appState);\n\n  // new group elements\n  for (const [id, isSelected] of Object.entries(groupIds)) {\n    if (isSelected) {\n      const elementsInGroup = getElementsInGroup(allElements, id);\n      if (elementsAreInFrameBounds(elementsInGroup, frame)) {\n        for (const element of elementsInGroup) {\n          nextElementsInFrame.add(element);\n        }\n      }\n    }\n  }\n  return [...nextElementsInFrame].filter(element => {\n    return !(isTextElement(element) && element.containerId);\n  });\n};\nexport const getElementsInNewFrame = (allElements, frame) => {\n  return omitGroupsContainingFrames(allElements, getElementsCompletelyInFrame(allElements, frame));\n};\nexport const getContainingFrame = (element, elementsMap) => {\n  if (element.frameId) {\n    var _Scene$getScene;\n    if (elementsMap) {\n      return elementsMap.get(element.frameId) || null;\n    }\n    return ((_Scene$getScene = Scene.getScene(element)) === null || _Scene$getScene === void 0 ? void 0 : _Scene$getScene.getElement(element.frameId)) || null;\n  }\n  return null;\n};\n\n// --------------------------- Frame Operations -------------------------------\nexport const addElementsToFrame = (allElements, elementsToAdd, frame) => {\n  const _elementsToAdd = [];\n  for (const element of elementsToAdd) {\n    _elementsToAdd.push(element);\n    const boundTextElement = getBoundTextElement(element);\n    if (boundTextElement) {\n      _elementsToAdd.push(boundTextElement);\n    }\n  }\n  let nextElements = allElements.slice();\n  const frameBoundary = findIndex(nextElements, e => e.frameId === frame.id);\n  for (const element of omitGroupsContainingFrames(allElements, _elementsToAdd)) {\n    if (element.frameId !== frame.id && !isFrameElement(element)) {\n      mutateElement(element, {\n        frameId: frame.id\n      }, false);\n      const frameIndex = findIndex(nextElements, e => e.id === frame.id);\n      const elementIndex = findIndex(nextElements, e => e.id === element.id);\n      if (elementIndex < frameBoundary) {\n        nextElements = [...nextElements.slice(0, elementIndex), ...nextElements.slice(elementIndex + 1, frameBoundary), element, ...nextElements.slice(frameBoundary)];\n      } else if (elementIndex > frameIndex) {\n        nextElements = [...nextElements.slice(0, frameIndex), element, ...nextElements.slice(frameIndex, elementIndex), ...nextElements.slice(elementIndex + 1)];\n      }\n    }\n  }\n  return nextElements;\n};\nexport const removeElementsFromFrame = (allElements, elementsToRemove, appState) => {\n  const _elementsToRemove = [];\n  for (const element of elementsToRemove) {\n    if (element.frameId) {\n      _elementsToRemove.push(element);\n      const boundTextElement = getBoundTextElement(element);\n      if (boundTextElement) {\n        _elementsToRemove.push(boundTextElement);\n      }\n    }\n  }\n  for (const element of _elementsToRemove) {\n    mutateElement(element, {\n      frameId: null\n    }, false);\n  }\n  const nextElements = moveOneRight(allElements, appState, Array.from(_elementsToRemove));\n  return nextElements;\n};\nexport const removeAllElementsFromFrame = (allElements, frame, appState) => {\n  const elementsInFrame = getFrameElements(allElements, frame.id);\n  return removeElementsFromFrame(allElements, elementsInFrame, appState);\n};\nexport const replaceAllElementsInFrame = (allElements, nextElementsInFrame, frame, appState) => {\n  return addElementsToFrame(removeAllElementsFromFrame(allElements, frame, appState), nextElementsInFrame, frame);\n};\n\n/** does not mutate elements, but return new ones */\nexport const updateFrameMembershipOfSelectedElements = (allElements, appState, app) => {\n  const selectedElements = app.scene.getSelectedElements({\n    selectedElementIds: appState.selectedElementIds,\n    // supplying elements explicitly in case we're passed non-state elements\n    elements: allElements\n  });\n  const elementsToFilter = new Set(selectedElements);\n  if (appState.editingGroupId) {\n    for (const element of selectedElements) {\n      if (element.groupIds.length === 0) {\n        elementsToFilter.add(element);\n      } else {\n        element.groupIds.flatMap(gid => getElementsInGroup(allElements, gid)).forEach(element => elementsToFilter.add(element));\n      }\n    }\n  }\n  const elementsToRemove = new Set();\n  elementsToFilter.forEach(element => {\n    if (element.frameId && !isFrameElement(element) && !isElementInFrame(element, allElements, appState)) {\n      elementsToRemove.add(element);\n    }\n  });\n  return elementsToRemove.size > 0 ? removeElementsFromFrame(allElements, [...elementsToRemove], appState) : allElements;\n};\n\n/**\n * filters out elements that are inside groups that contain a frame element\n * anywhere in the group tree\n */\nexport const omitGroupsContainingFrames = (allElements, selectedElements) => {\n  const uniqueGroupIds = new Set();\n  for (const el of selectedElements || allElements) {\n    const topMostGroupId = el.groupIds[el.groupIds.length - 1];\n    if (topMostGroupId) {\n      uniqueGroupIds.add(topMostGroupId);\n    }\n  }\n  const rejectedGroupIds = new Set();\n  for (const groupId of uniqueGroupIds) {\n    if (getElementsInGroup(allElements, groupId).some(el => isFrameElement(el))) {\n      rejectedGroupIds.add(groupId);\n    }\n  }\n  return (selectedElements || allElements).filter(el => !rejectedGroupIds.has(el.groupIds[el.groupIds.length - 1]));\n};\n\n/**\n * depending on the appState, return target frame, which is the frame the given element\n * is going to be added to or remove from\n */\nexport const getTargetFrame = (element, appState) => {\n  const _element = isTextElement(element) ? getContainerElement(element) || element : element;\n  return appState.selectedElementIds[_element.id] && appState.selectedElementsAreBeingDragged ? appState.frameToHighlight : getContainingFrame(_element);\n};\n\n// given an element, return if the element is in some frame\nexport const isElementInFrame = (element, allElements, appState) => {\n  const frame = getTargetFrame(element, appState);\n  const _element = isTextElement(element) ? getContainerElement(element) || element : element;\n  if (frame) {\n    if (_element.groupIds.length === 0) {\n      return elementOverlapsWithFrame(_element, frame);\n    }\n    const allElementsInGroup = new Set(_element.groupIds.flatMap(gid => getElementsInGroup(allElements, gid)));\n    if (appState.editingGroupId && appState.selectedElementsAreBeingDragged) {\n      const selectedElements = new Set(getSelectedElements(allElements, appState));\n      const editingGroupOverlapsFrame = appState.frameToHighlight !== null;\n      if (editingGroupOverlapsFrame) {\n        return true;\n      }\n      selectedElements.forEach(selectedElement => {\n        allElementsInGroup.delete(selectedElement);\n      });\n    }\n    for (const elementInGroup of allElementsInGroup) {\n      if (isFrameElement(elementInGroup)) {\n        return false;\n      }\n    }\n    for (const elementInGroup of allElementsInGroup) {\n      if (elementOverlapsWithFrame(elementInGroup, frame)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};","map":{"version":3,"names":["getCommonBounds","getElementAbsoluteCoords","isTextElement","isPointWithinBounds","getBoundTextElement","getContainerElement","arrayToMap","findIndex","mutateElement","getElementsWithinSelection","getSelectedElements","isFrameElement","moveOneRight","getElementsInGroup","selectGroupsFromGivenElements","Scene","getElementLineSegments","bindElementsToFramesAfterDuplication","nextElements","oldElements","oldIdToDuplicatedId","nextElementMap","element","frameId","nextElementId","get","id","nextFrameId","nextElement","Point","constructor","x","y","LineSegment","pointA","pointB","first","second","getBoundingBox","Math","min","max","FrameGeometry","crossProduct","a","b","doBoundingBoxesIntersect","isPointOnLine","aTmp","bTmp","r","abs","EPSILON","isPointRightOfLine","lineSegmentTouchesOrCrossesLine","doLineSegmentsIntersect","aSegment","bSegment","box1","box2","isElementIntersectingFrame","frame","frameLineSegments","elementLineSegments","intersecting","some","frameLineSegment","elementLineSegment","getElementsCompletelyInFrame","elements","omitGroupsContainingFrames","filter","type","isElementContainingFrame","e","getElementsIntersectingFrame","elementsAreInFrameBounds","selectionX1","selectionY1","selectionX2","selectionY2","elementX1","elementY1","elementX2","elementY2","elementOverlapsWithFrame","isCursorInFrame","cursorCoords","fx1","fy1","fx2","fy2","groupsAreAtLeastIntersectingTheFrame","groupIds","elementsInGroup","flatMap","groupId","length","find","groupsAreCompletelyOutOfFrame","undefined","groupByFrames","frameElementsMap","Map","has","set","getFrameElements","allElements","getElementsInResizingFrame","appState","prevElementsInFrame","nextElementsInFrame","Set","elementsCompletelyInFrame","elementsNotCompletelyInFrame","groupsToKeep","Array","from","delete","add","shouldRemoveElement","individualElementsCompletelyInFrame","newGroupElementsCompletelyInFrame","isSelected","Object","entries","containerId","getElementsInNewFrame","getContainingFrame","elementsMap","_Scene$getScene","getScene","getElement","addElementsToFrame","elementsToAdd","_elementsToAdd","push","boundTextElement","slice","frameBoundary","frameIndex","elementIndex","removeElementsFromFrame","elementsToRemove","_elementsToRemove","removeAllElementsFromFrame","elementsInFrame","replaceAllElementsInFrame","updateFrameMembershipOfSelectedElements","app","selectedElements","scene","selectedElementIds","elementsToFilter","editingGroupId","gid","forEach","isElementInFrame","size","uniqueGroupIds","el","topMostGroupId","rejectedGroupIds","getTargetFrame","_element","selectedElementsAreBeingDragged","frameToHighlight","allElementsInGroup","editingGroupOverlapsFrame","selectedElement","elementInGroup"],"sources":["D:/project/excalidraw-cn/src/frame.ts"],"sourcesContent":["import {\n  getCommonBounds,\n  getElementAbsoluteCoords,\n  isTextElement,\n} from \"./element\";\nimport {\n  ExcalidrawElement,\n  ExcalidrawFrameElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n} from \"./element/types\";\nimport { isPointWithinBounds } from \"./math\";\nimport {\n  getBoundTextElement,\n  getContainerElement,\n} from \"./element/textElement\";\nimport { arrayToMap, findIndex } from \"./utils\";\nimport { mutateElement } from \"./element/mutateElement\";\nimport { AppClassProperties, AppState } from \"./types\";\nimport { getElementsWithinSelection, getSelectedElements } from \"./scene\";\nimport { isFrameElement } from \"./element\";\nimport { moveOneRight } from \"./zindex\";\nimport { getElementsInGroup, selectGroupsFromGivenElements } from \"./groups\";\nimport Scene, { ExcalidrawElementsIncludingDeleted } from \"./scene/Scene\";\nimport { getElementLineSegments } from \"./element/bounds\";\n\n// --------------------------- Frame State ------------------------------------\nexport const bindElementsToFramesAfterDuplication = (\n  nextElements: ExcalidrawElement[],\n  oldElements: readonly ExcalidrawElement[],\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n) => {\n  const nextElementMap = arrayToMap(nextElements) as Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement\n  >;\n\n  for (const element of oldElements) {\n    if (element.frameId) {\n      // use its frameId to get the new frameId\n      const nextElementId = oldIdToDuplicatedId.get(element.id);\n      const nextFrameId = oldIdToDuplicatedId.get(element.frameId);\n      if (nextElementId) {\n        const nextElement = nextElementMap.get(nextElementId);\n        if (nextElement) {\n          mutateElement(\n            nextElement,\n            {\n              frameId: nextFrameId ?? element.frameId,\n            },\n            false,\n          );\n        }\n      }\n    }\n  }\n};\n\n// --------------------------- Frame Geometry ---------------------------------\nclass Point {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass LineSegment {\n  first: Point;\n  second: Point;\n\n  constructor(pointA: Point, pointB: Point) {\n    this.first = pointA;\n    this.second = pointB;\n  }\n\n  public getBoundingBox(): [Point, Point] {\n    return [\n      new Point(\n        Math.min(this.first.x, this.second.x),\n        Math.min(this.first.y, this.second.y),\n      ),\n      new Point(\n        Math.max(this.first.x, this.second.x),\n        Math.max(this.first.y, this.second.y),\n      ),\n    ];\n  }\n}\n\n// https://martin-thoma.com/how-to-check-if-two-line-segments-intersect/\nclass FrameGeometry {\n  private static EPSILON = 0.000001;\n\n  private static crossProduct(a: Point, b: Point) {\n    return a.x * b.y - b.x * a.y;\n  }\n\n  private static doBoundingBoxesIntersect(\n    a: [Point, Point],\n    b: [Point, Point],\n  ) {\n    return (\n      a[0].x <= b[1].x &&\n      a[1].x >= b[0].x &&\n      a[0].y <= b[1].y &&\n      a[1].y >= b[0].y\n    );\n  }\n\n  private static isPointOnLine(a: LineSegment, b: Point) {\n    const aTmp = new LineSegment(\n      new Point(0, 0),\n      new Point(a.second.x - a.first.x, a.second.y - a.first.y),\n    );\n    const bTmp = new Point(b.x - a.first.x, b.y - a.first.y);\n    const r = this.crossProduct(aTmp.second, bTmp);\n    return Math.abs(r) < this.EPSILON;\n  }\n\n  private static isPointRightOfLine(a: LineSegment, b: Point) {\n    const aTmp = new LineSegment(\n      new Point(0, 0),\n      new Point(a.second.x - a.first.x, a.second.y - a.first.y),\n    );\n    const bTmp = new Point(b.x - a.first.x, b.y - a.first.y);\n    return this.crossProduct(aTmp.second, bTmp) < 0;\n  }\n\n  private static lineSegmentTouchesOrCrossesLine(\n    a: LineSegment,\n    b: LineSegment,\n  ) {\n    return (\n      this.isPointOnLine(a, b.first) ||\n      this.isPointOnLine(a, b.second) ||\n      (this.isPointRightOfLine(a, b.first)\n        ? !this.isPointRightOfLine(a, b.second)\n        : this.isPointRightOfLine(a, b.second))\n    );\n  }\n\n  private static doLineSegmentsIntersect(\n    a: [readonly [number, number], readonly [number, number]],\n    b: [readonly [number, number], readonly [number, number]],\n  ) {\n    const aSegment = new LineSegment(\n      new Point(a[0][0], a[0][1]),\n      new Point(a[1][0], a[1][1]),\n    );\n    const bSegment = new LineSegment(\n      new Point(b[0][0], b[0][1]),\n      new Point(b[1][0], b[1][1]),\n    );\n\n    const box1 = aSegment.getBoundingBox();\n    const box2 = bSegment.getBoundingBox();\n    return (\n      this.doBoundingBoxesIntersect(box1, box2) &&\n      this.lineSegmentTouchesOrCrossesLine(aSegment, bSegment) &&\n      this.lineSegmentTouchesOrCrossesLine(bSegment, aSegment)\n    );\n  }\n\n  public static isElementIntersectingFrame(\n    element: ExcalidrawElement,\n    frame: ExcalidrawFrameElement,\n  ) {\n    const frameLineSegments = getElementLineSegments(frame);\n\n    const elementLineSegments = getElementLineSegments(element);\n\n    const intersecting = frameLineSegments.some((frameLineSegment) =>\n      elementLineSegments.some((elementLineSegment) =>\n        this.doLineSegmentsIntersect(frameLineSegment, elementLineSegment),\n      ),\n    );\n\n    return intersecting;\n  }\n}\n\nexport const getElementsCompletelyInFrame = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameElement,\n) =>\n  omitGroupsContainingFrames(\n    getElementsWithinSelection(elements, frame, false),\n  ).filter(\n    (element) =>\n      (element.type !== \"frame\" && !element.frameId) ||\n      element.frameId === frame.id,\n  );\n\nexport const isElementContainingFrame = (\n  elements: readonly ExcalidrawElement[],\n  element: ExcalidrawElement,\n  frame: ExcalidrawFrameElement,\n) => {\n  return getElementsWithinSelection(elements, element).some(\n    (e) => e.id === frame.id,\n  );\n};\n\nexport const getElementsIntersectingFrame = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameElement,\n) =>\n  elements.filter((element) =>\n    FrameGeometry.isElementIntersectingFrame(element, frame),\n  );\n\nexport const elementsAreInFrameBounds = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameElement,\n) => {\n  const [selectionX1, selectionY1, selectionX2, selectionY2] =\n    getElementAbsoluteCoords(frame);\n\n  const [elementX1, elementY1, elementX2, elementY2] =\n    getCommonBounds(elements);\n\n  return (\n    selectionX1 <= elementX1 &&\n    selectionY1 <= elementY1 &&\n    selectionX2 >= elementX2 &&\n    selectionY2 >= elementY2\n  );\n};\n\nexport const elementOverlapsWithFrame = (\n  element: ExcalidrawElement,\n  frame: ExcalidrawFrameElement,\n) => {\n  return (\n    elementsAreInFrameBounds([element], frame) ||\n    FrameGeometry.isElementIntersectingFrame(element, frame) ||\n    isElementContainingFrame([frame], element, frame)\n  );\n};\n\nexport const isCursorInFrame = (\n  cursorCoords: {\n    x: number;\n    y: number;\n  },\n  frame: NonDeleted<ExcalidrawFrameElement>,\n) => {\n  const [fx1, fy1, fx2, fy2] = getElementAbsoluteCoords(frame);\n\n  return isPointWithinBounds(\n    [fx1, fy1],\n    [cursorCoords.x, cursorCoords.y],\n    [fx2, fy2],\n  );\n};\n\nexport const groupsAreAtLeastIntersectingTheFrame = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  groupIds: readonly string[],\n  frame: ExcalidrawFrameElement,\n) => {\n  const elementsInGroup = groupIds.flatMap((groupId) =>\n    getElementsInGroup(elements, groupId),\n  );\n\n  if (elementsInGroup.length === 0) {\n    return true;\n  }\n\n  return !!elementsInGroup.find(\n    (element) =>\n      elementsAreInFrameBounds([element], frame) ||\n      FrameGeometry.isElementIntersectingFrame(element, frame),\n  );\n};\n\nexport const groupsAreCompletelyOutOfFrame = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  groupIds: readonly string[],\n  frame: ExcalidrawFrameElement,\n) => {\n  const elementsInGroup = groupIds.flatMap((groupId) =>\n    getElementsInGroup(elements, groupId),\n  );\n\n  if (elementsInGroup.length === 0) {\n    return true;\n  }\n\n  return (\n    elementsInGroup.find(\n      (element) =>\n        elementsAreInFrameBounds([element], frame) ||\n        FrameGeometry.isElementIntersectingFrame(element, frame),\n    ) === undefined\n  );\n};\n\n// --------------------------- Frame Utils ------------------------------------\n\n/**\n * Returns a map of frameId to frame elements. Includes empty frames.\n */\nexport const groupByFrames = (elements: readonly ExcalidrawElement[]) => {\n  const frameElementsMap = new Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement[]\n  >();\n\n  for (const element of elements) {\n    const frameId = isFrameElement(element) ? element.id : element.frameId;\n    if (frameId && !frameElementsMap.has(frameId)) {\n      frameElementsMap.set(frameId, getFrameElements(elements, frameId));\n    }\n  }\n\n  return frameElementsMap;\n};\n\nexport const getFrameElements = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n  frameId: string,\n) => allElements.filter((element) => element.frameId === frameId);\n\nexport const getElementsInResizingFrame = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n  frame: ExcalidrawFrameElement,\n  appState: AppState,\n): ExcalidrawElement[] => {\n  const prevElementsInFrame = getFrameElements(allElements, frame.id);\n  const nextElementsInFrame = new Set<ExcalidrawElement>(prevElementsInFrame);\n\n  const elementsCompletelyInFrame = new Set([\n    ...getElementsCompletelyInFrame(allElements, frame),\n    ...prevElementsInFrame.filter((element) =>\n      isElementContainingFrame(allElements, element, frame),\n    ),\n  ]);\n\n  const elementsNotCompletelyInFrame = prevElementsInFrame.filter(\n    (element) => !elementsCompletelyInFrame.has(element),\n  );\n\n  // for elements that are completely in the frame\n  // if they are part of some groups, then those groups are still\n  // considered to belong to the frame\n  const groupsToKeep = new Set<string>(\n    Array.from(elementsCompletelyInFrame).flatMap(\n      (element) => element.groupIds,\n    ),\n  );\n\n  for (const element of elementsNotCompletelyInFrame) {\n    if (!FrameGeometry.isElementIntersectingFrame(element, frame)) {\n      if (element.groupIds.length === 0) {\n        nextElementsInFrame.delete(element);\n      }\n    } else if (element.groupIds.length > 0) {\n      // group element intersects with the frame, we should keep the groups\n      // that this element is part of\n      for (const id of element.groupIds) {\n        groupsToKeep.add(id);\n      }\n    }\n  }\n\n  for (const element of elementsNotCompletelyInFrame) {\n    if (element.groupIds.length > 0) {\n      let shouldRemoveElement = true;\n\n      for (const id of element.groupIds) {\n        if (groupsToKeep.has(id)) {\n          shouldRemoveElement = false;\n        }\n      }\n\n      if (shouldRemoveElement) {\n        nextElementsInFrame.delete(element);\n      }\n    }\n  }\n\n  const individualElementsCompletelyInFrame = Array.from(\n    elementsCompletelyInFrame,\n  ).filter((element) => element.groupIds.length === 0);\n\n  for (const element of individualElementsCompletelyInFrame) {\n    nextElementsInFrame.add(element);\n  }\n\n  const newGroupElementsCompletelyInFrame = Array.from(\n    elementsCompletelyInFrame,\n  ).filter((element) => element.groupIds.length > 0);\n\n  const groupIds = selectGroupsFromGivenElements(\n    newGroupElementsCompletelyInFrame,\n    appState,\n  );\n\n  // new group elements\n  for (const [id, isSelected] of Object.entries(groupIds)) {\n    if (isSelected) {\n      const elementsInGroup = getElementsInGroup(allElements, id);\n\n      if (elementsAreInFrameBounds(elementsInGroup, frame)) {\n        for (const element of elementsInGroup) {\n          nextElementsInFrame.add(element);\n        }\n      }\n    }\n  }\n\n  return [...nextElementsInFrame].filter((element) => {\n    return !(isTextElement(element) && element.containerId);\n  });\n};\n\nexport const getElementsInNewFrame = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n  frame: ExcalidrawFrameElement,\n) => {\n  return omitGroupsContainingFrames(\n    allElements,\n    getElementsCompletelyInFrame(allElements, frame),\n  );\n};\n\nexport const getContainingFrame = (\n  element: ExcalidrawElement,\n  /**\n   * Optionally an elements map, in case the elements aren't in the Scene yet.\n   * Takes precedence over Scene elements, even if the element exists\n   * in Scene elements and not the supplied elements map.\n   */\n  elementsMap?: Map<string, ExcalidrawElement>,\n) => {\n  if (element.frameId) {\n    if (elementsMap) {\n      return (elementsMap.get(element.frameId) ||\n        null) as null | ExcalidrawFrameElement;\n    }\n    return (\n      (Scene.getScene(element)?.getElement(\n        element.frameId,\n      ) as ExcalidrawFrameElement) || null\n    );\n  }\n  return null;\n};\n\n// --------------------------- Frame Operations -------------------------------\nexport const addElementsToFrame = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n  elementsToAdd: NonDeletedExcalidrawElement[],\n  frame: ExcalidrawFrameElement,\n) => {\n  const _elementsToAdd: ExcalidrawElement[] = [];\n\n  for (const element of elementsToAdd) {\n    _elementsToAdd.push(element);\n\n    const boundTextElement = getBoundTextElement(element);\n    if (boundTextElement) {\n      _elementsToAdd.push(boundTextElement);\n    }\n  }\n\n  let nextElements = allElements.slice();\n\n  const frameBoundary = findIndex(nextElements, (e) => e.frameId === frame.id);\n\n  for (const element of omitGroupsContainingFrames(\n    allElements,\n    _elementsToAdd,\n  )) {\n    if (element.frameId !== frame.id && !isFrameElement(element)) {\n      mutateElement(\n        element,\n        {\n          frameId: frame.id,\n        },\n        false,\n      );\n\n      const frameIndex = findIndex(nextElements, (e) => e.id === frame.id);\n      const elementIndex = findIndex(nextElements, (e) => e.id === element.id);\n\n      if (elementIndex < frameBoundary) {\n        nextElements = [\n          ...nextElements.slice(0, elementIndex),\n          ...nextElements.slice(elementIndex + 1, frameBoundary),\n          element,\n          ...nextElements.slice(frameBoundary),\n        ];\n      } else if (elementIndex > frameIndex) {\n        nextElements = [\n          ...nextElements.slice(0, frameIndex),\n          element,\n          ...nextElements.slice(frameIndex, elementIndex),\n          ...nextElements.slice(elementIndex + 1),\n        ];\n      }\n    }\n  }\n\n  return nextElements;\n};\n\nexport const removeElementsFromFrame = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n  elementsToRemove: NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => {\n  const _elementsToRemove: ExcalidrawElement[] = [];\n\n  for (const element of elementsToRemove) {\n    if (element.frameId) {\n      _elementsToRemove.push(element);\n      const boundTextElement = getBoundTextElement(element);\n      if (boundTextElement) {\n        _elementsToRemove.push(boundTextElement);\n      }\n    }\n  }\n\n  for (const element of _elementsToRemove) {\n    mutateElement(\n      element,\n      {\n        frameId: null,\n      },\n      false,\n    );\n  }\n\n  const nextElements = moveOneRight(\n    allElements,\n    appState,\n    Array.from(_elementsToRemove),\n  );\n\n  return nextElements;\n};\n\nexport const removeAllElementsFromFrame = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n  frame: ExcalidrawFrameElement,\n  appState: AppState,\n) => {\n  const elementsInFrame = getFrameElements(allElements, frame.id);\n  return removeElementsFromFrame(allElements, elementsInFrame, appState);\n};\n\nexport const replaceAllElementsInFrame = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n  nextElementsInFrame: ExcalidrawElement[],\n  frame: ExcalidrawFrameElement,\n  appState: AppState,\n) => {\n  return addElementsToFrame(\n    removeAllElementsFromFrame(allElements, frame, appState),\n    nextElementsInFrame,\n    frame,\n  );\n};\n\n/** does not mutate elements, but return new ones */\nexport const updateFrameMembershipOfSelectedElements = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n  appState: AppState,\n  app: AppClassProperties,\n) => {\n  const selectedElements = app.scene.getSelectedElements({\n    selectedElementIds: appState.selectedElementIds,\n    // supplying elements explicitly in case we're passed non-state elements\n    elements: allElements,\n  });\n  const elementsToFilter = new Set<ExcalidrawElement>(selectedElements);\n\n  if (appState.editingGroupId) {\n    for (const element of selectedElements) {\n      if (element.groupIds.length === 0) {\n        elementsToFilter.add(element);\n      } else {\n        element.groupIds\n          .flatMap((gid) => getElementsInGroup(allElements, gid))\n          .forEach((element) => elementsToFilter.add(element));\n      }\n    }\n  }\n\n  const elementsToRemove = new Set<ExcalidrawElement>();\n\n  elementsToFilter.forEach((element) => {\n    if (\n      element.frameId &&\n      !isFrameElement(element) &&\n      !isElementInFrame(element, allElements, appState)\n    ) {\n      elementsToRemove.add(element);\n    }\n  });\n\n  return elementsToRemove.size > 0\n    ? removeElementsFromFrame(allElements, [...elementsToRemove], appState)\n    : allElements;\n};\n\n/**\n * filters out elements that are inside groups that contain a frame element\n * anywhere in the group tree\n */\nexport const omitGroupsContainingFrames = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n  /** subset of elements you want to filter. Optional perf optimization so we\n   * don't have to filter all elements unnecessarily\n   */\n  selectedElements?: readonly ExcalidrawElement[],\n) => {\n  const uniqueGroupIds = new Set<string>();\n  for (const el of selectedElements || allElements) {\n    const topMostGroupId = el.groupIds[el.groupIds.length - 1];\n    if (topMostGroupId) {\n      uniqueGroupIds.add(topMostGroupId);\n    }\n  }\n\n  const rejectedGroupIds = new Set<string>();\n  for (const groupId of uniqueGroupIds) {\n    if (\n      getElementsInGroup(allElements, groupId).some((el) => isFrameElement(el))\n    ) {\n      rejectedGroupIds.add(groupId);\n    }\n  }\n\n  return (selectedElements || allElements).filter(\n    (el) => !rejectedGroupIds.has(el.groupIds[el.groupIds.length - 1]),\n  );\n};\n\n/**\n * depending on the appState, return target frame, which is the frame the given element\n * is going to be added to or remove from\n */\nexport const getTargetFrame = (\n  element: ExcalidrawElement,\n  appState: AppState,\n) => {\n  const _element = isTextElement(element)\n    ? getContainerElement(element) || element\n    : element;\n\n  return appState.selectedElementIds[_element.id] &&\n    appState.selectedElementsAreBeingDragged\n    ? appState.frameToHighlight\n    : getContainingFrame(_element);\n};\n\n// given an element, return if the element is in some frame\nexport const isElementInFrame = (\n  element: ExcalidrawElement,\n  allElements: ExcalidrawElementsIncludingDeleted,\n  appState: AppState,\n) => {\n  const frame = getTargetFrame(element, appState);\n  const _element = isTextElement(element)\n    ? getContainerElement(element) || element\n    : element;\n\n  if (frame) {\n    if (_element.groupIds.length === 0) {\n      return elementOverlapsWithFrame(_element, frame);\n    }\n\n    const allElementsInGroup = new Set(\n      _element.groupIds.flatMap((gid) => getElementsInGroup(allElements, gid)),\n    );\n\n    if (appState.editingGroupId && appState.selectedElementsAreBeingDragged) {\n      const selectedElements = new Set(\n        getSelectedElements(allElements, appState),\n      );\n\n      const editingGroupOverlapsFrame = appState.frameToHighlight !== null;\n\n      if (editingGroupOverlapsFrame) {\n        return true;\n      }\n\n      selectedElements.forEach((selectedElement) => {\n        allElementsInGroup.delete(selectedElement);\n      });\n    }\n\n    for (const elementInGroup of allElementsInGroup) {\n      if (isFrameElement(elementInGroup)) {\n        return false;\n      }\n    }\n\n    for (const elementInGroup of allElementsInGroup) {\n      if (elementOverlapsWithFrame(elementInGroup, frame)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}