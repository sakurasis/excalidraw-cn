{"ast":null,"code":"import React from \"react\";\nimport { useI18n } from \"../i18n\";\n\n// Used for splitting i18nKey into tokens in Trans component\n// Example:\n// \"Please <link>click {{location}}</link> to continue.\".split(SPLIT_REGEX).filter(Boolean)\n// produces\n// [\"Please \", \"<link>\", \"click \", \"{{location}}\", \"</link>\", \" to continue.\"]\nconst SPLIT_REGEX = /({{[\\w-]+}})|(<[\\w-]+>)|(<\\/[\\w-]+>)/g;\n// Used for extracting \"location\" from \"{{location}}\"\nconst KEY_REGEXP = /{{([\\w-]+)}}/;\n// Used for extracting \"link\" from \"<link>\"\nconst TAG_START_REGEXP = /<([\\w-]+)>/;\n// Used for extracting \"link\" from \"</link>\"\nconst TAG_END_REGEXP = /<\\/([\\w-]+)>/;\nconst getTransChildren = (format, props) => {\n  const stack = [{\n    name: \"\",\n    children: []\n  }];\n  format.split(SPLIT_REGEX).filter(Boolean).forEach(match => {\n    const tagStartMatch = match.match(TAG_START_REGEXP);\n    const tagEndMatch = match.match(TAG_END_REGEXP);\n    const keyMatch = match.match(KEY_REGEXP);\n    if (tagStartMatch !== null) {\n      // The match is <tag>. Set the tag name as the name if it's one of the\n      // props, e.g. for \"Please <link>click the button</link> to continue\"\n      // tagStartMatch[1] = \"link\" and props contain \"link\" then it will be\n      // pushed to stack.\n      const name = tagStartMatch[1];\n      if (props.hasOwnProperty(name)) {\n        stack.push({\n          name,\n          children: []\n        });\n      } else {\n        console.warn(`Trans: missed to pass in prop ${name} for interpolating ${format}`);\n      }\n    } else if (tagEndMatch !== null) {\n      // If tag end match is found, this means we need to replace the content with\n      // its actual value in prop e.g. format = \"Please <link>click the\n      // button</link> to continue\", tagEndMatch is for \"</link>\", stack last item name =\n      // \"link\" and props.link = (el) => <a\n      // href=\"https://example.com\">{el}</a> then its prop value will be\n      // pushed to \"link\"'s children so on DOM when rendering it's rendered as\n      // <a href=\"https://example.com\">click the button</a>\n      const name = tagEndMatch[1];\n      if (name === stack[stack.length - 1].name) {\n        const item = stack.pop();\n        const itemChildren = /*#__PURE__*/React.createElement(React.Fragment, {}, ...item.children);\n        const fn = props[item.name];\n        if (typeof fn === \"function\") {\n          stack[stack.length - 1].children.push(fn(itemChildren));\n        }\n      } else {\n        console.warn(`Trans: unexpected end tag ${match} for interpolating ${format}`);\n      }\n    } else if (keyMatch !== null) {\n      // The match is for {{key}}. Check if the key is present in props and set\n      // the prop value as children of last stack item e.g. format = \"Hello\n      // {{name}}\", key = \"name\" and props.name = \"Excalidraw\" then its prop\n      // value will be pushed to \"name\"'s children so it's rendered on DOM as\n      // \"Hello Excalidraw\"\n      const name = keyMatch[1];\n      if (props.hasOwnProperty(name)) {\n        stack[stack.length - 1].children.push(props[name]);\n      } else {\n        console.warn(`Trans: key ${name} not in props for interpolating ${format}`);\n      }\n    } else {\n      // If none of cases match means we just need to push the string\n      // to stack eg - \"Hello {{name}} Whats up?\" \"Hello\", \"Whats up\" will be pushed\n      stack[stack.length - 1].children.push(match);\n    }\n  });\n  if (stack.length !== 1) {\n    console.warn(`Trans: stack not empty for interpolating ${format}`);\n  }\n  return stack[0].children;\n};\n\n/*\nTrans component is used for translating JSX.\n\n```json\n{\n  \"example1\": \"Hello {{audience}}\",\n  \"example2\": \"Please <link>click the button</link> to continue.\",\n  \"example3\": \"Please <link>click {{location}}</link> to continue.\",\n  \"example4\": \"Please <link>click <bold>{{location}}</bold></link> to continue.\",\n}\n```\n\n```jsx\n<Trans i18nKey=\"example1\" audience=\"world\" />\n\n<Trans\n  i18nKey=\"example2\"\n  connectLink={(el) => <a href=\"https://example.com\">{el}</a>}\n/>\n\n<Trans\n  i18nKey=\"example3\"\n  connectLink={(el) => <a href=\"https://example.com\">{el}</a>}\n  location=\"the button\"\n/>\n\n<Trans\n  i18nKey=\"example4\"\n  connectLink={(el) => <a href=\"https://example.com\">{el}</a>}\n  location=\"the button\"\n  bold={(el) => <strong>{el}</strong>}\n/>\n```\n\nOutput:\n\n```html\nHello world\nPlease <a href=\"https://example.com\">click the button</a> to continue.\nPlease <a href=\"https://example.com\">click the button</a> to continue.\nPlease <a href=\"https://example.com\">click <strong>the button</strong></a> to continue.\n```\n*/\nconst Trans = _ref => {\n  let {\n    i18nKey,\n    children,\n    ...props\n  } = _ref;\n  const {\n    t\n  } = useI18n();\n\n  // This is needed to avoid unique key error in list which gets rendered from getTransChildren\n  return /*#__PURE__*/React.createElement(React.Fragment, {}, ...getTransChildren(t(i18nKey), props));\n};\nexport default Trans;","map":{"version":3,"names":["React","useI18n","SPLIT_REGEX","KEY_REGEXP","TAG_START_REGEXP","TAG_END_REGEXP","getTransChildren","format","props","stack","name","children","split","filter","Boolean","forEach","match","tagStartMatch","tagEndMatch","keyMatch","hasOwnProperty","push","console","warn","length","item","pop","itemChildren","createElement","Fragment","fn","Trans","_ref","i18nKey","t"],"sources":["D:/project/excalidraw-cn/src/components/Trans.tsx"],"sourcesContent":["import React from \"react\";\n\nimport { useI18n } from \"../i18n\";\n\n// Used for splitting i18nKey into tokens in Trans component\n// Example:\n// \"Please <link>click {{location}}</link> to continue.\".split(SPLIT_REGEX).filter(Boolean)\n// produces\n// [\"Please \", \"<link>\", \"click \", \"{{location}}\", \"</link>\", \" to continue.\"]\nconst SPLIT_REGEX = /({{[\\w-]+}})|(<[\\w-]+>)|(<\\/[\\w-]+>)/g;\n// Used for extracting \"location\" from \"{{location}}\"\nconst KEY_REGEXP = /{{([\\w-]+)}}/;\n// Used for extracting \"link\" from \"<link>\"\nconst TAG_START_REGEXP = /<([\\w-]+)>/;\n// Used for extracting \"link\" from \"</link>\"\nconst TAG_END_REGEXP = /<\\/([\\w-]+)>/;\n\nconst getTransChildren = (\n  format: string,\n  props: {\n    [key: string]: React.ReactNode | ((el: React.ReactNode) => React.ReactNode);\n  },\n): React.ReactNode[] => {\n  const stack: { name: string; children: React.ReactNode[] }[] = [\n    {\n      name: \"\",\n      children: [],\n    },\n  ];\n\n  format\n    .split(SPLIT_REGEX)\n    .filter(Boolean)\n    .forEach((match) => {\n      const tagStartMatch = match.match(TAG_START_REGEXP);\n      const tagEndMatch = match.match(TAG_END_REGEXP);\n      const keyMatch = match.match(KEY_REGEXP);\n\n      if (tagStartMatch !== null) {\n        // The match is <tag>. Set the tag name as the name if it's one of the\n        // props, e.g. for \"Please <link>click the button</link> to continue\"\n        // tagStartMatch[1] = \"link\" and props contain \"link\" then it will be\n        // pushed to stack.\n        const name = tagStartMatch[1];\n        if (props.hasOwnProperty(name)) {\n          stack.push({\n            name,\n            children: [],\n          });\n        } else {\n          console.warn(\n            `Trans: missed to pass in prop ${name} for interpolating ${format}`,\n          );\n        }\n      } else if (tagEndMatch !== null) {\n        // If tag end match is found, this means we need to replace the content with\n        // its actual value in prop e.g. format = \"Please <link>click the\n        // button</link> to continue\", tagEndMatch is for \"</link>\", stack last item name =\n        // \"link\" and props.link = (el) => <a\n        // href=\"https://example.com\">{el}</a> then its prop value will be\n        // pushed to \"link\"'s children so on DOM when rendering it's rendered as\n        // <a href=\"https://example.com\">click the button</a>\n        const name = tagEndMatch[1];\n        if (name === stack[stack.length - 1].name) {\n          const item = stack.pop()!;\n          const itemChildren = React.createElement(\n            React.Fragment,\n            {},\n            ...item.children,\n          );\n          const fn = props[item.name];\n          if (typeof fn === \"function\") {\n            stack[stack.length - 1].children.push(fn(itemChildren));\n          }\n        } else {\n          console.warn(\n            `Trans: unexpected end tag ${match} for interpolating ${format}`,\n          );\n        }\n      } else if (keyMatch !== null) {\n        // The match is for {{key}}. Check if the key is present in props and set\n        // the prop value as children of last stack item e.g. format = \"Hello\n        // {{name}}\", key = \"name\" and props.name = \"Excalidraw\" then its prop\n        // value will be pushed to \"name\"'s children so it's rendered on DOM as\n        // \"Hello Excalidraw\"\n        const name = keyMatch[1];\n        if (props.hasOwnProperty(name)) {\n          stack[stack.length - 1].children.push(props[name] as React.ReactNode);\n        } else {\n          console.warn(\n            `Trans: key ${name} not in props for interpolating ${format}`,\n          );\n        }\n      } else {\n        // If none of cases match means we just need to push the string\n        // to stack eg - \"Hello {{name}} Whats up?\" \"Hello\", \"Whats up\" will be pushed\n        stack[stack.length - 1].children.push(match);\n      }\n    });\n\n  if (stack.length !== 1) {\n    console.warn(`Trans: stack not empty for interpolating ${format}`);\n  }\n\n  return stack[0].children;\n};\n\n/*\nTrans component is used for translating JSX.\n\n```json\n{\n  \"example1\": \"Hello {{audience}}\",\n  \"example2\": \"Please <link>click the button</link> to continue.\",\n  \"example3\": \"Please <link>click {{location}}</link> to continue.\",\n  \"example4\": \"Please <link>click <bold>{{location}}</bold></link> to continue.\",\n}\n```\n\n```jsx\n<Trans i18nKey=\"example1\" audience=\"world\" />\n\n<Trans\n  i18nKey=\"example2\"\n  connectLink={(el) => <a href=\"https://example.com\">{el}</a>}\n/>\n\n<Trans\n  i18nKey=\"example3\"\n  connectLink={(el) => <a href=\"https://example.com\">{el}</a>}\n  location=\"the button\"\n/>\n\n<Trans\n  i18nKey=\"example4\"\n  connectLink={(el) => <a href=\"https://example.com\">{el}</a>}\n  location=\"the button\"\n  bold={(el) => <strong>{el}</strong>}\n/>\n```\n\nOutput:\n\n```html\nHello world\nPlease <a href=\"https://example.com\">click the button</a> to continue.\nPlease <a href=\"https://example.com\">click the button</a> to continue.\nPlease <a href=\"https://example.com\">click <strong>the button</strong></a> to continue.\n```\n*/\nconst Trans = ({\n  i18nKey,\n  children,\n  ...props\n}: {\n  i18nKey: string;\n  [key: string]: React.ReactNode | ((el: React.ReactNode) => React.ReactNode);\n}) => {\n  const { t } = useI18n();\n\n  // This is needed to avoid unique key error in list which gets rendered from getTransChildren\n  return React.createElement(\n    React.Fragment,\n    {},\n    ...getTransChildren(t(i18nKey), props),\n  );\n};\n\nexport default Trans;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}