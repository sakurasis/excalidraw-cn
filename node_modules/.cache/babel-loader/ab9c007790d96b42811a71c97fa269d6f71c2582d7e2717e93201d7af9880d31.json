{"ast":null,"code":"import { getElementAbsoluteCoords } from \"./bounds\";\nimport { rotate } from \"../math\";\nimport { isTextElement } from \".\";\nimport { isFrameElement, isLinearElement } from \"./typeChecks\";\nimport { DEFAULT_SPACING } from \"../renderer/renderScene\";\nconst transformHandleSizes = {\n  mouse: 8,\n  pen: 16,\n  touch: 28\n};\nconst ROTATION_RESIZE_HANDLE_GAP = 16;\nexport const OMIT_SIDES_FOR_MULTIPLE_ELEMENTS = {\n  e: true,\n  s: true,\n  n: true,\n  w: true\n};\nexport const OMIT_SIDES_FOR_FRAME = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  rotation: true\n};\nconst OMIT_SIDES_FOR_TEXT_ELEMENT = {\n  e: true,\n  s: true,\n  n: true,\n  w: true\n};\nconst OMIT_SIDES_FOR_LINE_SLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  nw: true,\n  se: true\n};\nconst OMIT_SIDES_FOR_LINE_BACKSLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true\n};\nconst generateTransformHandle = (x, y, width, height, cx, cy, angle) => {\n  const [xx, yy] = rotate(x + width / 2, y + height / 2, cx, cy, angle);\n  return [xx - width / 2, yy - height / 2, width, height];\n};\nexport const getTransformHandlesFromCoords = function (_ref, angle, zoom, pointerType) {\n  let [x1, y1, x2, y2, cx, cy] = _ref;\n  let omitSides = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  let margin = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 4;\n  const size = transformHandleSizes[pointerType];\n  const handleWidth = size / zoom.value;\n  const handleHeight = size / zoom.value;\n  const handleMarginX = size / zoom.value;\n  const handleMarginY = size / zoom.value;\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const dashedLineMargin = margin / zoom.value;\n  const centeringOffset = (size - DEFAULT_SPACING * 2) / (2 * zoom.value);\n  const transformHandles = {\n    nw: omitSides.nw ? undefined : generateTransformHandle(x1 - dashedLineMargin - handleMarginX + centeringOffset, y1 - dashedLineMargin - handleMarginY + centeringOffset, handleWidth, handleHeight, cx, cy, angle),\n    ne: omitSides.ne ? undefined : generateTransformHandle(x2 + dashedLineMargin - centeringOffset, y1 - dashedLineMargin - handleMarginY + centeringOffset, handleWidth, handleHeight, cx, cy, angle),\n    sw: omitSides.sw ? undefined : generateTransformHandle(x1 - dashedLineMargin - handleMarginX + centeringOffset, y2 + dashedLineMargin - centeringOffset, handleWidth, handleHeight, cx, cy, angle),\n    se: omitSides.se ? undefined : generateTransformHandle(x2 + dashedLineMargin - centeringOffset, y2 + dashedLineMargin - centeringOffset, handleWidth, handleHeight, cx, cy, angle),\n    rotation: omitSides.rotation ? undefined : generateTransformHandle(x1 + width / 2 - handleWidth / 2, y1 - dashedLineMargin - handleMarginY + centeringOffset - ROTATION_RESIZE_HANDLE_GAP / zoom.value, handleWidth, handleHeight, cx, cy, angle)\n  };\n\n  // We only want to show height handles (all cardinal directions)  above a certain size\n  // Note: we render using \"mouse\" size so we should also use \"mouse\" size for this check\n  const minimumSizeForEightHandles = 5 * transformHandleSizes.mouse / zoom.value;\n  if (Math.abs(width) > minimumSizeForEightHandles) {\n    if (!omitSides.n) {\n      transformHandles.n = generateTransformHandle(x1 + width / 2 - handleWidth / 2, y1 - dashedLineMargin - handleMarginY + centeringOffset, handleWidth, handleHeight, cx, cy, angle);\n    }\n    if (!omitSides.s) {\n      transformHandles.s = generateTransformHandle(x1 + width / 2 - handleWidth / 2, y2 + dashedLineMargin - centeringOffset, handleWidth, handleHeight, cx, cy, angle);\n    }\n  }\n  if (Math.abs(height) > minimumSizeForEightHandles) {\n    if (!omitSides.w) {\n      transformHandles.w = generateTransformHandle(x1 - dashedLineMargin - handleMarginX + centeringOffset, y1 + height / 2 - handleHeight / 2, handleWidth, handleHeight, cx, cy, angle);\n    }\n    if (!omitSides.e) {\n      transformHandles.e = generateTransformHandle(x2 + dashedLineMargin - centeringOffset, y1 + height / 2 - handleHeight / 2, handleWidth, handleHeight, cx, cy, angle);\n    }\n  }\n  return transformHandles;\n};\nexport const getTransformHandles = function (element, zoom) {\n  let pointerType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"mouse\";\n  // so that when locked element is selected (especially when you toggle lock\n  // via keyboard) the locked element is visually distinct, indicating\n  // you can't move/resize\n  if (element.locked) {\n    return {};\n  }\n  let omitSides = {};\n  if (element.type === \"freedraw\" || isLinearElement(element)) {\n    if (element.points.length === 2) {\n      // only check the last point because starting point is always (0,0)\n      const [, p1] = element.points;\n      if (p1[0] === 0 || p1[1] === 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] > 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] > 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] < 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] < 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      }\n    }\n  } else if (isTextElement(element)) {\n    omitSides = OMIT_SIDES_FOR_TEXT_ELEMENT;\n  } else if (isFrameElement(element)) {\n    omitSides = {\n      rotation: true\n    };\n  }\n  const dashedLineMargin = isLinearElement(element) ? DEFAULT_SPACING + 8 : DEFAULT_SPACING;\n  return getTransformHandlesFromCoords(getElementAbsoluteCoords(element, true), element.angle, zoom, pointerType, omitSides, dashedLineMargin);\n};\nexport const shouldShowBoundingBox = (elements, appState) => {\n  if (appState.editingLinearElement) {\n    return false;\n  }\n  if (elements.length > 1) {\n    return true;\n  }\n  const element = elements[0];\n  if (!isLinearElement(element)) {\n    return true;\n  }\n  return element.points.length > 2;\n};","map":{"version":3,"names":["getElementAbsoluteCoords","rotate","isTextElement","isFrameElement","isLinearElement","DEFAULT_SPACING","transformHandleSizes","mouse","pen","touch","ROTATION_RESIZE_HANDLE_GAP","OMIT_SIDES_FOR_MULTIPLE_ELEMENTS","e","s","n","w","OMIT_SIDES_FOR_FRAME","rotation","OMIT_SIDES_FOR_TEXT_ELEMENT","OMIT_SIDES_FOR_LINE_SLASH","nw","se","OMIT_SIDES_FOR_LINE_BACKSLASH","generateTransformHandle","x","y","width","height","cx","cy","angle","xx","yy","getTransformHandlesFromCoords","_ref","zoom","pointerType","x1","y1","x2","y2","omitSides","arguments","length","undefined","margin","size","handleWidth","value","handleHeight","handleMarginX","handleMarginY","dashedLineMargin","centeringOffset","transformHandles","ne","sw","minimumSizeForEightHandles","Math","abs","getTransformHandles","element","locked","type","points","p1","shouldShowBoundingBox","elements","appState","editingLinearElement"],"sources":["D:/project/excalidraw-cn/src/element/transformHandles.ts"],"sourcesContent":["import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  PointerType,\n} from \"./types\";\n\nimport { getElementAbsoluteCoords } from \"./bounds\";\nimport { rotate } from \"../math\";\nimport { AppState, Zoom } from \"../types\";\nimport { isTextElement } from \".\";\nimport { isFrameElement, isLinearElement } from \"./typeChecks\";\nimport { DEFAULT_SPACING } from \"../renderer/renderScene\";\n\nexport type TransformHandleDirection =\n  | \"n\"\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"nw\"\n  | \"ne\"\n  | \"sw\"\n  | \"se\";\n\nexport type TransformHandleType = TransformHandleDirection | \"rotation\";\n\nexport type TransformHandle = [number, number, number, number];\nexport type TransformHandles = Partial<{\n  [T in TransformHandleType]: TransformHandle;\n}>;\nexport type MaybeTransformHandleType = TransformHandleType | false;\n\nconst transformHandleSizes: { [k in PointerType]: number } = {\n  mouse: 8,\n  pen: 16,\n  touch: 28,\n};\n\nconst ROTATION_RESIZE_HANDLE_GAP = 16;\n\nexport const OMIT_SIDES_FOR_MULTIPLE_ELEMENTS = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nexport const OMIT_SIDES_FOR_FRAME = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  rotation: true,\n};\n\nconst OMIT_SIDES_FOR_TEXT_ELEMENT = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_SLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  nw: true,\n  se: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_BACKSLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nconst generateTransformHandle = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n): TransformHandle => {\n  const [xx, yy] = rotate(x + width / 2, y + height / 2, cx, cy, angle);\n  return [xx - width / 2, yy - height / 2, width, height];\n};\n\nexport const getTransformHandlesFromCoords = (\n  [x1, y1, x2, y2, cx, cy]: [number, number, number, number, number, number],\n  angle: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n  omitSides: { [T in TransformHandleType]?: boolean } = {},\n  margin = 4,\n): TransformHandles => {\n  const size = transformHandleSizes[pointerType];\n  const handleWidth = size / zoom.value;\n  const handleHeight = size / zoom.value;\n\n  const handleMarginX = size / zoom.value;\n  const handleMarginY = size / zoom.value;\n\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const dashedLineMargin = margin / zoom.value;\n  const centeringOffset = (size - DEFAULT_SPACING * 2) / (2 * zoom.value);\n\n  const transformHandles: TransformHandles = {\n    nw: omitSides.nw\n      ? undefined\n      : generateTransformHandle(\n          x1 - dashedLineMargin - handleMarginX + centeringOffset,\n          y1 - dashedLineMargin - handleMarginY + centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    ne: omitSides.ne\n      ? undefined\n      : generateTransformHandle(\n          x2 + dashedLineMargin - centeringOffset,\n          y1 - dashedLineMargin - handleMarginY + centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    sw: omitSides.sw\n      ? undefined\n      : generateTransformHandle(\n          x1 - dashedLineMargin - handleMarginX + centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    se: omitSides.se\n      ? undefined\n      : generateTransformHandle(\n          x2 + dashedLineMargin - centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    rotation: omitSides.rotation\n      ? undefined\n      : generateTransformHandle(\n          x1 + width / 2 - handleWidth / 2,\n          y1 -\n            dashedLineMargin -\n            handleMarginY +\n            centeringOffset -\n            ROTATION_RESIZE_HANDLE_GAP / zoom.value,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n  };\n\n  // We only want to show height handles (all cardinal directions)  above a certain size\n  // Note: we render using \"mouse\" size so we should also use \"mouse\" size for this check\n  const minimumSizeForEightHandles =\n    (5 * transformHandleSizes.mouse) / zoom.value;\n  if (Math.abs(width) > minimumSizeForEightHandles) {\n    if (!omitSides.n) {\n      transformHandles.n = generateTransformHandle(\n        x1 + width / 2 - handleWidth / 2,\n        y1 - dashedLineMargin - handleMarginY + centeringOffset,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides.s) {\n      transformHandles.s = generateTransformHandle(\n        x1 + width / 2 - handleWidth / 2,\n        y2 + dashedLineMargin - centeringOffset,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n  if (Math.abs(height) > minimumSizeForEightHandles) {\n    if (!omitSides.w) {\n      transformHandles.w = generateTransformHandle(\n        x1 - dashedLineMargin - handleMarginX + centeringOffset,\n        y1 + height / 2 - handleHeight / 2,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides.e) {\n      transformHandles.e = generateTransformHandle(\n        x2 + dashedLineMargin - centeringOffset,\n        y1 + height / 2 - handleHeight / 2,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n\n  return transformHandles;\n};\n\nexport const getTransformHandles = (\n  element: ExcalidrawElement,\n  zoom: Zoom,\n  pointerType: PointerType = \"mouse\",\n): TransformHandles => {\n  // so that when locked element is selected (especially when you toggle lock\n  // via keyboard) the locked element is visually distinct, indicating\n  // you can't move/resize\n  if (element.locked) {\n    return {};\n  }\n\n  let omitSides: { [T in TransformHandleType]?: boolean } = {};\n  if (element.type === \"freedraw\" || isLinearElement(element)) {\n    if (element.points.length === 2) {\n      // only check the last point because starting point is always (0,0)\n      const [, p1] = element.points;\n      if (p1[0] === 0 || p1[1] === 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] > 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] > 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] < 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] < 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      }\n    }\n  } else if (isTextElement(element)) {\n    omitSides = OMIT_SIDES_FOR_TEXT_ELEMENT;\n  } else if (isFrameElement(element)) {\n    omitSides = {\n      rotation: true,\n    };\n  }\n  const dashedLineMargin = isLinearElement(element)\n    ? DEFAULT_SPACING + 8\n    : DEFAULT_SPACING;\n  return getTransformHandlesFromCoords(\n    getElementAbsoluteCoords(element, true),\n    element.angle,\n    zoom,\n    pointerType,\n    omitSides,\n    dashedLineMargin,\n  );\n};\n\nexport const shouldShowBoundingBox = (\n  elements: NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => {\n  if (appState.editingLinearElement) {\n    return false;\n  }\n  if (elements.length > 1) {\n    return true;\n  }\n  const element = elements[0];\n  if (!isLinearElement(element)) {\n    return true;\n  }\n\n  return element.points.length > 2;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}