{"ast":null,"code":"import { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { isLinearElement } from \"../element/typeChecks\";\nimport { register } from \"./register\";\nexport const actionToggleLinearEditor = register({\n  name: \"toggleLinearEditor\",\n  trackEvent: {\n    category: \"element\"\n  },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n      return true;\n    }\n    return false;\n  },\n  perform(elements, appState, _, app) {\n    var _appState$editingLine;\n    const selectedElement = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true\n    })[0];\n    const editingLinearElement = ((_appState$editingLine = appState.editingLinearElement) === null || _appState$editingLine === void 0 ? void 0 : _appState$editingLine.elementId) === selectedElement.id ? null : new LinearElementEditor(selectedElement, app.scene);\n    return {\n      appState: {\n        ...appState,\n        editingLinearElement\n      },\n      commitToHistory: false\n    };\n  },\n  contextItemLabel: (elements, appState, app) => {\n    var _appState$editingLine2;\n    const selectedElement = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true\n    })[0];\n    return ((_appState$editingLine2 = appState.editingLinearElement) === null || _appState$editingLine2 === void 0 ? void 0 : _appState$editingLine2.elementId) === selectedElement.id ? \"labels.lineEditor.exit\" : \"labels.lineEditor.edit\";\n  }\n});","map":{"version":3,"names":["LinearElementEditor","isLinearElement","register","actionToggleLinearEditor","name","trackEvent","category","predicate","elements","appState","_","app","selectedElements","scene","getSelectedElements","length","perform","_appState$editingLine","selectedElement","selectedElementIds","includeBoundTextElement","editingLinearElement","elementId","id","commitToHistory","contextItemLabel","_appState$editingLine2"],"sources":["D:/project/excalidraw-cn/src/actions/actionLinearEditor.ts"],"sourcesContent":["import { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { isLinearElement } from \"../element/typeChecks\";\nimport { ExcalidrawLinearElement } from \"../element/types\";\nimport { register } from \"./register\";\n\nexport const actionToggleLinearEditor = register({\n  name: \"toggleLinearEditor\",\n  trackEvent: {\n    category: \"element\",\n  },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n      return true;\n    }\n    return false;\n  },\n  perform(elements, appState, _, app) {\n    const selectedElement = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n    })[0] as ExcalidrawLinearElement;\n\n    const editingLinearElement =\n      appState.editingLinearElement?.elementId === selectedElement.id\n        ? null\n        : new LinearElementEditor(selectedElement, app.scene);\n    return {\n      appState: {\n        ...appState,\n        editingLinearElement,\n      },\n      commitToHistory: false,\n    };\n  },\n  contextItemLabel: (elements, appState, app) => {\n    const selectedElement = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n    })[0] as ExcalidrawLinearElement;\n    return appState.editingLinearElement?.elementId === selectedElement.id\n      ? \"labels.lineEditor.exit\"\n      : \"labels.lineEditor.edit\";\n  },\n});\n"],"mappings":"AAAA,SAASA,mBAAmB,QAAQ,gCAAgC;AACpE,SAASC,eAAe,QAAQ,uBAAuB;AAEvD,SAASC,QAAQ,QAAQ,YAAY;AAErC,OAAO,MAAMC,wBAAwB,GAAGD,QAAQ,CAAC;EAC/CE,IAAI,EAAE,oBAAoB;EAC1BC,UAAU,EAAE;IACVC,QAAQ,EAAE;EACZ,CAAC;EACDC,SAAS,EAAEA,CAACC,QAAQ,EAAEC,QAAQ,EAAEC,CAAC,EAAEC,GAAG,KAAK;IACzC,MAAMC,gBAAgB,GAAGD,GAAG,CAACE,KAAK,CAACC,mBAAmB,CAACL,QAAQ,CAAC;IAChE,IAAIG,gBAAgB,CAACG,MAAM,KAAK,CAAC,IAAId,eAAe,CAACW,gBAAgB,CAAC,CAAC,CAAC,CAAC,EAAE;MACzE,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd,CAAC;EACDI,OAAOA,CAACR,QAAQ,EAAEC,QAAQ,EAAEC,CAAC,EAAEC,GAAG,EAAE;IAAA,IAAAM,qBAAA;IAClC,MAAMC,eAAe,GAAGP,GAAG,CAACE,KAAK,CAACC,mBAAmB,CAAC;MACpDK,kBAAkB,EAAEV,QAAQ,CAACU,kBAAkB;MAC/CC,uBAAuB,EAAE;IAC3B,CAAC,CAAC,CAAC,CAAC,CAA4B;IAEhC,MAAMC,oBAAoB,GACxB,EAAAJ,qBAAA,GAAAR,QAAQ,CAACY,oBAAoB,cAAAJ,qBAAA,uBAA7BA,qBAAA,CAA+BK,SAAS,MAAKJ,eAAe,CAACK,EAAE,GAC3D,IAAI,GACJ,IAAIvB,mBAAmB,CAACkB,eAAe,EAAEP,GAAG,CAACE,KAAK,CAAC;IACzD,OAAO;MACLJ,QAAQ,EAAE;QACR,GAAGA,QAAQ;QACXY;MACF,CAAC;MACDG,eAAe,EAAE;IACnB,CAAC;EACH,CAAC;EACDC,gBAAgB,EAAEA,CAACjB,QAAQ,EAAEC,QAAQ,EAAEE,GAAG,KAAK;IAAA,IAAAe,sBAAA;IAC7C,MAAMR,eAAe,GAAGP,GAAG,CAACE,KAAK,CAACC,mBAAmB,CAAC;MACpDK,kBAAkB,EAAEV,QAAQ,CAACU,kBAAkB;MAC/CC,uBAAuB,EAAE;IAC3B,CAAC,CAAC,CAAC,CAAC,CAA4B;IAChC,OAAO,EAAAM,sBAAA,GAAAjB,QAAQ,CAACY,oBAAoB,cAAAK,sBAAA,uBAA7BA,sBAAA,CAA+BJ,SAAS,MAAKJ,eAAe,CAACK,EAAE,GAClE,wBAAwB,GACxB,wBAAwB;EAC9B;AACF,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}