{"ast":null,"code":"import { compressData } from \"../../data/encode\";\nimport { newElementWith } from \"../../element/mutateElement\";\nimport { isInitializedImageElement } from \"../../element/typeChecks\";\nimport { t } from \"../../i18n\";\nexport class FileManager {\n  constructor(_ref) {\n    let {\n      getFiles,\n      saveFiles\n    } = _ref;\n    /** files being fetched */\n    this.fetchingFiles = new Map();\n    /** files being saved */\n    this.savingFiles = new Map();\n    /* files already saved to persistent storage */\n    this.savedFiles = new Map();\n    this.erroredFiles = new Map();\n    this._getFiles = void 0;\n    this._saveFiles = void 0;\n    /**\n     * returns whether file is already saved or being processed\n     */\n    this.isFileHandled = id => {\n      return this.savedFiles.has(id) || this.fetchingFiles.has(id) || this.savingFiles.has(id) || this.erroredFiles.has(id);\n    };\n    this.isFileSaved = id => {\n      return this.savedFiles.has(id);\n    };\n    this.saveFiles = async _ref2 => {\n      let {\n        elements,\n        files\n      } = _ref2;\n      const addedFiles = new Map();\n      for (const element of elements) {\n        if (isInitializedImageElement(element) && files[element.fileId] && !this.isFileHandled(element.fileId)) {\n          addedFiles.set(element.fileId, files[element.fileId]);\n          this.savingFiles.set(element.fileId, true);\n        }\n      }\n      try {\n        const {\n          savedFiles,\n          erroredFiles\n        } = await this._saveFiles({\n          addedFiles\n        });\n        for (const [fileId] of savedFiles) {\n          this.savedFiles.set(fileId, true);\n        }\n        return {\n          savedFiles,\n          erroredFiles\n        };\n      } finally {\n        for (const [fileId] of addedFiles) {\n          this.savingFiles.delete(fileId);\n        }\n      }\n    };\n    this.getFiles = async ids => {\n      if (!ids.length) {\n        return {\n          loadedFiles: [],\n          erroredFiles: new Map()\n        };\n      }\n      for (const id of ids) {\n        this.fetchingFiles.set(id, true);\n      }\n      try {\n        const {\n          loadedFiles,\n          erroredFiles\n        } = await this._getFiles(ids);\n        for (const file of loadedFiles) {\n          this.savedFiles.set(file.id, true);\n        }\n        for (const [fileId] of erroredFiles) {\n          this.erroredFiles.set(fileId, true);\n        }\n        return {\n          loadedFiles,\n          erroredFiles\n        };\n      } finally {\n        for (const id of ids) {\n          this.fetchingFiles.delete(id);\n        }\n      }\n    };\n    /** a file element prevents unload only if it's being saved regardless of\n     *  its `status`. This ensures that elements who for any reason haven't\n     *  beed set to `saved` status don't prevent unload in future sessions.\n     *  Technically we should prevent unload when the origin client haven't\n     *  yet saved the `status` update to storage, but that should be taken care\n     *  of during regular beforeUnload unsaved files check.\n     */\n    this.shouldPreventUnload = elements => {\n      return elements.some(element => {\n        return isInitializedImageElement(element) && !element.isDeleted && this.savingFiles.has(element.fileId);\n      });\n    };\n    /**\n     * helper to determine if image element status needs updating\n     */\n    this.shouldUpdateImageElementStatus = element => {\n      return isInitializedImageElement(element) && this.isFileSaved(element.fileId) && element.status === \"pending\";\n    };\n    this._getFiles = getFiles;\n    this._saveFiles = saveFiles;\n  }\n  reset() {\n    this.fetchingFiles.clear();\n    this.savingFiles.clear();\n    this.savedFiles.clear();\n    this.erroredFiles.clear();\n  }\n}\nexport const encodeFilesForUpload = async _ref3 => {\n  let {\n    files,\n    maxBytes,\n    encryptionKey\n  } = _ref3;\n  const processedFiles = [];\n  for (const [id, fileData] of files) {\n    const buffer = new TextEncoder().encode(fileData.dataURL);\n    const encodedFile = await compressData(buffer, {\n      encryptionKey,\n      metadata: {\n        id,\n        mimeType: fileData.mimeType,\n        created: Date.now(),\n        lastRetrieved: Date.now()\n      }\n    });\n    if (buffer.byteLength > maxBytes) {\n      throw new Error(t(\"errors.fileTooBig\", {\n        maxSize: `${Math.trunc(maxBytes / 1024 / 1024)}MB`\n      }));\n    }\n    processedFiles.push({\n      id,\n      buffer: encodedFile\n    });\n  }\n  return processedFiles;\n};\nexport const updateStaleImageStatuses = params => {\n  if (!params.erroredFiles.size) {\n    return;\n  }\n  params.excalidrawAPI.updateScene({\n    elements: params.excalidrawAPI.getSceneElementsIncludingDeleted().map(element => {\n      if (isInitializedImageElement(element) && params.erroredFiles.has(element.fileId)) {\n        return newElementWith(element, {\n          status: \"error\"\n        });\n      }\n      return element;\n    })\n  });\n};","map":{"version":3,"names":["compressData","newElementWith","isInitializedImageElement","t","FileManager","constructor","_ref","getFiles","saveFiles","fetchingFiles","Map","savingFiles","savedFiles","erroredFiles","_getFiles","_saveFiles","isFileHandled","id","has","isFileSaved","_ref2","elements","files","addedFiles","element","fileId","set","delete","ids","length","loadedFiles","file","shouldPreventUnload","some","isDeleted","shouldUpdateImageElementStatus","status","reset","clear","encodeFilesForUpload","_ref3","maxBytes","encryptionKey","processedFiles","fileData","buffer","TextEncoder","encode","dataURL","encodedFile","metadata","mimeType","created","Date","now","lastRetrieved","byteLength","Error","maxSize","Math","trunc","push","updateStaleImageStatuses","params","size","excalidrawAPI","updateScene","getSceneElementsIncludingDeleted","map"],"sources":["D:/project/excalidraw-cn/src/excalidraw-app/data/FileManager.ts"],"sourcesContent":["import { compressData } from \"../../data/encode\";\nimport { newElementWith } from \"../../element/mutateElement\";\nimport { isInitializedImageElement } from \"../../element/typeChecks\";\nimport {\n  ExcalidrawElement,\n  ExcalidrawImageElement,\n  FileId,\n  InitializedExcalidrawImageElement,\n} from \"../../element/types\";\nimport { t } from \"../../i18n\";\nimport {\n  BinaryFileData,\n  BinaryFileMetadata,\n  ExcalidrawImperativeAPI,\n  BinaryFiles,\n} from \"../../types\";\n\nexport class FileManager {\n  /** files being fetched */\n  private fetchingFiles = new Map<ExcalidrawImageElement[\"fileId\"], true>();\n  /** files being saved */\n  private savingFiles = new Map<ExcalidrawImageElement[\"fileId\"], true>();\n  /* files already saved to persistent storage */\n  private savedFiles = new Map<ExcalidrawImageElement[\"fileId\"], true>();\n  private erroredFiles = new Map<ExcalidrawImageElement[\"fileId\"], true>();\n\n  private _getFiles;\n  private _saveFiles;\n\n  constructor({\n    getFiles,\n    saveFiles,\n  }: {\n    getFiles: (fileIds: FileId[]) => Promise<{\n      loadedFiles: BinaryFileData[];\n      erroredFiles: Map<FileId, true>;\n    }>;\n    saveFiles: (data: { addedFiles: Map<FileId, BinaryFileData> }) => Promise<{\n      savedFiles: Map<FileId, true>;\n      erroredFiles: Map<FileId, true>;\n    }>;\n  }) {\n    this._getFiles = getFiles;\n    this._saveFiles = saveFiles;\n  }\n\n  /**\n   * returns whether file is already saved or being processed\n   */\n  isFileHandled = (id: FileId) => {\n    return (\n      this.savedFiles.has(id) ||\n      this.fetchingFiles.has(id) ||\n      this.savingFiles.has(id) ||\n      this.erroredFiles.has(id)\n    );\n  };\n\n  isFileSaved = (id: FileId) => {\n    return this.savedFiles.has(id);\n  };\n\n  saveFiles = async ({\n    elements,\n    files,\n  }: {\n    elements: readonly ExcalidrawElement[];\n    files: BinaryFiles;\n  }) => {\n    const addedFiles: Map<FileId, BinaryFileData> = new Map();\n\n    for (const element of elements) {\n      if (\n        isInitializedImageElement(element) &&\n        files[element.fileId] &&\n        !this.isFileHandled(element.fileId)\n      ) {\n        addedFiles.set(element.fileId, files[element.fileId]);\n        this.savingFiles.set(element.fileId, true);\n      }\n    }\n\n    try {\n      const { savedFiles, erroredFiles } = await this._saveFiles({\n        addedFiles,\n      });\n\n      for (const [fileId] of savedFiles) {\n        this.savedFiles.set(fileId, true);\n      }\n\n      return {\n        savedFiles,\n        erroredFiles,\n      };\n    } finally {\n      for (const [fileId] of addedFiles) {\n        this.savingFiles.delete(fileId);\n      }\n    }\n  };\n\n  getFiles = async (\n    ids: FileId[],\n  ): Promise<{\n    loadedFiles: BinaryFileData[];\n    erroredFiles: Map<FileId, true>;\n  }> => {\n    if (!ids.length) {\n      return {\n        loadedFiles: [],\n        erroredFiles: new Map(),\n      };\n    }\n    for (const id of ids) {\n      this.fetchingFiles.set(id, true);\n    }\n\n    try {\n      const { loadedFiles, erroredFiles } = await this._getFiles(ids);\n\n      for (const file of loadedFiles) {\n        this.savedFiles.set(file.id, true);\n      }\n      for (const [fileId] of erroredFiles) {\n        this.erroredFiles.set(fileId, true);\n      }\n\n      return { loadedFiles, erroredFiles };\n    } finally {\n      for (const id of ids) {\n        this.fetchingFiles.delete(id);\n      }\n    }\n  };\n\n  /** a file element prevents unload only if it's being saved regardless of\n   *  its `status`. This ensures that elements who for any reason haven't\n   *  beed set to `saved` status don't prevent unload in future sessions.\n   *  Technically we should prevent unload when the origin client haven't\n   *  yet saved the `status` update to storage, but that should be taken care\n   *  of during regular beforeUnload unsaved files check.\n   */\n  shouldPreventUnload = (elements: readonly ExcalidrawElement[]) => {\n    return elements.some((element) => {\n      return (\n        isInitializedImageElement(element) &&\n        !element.isDeleted &&\n        this.savingFiles.has(element.fileId)\n      );\n    });\n  };\n\n  /**\n   * helper to determine if image element status needs updating\n   */\n  shouldUpdateImageElementStatus = (\n    element: ExcalidrawElement,\n  ): element is InitializedExcalidrawImageElement => {\n    return (\n      isInitializedImageElement(element) &&\n      this.isFileSaved(element.fileId) &&\n      element.status === \"pending\"\n    );\n  };\n\n  reset() {\n    this.fetchingFiles.clear();\n    this.savingFiles.clear();\n    this.savedFiles.clear();\n    this.erroredFiles.clear();\n  }\n}\n\nexport const encodeFilesForUpload = async ({\n  files,\n  maxBytes,\n  encryptionKey,\n}: {\n  files: Map<FileId, BinaryFileData>;\n  maxBytes: number;\n  encryptionKey: string;\n}) => {\n  const processedFiles: {\n    id: FileId;\n    buffer: Uint8Array;\n  }[] = [];\n\n  for (const [id, fileData] of files) {\n    const buffer = new TextEncoder().encode(fileData.dataURL);\n\n    const encodedFile = await compressData<BinaryFileMetadata>(buffer, {\n      encryptionKey,\n      metadata: {\n        id,\n        mimeType: fileData.mimeType,\n        created: Date.now(),\n        lastRetrieved: Date.now(),\n      },\n    });\n\n    if (buffer.byteLength > maxBytes) {\n      throw new Error(\n        t(\"errors.fileTooBig\", {\n          maxSize: `${Math.trunc(maxBytes / 1024 / 1024)}MB`,\n        }),\n      );\n    }\n\n    processedFiles.push({\n      id,\n      buffer: encodedFile,\n    });\n  }\n\n  return processedFiles;\n};\n\nexport const updateStaleImageStatuses = (params: {\n  excalidrawAPI: ExcalidrawImperativeAPI;\n  erroredFiles: Map<FileId, true>;\n  elements: readonly ExcalidrawElement[];\n}) => {\n  if (!params.erroredFiles.size) {\n    return;\n  }\n  params.excalidrawAPI.updateScene({\n    elements: params.excalidrawAPI\n      .getSceneElementsIncludingDeleted()\n      .map((element) => {\n        if (\n          isInitializedImageElement(element) &&\n          params.erroredFiles.has(element.fileId)\n        ) {\n          return newElementWith(element, {\n            status: \"error\",\n          });\n        }\n        return element;\n      }),\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}