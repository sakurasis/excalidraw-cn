{"ast":null,"code":"import { arrayToMap, getFontString, getUpdatedTimestamp, isTestEnv } from \"../utils\";\nimport { randomInteger, randomId } from \"../random\";\nimport { bumpVersion, newElementWith } from \"./mutateElement\";\nimport { getNewGroupIdsForDuplication } from \"../groups\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { adjustXYWithRotation } from \"../math\";\nimport { getResizedElementAbsoluteCoords } from \"./bounds\";\nimport { getContainerElement, measureText, normalizeText, wrapText, getBoundTextMaxWidth, getDefaultLineHeight } from \"./textElement\";\nimport { DEFAULT_ELEMENT_PROPS, DEFAULT_FONT_FAMILY, DEFAULT_FONT_SIZE, DEFAULT_TEXT_ALIGN, DEFAULT_VERTICAL_ALIGN, VERTICAL_ALIGN } from \"../constants\";\nconst _newElementBase = (type, _ref) => {\n  var _rest$seed, _rest$versionNonce;\n  let {\n    x,\n    y,\n    strokeColor = DEFAULT_ELEMENT_PROPS.strokeColor,\n    backgroundColor = DEFAULT_ELEMENT_PROPS.backgroundColor,\n    fillStyle = DEFAULT_ELEMENT_PROPS.fillStyle,\n    strokeWidth = DEFAULT_ELEMENT_PROPS.strokeWidth,\n    strokeStyle = DEFAULT_ELEMENT_PROPS.strokeStyle,\n    roughness = DEFAULT_ELEMENT_PROPS.roughness,\n    opacity = DEFAULT_ELEMENT_PROPS.opacity,\n    width = 0,\n    height = 0,\n    angle = 0,\n    groupIds = [],\n    frameId = null,\n    roundness = null,\n    boundElements = null,\n    link = null,\n    locked = DEFAULT_ELEMENT_PROPS.locked,\n    ...rest\n  } = _ref;\n  // assign type to guard against excess properties\n  const element = {\n    id: rest.id || randomId(),\n    type,\n    x,\n    y,\n    width,\n    height,\n    angle,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    strokeStyle,\n    roughness,\n    opacity,\n    groupIds,\n    frameId,\n    roundness,\n    seed: (_rest$seed = rest.seed) !== null && _rest$seed !== void 0 ? _rest$seed : randomInteger(),\n    version: rest.version || 1,\n    versionNonce: (_rest$versionNonce = rest.versionNonce) !== null && _rest$versionNonce !== void 0 ? _rest$versionNonce : 0,\n    isDeleted: false,\n    boundElements,\n    updated: getUpdatedTimestamp(),\n    link,\n    locked\n  };\n  return element;\n};\nexport const newElement = opts => _newElementBase(opts.type, opts);\nexport const newFrameElement = opts => {\n  const frameElement = newElementWith({\n    ..._newElementBase(\"frame\", opts),\n    type: \"frame\",\n    name: null\n  }, {});\n  return frameElement;\n};\n\n/** computes element x/y offset based on textAlign/verticalAlign */\nconst getTextElementPositionOffsets = (opts, metrics) => {\n  return {\n    x: opts.textAlign === \"center\" ? metrics.width / 2 : opts.textAlign === \"right\" ? metrics.width : 0,\n    y: opts.verticalAlign === \"middle\" ? metrics.height / 2 : 0\n  };\n};\nexport const newTextElement = opts => {\n  const fontFamily = opts.fontFamily || DEFAULT_FONT_FAMILY;\n  const fontSize = opts.fontSize || DEFAULT_FONT_SIZE;\n  const lineHeight = opts.lineHeight || getDefaultLineHeight(fontFamily);\n  const text = normalizeText(opts.text);\n  const metrics = measureText(text, getFontString({\n    fontFamily,\n    fontSize\n  }), lineHeight);\n  const textAlign = opts.textAlign || DEFAULT_TEXT_ALIGN;\n  const verticalAlign = opts.verticalAlign || DEFAULT_VERTICAL_ALIGN;\n  const offsets = getTextElementPositionOffsets({\n    textAlign,\n    verticalAlign\n  }, metrics);\n  const textElement = newElementWith({\n    ..._newElementBase(\"text\", opts),\n    text,\n    fontSize,\n    fontFamily,\n    textAlign,\n    verticalAlign,\n    x: opts.x - offsets.x,\n    y: opts.y - offsets.y,\n    width: metrics.width,\n    height: metrics.height,\n    baseline: metrics.baseline,\n    containerId: opts.containerId || null,\n    originalText: text,\n    lineHeight,\n    isFrameName: opts.isFrameName || false\n  }, {});\n  return textElement;\n};\nconst getAdjustedDimensions = (element, nextText) => {\n  const {\n    width: nextWidth,\n    height: nextHeight,\n    baseline: nextBaseline\n  } = measureText(nextText, getFontString(element), element.lineHeight);\n  const {\n    textAlign,\n    verticalAlign\n  } = element;\n  let x;\n  let y;\n  if (textAlign === \"center\" && verticalAlign === VERTICAL_ALIGN.MIDDLE && !element.containerId) {\n    const prevMetrics = measureText(element.text, getFontString(element), element.lineHeight);\n    const offsets = getTextElementPositionOffsets(element, {\n      width: nextWidth - prevMetrics.width,\n      height: nextHeight - prevMetrics.height\n    });\n    x = element.x - offsets.x;\n    y = element.y - offsets.y;\n  } else {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(element, nextWidth, nextHeight, false);\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n    [x, y] = adjustXYWithRotation({\n      s: true,\n      e: textAlign === \"center\" || textAlign === \"left\",\n      w: textAlign === \"center\" || textAlign === \"right\"\n    }, element.x, element.y, element.angle, deltaX1, deltaY1, deltaX2, deltaY2);\n  }\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    baseline: nextBaseline,\n    x: Number.isFinite(x) ? x : element.x,\n    y: Number.isFinite(y) ? y : element.y\n  };\n};\nexport const refreshTextDimensions = function (textElement) {\n  let text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : textElement.text;\n  if (textElement.isDeleted) {\n    return;\n  }\n  const container = getContainerElement(textElement);\n  if (container) {\n    text = wrapText(text, getFontString(textElement), getBoundTextMaxWidth(container));\n  }\n  const dimensions = getAdjustedDimensions(textElement, text);\n  return {\n    text,\n    ...dimensions\n  };\n};\nexport const updateTextElement = (textElement, _ref2) => {\n  let {\n    text,\n    isDeleted,\n    originalText\n  } = _ref2;\n  return newElementWith(textElement, {\n    originalText,\n    isDeleted: isDeleted !== null && isDeleted !== void 0 ? isDeleted : textElement.isDeleted,\n    ...refreshTextDimensions(textElement, originalText)\n  });\n};\nexport const newFreeDrawElement = opts => {\n  return {\n    ..._newElementBase(opts.type, opts),\n    points: opts.points || [],\n    pressures: [],\n    simulatePressure: opts.simulatePressure,\n    lastCommittedPoint: null\n  };\n};\nexport const newLinearElement = opts => {\n  return {\n    ..._newElementBase(opts.type, opts),\n    points: opts.points || [],\n    lastCommittedPoint: null,\n    startBinding: null,\n    endBinding: null,\n    startArrowhead: opts.startArrowhead,\n    endArrowhead: opts.endArrowhead\n  };\n};\nexport const newImageElement = opts => {\n  var _opts$status, _opts$fileId, _opts$scale;\n  return {\n    ..._newElementBase(\"image\", opts),\n    // in the future we'll support changing stroke color for some SVG elements,\n    // and `transparent` will likely mean \"use original colors of the image\"\n    strokeColor: \"transparent\",\n    status: (_opts$status = opts.status) !== null && _opts$status !== void 0 ? _opts$status : \"pending\",\n    fileId: (_opts$fileId = opts.fileId) !== null && _opts$fileId !== void 0 ? _opts$fileId : null,\n    scale: (_opts$scale = opts.scale) !== null && _opts$scale !== void 0 ? _opts$scale : [1, 1]\n  };\n};\n\n// Simplified deep clone for the purpose of cloning ExcalidrawElement.\n//\n// Only clones plain objects and arrays. Doesn't clone Date, RegExp, Map, Set,\n// Typed arrays and other non-null objects.\n//\n// Adapted from https://github.com/lukeed/klona\n//\n// The reason for `deepCopyElement()` wrapper is type safety (only allow\n// passing ExcalidrawElement as the top-level argument).\nconst _deepCopyElement = function (val) {\n  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // only clone non-primitives\n  if (val == null || typeof val !== \"object\") {\n    return val;\n  }\n  const objectType = Object.prototype.toString.call(val);\n  if (objectType === \"[object Object]\") {\n    const tmp = typeof val.constructor === \"function\" ? Object.create(Object.getPrototypeOf(val)) : {};\n    for (const key in val) {\n      if (val.hasOwnProperty(key)) {\n        // don't copy non-serializable objects like these caches. They'll be\n        // populated when the element is rendered.\n        if (depth === 0 && (key === \"shape\" || key === \"canvas\")) {\n          continue;\n        }\n        tmp[key] = _deepCopyElement(val[key], depth + 1);\n      }\n    }\n    return tmp;\n  }\n  if (Array.isArray(val)) {\n    let k = val.length;\n    const arr = new Array(k);\n    while (k--) {\n      arr[k] = _deepCopyElement(val[k], depth + 1);\n    }\n    return arr;\n  }\n\n  // we're not cloning non-array & non-plain-object objects because we\n  // don't support them on excalidraw elements yet. If we do, we need to make\n  // sure we start cloning them, so let's warn about it.\n  if (process.env.NODE_ENV === \"development\") {\n    if (objectType !== \"[object Object]\" && objectType !== \"[object Array]\" && objectType.startsWith(\"[object \")) {\n      console.warn(`_deepCloneElement: unexpected object type ${objectType}. This value will not be cloned!`);\n    }\n  }\n  return val;\n};\n\n/**\n * Clones ExcalidrawElement data structure. Does not regenerate id, nonce, or\n * any value. The purpose is to to break object references for immutability\n * reasons, whenever we want to keep the original element, but ensure it's not\n * mutated.\n *\n * Only clones plain objects and arrays. Doesn't clone Date, RegExp, Map, Set,\n * Typed arrays and other non-null objects.\n */\nexport const deepCopyElement = val => {\n  return _deepCopyElement(val);\n};\n\n/**\n * utility wrapper to generate new id. In test env it reuses the old + postfix\n * for test assertions.\n */\nconst regenerateId = previousId => {\n  if (isTestEnv() && previousId) {\n    var _window$h, _window$h$app;\n    let nextId = `${previousId}_copy`;\n    // `window.h` may not be defined in some unit tests\n    if ((_window$h = window.h) !== null && _window$h !== void 0 && (_window$h$app = _window$h.app) !== null && _window$h$app !== void 0 && _window$h$app.getSceneElementsIncludingDeleted().find(el => el.id === nextId)) {\n      nextId += \"_copy\";\n    }\n    return nextId;\n  }\n  return randomId();\n};\n\n/**\n * Duplicate an element, often used in the alt-drag operation.\n * Note that this method has gotten a bit complicated since the\n * introduction of gruoping/ungrouping elements.\n * @param editingGroupId The current group being edited. The new\n *                       element will inherit this group and its\n *                       parents.\n * @param groupIdMapForOperation A Map that maps old group IDs to\n *                               duplicated ones. If you are duplicating\n *                               multiple elements at once, share this map\n *                               amongst all of them\n * @param element Element to duplicate\n * @param overrides Any element properties to override\n */\nexport const duplicateElement = (editingGroupId, groupIdMapForOperation, element, overrides) => {\n  let copy = deepCopyElement(element);\n  copy.id = regenerateId(copy.id);\n  copy.boundElements = null;\n  copy.updated = getUpdatedTimestamp();\n  copy.seed = randomInteger();\n  copy.groupIds = getNewGroupIdsForDuplication(copy.groupIds, editingGroupId, groupId => {\n    if (!groupIdMapForOperation.has(groupId)) {\n      groupIdMapForOperation.set(groupId, regenerateId(groupId));\n    }\n    return groupIdMapForOperation.get(groupId);\n  });\n  if (overrides) {\n    copy = Object.assign(copy, overrides);\n  }\n  return copy;\n};\n\n/**\n * Clones elements, regenerating their ids (including bindings) and group ids.\n *\n * If bindings don't exist in the elements array, they are removed. Therefore,\n * it's advised to supply the whole elements array, or sets of elements that\n * are encapsulated (such as library items), if the purpose is to retain\n * bindings to the cloned elements intact.\n *\n * NOTE by default does not randomize or regenerate anything except the id.\n */\nexport const duplicateElements = (elements, opts) => {\n  const clonedElements = [];\n  const origElementsMap = arrayToMap(elements);\n\n  // used for for migrating old ids to new ids\n  const elementNewIdsMap = new Map();\n  const maybeGetNewId = id => {\n    // if we've already migrated the element id, return the new one directly\n    if (elementNewIdsMap.has(id)) {\n      return elementNewIdsMap.get(id);\n    }\n    // if we haven't migrated the element id, but an old element with the same\n    // id exists, generate a new id for it and return it\n    if (origElementsMap.has(id)) {\n      const newId = regenerateId(id);\n      elementNewIdsMap.set(id, newId);\n      return newId;\n    }\n    // if old element doesn't exist, return null to mark it for removal\n    return null;\n  };\n  const groupNewIdsMap = new Map();\n  for (const element of elements) {\n    const clonedElement = _deepCopyElement(element);\n    clonedElement.id = maybeGetNewId(element.id);\n    if (opts !== null && opts !== void 0 && opts.randomizeSeed) {\n      clonedElement.seed = randomInteger();\n      bumpVersion(clonedElement);\n    }\n    if (clonedElement.groupIds) {\n      clonedElement.groupIds = clonedElement.groupIds.map(groupId => {\n        if (!groupNewIdsMap.has(groupId)) {\n          groupNewIdsMap.set(groupId, regenerateId(groupId));\n        }\n        return groupNewIdsMap.get(groupId);\n      });\n    }\n    if (\"containerId\" in clonedElement && clonedElement.containerId) {\n      const newContainerId = maybeGetNewId(clonedElement.containerId);\n      clonedElement.containerId = newContainerId;\n    }\n    if (\"boundElements\" in clonedElement && clonedElement.boundElements) {\n      clonedElement.boundElements = clonedElement.boundElements.reduce((acc, binding) => {\n        const newBindingId = maybeGetNewId(binding.id);\n        if (newBindingId) {\n          acc.push({\n            ...binding,\n            id: newBindingId\n          });\n        }\n        return acc;\n      }, []);\n    }\n    if (\"endBinding\" in clonedElement && clonedElement.endBinding) {\n      const newEndBindingId = maybeGetNewId(clonedElement.endBinding.elementId);\n      clonedElement.endBinding = newEndBindingId ? {\n        ...clonedElement.endBinding,\n        elementId: newEndBindingId\n      } : null;\n    }\n    if (\"startBinding\" in clonedElement && clonedElement.startBinding) {\n      const newEndBindingId = maybeGetNewId(clonedElement.startBinding.elementId);\n      clonedElement.startBinding = newEndBindingId ? {\n        ...clonedElement.startBinding,\n        elementId: newEndBindingId\n      } : null;\n    }\n    if (clonedElement.frameId) {\n      clonedElement.frameId = maybeGetNewId(clonedElement.frameId);\n    }\n    clonedElements.push(clonedElement);\n  }\n  return clonedElements;\n};","map":{"version":3,"names":["arrayToMap","getFontString","getUpdatedTimestamp","isTestEnv","randomInteger","randomId","bumpVersion","newElementWith","getNewGroupIdsForDuplication","getElementAbsoluteCoords","adjustXYWithRotation","getResizedElementAbsoluteCoords","getContainerElement","measureText","normalizeText","wrapText","getBoundTextMaxWidth","getDefaultLineHeight","DEFAULT_ELEMENT_PROPS","DEFAULT_FONT_FAMILY","DEFAULT_FONT_SIZE","DEFAULT_TEXT_ALIGN","DEFAULT_VERTICAL_ALIGN","VERTICAL_ALIGN","_newElementBase","type","_ref","_rest$seed","_rest$versionNonce","x","y","strokeColor","backgroundColor","fillStyle","strokeWidth","strokeStyle","roughness","opacity","width","height","angle","groupIds","frameId","roundness","boundElements","link","locked","rest","element","id","seed","version","versionNonce","isDeleted","updated","newElement","opts","newFrameElement","frameElement","name","getTextElementPositionOffsets","metrics","textAlign","verticalAlign","newTextElement","fontFamily","fontSize","lineHeight","text","offsets","textElement","baseline","containerId","originalText","isFrameName","getAdjustedDimensions","nextText","nextWidth","nextHeight","nextBaseline","MIDDLE","prevMetrics","x1","y1","x2","y2","nextX1","nextY1","nextX2","nextY2","deltaX1","deltaY1","deltaX2","deltaY2","s","e","w","Number","isFinite","refreshTextDimensions","arguments","length","undefined","container","dimensions","updateTextElement","_ref2","newFreeDrawElement","points","pressures","simulatePressure","lastCommittedPoint","newLinearElement","startBinding","endBinding","startArrowhead","endArrowhead","newImageElement","_opts$status","_opts$fileId","_opts$scale","status","fileId","scale","_deepCopyElement","val","depth","objectType","Object","prototype","toString","call","tmp","constructor","create","getPrototypeOf","key","hasOwnProperty","Array","isArray","k","arr","process","env","NODE_ENV","startsWith","console","warn","deepCopyElement","regenerateId","previousId","_window$h","_window$h$app","nextId","window","h","app","getSceneElementsIncludingDeleted","find","el","duplicateElement","editingGroupId","groupIdMapForOperation","overrides","copy","groupId","has","set","get","assign","duplicateElements","elements","clonedElements","origElementsMap","elementNewIdsMap","Map","maybeGetNewId","newId","groupNewIdsMap","clonedElement","randomizeSeed","map","newContainerId","reduce","acc","binding","newBindingId","push","newEndBindingId","elementId"],"sources":["D:/project/excalidraw-cn/src/element/newElement.ts"],"sourcesContent":["import {\n  ExcalidrawElement,\n  ExcalidrawImageElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n  ExcalidrawGenericElement,\n  NonDeleted,\n  TextAlign,\n  GroupId,\n  VerticalAlign,\n  Arrowhead,\n  ExcalidrawFreeDrawElement,\n  FontFamilyValues,\n  ExcalidrawTextContainer,\n  ExcalidrawFrameElement,\n} from \"../element/types\";\nimport {\n  arrayToMap,\n  getFontString,\n  getUpdatedTimestamp,\n  isTestEnv,\n} from \"../utils\";\nimport { randomInteger, randomId } from \"../random\";\nimport { bumpVersion, newElementWith } from \"./mutateElement\";\nimport { getNewGroupIdsForDuplication } from \"../groups\";\nimport { AppState } from \"../types\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { adjustXYWithRotation } from \"../math\";\nimport { getResizedElementAbsoluteCoords } from \"./bounds\";\nimport {\n  getContainerElement,\n  measureText,\n  normalizeText,\n  wrapText,\n  getBoundTextMaxWidth,\n  getDefaultLineHeight,\n} from \"./textElement\";\nimport {\n  DEFAULT_ELEMENT_PROPS,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_TEXT_ALIGN,\n  DEFAULT_VERTICAL_ALIGN,\n  VERTICAL_ALIGN,\n} from \"../constants\";\nimport { MarkOptional, Merge, Mutable } from \"../utility-types\";\n\ntype ElementConstructorOpts = MarkOptional<\n  Omit<ExcalidrawGenericElement, \"id\" | \"type\" | \"isDeleted\" | \"updated\">,\n  | \"width\"\n  | \"height\"\n  | \"angle\"\n  | \"groupIds\"\n  | \"frameId\"\n  | \"boundElements\"\n  | \"seed\"\n  | \"version\"\n  | \"versionNonce\"\n  | \"link\"\n  | \"strokeStyle\"\n  | \"fillStyle\"\n  | \"strokeColor\"\n  | \"backgroundColor\"\n  | \"roughness\"\n  | \"strokeWidth\"\n  | \"roundness\"\n  | \"locked\"\n  | \"opacity\"\n>;\n\nconst _newElementBase = <T extends ExcalidrawElement>(\n  type: T[\"type\"],\n  {\n    x,\n    y,\n    strokeColor = DEFAULT_ELEMENT_PROPS.strokeColor,\n    backgroundColor = DEFAULT_ELEMENT_PROPS.backgroundColor,\n    fillStyle = DEFAULT_ELEMENT_PROPS.fillStyle,\n    strokeWidth = DEFAULT_ELEMENT_PROPS.strokeWidth,\n    strokeStyle = DEFAULT_ELEMENT_PROPS.strokeStyle,\n    roughness = DEFAULT_ELEMENT_PROPS.roughness,\n    opacity = DEFAULT_ELEMENT_PROPS.opacity,\n    width = 0,\n    height = 0,\n    angle = 0,\n    groupIds = [],\n    frameId = null,\n    roundness = null,\n    boundElements = null,\n    link = null,\n    locked = DEFAULT_ELEMENT_PROPS.locked,\n    ...rest\n  }: ElementConstructorOpts & Omit<Partial<ExcalidrawGenericElement>, \"type\">,\n) => {\n  // assign type to guard against excess properties\n  const element: Merge<ExcalidrawGenericElement, { type: T[\"type\"] }> = {\n    id: rest.id || randomId(),\n    type,\n    x,\n    y,\n    width,\n    height,\n    angle,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    strokeStyle,\n    roughness,\n    opacity,\n    groupIds,\n    frameId,\n    roundness,\n    seed: rest.seed ?? randomInteger(),\n    version: rest.version || 1,\n    versionNonce: rest.versionNonce ?? 0,\n    isDeleted: false as false,\n    boundElements,\n    updated: getUpdatedTimestamp(),\n    link,\n    locked,\n  };\n  return element;\n};\n\nexport const newElement = (\n  opts: {\n    type: ExcalidrawGenericElement[\"type\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawGenericElement> =>\n  _newElementBase<ExcalidrawGenericElement>(opts.type, opts);\n\nexport const newFrameElement = (\n  opts: ElementConstructorOpts,\n): NonDeleted<ExcalidrawFrameElement> => {\n  const frameElement = newElementWith(\n    {\n      ..._newElementBase<ExcalidrawFrameElement>(\"frame\", opts),\n      type: \"frame\",\n      name: null,\n    },\n    {},\n  );\n\n  return frameElement;\n};\n\n/** computes element x/y offset based on textAlign/verticalAlign */\nconst getTextElementPositionOffsets = (\n  opts: {\n    textAlign: ExcalidrawTextElement[\"textAlign\"];\n    verticalAlign: ExcalidrawTextElement[\"verticalAlign\"];\n  },\n  metrics: {\n    width: number;\n    height: number;\n  },\n) => {\n  return {\n    x:\n      opts.textAlign === \"center\"\n        ? metrics.width / 2\n        : opts.textAlign === \"right\"\n        ? metrics.width\n        : 0,\n    y: opts.verticalAlign === \"middle\" ? metrics.height / 2 : 0,\n  };\n};\n\nexport const newTextElement = (\n  opts: {\n    text: string;\n    fontSize?: number;\n    fontFamily?: FontFamilyValues;\n    textAlign?: TextAlign;\n    verticalAlign?: VerticalAlign;\n    containerId?: ExcalidrawTextContainer[\"id\"];\n    lineHeight?: ExcalidrawTextElement[\"lineHeight\"];\n    strokeWidth?: ExcalidrawTextElement[\"strokeWidth\"];\n    isFrameName?: boolean;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawTextElement> => {\n  const fontFamily = opts.fontFamily || DEFAULT_FONT_FAMILY;\n  const fontSize = opts.fontSize || DEFAULT_FONT_SIZE;\n  const lineHeight = opts.lineHeight || getDefaultLineHeight(fontFamily);\n  const text = normalizeText(opts.text);\n  const metrics = measureText(\n    text,\n    getFontString({ fontFamily, fontSize }),\n    lineHeight,\n  );\n  const textAlign = opts.textAlign || DEFAULT_TEXT_ALIGN;\n  const verticalAlign = opts.verticalAlign || DEFAULT_VERTICAL_ALIGN;\n  const offsets = getTextElementPositionOffsets(\n    { textAlign, verticalAlign },\n    metrics,\n  );\n\n  const textElement = newElementWith(\n    {\n      ..._newElementBase<ExcalidrawTextElement>(\"text\", opts),\n      text,\n      fontSize,\n      fontFamily,\n      textAlign,\n      verticalAlign,\n      x: opts.x - offsets.x,\n      y: opts.y - offsets.y,\n      width: metrics.width,\n      height: metrics.height,\n      baseline: metrics.baseline,\n      containerId: opts.containerId || null,\n      originalText: text,\n      lineHeight,\n      isFrameName: opts.isFrameName || false,\n    },\n    {},\n  );\n  return textElement;\n};\n\nconst getAdjustedDimensions = (\n  element: ExcalidrawTextElement,\n  nextText: string,\n): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  baseline: number;\n} => {\n  const {\n    width: nextWidth,\n    height: nextHeight,\n    baseline: nextBaseline,\n  } = measureText(nextText, getFontString(element), element.lineHeight);\n  const { textAlign, verticalAlign } = element;\n  let x: number;\n  let y: number;\n  if (\n    textAlign === \"center\" &&\n    verticalAlign === VERTICAL_ALIGN.MIDDLE &&\n    !element.containerId\n  ) {\n    const prevMetrics = measureText(\n      element.text,\n      getFontString(element),\n      element.lineHeight,\n    );\n    const offsets = getTextElementPositionOffsets(element, {\n      width: nextWidth - prevMetrics.width,\n      height: nextHeight - prevMetrics.height,\n    });\n\n    x = element.x - offsets.x;\n    y = element.y - offsets.y;\n  } else {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n      false,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n\n    [x, y] = adjustXYWithRotation(\n      {\n        s: true,\n        e: textAlign === \"center\" || textAlign === \"left\",\n        w: textAlign === \"center\" || textAlign === \"right\",\n      },\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n  }\n\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    baseline: nextBaseline,\n    x: Number.isFinite(x) ? x : element.x,\n    y: Number.isFinite(y) ? y : element.y,\n  };\n};\n\nexport const refreshTextDimensions = (\n  textElement: ExcalidrawTextElement,\n  text = textElement.text,\n) => {\n  if (textElement.isDeleted) {\n    return;\n  }\n  const container = getContainerElement(textElement);\n  if (container) {\n    text = wrapText(\n      text,\n      getFontString(textElement),\n      getBoundTextMaxWidth(container),\n    );\n  }\n  const dimensions = getAdjustedDimensions(textElement, text);\n  return { text, ...dimensions };\n};\n\nexport const updateTextElement = (\n  textElement: ExcalidrawTextElement,\n  {\n    text,\n    isDeleted,\n    originalText,\n  }: {\n    text: string;\n    isDeleted?: boolean;\n    originalText: string;\n  },\n): ExcalidrawTextElement => {\n  return newElementWith(textElement, {\n    originalText,\n    isDeleted: isDeleted ?? textElement.isDeleted,\n    ...refreshTextDimensions(textElement, originalText),\n  });\n};\n\nexport const newFreeDrawElement = (\n  opts: {\n    type: \"freedraw\";\n    points?: ExcalidrawFreeDrawElement[\"points\"];\n    simulatePressure: boolean;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawFreeDrawElement> => {\n  return {\n    ..._newElementBase<ExcalidrawFreeDrawElement>(opts.type, opts),\n    points: opts.points || [],\n    pressures: [],\n    simulatePressure: opts.simulatePressure,\n    lastCommittedPoint: null,\n  };\n};\n\nexport const newLinearElement = (\n  opts: {\n    type: ExcalidrawLinearElement[\"type\"];\n    startArrowhead: Arrowhead | null;\n    endArrowhead: Arrowhead | null;\n    points?: ExcalidrawLinearElement[\"points\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawLinearElement> => {\n  return {\n    ..._newElementBase<ExcalidrawLinearElement>(opts.type, opts),\n    points: opts.points || [],\n    lastCommittedPoint: null,\n    startBinding: null,\n    endBinding: null,\n    startArrowhead: opts.startArrowhead,\n    endArrowhead: opts.endArrowhead,\n  };\n};\n\nexport const newImageElement = (\n  opts: {\n    type: ExcalidrawImageElement[\"type\"];\n    status?: ExcalidrawImageElement[\"status\"];\n    fileId?: ExcalidrawImageElement[\"fileId\"];\n    scale?: ExcalidrawImageElement[\"scale\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawImageElement> => {\n  return {\n    ..._newElementBase<ExcalidrawImageElement>(\"image\", opts),\n    // in the future we'll support changing stroke color for some SVG elements,\n    // and `transparent` will likely mean \"use original colors of the image\"\n    strokeColor: \"transparent\",\n    status: opts.status ?? \"pending\",\n    fileId: opts.fileId ?? null,\n    scale: opts.scale ?? [1, 1],\n  };\n};\n\n// Simplified deep clone for the purpose of cloning ExcalidrawElement.\n//\n// Only clones plain objects and arrays. Doesn't clone Date, RegExp, Map, Set,\n// Typed arrays and other non-null objects.\n//\n// Adapted from https://github.com/lukeed/klona\n//\n// The reason for `deepCopyElement()` wrapper is type safety (only allow\n// passing ExcalidrawElement as the top-level argument).\nconst _deepCopyElement = (val: any, depth: number = 0) => {\n  // only clone non-primitives\n  if (val == null || typeof val !== \"object\") {\n    return val;\n  }\n\n  const objectType = Object.prototype.toString.call(val);\n\n  if (objectType === \"[object Object]\") {\n    const tmp =\n      typeof val.constructor === \"function\"\n        ? Object.create(Object.getPrototypeOf(val))\n        : {};\n    for (const key in val) {\n      if (val.hasOwnProperty(key)) {\n        // don't copy non-serializable objects like these caches. They'll be\n        // populated when the element is rendered.\n        if (depth === 0 && (key === \"shape\" || key === \"canvas\")) {\n          continue;\n        }\n        tmp[key] = _deepCopyElement(val[key], depth + 1);\n      }\n    }\n    return tmp;\n  }\n\n  if (Array.isArray(val)) {\n    let k = val.length;\n    const arr = new Array(k);\n    while (k--) {\n      arr[k] = _deepCopyElement(val[k], depth + 1);\n    }\n    return arr;\n  }\n\n  // we're not cloning non-array & non-plain-object objects because we\n  // don't support them on excalidraw elements yet. If we do, we need to make\n  // sure we start cloning them, so let's warn about it.\n  if (process.env.NODE_ENV === \"development\") {\n    if (\n      objectType !== \"[object Object]\" &&\n      objectType !== \"[object Array]\" &&\n      objectType.startsWith(\"[object \")\n    ) {\n      console.warn(\n        `_deepCloneElement: unexpected object type ${objectType}. This value will not be cloned!`,\n      );\n    }\n  }\n\n  return val;\n};\n\n/**\n * Clones ExcalidrawElement data structure. Does not regenerate id, nonce, or\n * any value. The purpose is to to break object references for immutability\n * reasons, whenever we want to keep the original element, but ensure it's not\n * mutated.\n *\n * Only clones plain objects and arrays. Doesn't clone Date, RegExp, Map, Set,\n * Typed arrays and other non-null objects.\n */\nexport const deepCopyElement = <T extends ExcalidrawElement>(\n  val: T,\n): Mutable<T> => {\n  return _deepCopyElement(val);\n};\n\n/**\n * utility wrapper to generate new id. In test env it reuses the old + postfix\n * for test assertions.\n */\nconst regenerateId = (\n  /** supply null if no previous id exists */\n  previousId: string | null,\n) => {\n  if (isTestEnv() && previousId) {\n    let nextId = `${previousId}_copy`;\n    // `window.h` may not be defined in some unit tests\n    if (\n      window.h?.app\n        ?.getSceneElementsIncludingDeleted()\n        .find((el) => el.id === nextId)\n    ) {\n      nextId += \"_copy\";\n    }\n    return nextId;\n  }\n  return randomId();\n};\n\n/**\n * Duplicate an element, often used in the alt-drag operation.\n * Note that this method has gotten a bit complicated since the\n * introduction of gruoping/ungrouping elements.\n * @param editingGroupId The current group being edited. The new\n *                       element will inherit this group and its\n *                       parents.\n * @param groupIdMapForOperation A Map that maps old group IDs to\n *                               duplicated ones. If you are duplicating\n *                               multiple elements at once, share this map\n *                               amongst all of them\n * @param element Element to duplicate\n * @param overrides Any element properties to override\n */\nexport const duplicateElement = <TElement extends ExcalidrawElement>(\n  editingGroupId: AppState[\"editingGroupId\"],\n  groupIdMapForOperation: Map<GroupId, GroupId>,\n  element: TElement,\n  overrides?: Partial<TElement>,\n): Readonly<TElement> => {\n  let copy = deepCopyElement(element);\n\n  copy.id = regenerateId(copy.id);\n  copy.boundElements = null;\n  copy.updated = getUpdatedTimestamp();\n  copy.seed = randomInteger();\n  copy.groupIds = getNewGroupIdsForDuplication(\n    copy.groupIds,\n    editingGroupId,\n    (groupId) => {\n      if (!groupIdMapForOperation.has(groupId)) {\n        groupIdMapForOperation.set(groupId, regenerateId(groupId));\n      }\n      return groupIdMapForOperation.get(groupId)!;\n    },\n  );\n  if (overrides) {\n    copy = Object.assign(copy, overrides);\n  }\n  return copy;\n};\n\n/**\n * Clones elements, regenerating their ids (including bindings) and group ids.\n *\n * If bindings don't exist in the elements array, they are removed. Therefore,\n * it's advised to supply the whole elements array, or sets of elements that\n * are encapsulated (such as library items), if the purpose is to retain\n * bindings to the cloned elements intact.\n *\n * NOTE by default does not randomize or regenerate anything except the id.\n */\nexport const duplicateElements = (\n  elements: readonly ExcalidrawElement[],\n  opts?: {\n    /** NOTE also updates version flags and `updated` */\n    randomizeSeed: boolean;\n  },\n) => {\n  const clonedElements: ExcalidrawElement[] = [];\n\n  const origElementsMap = arrayToMap(elements);\n\n  // used for for migrating old ids to new ids\n  const elementNewIdsMap = new Map<\n    /* orig */ ExcalidrawElement[\"id\"],\n    /* new */ ExcalidrawElement[\"id\"]\n  >();\n\n  const maybeGetNewId = (id: ExcalidrawElement[\"id\"]) => {\n    // if we've already migrated the element id, return the new one directly\n    if (elementNewIdsMap.has(id)) {\n      return elementNewIdsMap.get(id)!;\n    }\n    // if we haven't migrated the element id, but an old element with the same\n    // id exists, generate a new id for it and return it\n    if (origElementsMap.has(id)) {\n      const newId = regenerateId(id);\n      elementNewIdsMap.set(id, newId);\n      return newId;\n    }\n    // if old element doesn't exist, return null to mark it for removal\n    return null;\n  };\n\n  const groupNewIdsMap = new Map</* orig */ GroupId, /* new */ GroupId>();\n\n  for (const element of elements) {\n    const clonedElement: Mutable<ExcalidrawElement> = _deepCopyElement(element);\n\n    clonedElement.id = maybeGetNewId(element.id)!;\n\n    if (opts?.randomizeSeed) {\n      clonedElement.seed = randomInteger();\n      bumpVersion(clonedElement);\n    }\n\n    if (clonedElement.groupIds) {\n      clonedElement.groupIds = clonedElement.groupIds.map((groupId) => {\n        if (!groupNewIdsMap.has(groupId)) {\n          groupNewIdsMap.set(groupId, regenerateId(groupId));\n        }\n        return groupNewIdsMap.get(groupId)!;\n      });\n    }\n\n    if (\"containerId\" in clonedElement && clonedElement.containerId) {\n      const newContainerId = maybeGetNewId(clonedElement.containerId);\n      clonedElement.containerId = newContainerId;\n    }\n\n    if (\"boundElements\" in clonedElement && clonedElement.boundElements) {\n      clonedElement.boundElements = clonedElement.boundElements.reduce(\n        (\n          acc: Mutable<NonNullable<ExcalidrawElement[\"boundElements\"]>>,\n          binding,\n        ) => {\n          const newBindingId = maybeGetNewId(binding.id);\n          if (newBindingId) {\n            acc.push({ ...binding, id: newBindingId });\n          }\n          return acc;\n        },\n        [],\n      );\n    }\n\n    if (\"endBinding\" in clonedElement && clonedElement.endBinding) {\n      const newEndBindingId = maybeGetNewId(clonedElement.endBinding.elementId);\n      clonedElement.endBinding = newEndBindingId\n        ? {\n            ...clonedElement.endBinding,\n            elementId: newEndBindingId,\n          }\n        : null;\n    }\n    if (\"startBinding\" in clonedElement && clonedElement.startBinding) {\n      const newEndBindingId = maybeGetNewId(\n        clonedElement.startBinding.elementId,\n      );\n      clonedElement.startBinding = newEndBindingId\n        ? {\n            ...clonedElement.startBinding,\n            elementId: newEndBindingId,\n          }\n        : null;\n    }\n\n    if (clonedElement.frameId) {\n      clonedElement.frameId = maybeGetNewId(clonedElement.frameId);\n    }\n\n    clonedElements.push(clonedElement);\n  }\n\n  return clonedElements;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}