{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { fill, getFunctionName, getGlobalObject } from '@sentry/utils';\nimport { wrap } from '../helpers';\nvar DEFAULT_EVENT_TARGET = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'];\n/** Wrap timer functions and event targets to catch errors and provide better meta data */\nvar TryCatch = /** @class */function () {\n  /**\n   * @inheritDoc\n   */\n  function TryCatch(options) {\n    /**\n     * @inheritDoc\n     */\n    this.name = TryCatch.id;\n    this._options = __assign({\n      XMLHttpRequest: true,\n      eventTarget: true,\n      requestAnimationFrame: true,\n      setInterval: true,\n      setTimeout: true\n    }, options);\n  }\n  /**\n   * Wrap timer functions and event targets to catch errors\n   * and provide better metadata.\n   */\n  TryCatch.prototype.setupOnce = function () {\n    var global = getGlobalObject();\n    if (this._options.setTimeout) {\n      fill(global, 'setTimeout', this._wrapTimeFunction.bind(this));\n    }\n    if (this._options.setInterval) {\n      fill(global, 'setInterval', this._wrapTimeFunction.bind(this));\n    }\n    if (this._options.requestAnimationFrame) {\n      fill(global, 'requestAnimationFrame', this._wrapRAF.bind(this));\n    }\n    if (this._options.XMLHttpRequest && 'XMLHttpRequest' in global) {\n      fill(XMLHttpRequest.prototype, 'send', this._wrapXHR.bind(this));\n    }\n    if (this._options.eventTarget) {\n      var eventTarget = Array.isArray(this._options.eventTarget) ? this._options.eventTarget : DEFAULT_EVENT_TARGET;\n      eventTarget.forEach(this._wrapEventTarget.bind(this));\n    }\n  };\n  /** JSDoc */\n  TryCatch.prototype._wrapTimeFunction = function (original) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var originalCallback = args[0];\n      args[0] = wrap(originalCallback, {\n        mechanism: {\n          data: {\n            function: getFunctionName(original)\n          },\n          handled: true,\n          type: 'instrument'\n        }\n      });\n      return original.apply(this, args);\n    };\n  };\n  /** JSDoc */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  TryCatch.prototype._wrapRAF = function (original) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function (callback) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return original.call(this, wrap(callback, {\n        mechanism: {\n          data: {\n            function: 'requestAnimationFrame',\n            handler: getFunctionName(original)\n          },\n          handled: true,\n          type: 'instrument'\n        }\n      }));\n    };\n  };\n  /** JSDoc */\n  TryCatch.prototype._wrapEventTarget = function (target) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var global = getGlobalObject();\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    var proto = global[target] && global[target].prototype;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n    fill(proto, 'addEventListener', function (original) {\n      return function (eventName, fn, options) {\n        try {\n          if (typeof fn.handleEvent === 'function') {\n            fn.handleEvent = wrap(fn.handleEvent.bind(fn), {\n              mechanism: {\n                data: {\n                  function: 'handleEvent',\n                  handler: getFunctionName(fn),\n                  target: target\n                },\n                handled: true,\n                type: 'instrument'\n              }\n            });\n          }\n        } catch (err) {\n          // can sometimes get 'Permission denied to access property \"handle Event'\n        }\n        return original.call(this, eventName,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        wrap(fn, {\n          mechanism: {\n            data: {\n              function: 'addEventListener',\n              handler: getFunctionName(fn),\n              target: target\n            },\n            handled: true,\n            type: 'instrument'\n          }\n        }), options);\n      };\n    });\n    fill(proto, 'removeEventListener', function (originalRemoveEventListener) {\n      return function (eventName, fn, options) {\n        var _a;\n        /**\n         * There are 2 possible scenarios here:\n         *\n         * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified\n         * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function\n         * as a pass-through, and call original `removeEventListener` with it.\n         *\n         * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using\n         * our wrapped version of `addEventListener`, which internally calls `wrap` helper.\n         * This helper \"wraps\" whole callback inside a try/catch statement, and attached appropriate metadata to it,\n         * in order for us to make a distinction between wrapped/non-wrapped functions possible.\n         * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.\n         *\n         * When someone adds a handler prior to initialization, and then do it again, but after,\n         * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible\n         * to get rid of the initial handler and it'd stick there forever.\n         */\n        var wrappedEventHandler = fn;\n        try {\n          var originalEventHandler = (_a = wrappedEventHandler) === null || _a === void 0 ? void 0 : _a.__sentry_wrapped__;\n          if (originalEventHandler) {\n            originalRemoveEventListener.call(this, eventName, originalEventHandler, options);\n          }\n        } catch (e) {\n          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n        }\n        return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);\n      };\n    });\n  };\n  /** JSDoc */\n  TryCatch.prototype._wrapXHR = function (originalSend) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      var xhr = this;\n      var xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];\n      xmlHttpRequestProps.forEach(function (prop) {\n        if (prop in xhr && typeof xhr[prop] === 'function') {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fill(xhr, prop, function (original) {\n            var wrapOptions = {\n              mechanism: {\n                data: {\n                  function: prop,\n                  handler: getFunctionName(original)\n                },\n                handled: true,\n                type: 'instrument'\n              }\n            };\n            // If Instrument integration has been called before TryCatch, get the name of original function\n            if (original.__sentry_original__) {\n              wrapOptions.mechanism.data.handler = getFunctionName(original.__sentry_original__);\n            }\n            // Otherwise wrap directly\n            return wrap(original, wrapOptions);\n          });\n        }\n      });\n      return originalSend.apply(this, args);\n    };\n  };\n  /**\n   * @inheritDoc\n   */\n  TryCatch.id = 'TryCatch';\n  return TryCatch;\n}();\nexport { TryCatch };","map":{"version":3,"names":["fill","getFunctionName","getGlobalObject","wrap","DEFAULT_EVENT_TARGET","TryCatch","options","name","id","_options","__assign","XMLHttpRequest","eventTarget","requestAnimationFrame","setInterval","setTimeout","prototype","setupOnce","global","_wrapTimeFunction","bind","_wrapRAF","_wrapXHR","Array","isArray","forEach","_wrapEventTarget","original","args","_i","arguments","length","originalCallback","mechanism","data","function","handled","type","apply","callback","call","handler","target","proto","hasOwnProperty","eventName","fn","handleEvent","err","originalRemoveEventListener","wrappedEventHandler","originalEventHandler","_a","__sentry_wrapped__","e","originalSend","xhr","xmlHttpRequestProps","prop","wrapOptions","__sentry_original__"],"sources":["D:\\project\\excalidraw-cn\\node_modules\\@sentry\\browser\\src\\integrations\\trycatch.ts"],"sourcesContent":["import { Integration, WrappedFunction } from '@sentry/types';\nimport { fill, getFunctionName, getGlobalObject } from '@sentry/utils';\n\nimport { wrap } from '../helpers';\n\nconst DEFAULT_EVENT_TARGET = [\n  'EventTarget',\n  'Window',\n  'Node',\n  'ApplicationCache',\n  'AudioTrackList',\n  'ChannelMergerNode',\n  'CryptoOperation',\n  'EventSource',\n  'FileReader',\n  'HTMLUnknownElement',\n  'IDBDatabase',\n  'IDBRequest',\n  'IDBTransaction',\n  'KeyOperation',\n  'MediaController',\n  'MessagePort',\n  'ModalWindow',\n  'Notification',\n  'SVGElementInstance',\n  'Screen',\n  'TextTrack',\n  'TextTrackCue',\n  'TextTrackList',\n  'WebSocket',\n  'WebSocketWorker',\n  'Worker',\n  'XMLHttpRequest',\n  'XMLHttpRequestEventTarget',\n  'XMLHttpRequestUpload',\n];\n\ntype XMLHttpRequestProp = 'onload' | 'onerror' | 'onprogress' | 'onreadystatechange';\n\n/** JSDoc */\ninterface TryCatchOptions {\n  setTimeout: boolean;\n  setInterval: boolean;\n  requestAnimationFrame: boolean;\n  XMLHttpRequest: boolean;\n  eventTarget: boolean | string[];\n}\n\n/** Wrap timer functions and event targets to catch errors and provide better meta data */\nexport class TryCatch implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'TryCatch';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = TryCatch.id;\n\n  /** JSDoc */\n  private readonly _options: TryCatchOptions;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options?: Partial<TryCatchOptions>) {\n    this._options = {\n      XMLHttpRequest: true,\n      eventTarget: true,\n      requestAnimationFrame: true,\n      setInterval: true,\n      setTimeout: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Wrap timer functions and event targets to catch errors\n   * and provide better metadata.\n   */\n  public setupOnce(): void {\n    const global = getGlobalObject();\n\n    if (this._options.setTimeout) {\n      fill(global, 'setTimeout', this._wrapTimeFunction.bind(this));\n    }\n\n    if (this._options.setInterval) {\n      fill(global, 'setInterval', this._wrapTimeFunction.bind(this));\n    }\n\n    if (this._options.requestAnimationFrame) {\n      fill(global, 'requestAnimationFrame', this._wrapRAF.bind(this));\n    }\n\n    if (this._options.XMLHttpRequest && 'XMLHttpRequest' in global) {\n      fill(XMLHttpRequest.prototype, 'send', this._wrapXHR.bind(this));\n    }\n\n    if (this._options.eventTarget) {\n      const eventTarget = Array.isArray(this._options.eventTarget) ? this._options.eventTarget : DEFAULT_EVENT_TARGET;\n      eventTarget.forEach(this._wrapEventTarget.bind(this));\n    }\n  }\n\n  /** JSDoc */\n  private _wrapTimeFunction(original: () => void): () => number {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function(this: any, ...args: any[]): number {\n      const originalCallback = args[0];\n      args[0] = wrap(originalCallback, {\n        mechanism: {\n          data: { function: getFunctionName(original) },\n          handled: true,\n          type: 'instrument',\n        },\n      });\n      return original.apply(this, args);\n    };\n  }\n\n  /** JSDoc */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _wrapRAF(original: any): (callback: () => void) => any {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function(this: any, callback: () => void): () => void {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return original.call(\n        this,\n        wrap(callback, {\n          mechanism: {\n            data: {\n              function: 'requestAnimationFrame',\n              handler: getFunctionName(original),\n            },\n            handled: true,\n            type: 'instrument',\n          },\n        }),\n      );\n    };\n  }\n\n  /** JSDoc */\n  private _wrapEventTarget(target: string): void {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const global = getGlobalObject() as { [key: string]: any };\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const proto = global[target] && global[target].prototype;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function(\n      original: () => void,\n    ): (eventName: string, fn: EventListenerObject, options?: boolean | AddEventListenerOptions) => void {\n      return function(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this: any,\n        eventName: string,\n        fn: EventListenerObject,\n        options?: boolean | AddEventListenerOptions,\n      ): (eventName: string, fn: EventListenerObject, capture?: boolean, secure?: boolean) => void {\n        try {\n          if (typeof fn.handleEvent === 'function') {\n            fn.handleEvent = wrap(fn.handleEvent.bind(fn), {\n              mechanism: {\n                data: {\n                  function: 'handleEvent',\n                  handler: getFunctionName(fn),\n                  target,\n                },\n                handled: true,\n                type: 'instrument',\n              },\n            });\n          }\n        } catch (err) {\n          // can sometimes get 'Permission denied to access property \"handle Event'\n        }\n\n        return original.call(\n          this,\n          eventName,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          wrap((fn as any) as WrappedFunction, {\n            mechanism: {\n              data: {\n                function: 'addEventListener',\n                handler: getFunctionName(fn),\n                target,\n              },\n              handled: true,\n              type: 'instrument',\n            },\n          }),\n          options,\n        );\n      };\n    });\n\n    fill(proto, 'removeEventListener', function(\n      originalRemoveEventListener: () => void,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): (this: any, eventName: string, fn: EventListenerObject, options?: boolean | EventListenerOptions) => () => void {\n      return function(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this: any,\n        eventName: string,\n        fn: EventListenerObject,\n        options?: boolean | EventListenerOptions,\n      ): () => void {\n        /**\n         * There are 2 possible scenarios here:\n         *\n         * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified\n         * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function\n         * as a pass-through, and call original `removeEventListener` with it.\n         *\n         * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using\n         * our wrapped version of `addEventListener`, which internally calls `wrap` helper.\n         * This helper \"wraps\" whole callback inside a try/catch statement, and attached appropriate metadata to it,\n         * in order for us to make a distinction between wrapped/non-wrapped functions possible.\n         * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.\n         *\n         * When someone adds a handler prior to initialization, and then do it again, but after,\n         * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible\n         * to get rid of the initial handler and it'd stick there forever.\n         */\n        const wrappedEventHandler = (fn as unknown) as WrappedFunction;\n        try {\n          const originalEventHandler = wrappedEventHandler?.__sentry_wrapped__;\n          if (originalEventHandler) {\n            originalRemoveEventListener.call(this, eventName, originalEventHandler, options);\n          }\n        } catch (e) {\n          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n        }\n        return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);\n      };\n    });\n  }\n\n  /** JSDoc */\n  private _wrapXHR(originalSend: () => void): () => void {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function(this: XMLHttpRequest, ...args: any[]): void {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const xhr = this;\n      const xmlHttpRequestProps: XMLHttpRequestProp[] = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];\n\n      xmlHttpRequestProps.forEach(prop => {\n        if (prop in xhr && typeof xhr[prop] === 'function') {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fill(xhr, prop, function(original: WrappedFunction): () => any {\n            const wrapOptions = {\n              mechanism: {\n                data: {\n                  function: prop,\n                  handler: getFunctionName(original),\n                },\n                handled: true,\n                type: 'instrument',\n              },\n            };\n\n            // If Instrument integration has been called before TryCatch, get the name of original function\n            if (original.__sentry_original__) {\n              wrapOptions.mechanism.data.handler = getFunctionName(original.__sentry_original__);\n            }\n\n            // Otherwise wrap directly\n            return wrap(original, wrapOptions);\n          });\n        }\n      });\n\n      return originalSend.apply(this, args);\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}