{"ast":null,"code":"import { mutateElement } from \"./mutateElement\";\nimport { isFreeDrawElement, isLinearElement } from \"./typeChecks\";\nimport { SHIFT_LOCKING_ANGLE } from \"../constants\";\nexport const isInvisiblySmallElement = element => {\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    return element.points.length < 2;\n  }\n  return element.width === 0 && element.height === 0;\n};\n\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\nexport const getPerfectElementSize = (elementType, width, height) => {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n  if (elementType === \"line\" || elementType === \"arrow\" || elementType === \"freedraw\") {\n    const lockedAngle = Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) * SHIFT_LOCKING_ANGLE;\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height = absWidth * Math.tan(lockedAngle) * Math.sign(height) || height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n  return {\n    width,\n    height\n  };\n};\nexport const getLockedLinearCursorAlignSize = (originX, originY, x, y) => {\n  let width = x - originX;\n  let height = y - originY;\n  const lockedAngle = Math.round(Math.atan(height / width) / SHIFT_LOCKING_ANGLE) * SHIFT_LOCKING_ANGLE;\n  if (lockedAngle === 0) {\n    height = 0;\n  } else if (lockedAngle === Math.PI / 2) {\n    width = 0;\n  } else {\n    // locked angle line, y = mx + b => mx - y + b = 0\n    const a1 = Math.tan(lockedAngle);\n    const b1 = -1;\n    const c1 = originY - a1 * originX;\n\n    // line through cursor, perpendicular to locked angle line\n    const a2 = -1 / a1;\n    const b2 = -1;\n    const c2 = y - a2 * x;\n\n    // intersection of the two lines above\n    const intersectX = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n    const intersectY = (c1 * a2 - c2 * a1) / (a1 * b2 - a2 * b1);\n\n    // delta\n    width = intersectX - originX;\n    height = intersectY - originY;\n  }\n  return {\n    width,\n    height\n  };\n};\nexport const resizePerfectLineForNWHandler = (element, x, y) => {\n  const anchorX = element.x + element.width;\n  const anchorY = element.y + element.height;\n  const distanceToAnchorX = x - anchorX;\n  const distanceToAnchorY = y - anchorY;\n  if (Math.abs(distanceToAnchorX) < Math.abs(distanceToAnchorY) / 2) {\n    mutateElement(element, {\n      x: anchorX,\n      width: 0,\n      y,\n      height: -distanceToAnchorY\n    });\n  } else if (Math.abs(distanceToAnchorY) < Math.abs(element.width) / 2) {\n    mutateElement(element, {\n      y: anchorY,\n      height: 0\n    });\n  } else {\n    const nextHeight = Math.sign(distanceToAnchorY) * Math.sign(distanceToAnchorX) * element.width;\n    mutateElement(element, {\n      x,\n      y: anchorY - nextHeight,\n      width: -distanceToAnchorX,\n      height: nextHeight\n    });\n  }\n};\nexport const getNormalizedDimensions = element => {\n  const ret = {\n    width: element.width,\n    height: element.height,\n    x: element.x,\n    y: element.y\n  };\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    ret.width = nextWidth;\n    ret.x = element.x - nextWidth;\n  }\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    ret.height = nextHeight;\n    ret.y = element.y - nextHeight;\n  }\n  return ret;\n};","map":{"version":3,"names":["mutateElement","isFreeDrawElement","isLinearElement","SHIFT_LOCKING_ANGLE","isInvisiblySmallElement","element","points","length","width","height","getPerfectElementSize","elementType","absWidth","Math","abs","absHeight","lockedAngle","round","atan","PI","tan","sign","getLockedLinearCursorAlignSize","originX","originY","x","y","a1","b1","c1","a2","b2","c2","intersectX","intersectY","resizePerfectLineForNWHandler","anchorX","anchorY","distanceToAnchorX","distanceToAnchorY","nextHeight","getNormalizedDimensions","ret","nextWidth"],"sources":["D:/project/excalidraw-cn/src/element/sizeHelpers.ts"],"sourcesContent":["import { ExcalidrawElement } from \"./types\";\nimport { mutateElement } from \"./mutateElement\";\nimport { isFreeDrawElement, isLinearElement } from \"./typeChecks\";\nimport { SHIFT_LOCKING_ANGLE } from \"../constants\";\nimport { AppState } from \"../types\";\n\nexport const isInvisiblySmallElement = (\n  element: ExcalidrawElement,\n): boolean => {\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    return element.points.length < 2;\n  }\n  return element.width === 0 && element.height === 0;\n};\n\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\nexport const getPerfectElementSize = (\n  elementType: AppState[\"activeTool\"][\"type\"],\n  width: number,\n  height: number,\n): { width: number; height: number } => {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n\n  if (\n    elementType === \"line\" ||\n    elementType === \"arrow\" ||\n    elementType === \"freedraw\"\n  ) {\n    const lockedAngle =\n      Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE;\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height = absWidth * Math.tan(lockedAngle) * Math.sign(height) || height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n  return { width, height };\n};\n\nexport const getLockedLinearCursorAlignSize = (\n  originX: number,\n  originY: number,\n  x: number,\n  y: number,\n) => {\n  let width = x - originX;\n  let height = y - originY;\n\n  const lockedAngle =\n    Math.round(Math.atan(height / width) / SHIFT_LOCKING_ANGLE) *\n    SHIFT_LOCKING_ANGLE;\n\n  if (lockedAngle === 0) {\n    height = 0;\n  } else if (lockedAngle === Math.PI / 2) {\n    width = 0;\n  } else {\n    // locked angle line, y = mx + b => mx - y + b = 0\n    const a1 = Math.tan(lockedAngle);\n    const b1 = -1;\n    const c1 = originY - a1 * originX;\n\n    // line through cursor, perpendicular to locked angle line\n    const a2 = -1 / a1;\n    const b2 = -1;\n    const c2 = y - a2 * x;\n\n    // intersection of the two lines above\n    const intersectX = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n    const intersectY = (c1 * a2 - c2 * a1) / (a1 * b2 - a2 * b1);\n\n    // delta\n    width = intersectX - originX;\n    height = intersectY - originY;\n  }\n\n  return { width, height };\n};\n\nexport const resizePerfectLineForNWHandler = (\n  element: ExcalidrawElement,\n  x: number,\n  y: number,\n) => {\n  const anchorX = element.x + element.width;\n  const anchorY = element.y + element.height;\n  const distanceToAnchorX = x - anchorX;\n  const distanceToAnchorY = y - anchorY;\n  if (Math.abs(distanceToAnchorX) < Math.abs(distanceToAnchorY) / 2) {\n    mutateElement(element, {\n      x: anchorX,\n      width: 0,\n      y,\n      height: -distanceToAnchorY,\n    });\n  } else if (Math.abs(distanceToAnchorY) < Math.abs(element.width) / 2) {\n    mutateElement(element, {\n      y: anchorY,\n      height: 0,\n    });\n  } else {\n    const nextHeight =\n      Math.sign(distanceToAnchorY) *\n      Math.sign(distanceToAnchorX) *\n      element.width;\n    mutateElement(element, {\n      x,\n      y: anchorY - nextHeight,\n      width: -distanceToAnchorX,\n      height: nextHeight,\n    });\n  }\n};\n\nexport const getNormalizedDimensions = (\n  element: Pick<ExcalidrawElement, \"width\" | \"height\" | \"x\" | \"y\">,\n): {\n  width: ExcalidrawElement[\"width\"];\n  height: ExcalidrawElement[\"height\"];\n  x: ExcalidrawElement[\"x\"];\n  y: ExcalidrawElement[\"y\"];\n} => {\n  const ret = {\n    width: element.width,\n    height: element.height,\n    x: element.x,\n    y: element.y,\n  };\n\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    ret.width = nextWidth;\n    ret.x = element.x - nextWidth;\n  }\n\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    ret.height = nextHeight;\n    ret.y = element.y - nextHeight;\n  }\n\n  return ret;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}