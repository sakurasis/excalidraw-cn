{"ast":null,"code":"import _toConsumableArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _createForOfIteratorHelper from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import _objectSpread from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _slicedToArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import _classCallCheck from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createClass.js\";import{distance2d,rotate,isPathALoop,getGridPoint,rotatePoint,centerPoint,getControlPointsForBezierCurve,getBezierXY,getBezierCurveLength,mapIntervalToBezierT,arePointsEqual as _arePointsEqual}from\"../math\";import{getElementAbsoluteCoords,getLockedLinearCursorAlignSize}from\".\";import{getCurvePathOps,getElementPointsCoords,getMinMaxXYFromCurvePathOps}from\"./bounds\";import{mutateElement}from\"./mutateElement\";import Scene from\"../scene/Scene\";import{bindOrUnbindLinearElement,getHoveredElementForBinding,isBindingEnabled}from\"./binding\";import{tupleToCoors}from\"../utils\";import{isBindingElement}from\"./typeChecks\";import{shouldRotateWithDiscreteAngle}from\"../keys\";import{getBoundTextElement,handleBindTextResize}from\"./textElement\";import{getShapeForElement}from\"../renderer/renderElement\";import{DRAGGING_THRESHOLD}from\"../constants\";var editorMidPointsCache={version:null,points:[],zoom:null};export var LinearElementEditor=/*#__PURE__*/function(){function LinearElementEditor(element,scene){_classCallCheck(this,LinearElementEditor);this.elementId=void 0;/** indices */this.selectedPointsIndices=void 0;this.pointerDownState=void 0;/** whether you're dragging a point */this.isDragging=void 0;this.lastUncommittedPoint=void 0;this.pointerOffset=void 0;this.startBindingElement=void 0;this.endBindingElement=void 0;this.hoverPointIndex=void 0;this.segmentMidPointHoveredCoords=void 0;this.elementId=element.id;Scene.mapElementToScene(this.elementId,scene);LinearElementEditor.normalizePoints(element);this.selectedPointsIndices=null;this.lastUncommittedPoint=null;this.isDragging=false;this.pointerOffset={x:0,y:0};this.startBindingElement=\"keep\";this.endBindingElement=\"keep\";this.pointerDownState={prevSelectedPointsIndices:null,lastClickedPoint:-1,origin:null,segmentMidpoint:{value:null,index:null,added:false}};this.hoverPointIndex=-1;this.segmentMidPointHoveredCoords=null;}// ---------------------------------------------------------------------------\n// static methods\n// ---------------------------------------------------------------------------\n_createClass(LinearElementEditor,null,[{key:\"getElement\",value:/**\n   * @param id the `elementId` from the instance of this class (so that we can\n   *  statically guarantee this method returns an ExcalidrawLinearElement)\n   */function getElement(id){var _Scene$getScene;var element=(_Scene$getScene=Scene.getScene(id))===null||_Scene$getScene===void 0?void 0:_Scene$getScene.getNonDeletedElement(id);if(element){return element;}return null;}},{key:\"handleBoxSelection\",value:function handleBoxSelection(event,appState,setState){var _appState$draggingEle;if(!appState.editingLinearElement||((_appState$draggingEle=appState.draggingElement)===null||_appState$draggingEle===void 0?void 0:_appState$draggingEle.type)!==\"selection\"){return false;}var editingLinearElement=appState.editingLinearElement;var selectedPointsIndices=editingLinearElement.selectedPointsIndices,elementId=editingLinearElement.elementId;var element=LinearElementEditor.getElement(elementId);if(!element){return false;}var _getElementAbsoluteCo=getElementAbsoluteCoords(appState.draggingElement),_getElementAbsoluteCo2=_slicedToArray(_getElementAbsoluteCo,4),selectionX1=_getElementAbsoluteCo2[0],selectionY1=_getElementAbsoluteCo2[1],selectionX2=_getElementAbsoluteCo2[2],selectionY2=_getElementAbsoluteCo2[3];var pointsSceneCoords=LinearElementEditor.getPointsGlobalCoordinates(element);var nextSelectedPoints=pointsSceneCoords.reduce(function(acc,point,index){if(point[0]>=selectionX1&&point[0]<=selectionX2&&point[1]>=selectionY1&&point[1]<=selectionY2||event.shiftKey&&selectedPointsIndices!==null&&selectedPointsIndices!==void 0&&selectedPointsIndices.includes(index)){acc.push(index);}return acc;},[]);setState({editingLinearElement:_objectSpread(_objectSpread({},editingLinearElement),{},{selectedPointsIndices:nextSelectedPoints.length?nextSelectedPoints:null})});}/** @returns whether point was dragged */},{key:\"handlePointDragging\",value:function handlePointDragging(event,appState,scenePointerX,scenePointerY,maybeSuggestBinding,linearElementEditor){if(!linearElementEditor){return false;}var selectedPointsIndices=linearElementEditor.selectedPointsIndices,elementId=linearElementEditor.elementId;var element=LinearElementEditor.getElement(elementId);if(!element){return false;}// point that's being dragged (out of all selected points)\nvar draggingPoint=element.points[linearElementEditor.pointerDownState.lastClickedPoint];if(selectedPointsIndices&&draggingPoint){if(shouldRotateWithDiscreteAngle(event)&&selectedPointsIndices.length===1&&element.points.length>1){var selectedIndex=selectedPointsIndices[0];var referencePoint=element.points[selectedIndex===0?1:selectedIndex-1];var _LinearElementEditor$=LinearElementEditor._getShiftLockedDelta(element,referencePoint,[scenePointerX,scenePointerY],appState.gridSize),_LinearElementEditor$2=_slicedToArray(_LinearElementEditor$,2),width=_LinearElementEditor$2[0],height=_LinearElementEditor$2[1];LinearElementEditor.movePoints(element,[{index:selectedIndex,point:[width+referencePoint[0],height+referencePoint[1]],isDragging:selectedIndex===linearElementEditor.pointerDownState.lastClickedPoint}]);}else{var newDraggingPointPosition=LinearElementEditor.createPointAt(element,scenePointerX-linearElementEditor.pointerOffset.x,scenePointerY-linearElementEditor.pointerOffset.y,appState.gridSize);var deltaX=newDraggingPointPosition[0]-draggingPoint[0];var deltaY=newDraggingPointPosition[1]-draggingPoint[1];LinearElementEditor.movePoints(element,selectedPointsIndices.map(function(pointIndex){var newPointPosition=pointIndex===linearElementEditor.pointerDownState.lastClickedPoint?LinearElementEditor.createPointAt(element,scenePointerX-linearElementEditor.pointerOffset.x,scenePointerY-linearElementEditor.pointerOffset.y,appState.gridSize):[element.points[pointIndex][0]+deltaX,element.points[pointIndex][1]+deltaY];return{index:pointIndex,point:newPointPosition,isDragging:pointIndex===linearElementEditor.pointerDownState.lastClickedPoint};}));var boundTextElement=getBoundTextElement(element);if(boundTextElement){handleBindTextResize(element,false);}}// suggest bindings for first and last point if selected\nif(isBindingElement(element,false)){var coords=[];var firstSelectedIndex=selectedPointsIndices[0];if(firstSelectedIndex===0){coords.push(tupleToCoors(LinearElementEditor.getPointGlobalCoordinates(element,element.points[0])));}var lastSelectedIndex=selectedPointsIndices[selectedPointsIndices.length-1];if(lastSelectedIndex===element.points.length-1){coords.push(tupleToCoors(LinearElementEditor.getPointGlobalCoordinates(element,element.points[lastSelectedIndex])));}if(coords.length){maybeSuggestBinding(element,coords);}}return true;}return false;}},{key:\"handlePointerUp\",value:function handlePointerUp(event,editingLinearElement,appState){var _pointerDownState$pre;var elementId=editingLinearElement.elementId,selectedPointsIndices=editingLinearElement.selectedPointsIndices,isDragging=editingLinearElement.isDragging,pointerDownState=editingLinearElement.pointerDownState;var element=LinearElementEditor.getElement(elementId);if(!element){return editingLinearElement;}var bindings={};if(isDragging&&selectedPointsIndices){var _iterator=_createForOfIteratorHelper(selectedPointsIndices),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var selectedPoint=_step.value;if(selectedPoint===0||selectedPoint===element.points.length-1){if(isPathALoop(element.points,appState.zoom.value)){LinearElementEditor.movePoints(element,[{index:selectedPoint,point:selectedPoint===0?element.points[element.points.length-1]:element.points[0]}]);}var bindingElement=isBindingEnabled(appState)?getHoveredElementForBinding(tupleToCoors(LinearElementEditor.getPointAtIndexGlobalCoordinates(element,selectedPoint)),Scene.getScene(element)):null;bindings[selectedPoint===0?\"startBindingElement\":\"endBindingElement\"]=bindingElement;}}}catch(err){_iterator.e(err);}finally{_iterator.f();}}return _objectSpread(_objectSpread(_objectSpread({},editingLinearElement),bindings),{},{// if clicking without previously dragging a point(s), and not holding\n// shift, deselect all points except the one clicked. If holding shift,\n// toggle the point.\nselectedPointsIndices:isDragging||event.shiftKey?!isDragging&&event.shiftKey&&(_pointerDownState$pre=pointerDownState.prevSelectedPointsIndices)!==null&&_pointerDownState$pre!==void 0&&_pointerDownState$pre.includes(pointerDownState.lastClickedPoint)?selectedPointsIndices&&selectedPointsIndices.filter(function(pointIndex){return pointIndex!==pointerDownState.lastClickedPoint;}):selectedPointsIndices:selectedPointsIndices!==null&&selectedPointsIndices!==void 0&&selectedPointsIndices.includes(pointerDownState.lastClickedPoint)?[pointerDownState.lastClickedPoint]:selectedPointsIndices,isDragging:false,pointerOffset:{x:0,y:0}});}},{key:\"isSegmentTooShort\",value:function isSegmentTooShort(element,startPoint,endPoint,zoom){var distance=distance2d(startPoint[0],startPoint[1],endPoint[0],endPoint[1]);if(element.points.length>2&&element.roundness){distance=getBezierCurveLength(element,endPoint);}return distance*zoom.value<LinearElementEditor.POINT_HANDLE_SIZE*4;}},{key:\"getSegmentMidPoint\",value:function getSegmentMidPoint(element,startPoint,endPoint,endPointIndex){var segmentMidPoint=centerPoint(startPoint,endPoint);if(element.points.length>2&&element.roundness){var controlPoints=getControlPointsForBezierCurve(element,element.points[endPointIndex]);if(controlPoints){var t=mapIntervalToBezierT(element,element.points[endPointIndex],0.5);var _getBezierXY=getBezierXY(controlPoints[0],controlPoints[1],controlPoints[2],controlPoints[3],t),_getBezierXY2=_slicedToArray(_getBezierXY,2),tx=_getBezierXY2[0],ty=_getBezierXY2[1];segmentMidPoint=LinearElementEditor.getPointGlobalCoordinates(element,[tx,ty]);}}return segmentMidPoint;}},{key:\"getSegmentMidPointIndex\",value:function getSegmentMidPointIndex(linearElementEditor,appState,midPoint){var element=LinearElementEditor.getElement(linearElementEditor.elementId);if(!element){return-1;}var midPoints=LinearElementEditor.getEditorMidPoints(element,appState);var index=0;while(index<midPoints.length){if(LinearElementEditor.arePointsEqual(midPoint,midPoints[index])){return index+1;}index++;}return-1;}},{key:\"handlePointerDown\",value:function handlePointerDown(event,appState,history,scenePointer,linearElementEditor){var _linearElementEditor$;var ret={didAddPoint:false,hitElement:null,linearElementEditor:null};if(!linearElementEditor){return ret;}var elementId=linearElementEditor.elementId;var element=LinearElementEditor.getElement(elementId);if(!element){return ret;}var segmentMidpoint=LinearElementEditor.getSegmentMidpointHitCoords(linearElementEditor,scenePointer,appState);var segmentMidpointIndex=null;if(segmentMidpoint){segmentMidpointIndex=LinearElementEditor.getSegmentMidPointIndex(linearElementEditor,appState,segmentMidpoint);}if(event.altKey&&appState.editingLinearElement){if(linearElementEditor.lastUncommittedPoint==null){mutateElement(element,{points:[].concat(_toConsumableArray(element.points),[LinearElementEditor.createPointAt(element,scenePointer.x,scenePointer.y,appState.gridSize)])});ret.didAddPoint=true;}history.resumeRecording();ret.linearElementEditor=_objectSpread(_objectSpread({},linearElementEditor),{},{pointerDownState:{prevSelectedPointsIndices:linearElementEditor.selectedPointsIndices,lastClickedPoint:-1,origin:{x:scenePointer.x,y:scenePointer.y},segmentMidpoint:{value:segmentMidpoint,index:segmentMidpointIndex,added:false}},selectedPointsIndices:[element.points.length-1],lastUncommittedPoint:null,endBindingElement:getHoveredElementForBinding(scenePointer,Scene.getScene(element))});ret.didAddPoint=true;return ret;}var clickedPointIndex=LinearElementEditor.getPointIndexUnderCursor(element,appState.zoom,scenePointer.x,scenePointer.y);// if we clicked on a point, set the element as hitElement otherwise\n// it would get deselected if the point is outside the hitbox area\nif(clickedPointIndex>=0||segmentMidpoint){ret.hitElement=element;}else{// You might be wandering why we are storing the binding elements on\n// LinearElementEditor and passing them in, instead of calculating them\n// from the end points of the `linearElement` - this is to allow disabling\n// binding (which needs to happen at the point the user finishes moving\n// the point).\nvar startBindingElement=linearElementEditor.startBindingElement,endBindingElement=linearElementEditor.endBindingElement;if(isBindingEnabled(appState)&&isBindingElement(element)){bindOrUnbindLinearElement(element,startBindingElement,endBindingElement);}}var _getElementAbsoluteCo3=getElementAbsoluteCoords(element),_getElementAbsoluteCo4=_slicedToArray(_getElementAbsoluteCo3,4),x1=_getElementAbsoluteCo4[0],y1=_getElementAbsoluteCo4[1],x2=_getElementAbsoluteCo4[2],y2=_getElementAbsoluteCo4[3];var cx=(x1+x2)/2;var cy=(y1+y2)/2;var targetPoint=clickedPointIndex>-1&&rotate(element.x+element.points[clickedPointIndex][0],element.y+element.points[clickedPointIndex][1],cx,cy,element.angle);var nextSelectedPointsIndices=clickedPointIndex>-1||event.shiftKey?event.shiftKey||(_linearElementEditor$=linearElementEditor.selectedPointsIndices)!==null&&_linearElementEditor$!==void 0&&_linearElementEditor$.includes(clickedPointIndex)?normalizeSelectedPoints([].concat(_toConsumableArray(linearElementEditor.selectedPointsIndices||[]),[clickedPointIndex])):[clickedPointIndex]:null;ret.linearElementEditor=_objectSpread(_objectSpread({},linearElementEditor),{},{pointerDownState:{prevSelectedPointsIndices:linearElementEditor.selectedPointsIndices,lastClickedPoint:clickedPointIndex,origin:{x:scenePointer.x,y:scenePointer.y},segmentMidpoint:{value:segmentMidpoint,index:segmentMidpointIndex,added:false}},selectedPointsIndices:nextSelectedPointsIndices,pointerOffset:targetPoint?{x:scenePointer.x-targetPoint[0],y:scenePointer.y-targetPoint[1]}:{x:0,y:0}});return ret;}},{key:\"arePointsEqual\",value:function arePointsEqual(point1,point2){if(!point1&&!point2){return true;}if(!point1||!point2){return false;}return _arePointsEqual(point1,point2);}},{key:\"handlePointerMove\",value:function handlePointerMove(event,scenePointerX,scenePointerY,appState){if(!appState.editingLinearElement){return null;}var _appState$editingLine=appState.editingLinearElement,elementId=_appState$editingLine.elementId,lastUncommittedPoint=_appState$editingLine.lastUncommittedPoint;var element=LinearElementEditor.getElement(elementId);if(!element){return appState.editingLinearElement;}var points=element.points;var lastPoint=points[points.length-1];if(!event.altKey){if(lastPoint===lastUncommittedPoint){LinearElementEditor.deletePoints(element,[points.length-1]);}return _objectSpread(_objectSpread({},appState.editingLinearElement),{},{lastUncommittedPoint:null});}var newPoint;if(shouldRotateWithDiscreteAngle(event)&&points.length>=2){var lastCommittedPoint=points[points.length-2];var _LinearElementEditor$3=LinearElementEditor._getShiftLockedDelta(element,lastCommittedPoint,[scenePointerX,scenePointerY],appState.gridSize),_LinearElementEditor$4=_slicedToArray(_LinearElementEditor$3,2),width=_LinearElementEditor$4[0],height=_LinearElementEditor$4[1];newPoint=[width+lastCommittedPoint[0],height+lastCommittedPoint[1]];}else{newPoint=LinearElementEditor.createPointAt(element,scenePointerX-appState.editingLinearElement.pointerOffset.x,scenePointerY-appState.editingLinearElement.pointerOffset.y,appState.gridSize);}if(lastPoint===lastUncommittedPoint){LinearElementEditor.movePoints(element,[{index:element.points.length-1,point:newPoint}]);}else{LinearElementEditor.addPoints(element,appState,[{point:newPoint}]);}return _objectSpread(_objectSpread({},appState.editingLinearElement),{},{lastUncommittedPoint:element.points[element.points.length-1]});}/** scene coords */},{key:\"getPointGlobalCoordinates\",value:function getPointGlobalCoordinates(element,point){var _getElementAbsoluteCo5=getElementAbsoluteCoords(element),_getElementAbsoluteCo6=_slicedToArray(_getElementAbsoluteCo5,4),x1=_getElementAbsoluteCo6[0],y1=_getElementAbsoluteCo6[1],x2=_getElementAbsoluteCo6[2],y2=_getElementAbsoluteCo6[3];var cx=(x1+x2)/2;var cy=(y1+y2)/2;var x=element.x,y=element.y;var _rotate=rotate(x+point[0],y+point[1],cx,cy,element.angle);var _rotate2=_slicedToArray(_rotate,2);x=_rotate2[0];y=_rotate2[1];return[x,y];}/** scene coords */},{key:\"getPointsGlobalCoordinates\",value:function getPointsGlobalCoordinates(element){var _getElementAbsoluteCo7=getElementAbsoluteCoords(element),_getElementAbsoluteCo8=_slicedToArray(_getElementAbsoluteCo7,4),x1=_getElementAbsoluteCo8[0],y1=_getElementAbsoluteCo8[1],x2=_getElementAbsoluteCo8[2],y2=_getElementAbsoluteCo8[3];var cx=(x1+x2)/2;var cy=(y1+y2)/2;return element.points.map(function(point){var x=element.x,y=element.y;var _rotate3=rotate(x+point[0],y+point[1],cx,cy,element.angle);var _rotate4=_slicedToArray(_rotate3,2);x=_rotate4[0];y=_rotate4[1];return[x,y];});}},{key:\"getPointAtIndexGlobalCoordinates\",value:function getPointAtIndexGlobalCoordinates(element,indexMaybeFromEnd// -1 for last element\n){var index=indexMaybeFromEnd<0?element.points.length+indexMaybeFromEnd:indexMaybeFromEnd;var _getElementAbsoluteCo9=getElementAbsoluteCoords(element),_getElementAbsoluteCo10=_slicedToArray(_getElementAbsoluteCo9,4),x1=_getElementAbsoluteCo10[0],y1=_getElementAbsoluteCo10[1],x2=_getElementAbsoluteCo10[2],y2=_getElementAbsoluteCo10[3];var cx=(x1+x2)/2;var cy=(y1+y2)/2;var point=element.points[index];var x=element.x,y=element.y;return point?rotate(x+point[0],y+point[1],cx,cy,element.angle):rotate(x,y,cx,cy,element.angle);}},{key:\"pointFromAbsoluteCoords\",value:function pointFromAbsoluteCoords(element,absoluteCoords){var _getElementAbsoluteCo11=getElementAbsoluteCoords(element),_getElementAbsoluteCo12=_slicedToArray(_getElementAbsoluteCo11,4),x1=_getElementAbsoluteCo12[0],y1=_getElementAbsoluteCo12[1],x2=_getElementAbsoluteCo12[2],y2=_getElementAbsoluteCo12[3];var cx=(x1+x2)/2;var cy=(y1+y2)/2;var _rotate5=rotate(absoluteCoords[0],absoluteCoords[1],cx,cy,-element.angle),_rotate6=_slicedToArray(_rotate5,2),x=_rotate6[0],y=_rotate6[1];return[x-element.x,y-element.y];}},{key:\"getPointIndexUnderCursor\",value:function getPointIndexUnderCursor(element,zoom,x,y){var pointHandles=LinearElementEditor.getPointsGlobalCoordinates(element);var idx=pointHandles.length;// loop from right to left because points on the right are rendered over\n// points on the left, thus should take precedence when clicking, if they\n// overlap\nwhile(--idx>-1){var point=pointHandles[idx];if(distance2d(x,y,point[0],point[1])*zoom.value<// +1px to account for outline stroke\nLinearElementEditor.POINT_HANDLE_SIZE+1){return idx;}}return-1;}},{key:\"createPointAt\",value:function createPointAt(element,scenePointerX,scenePointerY,gridSize){var pointerOnGrid=getGridPoint(scenePointerX,scenePointerY,gridSize);var _getElementAbsoluteCo13=getElementAbsoluteCoords(element),_getElementAbsoluteCo14=_slicedToArray(_getElementAbsoluteCo13,4),x1=_getElementAbsoluteCo14[0],y1=_getElementAbsoluteCo14[1],x2=_getElementAbsoluteCo14[2],y2=_getElementAbsoluteCo14[3];var cx=(x1+x2)/2;var cy=(y1+y2)/2;var _rotate7=rotate(pointerOnGrid[0],pointerOnGrid[1],cx,cy,-element.angle),_rotate8=_slicedToArray(_rotate7,2),rotatedX=_rotate8[0],rotatedY=_rotate8[1];return[rotatedX-element.x,rotatedY-element.y];}/**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   * expected in various parts of the codebase. Also returns new x/y to account\n   * for the potential normalization.\n   */},{key:\"getNormalizedPoints\",value:function getNormalizedPoints(element){var points=element.points;var offsetX=points[0][0];var offsetY=points[0][1];return{points:points.map(function(point,_idx){return[point[0]-offsetX,point[1]-offsetY];}),x:element.x+offsetX,y:element.y+offsetY};}// element-mutating methods\n// ---------------------------------------------------------------------------\n},{key:\"normalizePoints\",value:function normalizePoints(element){mutateElement(element,LinearElementEditor.getNormalizedPoints(element));}},{key:\"duplicateSelectedPoints\",value:function duplicateSelectedPoints(appState){if(!appState.editingLinearElement){return false;}var _appState$editingLine2=appState.editingLinearElement,selectedPointsIndices=_appState$editingLine2.selectedPointsIndices,elementId=_appState$editingLine2.elementId;var element=LinearElementEditor.getElement(elementId);if(!element||selectedPointsIndices===null){return false;}var points=element.points;var nextSelectedIndices=[];var pointAddedToEnd=false;var indexCursor=-1;var nextPoints=points.reduce(function(acc,point,index){++indexCursor;acc.push(point);var isSelected=selectedPointsIndices.includes(index);if(isSelected){var nextPoint=points[index+1];if(!nextPoint){pointAddedToEnd=true;}acc.push(nextPoint?[(point[0]+nextPoint[0])/2,(point[1]+nextPoint[1])/2]:[point[0],point[1]]);nextSelectedIndices.push(indexCursor+1);++indexCursor;}return acc;},[]);mutateElement(element,{points:nextPoints});// temp hack to ensure the line doesn't move when adding point to the end,\n// potentially expanding the bounding box\nif(pointAddedToEnd){var lastPoint=element.points[element.points.length-1];LinearElementEditor.movePoints(element,[{index:element.points.length-1,point:[lastPoint[0]+30,lastPoint[1]+30]}]);}return{appState:_objectSpread(_objectSpread({},appState),{},{editingLinearElement:_objectSpread(_objectSpread({},appState.editingLinearElement),{},{selectedPointsIndices:nextSelectedIndices})})};}},{key:\"deletePoints\",value:function deletePoints(element,pointIndices){var offsetX=0;var offsetY=0;var isDeletingOriginPoint=pointIndices.includes(0);// if deleting first point, make the next to be [0,0] and recalculate\n// positions of the rest with respect to it\nif(isDeletingOriginPoint){var firstNonDeletedPoint=element.points.find(function(point,idx){return!pointIndices.includes(idx);});if(firstNonDeletedPoint){offsetX=firstNonDeletedPoint[0];offsetY=firstNonDeletedPoint[1];}}var nextPoints=element.points.reduce(function(acc,point,idx){if(!pointIndices.includes(idx)){acc.push(!acc.length?[0,0]:[point[0]-offsetX,point[1]-offsetY]);}return acc;},[]);LinearElementEditor._updatePoints(element,nextPoints,offsetX,offsetY);}},{key:\"addPoints\",value:function addPoints(element,appState,targetPoints){var offsetX=0;var offsetY=0;var nextPoints=[].concat(_toConsumableArray(element.points),_toConsumableArray(targetPoints.map(function(x){return x.point;})));LinearElementEditor._updatePoints(element,nextPoints,offsetX,offsetY);}},{key:\"movePoints\",value:function movePoints(element,targetPoints,otherUpdates){var points=element.points;// in case we're moving start point, instead of modifying its position\n// which would break the invariant of it being at [0,0], we move\n// all the other points in the opposite direction by delta to\n// offset it. We do the same with actual element.x/y position, so\n// this hacks are completely transparent to the user.\nvar offsetX=0;var offsetY=0;var selectedOriginPoint=targetPoints.find(function(_ref){var index=_ref.index;return index===0;});if(selectedOriginPoint){offsetX=selectedOriginPoint.point[0]+points[selectedOriginPoint.index][0];offsetY=selectedOriginPoint.point[1]+points[selectedOriginPoint.index][1];}var nextPoints=points.map(function(point,idx){var selectedPointData=targetPoints.find(function(p){return p.index===idx;});if(selectedPointData){if(selectedOriginPoint){return point;}var deltaX=selectedPointData.point[0]-points[selectedPointData.index][0];var deltaY=selectedPointData.point[1]-points[selectedPointData.index][1];return[point[0]+deltaX,point[1]+deltaY];}return offsetX||offsetY?[point[0]-offsetX,point[1]-offsetY]:point;});LinearElementEditor._updatePoints(element,nextPoints,offsetX,offsetY,otherUpdates);}},{key:\"shouldAddMidpoint\",value:function shouldAddMidpoint(linearElementEditor,pointerCoords,appState){var element=LinearElementEditor.getElement(linearElementEditor.elementId);if(!element){return false;}var segmentMidpoint=linearElementEditor.pointerDownState.segmentMidpoint;if(segmentMidpoint.added||segmentMidpoint.value===null||segmentMidpoint.index===null||linearElementEditor.pointerDownState.origin===null){return false;}var origin=linearElementEditor.pointerDownState.origin;var dist=distance2d(origin.x,origin.y,pointerCoords.x,pointerCoords.y);if(!appState.editingLinearElement&&dist<DRAGGING_THRESHOLD/appState.zoom.value){return false;}return true;}},{key:\"addMidpoint\",value:function addMidpoint(linearElementEditor,pointerCoords,appState){var element=LinearElementEditor.getElement(linearElementEditor.elementId);if(!element){return;}var segmentMidpoint=linearElementEditor.pointerDownState.segmentMidpoint;var ret={pointerDownState:linearElementEditor.pointerDownState,selectedPointsIndices:linearElementEditor.selectedPointsIndices};var midpoint=LinearElementEditor.createPointAt(element,pointerCoords.x,pointerCoords.y,appState.gridSize);var points=[].concat(_toConsumableArray(element.points.slice(0,segmentMidpoint.index)),[midpoint],_toConsumableArray(element.points.slice(segmentMidpoint.index)));mutateElement(element,{points:points});ret.pointerDownState=_objectSpread(_objectSpread({},linearElementEditor.pointerDownState),{},{segmentMidpoint:_objectSpread(_objectSpread({},linearElementEditor.pointerDownState.segmentMidpoint),{},{added:true}),lastClickedPoint:segmentMidpoint.index});ret.selectedPointsIndices=[segmentMidpoint.index];return ret;}},{key:\"_updatePoints\",value:function _updatePoints(element,nextPoints,offsetX,offsetY,otherUpdates){var nextCoords=getElementPointsCoords(element,nextPoints);var prevCoords=getElementPointsCoords(element,element.points);var nextCenterX=(nextCoords[0]+nextCoords[2])/2;var nextCenterY=(nextCoords[1]+nextCoords[3])/2;var prevCenterX=(prevCoords[0]+prevCoords[2])/2;var prevCenterY=(prevCoords[1]+prevCoords[3])/2;var dX=prevCenterX-nextCenterX;var dY=prevCenterY-nextCenterY;var rotated=rotate(offsetX,offsetY,dX,dY,element.angle);mutateElement(element,_objectSpread(_objectSpread({},otherUpdates),{},{points:nextPoints,x:element.x+rotated[0],y:element.y+rotated[1]}));}},{key:\"_getShiftLockedDelta\",value:function _getShiftLockedDelta(element,referencePoint,scenePointer,gridSize){var referencePointCoords=LinearElementEditor.getPointGlobalCoordinates(element,referencePoint);var _getGridPoint=getGridPoint(scenePointer[0],scenePointer[1],gridSize),_getGridPoint2=_slicedToArray(_getGridPoint,2),gridX=_getGridPoint2[0],gridY=_getGridPoint2[1];var _getLockedLinearCurso=getLockedLinearCursorAlignSize(referencePointCoords[0],referencePointCoords[1],gridX,gridY),width=_getLockedLinearCurso.width,height=_getLockedLinearCurso.height;return rotatePoint([width,height],[0,0],-element.angle);}}]);return LinearElementEditor;}();LinearElementEditor.POINT_HANDLE_SIZE=10;LinearElementEditor.getEditorMidPoints=function(element,appState){var boundText=getBoundTextElement(element);// Since its not needed outside editor unless 2 pointer lines or bound text\nif(!appState.editingLinearElement&&element.points.length>2&&!boundText){return[];}if(editorMidPointsCache.version===element.version&&editorMidPointsCache.zoom===appState.zoom.value){return editorMidPointsCache.points;}LinearElementEditor.updateEditorMidPointsCache(element,appState);return editorMidPointsCache.points;};LinearElementEditor.updateEditorMidPointsCache=function(element,appState){var points=LinearElementEditor.getPointsGlobalCoordinates(element);var index=0;var midpoints=[];while(index<points.length-1){if(LinearElementEditor.isSegmentTooShort(element,element.points[index],element.points[index+1],appState.zoom)){midpoints.push(null);index++;continue;}var segmentMidPoint=LinearElementEditor.getSegmentMidPoint(element,points[index],points[index+1],index+1);midpoints.push(segmentMidPoint);index++;}editorMidPointsCache.points=midpoints;editorMidPointsCache.version=element.version;editorMidPointsCache.zoom=appState.zoom.value;};LinearElementEditor.getSegmentMidpointHitCoords=function(linearElementEditor,scenePointer,appState){var elementId=linearElementEditor.elementId;var element=LinearElementEditor.getElement(elementId);if(!element){return null;}var clickedPointIndex=LinearElementEditor.getPointIndexUnderCursor(element,appState.zoom,scenePointer.x,scenePointer.y);if(clickedPointIndex>=0){return null;}var points=LinearElementEditor.getPointsGlobalCoordinates(element);if(points.length>=3&&!appState.editingLinearElement){return null;}var threshold=LinearElementEditor.POINT_HANDLE_SIZE/appState.zoom.value;var existingSegmentMidpointHitCoords=linearElementEditor.segmentMidPointHoveredCoords;if(existingSegmentMidpointHitCoords){var distance=distance2d(existingSegmentMidpointHitCoords[0],existingSegmentMidpointHitCoords[1],scenePointer.x,scenePointer.y);if(distance<=threshold){return existingSegmentMidpointHitCoords;}}var index=0;var midPoints=LinearElementEditor.getEditorMidPoints(element,appState);while(index<midPoints.length){if(midPoints[index]!==null){var _distance=distance2d(midPoints[index][0],midPoints[index][1],scenePointer.x,scenePointer.y);if(_distance<=threshold){return midPoints[index];}}index++;}return null;};LinearElementEditor.getBoundTextElementPosition=function(element,boundTextElement){var points=LinearElementEditor.getPointsGlobalCoordinates(element);if(points.length<2){mutateElement(boundTextElement,{isDeleted:true});}var x=0;var y=0;if(element.points.length%2===1){var index=Math.floor(element.points.length/2);var midPoint=LinearElementEditor.getPointGlobalCoordinates(element,element.points[index]);x=midPoint[0]-boundTextElement.width/2;y=midPoint[1]-boundTextElement.height/2;}else{var _index=element.points.length/2-1;var midSegmentMidpoint=editorMidPointsCache.points[_index];if(element.points.length===2){midSegmentMidpoint=centerPoint(points[0],points[1]);}if(!midSegmentMidpoint||editorMidPointsCache.version!==element.version){midSegmentMidpoint=LinearElementEditor.getSegmentMidPoint(element,points[_index],points[_index+1],_index+1);}x=midSegmentMidpoint[0]-boundTextElement.width/2;y=midSegmentMidpoint[1]-boundTextElement.height/2;}return{x:x,y:y};};LinearElementEditor.getMinMaxXYWithBoundText=function(element,elementBounds,boundTextElement){var _elementBounds=_slicedToArray(elementBounds,4),x1=_elementBounds[0],y1=_elementBounds[1],x2=_elementBounds[2],y2=_elementBounds[3];var cx=(x1+x2)/2;var cy=(y1+y2)/2;var _LinearElementEditor$5=LinearElementEditor.getBoundTextElementPosition(element,boundTextElement),boundTextX1=_LinearElementEditor$5.x,boundTextY1=_LinearElementEditor$5.y;var boundTextX2=boundTextX1+boundTextElement.width;var boundTextY2=boundTextY1+boundTextElement.height;var topLeftRotatedPoint=rotatePoint([x1,y1],[cx,cy],element.angle);var topRightRotatedPoint=rotatePoint([x2,y1],[cx,cy],element.angle);var counterRotateBoundTextTopLeft=rotatePoint([boundTextX1,boundTextY1],[cx,cy],-element.angle);var counterRotateBoundTextTopRight=rotatePoint([boundTextX2,boundTextY1],[cx,cy],-element.angle);var counterRotateBoundTextBottomLeft=rotatePoint([boundTextX1,boundTextY2],[cx,cy],-element.angle);var counterRotateBoundTextBottomRight=rotatePoint([boundTextX2,boundTextY2],[cx,cy],-element.angle);if(topLeftRotatedPoint[0]<topRightRotatedPoint[0]&&topLeftRotatedPoint[1]>=topRightRotatedPoint[1]){x1=Math.min(x1,counterRotateBoundTextBottomLeft[0]);x2=Math.max(x2,Math.max(counterRotateBoundTextTopRight[0],counterRotateBoundTextBottomRight[0]));y1=Math.min(y1,counterRotateBoundTextTopLeft[1]);y2=Math.max(y2,counterRotateBoundTextBottomRight[1]);}else if(topLeftRotatedPoint[0]>=topRightRotatedPoint[0]&&topLeftRotatedPoint[1]>topRightRotatedPoint[1]){x1=Math.min(x1,counterRotateBoundTextBottomRight[0]);x2=Math.max(x2,Math.max(counterRotateBoundTextTopLeft[0],counterRotateBoundTextTopRight[0]));y1=Math.min(y1,counterRotateBoundTextBottomLeft[1]);y2=Math.max(y2,counterRotateBoundTextTopRight[1]);}else if(topLeftRotatedPoint[0]>=topRightRotatedPoint[0]){x1=Math.min(x1,counterRotateBoundTextTopRight[0]);x2=Math.max(x2,counterRotateBoundTextBottomLeft[0]);y1=Math.min(y1,counterRotateBoundTextBottomRight[1]);y2=Math.max(y2,counterRotateBoundTextTopLeft[1]);}else if(topLeftRotatedPoint[1]<=topRightRotatedPoint[1]){x1=Math.min(x1,Math.min(counterRotateBoundTextTopRight[0],counterRotateBoundTextTopLeft[0]));x2=Math.max(x2,counterRotateBoundTextBottomRight[0]);y1=Math.min(y1,counterRotateBoundTextTopRight[1]);y2=Math.max(y2,counterRotateBoundTextBottomLeft[1]);}return[x1,y1,x2,y2,cx,cy];};LinearElementEditor.getElementAbsoluteCoords=function(element){var includeBoundText=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var coords;var x1;var y1;var x2;var y2;if(element.points.length<2||!getShapeForElement(element)){// XXX this is just a poor estimate and not very useful\nvar _element$points$reduc=element.points.reduce(function(limits,_ref2){var _ref3=_slicedToArray(_ref2,2),x=_ref3[0],y=_ref3[1];limits.minY=Math.min(limits.minY,y);limits.minX=Math.min(limits.minX,x);limits.maxX=Math.max(limits.maxX,x);limits.maxY=Math.max(limits.maxY,y);return limits;},{minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity}),minX=_element$points$reduc.minX,minY=_element$points$reduc.minY,maxX=_element$points$reduc.maxX,maxY=_element$points$reduc.maxY;x1=minX+element.x;y1=minY+element.y;x2=maxX+element.x;y2=maxY+element.y;}else{var shape=getShapeForElement(element);// first element is always the curve\nvar ops=getCurvePathOps(shape[0]);var _getMinMaxXYFromCurve=getMinMaxXYFromCurvePathOps(ops),_getMinMaxXYFromCurve2=_slicedToArray(_getMinMaxXYFromCurve,4),_minX=_getMinMaxXYFromCurve2[0],_minY=_getMinMaxXYFromCurve2[1],_maxX=_getMinMaxXYFromCurve2[2],_maxY=_getMinMaxXYFromCurve2[3];x1=_minX+element.x;y1=_minY+element.y;x2=_maxX+element.x;y2=_maxY+element.y;}var cx=(x1+x2)/2;var cy=(y1+y2)/2;coords=[x1,y1,x2,y2,cx,cy];if(!includeBoundText){return coords;}var boundTextElement=getBoundTextElement(element);if(boundTextElement){coords=LinearElementEditor.getMinMaxXYWithBoundText(element,[x1,y1,x2,y2],boundTextElement);}return coords;};var normalizeSelectedPoints=function normalizeSelectedPoints(points){var nextPoints=_toConsumableArray(new Set(points.filter(function(p){return p!==null&&p!==-1;})));nextPoints=nextPoints.sort(function(a,b){return a-b;});return nextPoints.length?nextPoints:null;};","map":{"version":3,"names":["distance2d","rotate","isPathALoop","getGridPoint","rotatePoint","centerPoint","getControlPointsForBezierCurve","getBezierXY","getBezierCurveLength","mapIntervalToBezierT","arePointsEqual","getElementAbsoluteCoords","getLockedLinearCursorAlignSize","getCurvePathOps","getElementPointsCoords","getMinMaxXYFromCurvePathOps","mutateElement","Scene","bindOrUnbindLinearElement","getHoveredElementForBinding","isBindingEnabled","tupleToCoors","isBindingElement","shouldRotateWithDiscreteAngle","getBoundTextElement","handleBindTextResize","getShapeForElement","DRAGGING_THRESHOLD","editorMidPointsCache","version","points","zoom","LinearElementEditor","element","scene","_classCallCheck","elementId","selectedPointsIndices","pointerDownState","isDragging","lastUncommittedPoint","pointerOffset","startBindingElement","endBindingElement","hoverPointIndex","segmentMidPointHoveredCoords","id","mapElementToScene","normalizePoints","x","y","prevSelectedPointsIndices","lastClickedPoint","origin","segmentMidpoint","value","index","added","_createClass","key","getElement","_Scene$getScene","getScene","getNonDeletedElement","handleBoxSelection","event","appState","setState","_appState$draggingEle","editingLinearElement","draggingElement","type","_getElementAbsoluteCo","_getElementAbsoluteCo2","_slicedToArray","selectionX1","selectionY1","selectionX2","selectionY2","pointsSceneCoords","getPointsGlobalCoordinates","nextSelectedPoints","reduce","acc","point","shiftKey","includes","push","_objectSpread","length","handlePointDragging","scenePointerX","scenePointerY","maybeSuggestBinding","linearElementEditor","draggingPoint","selectedIndex","referencePoint","_LinearElementEditor$","_getShiftLockedDelta","gridSize","_LinearElementEditor$2","width","height","movePoints","newDraggingPointPosition","createPointAt","deltaX","deltaY","map","pointIndex","newPointPosition","boundTextElement","coords","firstSelectedIndex","getPointGlobalCoordinates","lastSelectedIndex","handlePointerUp","_pointerDownState$pre","bindings","_iterator","_createForOfIteratorHelper","_step","s","n","done","selectedPoint","bindingElement","getPointAtIndexGlobalCoordinates","err","e","f","filter","isSegmentTooShort","startPoint","endPoint","distance","roundness","POINT_HANDLE_SIZE","getSegmentMidPoint","endPointIndex","segmentMidPoint","controlPoints","t","_getBezierXY","_getBezierXY2","tx","ty","getSegmentMidPointIndex","midPoint","midPoints","getEditorMidPoints","handlePointerDown","history","scenePointer","_linearElementEditor$","ret","didAddPoint","hitElement","getSegmentMidpointHitCoords","segmentMidpointIndex","altKey","concat","_toConsumableArray","resumeRecording","clickedPointIndex","getPointIndexUnderCursor","_getElementAbsoluteCo3","_getElementAbsoluteCo4","x1","y1","x2","y2","cx","cy","targetPoint","angle","nextSelectedPointsIndices","normalizeSelectedPoints","point1","point2","handlePointerMove","_appState$editingLine","lastPoint","deletePoints","newPoint","lastCommittedPoint","_LinearElementEditor$3","_LinearElementEditor$4","addPoints","_getElementAbsoluteCo5","_getElementAbsoluteCo6","_rotate","_rotate2","_getElementAbsoluteCo7","_getElementAbsoluteCo8","_rotate3","_rotate4","indexMaybeFromEnd","_getElementAbsoluteCo9","_getElementAbsoluteCo10","pointFromAbsoluteCoords","absoluteCoords","_getElementAbsoluteCo11","_getElementAbsoluteCo12","_rotate5","_rotate6","pointHandles","idx","pointerOnGrid","_getElementAbsoluteCo13","_getElementAbsoluteCo14","_rotate7","_rotate8","rotatedX","rotatedY","getNormalizedPoints","offsetX","offsetY","_idx","duplicateSelectedPoints","_appState$editingLine2","nextSelectedIndices","pointAddedToEnd","indexCursor","nextPoints","isSelected","nextPoint","pointIndices","isDeletingOriginPoint","firstNonDeletedPoint","find","_updatePoints","targetPoints","otherUpdates","selectedOriginPoint","_ref","selectedPointData","p","shouldAddMidpoint","pointerCoords","dist","addMidpoint","midpoint","slice","nextCoords","prevCoords","nextCenterX","nextCenterY","prevCenterX","prevCenterY","dX","dY","rotated","referencePointCoords","_getGridPoint","_getGridPoint2","gridX","gridY","_getLockedLinearCurso","boundText","updateEditorMidPointsCache","midpoints","threshold","existingSegmentMidpointHitCoords","getBoundTextElementPosition","isDeleted","Math","floor","midSegmentMidpoint","getMinMaxXYWithBoundText","elementBounds","_elementBounds","_LinearElementEditor$5","boundTextX1","boundTextY1","boundTextX2","boundTextY2","topLeftRotatedPoint","topRightRotatedPoint","counterRotateBoundTextTopLeft","counterRotateBoundTextTopRight","counterRotateBoundTextBottomLeft","counterRotateBoundTextBottomRight","min","max","includeBoundText","arguments","undefined","_element$points$reduc","limits","_ref2","_ref3","minY","minX","maxX","maxY","Infinity","shape","ops","_getMinMaxXYFromCurve","_getMinMaxXYFromCurve2","Set","sort","a","b"],"sources":["D:/project/excalidraw-cn/src/element/linearElementEditor.ts"],"sourcesContent":["import {\n  NonDeleted,\n  ExcalidrawLinearElement,\n  ExcalidrawElement,\n  PointBinding,\n  ExcalidrawBindableElement,\n  ExcalidrawTextElementWithContainer,\n} from \"./types\";\nimport {\n  distance2d,\n  rotate,\n  isPathALoop,\n  getGridPoint,\n  rotatePoint,\n  centerPoint,\n  getControlPointsForBezierCurve,\n  getBezierXY,\n  getBezierCurveLength,\n  mapIntervalToBezierT,\n  arePointsEqual,\n} from \"../math\";\nimport { getElementAbsoluteCoords, getLockedLinearCursorAlignSize } from \".\";\nimport {\n  getCurvePathOps,\n  getElementPointsCoords,\n  getMinMaxXYFromCurvePathOps,\n} from \"./bounds\";\nimport { Point, AppState, PointerCoords } from \"../types\";\nimport { mutateElement } from \"./mutateElement\";\nimport History from \"../history\";\n\nimport Scene from \"../scene/Scene\";\nimport {\n  bindOrUnbindLinearElement,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n} from \"./binding\";\nimport { tupleToCoors } from \"../utils\";\nimport { isBindingElement } from \"./typeChecks\";\nimport { shouldRotateWithDiscreteAngle } from \"../keys\";\nimport { getBoundTextElement, handleBindTextResize } from \"./textElement\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\nimport { DRAGGING_THRESHOLD } from \"../constants\";\nimport { Mutable } from \"../utility-types\";\n\nconst editorMidPointsCache: {\n  version: number | null;\n  points: (Point | null)[];\n  zoom: number | null;\n} = { version: null, points: [], zoom: null };\nexport class LinearElementEditor {\n  public readonly elementId: ExcalidrawElement[\"id\"] & {\n    _brand: \"excalidrawLinearElementId\";\n  };\n  /** indices */\n  public readonly selectedPointsIndices: readonly number[] | null;\n\n  public readonly pointerDownState: Readonly<{\n    prevSelectedPointsIndices: readonly number[] | null;\n    /** index */\n    lastClickedPoint: number;\n    origin: Readonly<{ x: number; y: number }> | null;\n    segmentMidpoint: {\n      value: Point | null;\n      index: number | null;\n      added: boolean;\n    };\n  }>;\n\n  /** whether you're dragging a point */\n  public readonly isDragging: boolean;\n  public readonly lastUncommittedPoint: Point | null;\n  public readonly pointerOffset: Readonly<{ x: number; y: number }>;\n  public readonly startBindingElement:\n    | ExcalidrawBindableElement\n    | null\n    | \"keep\";\n  public readonly endBindingElement: ExcalidrawBindableElement | null | \"keep\";\n  public readonly hoverPointIndex: number;\n  public readonly segmentMidPointHoveredCoords: Point | null;\n\n  constructor(element: NonDeleted<ExcalidrawLinearElement>, scene: Scene) {\n    this.elementId = element.id as string & {\n      _brand: \"excalidrawLinearElementId\";\n    };\n    Scene.mapElementToScene(this.elementId, scene);\n    LinearElementEditor.normalizePoints(element);\n\n    this.selectedPointsIndices = null;\n    this.lastUncommittedPoint = null;\n    this.isDragging = false;\n    this.pointerOffset = { x: 0, y: 0 };\n    this.startBindingElement = \"keep\";\n    this.endBindingElement = \"keep\";\n    this.pointerDownState = {\n      prevSelectedPointsIndices: null,\n      lastClickedPoint: -1,\n      origin: null,\n\n      segmentMidpoint: {\n        value: null,\n        index: null,\n        added: false,\n      },\n    };\n    this.hoverPointIndex = -1;\n    this.segmentMidPointHoveredCoords = null;\n  }\n\n  // ---------------------------------------------------------------------------\n  // static methods\n  // ---------------------------------------------------------------------------\n\n  static POINT_HANDLE_SIZE = 10;\n  /**\n   * @param id the `elementId` from the instance of this class (so that we can\n   *  statically guarantee this method returns an ExcalidrawLinearElement)\n   */\n  static getElement(id: InstanceType<typeof LinearElementEditor>[\"elementId\"]) {\n    const element = Scene.getScene(id)?.getNonDeletedElement(id);\n    if (element) {\n      return element as NonDeleted<ExcalidrawLinearElement>;\n    }\n    return null;\n  }\n\n  static handleBoxSelection(\n    event: PointerEvent,\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n  ) {\n    if (\n      !appState.editingLinearElement ||\n      appState.draggingElement?.type !== \"selection\"\n    ) {\n      return false;\n    }\n    const { editingLinearElement } = appState;\n    const { selectedPointsIndices, elementId } = editingLinearElement;\n\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return false;\n    }\n\n    const [selectionX1, selectionY1, selectionX2, selectionY2] =\n      getElementAbsoluteCoords(appState.draggingElement);\n\n    const pointsSceneCoords =\n      LinearElementEditor.getPointsGlobalCoordinates(element);\n\n    const nextSelectedPoints = pointsSceneCoords.reduce(\n      (acc: number[], point, index) => {\n        if (\n          (point[0] >= selectionX1 &&\n            point[0] <= selectionX2 &&\n            point[1] >= selectionY1 &&\n            point[1] <= selectionY2) ||\n          (event.shiftKey && selectedPointsIndices?.includes(index))\n        ) {\n          acc.push(index);\n        }\n\n        return acc;\n      },\n      [],\n    );\n\n    setState({\n      editingLinearElement: {\n        ...editingLinearElement,\n        selectedPointsIndices: nextSelectedPoints.length\n          ? nextSelectedPoints\n          : null,\n      },\n    });\n  }\n\n  /** @returns whether point was dragged */\n  static handlePointDragging(\n    event: PointerEvent,\n    appState: AppState,\n    scenePointerX: number,\n    scenePointerY: number,\n    maybeSuggestBinding: (\n      element: NonDeleted<ExcalidrawLinearElement>,\n      pointSceneCoords: { x: number; y: number }[],\n    ) => void,\n    linearElementEditor: LinearElementEditor,\n  ): boolean {\n    if (!linearElementEditor) {\n      return false;\n    }\n    const { selectedPointsIndices, elementId } = linearElementEditor;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return false;\n    }\n\n    // point that's being dragged (out of all selected points)\n    const draggingPoint = element.points[\n      linearElementEditor.pointerDownState.lastClickedPoint\n    ] as [number, number] | undefined;\n\n    if (selectedPointsIndices && draggingPoint) {\n      if (\n        shouldRotateWithDiscreteAngle(event) &&\n        selectedPointsIndices.length === 1 &&\n        element.points.length > 1\n      ) {\n        const selectedIndex = selectedPointsIndices[0];\n        const referencePoint =\n          element.points[selectedIndex === 0 ? 1 : selectedIndex - 1];\n\n        const [width, height] = LinearElementEditor._getShiftLockedDelta(\n          element,\n          referencePoint,\n          [scenePointerX, scenePointerY],\n          appState.gridSize,\n        );\n\n        LinearElementEditor.movePoints(element, [\n          {\n            index: selectedIndex,\n            point: [width + referencePoint[0], height + referencePoint[1]],\n            isDragging:\n              selectedIndex ===\n              linearElementEditor.pointerDownState.lastClickedPoint,\n          },\n        ]);\n      } else {\n        const newDraggingPointPosition = LinearElementEditor.createPointAt(\n          element,\n          scenePointerX - linearElementEditor.pointerOffset.x,\n          scenePointerY - linearElementEditor.pointerOffset.y,\n          appState.gridSize,\n        );\n\n        const deltaX = newDraggingPointPosition[0] - draggingPoint[0];\n        const deltaY = newDraggingPointPosition[1] - draggingPoint[1];\n\n        LinearElementEditor.movePoints(\n          element,\n          selectedPointsIndices.map((pointIndex) => {\n            const newPointPosition =\n              pointIndex ===\n              linearElementEditor.pointerDownState.lastClickedPoint\n                ? LinearElementEditor.createPointAt(\n                    element,\n                    scenePointerX - linearElementEditor.pointerOffset.x,\n                    scenePointerY - linearElementEditor.pointerOffset.y,\n                    appState.gridSize,\n                  )\n                : ([\n                    element.points[pointIndex][0] + deltaX,\n                    element.points[pointIndex][1] + deltaY,\n                  ] as const);\n            return {\n              index: pointIndex,\n              point: newPointPosition,\n              isDragging:\n                pointIndex ===\n                linearElementEditor.pointerDownState.lastClickedPoint,\n            };\n          }),\n        );\n\n        const boundTextElement = getBoundTextElement(element);\n        if (boundTextElement) {\n          handleBindTextResize(element, false);\n        }\n      }\n\n      // suggest bindings for first and last point if selected\n      if (isBindingElement(element, false)) {\n        const coords: { x: number; y: number }[] = [];\n\n        const firstSelectedIndex = selectedPointsIndices[0];\n        if (firstSelectedIndex === 0) {\n          coords.push(\n            tupleToCoors(\n              LinearElementEditor.getPointGlobalCoordinates(\n                element,\n                element.points[0],\n              ),\n            ),\n          );\n        }\n\n        const lastSelectedIndex =\n          selectedPointsIndices[selectedPointsIndices.length - 1];\n        if (lastSelectedIndex === element.points.length - 1) {\n          coords.push(\n            tupleToCoors(\n              LinearElementEditor.getPointGlobalCoordinates(\n                element,\n                element.points[lastSelectedIndex],\n              ),\n            ),\n          );\n        }\n\n        if (coords.length) {\n          maybeSuggestBinding(element, coords);\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  static handlePointerUp(\n    event: PointerEvent,\n    editingLinearElement: LinearElementEditor,\n    appState: AppState,\n  ): LinearElementEditor {\n    const { elementId, selectedPointsIndices, isDragging, pointerDownState } =\n      editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    const bindings: Mutable<\n      Partial<\n        Pick<\n          InstanceType<typeof LinearElementEditor>,\n          \"startBindingElement\" | \"endBindingElement\"\n        >\n      >\n    > = {};\n\n    if (isDragging && selectedPointsIndices) {\n      for (const selectedPoint of selectedPointsIndices) {\n        if (\n          selectedPoint === 0 ||\n          selectedPoint === element.points.length - 1\n        ) {\n          if (isPathALoop(element.points, appState.zoom.value)) {\n            LinearElementEditor.movePoints(element, [\n              {\n                index: selectedPoint,\n                point:\n                  selectedPoint === 0\n                    ? element.points[element.points.length - 1]\n                    : element.points[0],\n              },\n            ]);\n          }\n\n          const bindingElement = isBindingEnabled(appState)\n            ? getHoveredElementForBinding(\n                tupleToCoors(\n                  LinearElementEditor.getPointAtIndexGlobalCoordinates(\n                    element,\n                    selectedPoint!,\n                  ),\n                ),\n                Scene.getScene(element)!,\n              )\n            : null;\n\n          bindings[\n            selectedPoint === 0 ? \"startBindingElement\" : \"endBindingElement\"\n          ] = bindingElement;\n        }\n      }\n    }\n\n    return {\n      ...editingLinearElement,\n      ...bindings,\n      // if clicking without previously dragging a point(s), and not holding\n      // shift, deselect all points except the one clicked. If holding shift,\n      // toggle the point.\n      selectedPointsIndices:\n        isDragging || event.shiftKey\n          ? !isDragging &&\n            event.shiftKey &&\n            pointerDownState.prevSelectedPointsIndices?.includes(\n              pointerDownState.lastClickedPoint,\n            )\n            ? selectedPointsIndices &&\n              selectedPointsIndices.filter(\n                (pointIndex) =>\n                  pointIndex !== pointerDownState.lastClickedPoint,\n              )\n            : selectedPointsIndices\n          : selectedPointsIndices?.includes(pointerDownState.lastClickedPoint)\n          ? [pointerDownState.lastClickedPoint]\n          : selectedPointsIndices,\n      isDragging: false,\n      pointerOffset: { x: 0, y: 0 },\n    };\n  }\n\n  static getEditorMidPoints = (\n    element: NonDeleted<ExcalidrawLinearElement>,\n    appState: AppState,\n  ): typeof editorMidPointsCache[\"points\"] => {\n    const boundText = getBoundTextElement(element);\n\n    // Since its not needed outside editor unless 2 pointer lines or bound text\n    if (\n      !appState.editingLinearElement &&\n      element.points.length > 2 &&\n      !boundText\n    ) {\n      return [];\n    }\n    if (\n      editorMidPointsCache.version === element.version &&\n      editorMidPointsCache.zoom === appState.zoom.value\n    ) {\n      return editorMidPointsCache.points;\n    }\n    LinearElementEditor.updateEditorMidPointsCache(element, appState);\n    return editorMidPointsCache.points!;\n  };\n\n  static updateEditorMidPointsCache = (\n    element: NonDeleted<ExcalidrawLinearElement>,\n    appState: AppState,\n  ) => {\n    const points = LinearElementEditor.getPointsGlobalCoordinates(element);\n\n    let index = 0;\n    const midpoints: (Point | null)[] = [];\n    while (index < points.length - 1) {\n      if (\n        LinearElementEditor.isSegmentTooShort(\n          element,\n          element.points[index],\n          element.points[index + 1],\n          appState.zoom,\n        )\n      ) {\n        midpoints.push(null);\n        index++;\n        continue;\n      }\n      const segmentMidPoint = LinearElementEditor.getSegmentMidPoint(\n        element,\n        points[index],\n        points[index + 1],\n        index + 1,\n      );\n      midpoints.push(segmentMidPoint);\n      index++;\n    }\n    editorMidPointsCache.points = midpoints;\n    editorMidPointsCache.version = element.version;\n    editorMidPointsCache.zoom = appState.zoom.value;\n  };\n\n  static getSegmentMidpointHitCoords = (\n    linearElementEditor: LinearElementEditor,\n    scenePointer: { x: number; y: number },\n    appState: AppState,\n  ) => {\n    const { elementId } = linearElementEditor;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return null;\n    }\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n    if (clickedPointIndex >= 0) {\n      return null;\n    }\n    const points = LinearElementEditor.getPointsGlobalCoordinates(element);\n    if (points.length >= 3 && !appState.editingLinearElement) {\n      return null;\n    }\n\n    const threshold =\n      LinearElementEditor.POINT_HANDLE_SIZE / appState.zoom.value;\n\n    const existingSegmentMidpointHitCoords =\n      linearElementEditor.segmentMidPointHoveredCoords;\n    if (existingSegmentMidpointHitCoords) {\n      const distance = distance2d(\n        existingSegmentMidpointHitCoords[0],\n        existingSegmentMidpointHitCoords[1],\n        scenePointer.x,\n        scenePointer.y,\n      );\n      if (distance <= threshold) {\n        return existingSegmentMidpointHitCoords;\n      }\n    }\n    let index = 0;\n    const midPoints: typeof editorMidPointsCache[\"points\"] =\n      LinearElementEditor.getEditorMidPoints(element, appState);\n    while (index < midPoints.length) {\n      if (midPoints[index] !== null) {\n        const distance = distance2d(\n          midPoints[index]![0],\n          midPoints[index]![1],\n          scenePointer.x,\n          scenePointer.y,\n        );\n        if (distance <= threshold) {\n          return midPoints[index];\n        }\n      }\n\n      index++;\n    }\n    return null;\n  };\n\n  static isSegmentTooShort(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    startPoint: Point,\n    endPoint: Point,\n    zoom: AppState[\"zoom\"],\n  ) {\n    let distance = distance2d(\n      startPoint[0],\n      startPoint[1],\n      endPoint[0],\n      endPoint[1],\n    );\n    if (element.points.length > 2 && element.roundness) {\n      distance = getBezierCurveLength(element, endPoint);\n    }\n\n    return distance * zoom.value < LinearElementEditor.POINT_HANDLE_SIZE * 4;\n  }\n\n  static getSegmentMidPoint(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    startPoint: Point,\n    endPoint: Point,\n    endPointIndex: number,\n  ) {\n    let segmentMidPoint = centerPoint(startPoint, endPoint);\n    if (element.points.length > 2 && element.roundness) {\n      const controlPoints = getControlPointsForBezierCurve(\n        element,\n        element.points[endPointIndex],\n      );\n      if (controlPoints) {\n        const t = mapIntervalToBezierT(\n          element,\n          element.points[endPointIndex],\n          0.5,\n        );\n\n        const [tx, ty] = getBezierXY(\n          controlPoints[0],\n          controlPoints[1],\n          controlPoints[2],\n          controlPoints[3],\n          t,\n        );\n        segmentMidPoint = LinearElementEditor.getPointGlobalCoordinates(\n          element,\n          [tx, ty],\n        );\n      }\n    }\n\n    return segmentMidPoint;\n  }\n\n  static getSegmentMidPointIndex(\n    linearElementEditor: LinearElementEditor,\n    appState: AppState,\n    midPoint: Point,\n  ) {\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n    );\n    if (!element) {\n      return -1;\n    }\n    const midPoints = LinearElementEditor.getEditorMidPoints(element, appState);\n    let index = 0;\n    while (index < midPoints.length) {\n      if (LinearElementEditor.arePointsEqual(midPoint, midPoints[index])) {\n        return index + 1;\n      }\n      index++;\n    }\n    return -1;\n  }\n\n  static handlePointerDown(\n    event: React.PointerEvent<HTMLElement>,\n    appState: AppState,\n    history: History,\n    scenePointer: { x: number; y: number },\n    linearElementEditor: LinearElementEditor,\n  ): {\n    didAddPoint: boolean;\n    hitElement: NonDeleted<ExcalidrawElement> | null;\n    linearElementEditor: LinearElementEditor | null;\n  } {\n    const ret: ReturnType<typeof LinearElementEditor[\"handlePointerDown\"]> = {\n      didAddPoint: false,\n      hitElement: null,\n      linearElementEditor: null,\n    };\n\n    if (!linearElementEditor) {\n      return ret;\n    }\n\n    const { elementId } = linearElementEditor;\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element) {\n      return ret;\n    }\n    const segmentMidpoint = LinearElementEditor.getSegmentMidpointHitCoords(\n      linearElementEditor,\n      scenePointer,\n      appState,\n    );\n    let segmentMidpointIndex = null;\n    if (segmentMidpoint) {\n      segmentMidpointIndex = LinearElementEditor.getSegmentMidPointIndex(\n        linearElementEditor,\n        appState,\n        segmentMidpoint,\n      );\n    }\n    if (event.altKey && appState.editingLinearElement) {\n      if (linearElementEditor.lastUncommittedPoint == null) {\n        mutateElement(element, {\n          points: [\n            ...element.points,\n            LinearElementEditor.createPointAt(\n              element,\n              scenePointer.x,\n              scenePointer.y,\n              appState.gridSize,\n            ),\n          ],\n        });\n        ret.didAddPoint = true;\n      }\n      history.resumeRecording();\n      ret.linearElementEditor = {\n        ...linearElementEditor,\n        pointerDownState: {\n          prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,\n          lastClickedPoint: -1,\n          origin: { x: scenePointer.x, y: scenePointer.y },\n          segmentMidpoint: {\n            value: segmentMidpoint,\n            index: segmentMidpointIndex,\n            added: false,\n          },\n        },\n        selectedPointsIndices: [element.points.length - 1],\n        lastUncommittedPoint: null,\n        endBindingElement: getHoveredElementForBinding(\n          scenePointer,\n          Scene.getScene(element)!,\n        ),\n      };\n\n      ret.didAddPoint = true;\n      return ret;\n    }\n\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n    // if we clicked on a point, set the element as hitElement otherwise\n    // it would get deselected if the point is outside the hitbox area\n    if (clickedPointIndex >= 0 || segmentMidpoint) {\n      ret.hitElement = element;\n    } else {\n      // You might be wandering why we are storing the binding elements on\n      // LinearElementEditor and passing them in, instead of calculating them\n      // from the end points of the `linearElement` - this is to allow disabling\n      // binding (which needs to happen at the point the user finishes moving\n      // the point).\n      const { startBindingElement, endBindingElement } = linearElementEditor;\n      if (isBindingEnabled(appState) && isBindingElement(element)) {\n        bindOrUnbindLinearElement(\n          element,\n          startBindingElement,\n          endBindingElement,\n        );\n      }\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const targetPoint =\n      clickedPointIndex > -1 &&\n      rotate(\n        element.x + element.points[clickedPointIndex][0],\n        element.y + element.points[clickedPointIndex][1],\n        cx,\n        cy,\n        element.angle,\n      );\n\n    const nextSelectedPointsIndices =\n      clickedPointIndex > -1 || event.shiftKey\n        ? event.shiftKey ||\n          linearElementEditor.selectedPointsIndices?.includes(clickedPointIndex)\n          ? normalizeSelectedPoints([\n              ...(linearElementEditor.selectedPointsIndices || []),\n              clickedPointIndex,\n            ])\n          : [clickedPointIndex]\n        : null;\n    ret.linearElementEditor = {\n      ...linearElementEditor,\n      pointerDownState: {\n        prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,\n        lastClickedPoint: clickedPointIndex,\n        origin: { x: scenePointer.x, y: scenePointer.y },\n        segmentMidpoint: {\n          value: segmentMidpoint,\n          index: segmentMidpointIndex,\n          added: false,\n        },\n      },\n      selectedPointsIndices: nextSelectedPointsIndices,\n      pointerOffset: targetPoint\n        ? {\n            x: scenePointer.x - targetPoint[0],\n            y: scenePointer.y - targetPoint[1],\n          }\n        : { x: 0, y: 0 },\n    };\n\n    return ret;\n  }\n\n  static arePointsEqual(point1: Point | null, point2: Point | null) {\n    if (!point1 && !point2) {\n      return true;\n    }\n    if (!point1 || !point2) {\n      return false;\n    }\n    return arePointsEqual(point1, point2);\n  }\n\n  static handlePointerMove(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    appState: AppState,\n  ): LinearElementEditor | null {\n    if (!appState.editingLinearElement) {\n      return null;\n    }\n    const { elementId, lastUncommittedPoint } = appState.editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return appState.editingLinearElement;\n    }\n\n    const { points } = element;\n    const lastPoint = points[points.length - 1];\n\n    if (!event.altKey) {\n      if (lastPoint === lastUncommittedPoint) {\n        LinearElementEditor.deletePoints(element, [points.length - 1]);\n      }\n      return {\n        ...appState.editingLinearElement,\n        lastUncommittedPoint: null,\n      };\n    }\n\n    let newPoint: Point;\n\n    if (shouldRotateWithDiscreteAngle(event) && points.length >= 2) {\n      const lastCommittedPoint = points[points.length - 2];\n\n      const [width, height] = LinearElementEditor._getShiftLockedDelta(\n        element,\n        lastCommittedPoint,\n        [scenePointerX, scenePointerY],\n        appState.gridSize,\n      );\n\n      newPoint = [\n        width + lastCommittedPoint[0],\n        height + lastCommittedPoint[1],\n      ];\n    } else {\n      newPoint = LinearElementEditor.createPointAt(\n        element,\n        scenePointerX - appState.editingLinearElement.pointerOffset.x,\n        scenePointerY - appState.editingLinearElement.pointerOffset.y,\n        appState.gridSize,\n      );\n    }\n\n    if (lastPoint === lastUncommittedPoint) {\n      LinearElementEditor.movePoints(element, [\n        {\n          index: element.points.length - 1,\n          point: newPoint,\n        },\n      ]);\n    } else {\n      LinearElementEditor.addPoints(element, appState, [{ point: newPoint }]);\n    }\n    return {\n      ...appState.editingLinearElement,\n      lastUncommittedPoint: element.points[element.points.length - 1],\n    };\n  }\n\n  /** scene coords */\n  static getPointGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    point: Point,\n  ) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    let { x, y } = element;\n    [x, y] = rotate(x + point[0], y + point[1], cx, cy, element.angle);\n    return [x, y] as const;\n  }\n\n  /** scene coords */\n  static getPointsGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n  ): Point[] {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return element.points.map((point) => {\n      let { x, y } = element;\n      [x, y] = rotate(x + point[0], y + point[1], cx, cy, element.angle);\n      return [x, y] as const;\n    });\n  }\n\n  static getPointAtIndexGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    indexMaybeFromEnd: number, // -1 for last element\n  ): Point {\n    const index =\n      indexMaybeFromEnd < 0\n        ? element.points.length + indexMaybeFromEnd\n        : indexMaybeFromEnd;\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    const point = element.points[index];\n    const { x, y } = element;\n    return point\n      ? rotate(x + point[0], y + point[1], cx, cy, element.angle)\n      : rotate(x, y, cx, cy, element.angle);\n  }\n\n  static pointFromAbsoluteCoords(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    absoluteCoords: Point,\n  ): Point {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [x, y] = rotate(\n      absoluteCoords[0],\n      absoluteCoords[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n    return [x - element.x, y - element.y];\n  }\n\n  static getPointIndexUnderCursor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    zoom: AppState[\"zoom\"],\n    x: number,\n    y: number,\n  ) {\n    const pointHandles =\n      LinearElementEditor.getPointsGlobalCoordinates(element);\n    let idx = pointHandles.length;\n    // loop from right to left because points on the right are rendered over\n    // points on the left, thus should take precedence when clicking, if they\n    // overlap\n    while (--idx > -1) {\n      const point = pointHandles[idx];\n      if (\n        distance2d(x, y, point[0], point[1]) * zoom.value <\n        // +1px to account for outline stroke\n        LinearElementEditor.POINT_HANDLE_SIZE + 1\n      ) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n\n  static createPointAt(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    gridSize: number | null,\n  ): Point {\n    const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [rotatedX, rotatedY] = rotate(\n      pointerOnGrid[0],\n      pointerOnGrid[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n\n    return [rotatedX - element.x, rotatedY - element.y];\n  }\n\n  /**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   * expected in various parts of the codebase. Also returns new x/y to account\n   * for the potential normalization.\n   */\n  static getNormalizedPoints(element: ExcalidrawLinearElement) {\n    const { points } = element;\n\n    const offsetX = points[0][0];\n    const offsetY = points[0][1];\n\n    return {\n      points: points.map((point, _idx) => {\n        return [point[0] - offsetX, point[1] - offsetY] as const;\n      }),\n      x: element.x + offsetX,\n      y: element.y + offsetY,\n    };\n  }\n\n  // element-mutating methods\n  // ---------------------------------------------------------------------------\n\n  static normalizePoints(element: NonDeleted<ExcalidrawLinearElement>) {\n    mutateElement(element, LinearElementEditor.getNormalizedPoints(element));\n  }\n\n  static duplicateSelectedPoints(appState: AppState) {\n    if (!appState.editingLinearElement) {\n      return false;\n    }\n\n    const { selectedPointsIndices, elementId } = appState.editingLinearElement;\n\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element || selectedPointsIndices === null) {\n      return false;\n    }\n\n    const { points } = element;\n\n    const nextSelectedIndices: number[] = [];\n\n    let pointAddedToEnd = false;\n    let indexCursor = -1;\n    const nextPoints = points.reduce((acc: Point[], point, index) => {\n      ++indexCursor;\n      acc.push(point);\n\n      const isSelected = selectedPointsIndices.includes(index);\n      if (isSelected) {\n        const nextPoint = points[index + 1];\n\n        if (!nextPoint) {\n          pointAddedToEnd = true;\n        }\n        acc.push(\n          nextPoint\n            ? [(point[0] + nextPoint[0]) / 2, (point[1] + nextPoint[1]) / 2]\n            : [point[0], point[1]],\n        );\n\n        nextSelectedIndices.push(indexCursor + 1);\n        ++indexCursor;\n      }\n\n      return acc;\n    }, []);\n\n    mutateElement(element, { points: nextPoints });\n\n    // temp hack to ensure the line doesn't move when adding point to the end,\n    // potentially expanding the bounding box\n    if (pointAddedToEnd) {\n      const lastPoint = element.points[element.points.length - 1];\n      LinearElementEditor.movePoints(element, [\n        {\n          index: element.points.length - 1,\n          point: [lastPoint[0] + 30, lastPoint[1] + 30],\n        },\n      ]);\n    }\n\n    return {\n      appState: {\n        ...appState,\n        editingLinearElement: {\n          ...appState.editingLinearElement,\n          selectedPointsIndices: nextSelectedIndices,\n        },\n      },\n    };\n  }\n\n  static deletePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    pointIndices: readonly number[],\n  ) {\n    let offsetX = 0;\n    let offsetY = 0;\n\n    const isDeletingOriginPoint = pointIndices.includes(0);\n\n    // if deleting first point, make the next to be [0,0] and recalculate\n    // positions of the rest with respect to it\n    if (isDeletingOriginPoint) {\n      const firstNonDeletedPoint = element.points.find((point, idx) => {\n        return !pointIndices.includes(idx);\n      });\n      if (firstNonDeletedPoint) {\n        offsetX = firstNonDeletedPoint[0];\n        offsetY = firstNonDeletedPoint[1];\n      }\n    }\n\n    const nextPoints = element.points.reduce((acc: Point[], point, idx) => {\n      if (!pointIndices.includes(idx)) {\n        acc.push(\n          !acc.length ? [0, 0] : [point[0] - offsetX, point[1] - offsetY],\n        );\n      }\n      return acc;\n    }, []);\n\n    LinearElementEditor._updatePoints(element, nextPoints, offsetX, offsetY);\n  }\n\n  static addPoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    appState: AppState,\n    targetPoints: { point: Point }[],\n  ) {\n    const offsetX = 0;\n    const offsetY = 0;\n\n    const nextPoints = [...element.points, ...targetPoints.map((x) => x.point)];\n    LinearElementEditor._updatePoints(element, nextPoints, offsetX, offsetY);\n  }\n\n  static movePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    targetPoints: { index: number; point: Point; isDragging?: boolean }[],\n    otherUpdates?: { startBinding?: PointBinding; endBinding?: PointBinding },\n  ) {\n    const { points } = element;\n\n    // in case we're moving start point, instead of modifying its position\n    // which would break the invariant of it being at [0,0], we move\n    // all the other points in the opposite direction by delta to\n    // offset it. We do the same with actual element.x/y position, so\n    // this hacks are completely transparent to the user.\n    let offsetX = 0;\n    let offsetY = 0;\n\n    const selectedOriginPoint = targetPoints.find(({ index }) => index === 0);\n\n    if (selectedOriginPoint) {\n      offsetX =\n        selectedOriginPoint.point[0] + points[selectedOriginPoint.index][0];\n      offsetY =\n        selectedOriginPoint.point[1] + points[selectedOriginPoint.index][1];\n    }\n\n    const nextPoints = points.map((point, idx) => {\n      const selectedPointData = targetPoints.find((p) => p.index === idx);\n      if (selectedPointData) {\n        if (selectedOriginPoint) {\n          return point;\n        }\n\n        const deltaX =\n          selectedPointData.point[0] - points[selectedPointData.index][0];\n        const deltaY =\n          selectedPointData.point[1] - points[selectedPointData.index][1];\n\n        return [point[0] + deltaX, point[1] + deltaY] as const;\n      }\n      return offsetX || offsetY\n        ? ([point[0] - offsetX, point[1] - offsetY] as const)\n        : point;\n    });\n\n    LinearElementEditor._updatePoints(\n      element,\n      nextPoints,\n      offsetX,\n      offsetY,\n      otherUpdates,\n    );\n  }\n\n  static shouldAddMidpoint(\n    linearElementEditor: LinearElementEditor,\n    pointerCoords: PointerCoords,\n    appState: AppState,\n  ) {\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n    );\n\n    if (!element) {\n      return false;\n    }\n\n    const { segmentMidpoint } = linearElementEditor.pointerDownState;\n\n    if (\n      segmentMidpoint.added ||\n      segmentMidpoint.value === null ||\n      segmentMidpoint.index === null ||\n      linearElementEditor.pointerDownState.origin === null\n    ) {\n      return false;\n    }\n\n    const origin = linearElementEditor.pointerDownState.origin!;\n    const dist = distance2d(\n      origin.x,\n      origin.y,\n      pointerCoords.x,\n      pointerCoords.y,\n    );\n    if (\n      !appState.editingLinearElement &&\n      dist < DRAGGING_THRESHOLD / appState.zoom.value\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  static addMidpoint(\n    linearElementEditor: LinearElementEditor,\n    pointerCoords: PointerCoords,\n    appState: AppState,\n  ) {\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n    );\n    if (!element) {\n      return;\n    }\n    const { segmentMidpoint } = linearElementEditor.pointerDownState;\n    const ret: {\n      pointerDownState: LinearElementEditor[\"pointerDownState\"];\n      selectedPointsIndices: LinearElementEditor[\"selectedPointsIndices\"];\n    } = {\n      pointerDownState: linearElementEditor.pointerDownState,\n      selectedPointsIndices: linearElementEditor.selectedPointsIndices,\n    };\n\n    const midpoint = LinearElementEditor.createPointAt(\n      element,\n      pointerCoords.x,\n      pointerCoords.y,\n      appState.gridSize,\n    );\n    const points = [\n      ...element.points.slice(0, segmentMidpoint.index!),\n      midpoint,\n      ...element.points.slice(segmentMidpoint.index!),\n    ];\n\n    mutateElement(element, {\n      points,\n    });\n\n    ret.pointerDownState = {\n      ...linearElementEditor.pointerDownState,\n      segmentMidpoint: {\n        ...linearElementEditor.pointerDownState.segmentMidpoint,\n        added: true,\n      },\n      lastClickedPoint: segmentMidpoint.index!,\n    };\n    ret.selectedPointsIndices = [segmentMidpoint.index!];\n    return ret;\n  }\n\n  private static _updatePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    nextPoints: readonly Point[],\n    offsetX: number,\n    offsetY: number,\n    otherUpdates?: { startBinding?: PointBinding; endBinding?: PointBinding },\n  ) {\n    const nextCoords = getElementPointsCoords(element, nextPoints);\n    const prevCoords = getElementPointsCoords(element, element.points);\n    const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;\n    const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;\n    const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;\n    const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;\n    const dX = prevCenterX - nextCenterX;\n    const dY = prevCenterY - nextCenterY;\n    const rotated = rotate(offsetX, offsetY, dX, dY, element.angle);\n    mutateElement(element, {\n      ...otherUpdates,\n      points: nextPoints,\n      x: element.x + rotated[0],\n      y: element.y + rotated[1],\n    });\n  }\n\n  private static _getShiftLockedDelta(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    referencePoint: Point,\n    scenePointer: Point,\n    gridSize: number | null,\n  ) {\n    const referencePointCoords = LinearElementEditor.getPointGlobalCoordinates(\n      element,\n      referencePoint,\n    );\n\n    const [gridX, gridY] = getGridPoint(\n      scenePointer[0],\n      scenePointer[1],\n      gridSize,\n    );\n\n    const { width, height } = getLockedLinearCursorAlignSize(\n      referencePointCoords[0],\n      referencePointCoords[1],\n      gridX,\n      gridY,\n    );\n\n    return rotatePoint([width, height], [0, 0], -element.angle);\n  }\n\n  static getBoundTextElementPosition = (\n    element: ExcalidrawLinearElement,\n    boundTextElement: ExcalidrawTextElementWithContainer,\n  ): { x: number; y: number } => {\n    const points = LinearElementEditor.getPointsGlobalCoordinates(element);\n    if (points.length < 2) {\n      mutateElement(boundTextElement, { isDeleted: true });\n    }\n    let x = 0;\n    let y = 0;\n    if (element.points.length % 2 === 1) {\n      const index = Math.floor(element.points.length / 2);\n      const midPoint = LinearElementEditor.getPointGlobalCoordinates(\n        element,\n        element.points[index],\n      );\n      x = midPoint[0] - boundTextElement.width / 2;\n      y = midPoint[1] - boundTextElement.height / 2;\n    } else {\n      const index = element.points.length / 2 - 1;\n\n      let midSegmentMidpoint = editorMidPointsCache.points[index];\n      if (element.points.length === 2) {\n        midSegmentMidpoint = centerPoint(points[0], points[1]);\n      }\n      if (\n        !midSegmentMidpoint ||\n        editorMidPointsCache.version !== element.version\n      ) {\n        midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(\n          element,\n          points[index],\n          points[index + 1],\n          index + 1,\n        );\n      }\n      x = midSegmentMidpoint[0] - boundTextElement.width / 2;\n      y = midSegmentMidpoint[1] - boundTextElement.height / 2;\n    }\n    return { x, y };\n  };\n\n  static getMinMaxXYWithBoundText = (\n    element: ExcalidrawLinearElement,\n    elementBounds: [number, number, number, number],\n    boundTextElement: ExcalidrawTextElementWithContainer,\n  ): [number, number, number, number, number, number] => {\n    let [x1, y1, x2, y2] = elementBounds;\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const { x: boundTextX1, y: boundTextY1 } =\n      LinearElementEditor.getBoundTextElementPosition(\n        element,\n        boundTextElement,\n      );\n    const boundTextX2 = boundTextX1 + boundTextElement.width;\n    const boundTextY2 = boundTextY1 + boundTextElement.height;\n\n    const topLeftRotatedPoint = rotatePoint([x1, y1], [cx, cy], element.angle);\n    const topRightRotatedPoint = rotatePoint([x2, y1], [cx, cy], element.angle);\n\n    const counterRotateBoundTextTopLeft = rotatePoint(\n      [boundTextX1, boundTextY1],\n\n      [cx, cy],\n\n      -element.angle,\n    );\n    const counterRotateBoundTextTopRight = rotatePoint(\n      [boundTextX2, boundTextY1],\n\n      [cx, cy],\n\n      -element.angle,\n    );\n    const counterRotateBoundTextBottomLeft = rotatePoint(\n      [boundTextX1, boundTextY2],\n\n      [cx, cy],\n\n      -element.angle,\n    );\n    const counterRotateBoundTextBottomRight = rotatePoint(\n      [boundTextX2, boundTextY2],\n\n      [cx, cy],\n\n      -element.angle,\n    );\n\n    if (\n      topLeftRotatedPoint[0] < topRightRotatedPoint[0] &&\n      topLeftRotatedPoint[1] >= topRightRotatedPoint[1]\n    ) {\n      x1 = Math.min(x1, counterRotateBoundTextBottomLeft[0]);\n      x2 = Math.max(\n        x2,\n        Math.max(\n          counterRotateBoundTextTopRight[0],\n          counterRotateBoundTextBottomRight[0],\n        ),\n      );\n      y1 = Math.min(y1, counterRotateBoundTextTopLeft[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextBottomRight[1]);\n    } else if (\n      topLeftRotatedPoint[0] >= topRightRotatedPoint[0] &&\n      topLeftRotatedPoint[1] > topRightRotatedPoint[1]\n    ) {\n      x1 = Math.min(x1, counterRotateBoundTextBottomRight[0]);\n      x2 = Math.max(\n        x2,\n        Math.max(\n          counterRotateBoundTextTopLeft[0],\n          counterRotateBoundTextTopRight[0],\n        ),\n      );\n      y1 = Math.min(y1, counterRotateBoundTextBottomLeft[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextTopRight[1]);\n    } else if (topLeftRotatedPoint[0] >= topRightRotatedPoint[0]) {\n      x1 = Math.min(x1, counterRotateBoundTextTopRight[0]);\n      x2 = Math.max(x2, counterRotateBoundTextBottomLeft[0]);\n      y1 = Math.min(y1, counterRotateBoundTextBottomRight[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextTopLeft[1]);\n    } else if (topLeftRotatedPoint[1] <= topRightRotatedPoint[1]) {\n      x1 = Math.min(\n        x1,\n        Math.min(\n          counterRotateBoundTextTopRight[0],\n          counterRotateBoundTextTopLeft[0],\n        ),\n      );\n\n      x2 = Math.max(x2, counterRotateBoundTextBottomRight[0]);\n      y1 = Math.min(y1, counterRotateBoundTextTopRight[1]);\n      y2 = Math.max(y2, counterRotateBoundTextBottomLeft[1]);\n    }\n\n    return [x1, y1, x2, y2, cx, cy];\n  };\n\n  static getElementAbsoluteCoords = (\n    element: ExcalidrawLinearElement,\n    includeBoundText: boolean = false,\n  ): [number, number, number, number, number, number] => {\n    let coords: [number, number, number, number, number, number];\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    if (element.points.length < 2 || !getShapeForElement(element)) {\n      // XXX this is just a poor estimate and not very useful\n      const { minX, minY, maxX, maxY } = element.points.reduce(\n        (limits, [x, y]) => {\n          limits.minY = Math.min(limits.minY, y);\n          limits.minX = Math.min(limits.minX, x);\n\n          limits.maxX = Math.max(limits.maxX, x);\n          limits.maxY = Math.max(limits.maxY, y);\n\n          return limits;\n        },\n        { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n      );\n      x1 = minX + element.x;\n      y1 = minY + element.y;\n      x2 = maxX + element.x;\n      y2 = maxY + element.y;\n    } else {\n      const shape = getShapeForElement(element)!;\n\n      // first element is always the curve\n      const ops = getCurvePathOps(shape[0]);\n\n      const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n      x1 = minX + element.x;\n      y1 = minY + element.y;\n      x2 = maxX + element.x;\n      y2 = maxY + element.y;\n    }\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    coords = [x1, y1, x2, y2, cx, cy];\n\n    if (!includeBoundText) {\n      return coords;\n    }\n    const boundTextElement = getBoundTextElement(element);\n    if (boundTextElement) {\n      coords = LinearElementEditor.getMinMaxXYWithBoundText(\n        element,\n        [x1, y1, x2, y2],\n        boundTextElement,\n      );\n    }\n\n    return coords;\n  };\n}\n\nconst normalizeSelectedPoints = (\n  points: (number | null)[],\n): number[] | null => {\n  let nextPoints = [\n    ...new Set(points.filter((p) => p !== null && p !== -1)),\n  ] as number[];\n  nextPoints = nextPoints.sort((a, b) => a - b);\n  return nextPoints.length ? nextPoints : null;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}