{"ast":null,"code":"import { SHIFT_LOCKING_ANGLE } from \"../constants\";\nimport { rescalePoints } from \"../points\";\nimport { rotate, adjustXYWithRotation, centerPoint, rotatePoint } from \"../math\";\nimport { getElementAbsoluteCoords, getCommonBounds, getResizedElementAbsoluteCoords, getCommonBoundingBox, getElementPointsCoords } from \"./bounds\";\nimport { isArrowElement, isBoundToContainer, isFrameElement, isFreeDrawElement, isImageElement, isLinearElement, isTextElement } from \"./typeChecks\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getFontString } from \"../utils\";\nimport { updateBoundElements } from \"./binding\";\nimport Scene from \"../scene/Scene\";\nimport { getApproxMinLineWidth, getBoundTextElement, getBoundTextElementId, getContainerElement, handleBindTextResize, getBoundTextMaxWidth, getApproxMinLineHeight, measureText, getBoundTextMaxHeight } from \"./textElement\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nexport const normalizeAngle = angle => {\n  if (angle < 0) {\n    return angle + 2 * Math.PI;\n  }\n  if (angle >= 2 * Math.PI) {\n    return angle - 2 * Math.PI;\n  }\n  return angle;\n};\n\n// Returns true when transform (resizing/rotation) happened\nexport const transformElements = (pointerDownState, transformHandleType, selectedElements, resizeArrowDirection, shouldRotateWithDiscreteAngle, shouldResizeFromCenter, shouldMaintainAspectRatio, pointerX, pointerY, centerX, centerY) => {\n  if (selectedElements.length === 1) {\n    const [element] = selectedElements;\n    if (transformHandleType === \"rotation\") {\n      rotateSingleElement(element, pointerX, pointerY, shouldRotateWithDiscreteAngle, pointerDownState.originalElements);\n      updateBoundElements(element);\n    } else if (isTextElement(element) && (transformHandleType === \"nw\" || transformHandleType === \"ne\" || transformHandleType === \"sw\" || transformHandleType === \"se\")) {\n      resizeSingleTextElement(element, transformHandleType, shouldResizeFromCenter, pointerX, pointerY);\n      updateBoundElements(element);\n    } else if (transformHandleType) {\n      resizeSingleElement(pointerDownState.originalElements, shouldMaintainAspectRatio, element, transformHandleType, shouldResizeFromCenter, pointerX, pointerY);\n    }\n    return true;\n  } else if (selectedElements.length > 1) {\n    if (transformHandleType === \"rotation\") {\n      rotateMultipleElements(pointerDownState, selectedElements, pointerX, pointerY, shouldRotateWithDiscreteAngle, centerX, centerY);\n      return true;\n    } else if (transformHandleType === \"nw\" || transformHandleType === \"ne\" || transformHandleType === \"sw\" || transformHandleType === \"se\") {\n      resizeMultipleElements(pointerDownState, selectedElements, transformHandleType, shouldResizeFromCenter, pointerX, pointerY);\n      return true;\n    }\n  }\n  return false;\n};\nconst rotateSingleElement = (element, pointerX, pointerY, shouldRotateWithDiscreteAngle, originalElements) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  let angle;\n  if (isFrameElement(element)) {\n    angle = 0;\n  } else {\n    angle = 5 * Math.PI / 2 + Math.atan2(pointerY - cy, pointerX - cx);\n    if (shouldRotateWithDiscreteAngle) {\n      angle += SHIFT_LOCKING_ANGLE / 2;\n      angle -= angle % SHIFT_LOCKING_ANGLE;\n    }\n    angle = normalizeAngle(angle);\n  }\n  const boundTextElementId = getBoundTextElementId(element);\n  mutateElement(element, {\n    angle\n  });\n  if (boundTextElementId) {\n    var _Scene$getScene;\n    const textElement = (_Scene$getScene = Scene.getScene(element)) === null || _Scene$getScene === void 0 ? void 0 : _Scene$getScene.getElement(boundTextElementId);\n    if (textElement && !isArrowElement(element)) {\n      mutateElement(textElement, {\n        angle\n      });\n    }\n  }\n};\nconst rescalePointsInElement = (element, width, height, normalizePoints) => isLinearElement(element) || isFreeDrawElement(element) ? {\n  points: rescalePoints(0, width, rescalePoints(1, height, element.points, normalizePoints), normalizePoints)\n} : {};\nconst MIN_FONT_SIZE = 1;\nconst measureFontSizeFromWidth = (element, nextWidth, nextHeight) => {\n  // We only use width to scale font on resize\n  let width = element.width;\n  const hasContainer = isBoundToContainer(element);\n  if (hasContainer) {\n    const container = getContainerElement(element);\n    if (container) {\n      width = getBoundTextMaxWidth(container);\n    }\n  }\n  const nextFontSize = element.fontSize * (nextWidth / width);\n  if (nextFontSize < MIN_FONT_SIZE) {\n    return null;\n  }\n  const metrics = measureText(element.text, getFontString({\n    fontSize: nextFontSize,\n    fontFamily: element.fontFamily\n  }), element.lineHeight);\n  return {\n    size: nextFontSize,\n    baseline: metrics.baseline + (nextHeight - metrics.height)\n  };\n};\nconst getSidesForTransformHandle = (transformHandleType, shouldResizeFromCenter) => {\n  return {\n    n: /^(n|ne|nw)$/.test(transformHandleType) || shouldResizeFromCenter && /^(s|se|sw)$/.test(transformHandleType),\n    s: /^(s|se|sw)$/.test(transformHandleType) || shouldResizeFromCenter && /^(n|ne|nw)$/.test(transformHandleType),\n    w: /^(w|nw|sw)$/.test(transformHandleType) || shouldResizeFromCenter && /^(e|ne|se)$/.test(transformHandleType),\n    e: /^(e|ne|se)$/.test(transformHandleType) || shouldResizeFromCenter && /^(w|nw|sw)$/.test(transformHandleType)\n  };\n};\nconst resizeSingleTextElement = (element, transformHandleType, shouldResizeFromCenter, pointerX, pointerY) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  // rotation pointer with reverse angle\n  const [rotatedX, rotatedY] = rotate(pointerX, pointerY, cx, cy, -element.angle);\n  let scale;\n  switch (transformHandleType) {\n    case \"se\":\n      scale = Math.max((rotatedX - x1) / (x2 - x1), (rotatedY - y1) / (y2 - y1));\n      break;\n    case \"nw\":\n      scale = Math.max((x2 - rotatedX) / (x2 - x1), (y2 - rotatedY) / (y2 - y1));\n      break;\n    case \"ne\":\n      scale = Math.max((rotatedX - x1) / (x2 - x1), (y2 - rotatedY) / (y2 - y1));\n      break;\n    case \"sw\":\n      scale = Math.max((x2 - rotatedX) / (x2 - x1), (rotatedY - y1) / (y2 - y1));\n      break;\n  }\n  if (scale > 0) {\n    const nextWidth = element.width * scale;\n    const nextHeight = element.height * scale;\n    const metrics = measureFontSizeFromWidth(element, nextWidth, nextHeight);\n    if (metrics === null) {\n      return;\n    }\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(element, nextWidth, nextHeight, false);\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n    const [nextElementX, nextElementY] = adjustXYWithRotation(getSidesForTransformHandle(transformHandleType, shouldResizeFromCenter), element.x, element.y, element.angle, deltaX1, deltaY1, deltaX2, deltaY2);\n    mutateElement(element, {\n      fontSize: metrics.size,\n      width: nextWidth,\n      height: nextHeight,\n      baseline: metrics.baseline,\n      x: nextElementX,\n      y: nextElementY\n    });\n  }\n};\nexport const resizeSingleElement = (originalElements, shouldMaintainAspectRatio, element, transformHandleDirection, shouldResizeFromCenter, pointerX, pointerY) => {\n  const stateAtResizeStart = originalElements.get(element.id);\n  // Gets bounds corners\n  const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(stateAtResizeStart, stateAtResizeStart.width, stateAtResizeStart.height, true);\n  const startTopLeft = [x1, y1];\n  const startBottomRight = [x2, y2];\n  const startCenter = centerPoint(startTopLeft, startBottomRight);\n\n  // Calculate new dimensions based on cursor position\n  const rotatedPointer = rotatePoint([pointerX, pointerY], startCenter, -stateAtResizeStart.angle);\n\n  // Get bounds corners rendered on screen\n  const [esx1, esy1, esx2, esy2] = getResizedElementAbsoluteCoords(element, element.width, element.height, true);\n  const boundsCurrentWidth = esx2 - esx1;\n  const boundsCurrentHeight = esy2 - esy1;\n\n  // It's important we set the initial scale value based on the width and height at resize start,\n  // otherwise previous dimensions affected by modifiers will be taken into account.\n  const atStartBoundsWidth = startBottomRight[0] - startTopLeft[0];\n  const atStartBoundsHeight = startBottomRight[1] - startTopLeft[1];\n  let scaleX = atStartBoundsWidth / boundsCurrentWidth;\n  let scaleY = atStartBoundsHeight / boundsCurrentHeight;\n  let boundTextFont = {};\n  const boundTextElement = getBoundTextElement(element);\n  if (transformHandleDirection.includes(\"e\")) {\n    scaleX = (rotatedPointer[0] - startTopLeft[0]) / boundsCurrentWidth;\n  }\n  if (transformHandleDirection.includes(\"s\")) {\n    scaleY = (rotatedPointer[1] - startTopLeft[1]) / boundsCurrentHeight;\n  }\n  if (transformHandleDirection.includes(\"w\")) {\n    scaleX = (startBottomRight[0] - rotatedPointer[0]) / boundsCurrentWidth;\n  }\n  if (transformHandleDirection.includes(\"n\")) {\n    scaleY = (startBottomRight[1] - rotatedPointer[1]) / boundsCurrentHeight;\n  }\n\n  // Linear elements dimensions differ from bounds dimensions\n  const eleInitialWidth = stateAtResizeStart.width;\n  const eleInitialHeight = stateAtResizeStart.height;\n  // We have to use dimensions of element on screen, otherwise the scaling of the\n  // dimensions won't match the cursor for linear elements.\n  let eleNewWidth = element.width * scaleX;\n  let eleNewHeight = element.height * scaleY;\n\n  // adjust dimensions for resizing from center\n  if (shouldResizeFromCenter) {\n    eleNewWidth = 2 * eleNewWidth - eleInitialWidth;\n    eleNewHeight = 2 * eleNewHeight - eleInitialHeight;\n  }\n\n  // adjust dimensions to keep sides ratio\n  if (shouldMaintainAspectRatio) {\n    const widthRatio = Math.abs(eleNewWidth) / eleInitialWidth;\n    const heightRatio = Math.abs(eleNewHeight) / eleInitialHeight;\n    if (transformHandleDirection.length === 1) {\n      eleNewHeight *= widthRatio;\n      eleNewWidth *= heightRatio;\n    }\n    if (transformHandleDirection.length === 2) {\n      const ratio = Math.max(widthRatio, heightRatio);\n      eleNewWidth = eleInitialWidth * ratio * Math.sign(eleNewWidth);\n      eleNewHeight = eleInitialHeight * ratio * Math.sign(eleNewHeight);\n    }\n  }\n  if (boundTextElement) {\n    const stateOfBoundTextElementAtResize = originalElements.get(boundTextElement.id);\n    if (stateOfBoundTextElementAtResize) {\n      boundTextFont = {\n        fontSize: stateOfBoundTextElementAtResize.fontSize,\n        baseline: stateOfBoundTextElementAtResize.baseline\n      };\n    }\n    if (shouldMaintainAspectRatio) {\n      const updatedElement = {\n        ...element,\n        width: eleNewWidth,\n        height: eleNewHeight\n      };\n      const nextFont = measureFontSizeFromWidth(boundTextElement, getBoundTextMaxWidth(updatedElement), getBoundTextMaxHeight(updatedElement, boundTextElement));\n      if (nextFont === null) {\n        return;\n      }\n      boundTextFont = {\n        fontSize: nextFont.size,\n        baseline: nextFont.baseline\n      };\n    } else {\n      const minWidth = getApproxMinLineWidth(getFontString(boundTextElement), boundTextElement.lineHeight);\n      const minHeight = getApproxMinLineHeight(boundTextElement.fontSize, boundTextElement.lineHeight);\n      eleNewWidth = Math.ceil(Math.max(eleNewWidth, minWidth));\n      eleNewHeight = Math.ceil(Math.max(eleNewHeight, minHeight));\n    }\n  }\n  const [newBoundsX1, newBoundsY1, newBoundsX2, newBoundsY2] = getResizedElementAbsoluteCoords(stateAtResizeStart, eleNewWidth, eleNewHeight, true);\n  const newBoundsWidth = newBoundsX2 - newBoundsX1;\n  const newBoundsHeight = newBoundsY2 - newBoundsY1;\n\n  // Calculate new topLeft based on fixed corner during resize\n  let newTopLeft = [...startTopLeft];\n  if ([\"n\", \"w\", \"nw\"].includes(transformHandleDirection)) {\n    newTopLeft = [startBottomRight[0] - Math.abs(newBoundsWidth), startBottomRight[1] - Math.abs(newBoundsHeight)];\n  }\n  if (transformHandleDirection === \"ne\") {\n    const bottomLeft = [startTopLeft[0], startBottomRight[1]];\n    newTopLeft = [bottomLeft[0], bottomLeft[1] - Math.abs(newBoundsHeight)];\n  }\n  if (transformHandleDirection === \"sw\") {\n    const topRight = [startBottomRight[0], startTopLeft[1]];\n    newTopLeft = [topRight[0] - Math.abs(newBoundsWidth), topRight[1]];\n  }\n\n  // Keeps opposite handle fixed during resize\n  if (shouldMaintainAspectRatio) {\n    if ([\"s\", \"n\"].includes(transformHandleDirection)) {\n      newTopLeft[0] = startCenter[0] - newBoundsWidth / 2;\n    }\n    if ([\"e\", \"w\"].includes(transformHandleDirection)) {\n      newTopLeft[1] = startCenter[1] - newBoundsHeight / 2;\n    }\n  }\n\n  // Flip horizontally\n  if (eleNewWidth < 0) {\n    if (transformHandleDirection.includes(\"e\")) {\n      newTopLeft[0] -= Math.abs(newBoundsWidth);\n    }\n    if (transformHandleDirection.includes(\"w\")) {\n      newTopLeft[0] += Math.abs(newBoundsWidth);\n    }\n  }\n  // Flip vertically\n  if (eleNewHeight < 0) {\n    if (transformHandleDirection.includes(\"s\")) {\n      newTopLeft[1] -= Math.abs(newBoundsHeight);\n    }\n    if (transformHandleDirection.includes(\"n\")) {\n      newTopLeft[1] += Math.abs(newBoundsHeight);\n    }\n  }\n  if (shouldResizeFromCenter) {\n    newTopLeft[0] = startCenter[0] - Math.abs(newBoundsWidth) / 2;\n    newTopLeft[1] = startCenter[1] - Math.abs(newBoundsHeight) / 2;\n  }\n\n  // adjust topLeft to new rotation point\n  const angle = stateAtResizeStart.angle;\n  const rotatedTopLeft = rotatePoint(newTopLeft, startCenter, angle);\n  const newCenter = [newTopLeft[0] + Math.abs(newBoundsWidth) / 2, newTopLeft[1] + Math.abs(newBoundsHeight) / 2];\n  const rotatedNewCenter = rotatePoint(newCenter, startCenter, angle);\n  newTopLeft = rotatePoint(rotatedTopLeft, rotatedNewCenter, -angle);\n\n  // Readjust points for linear elements\n  let rescaledElementPointsY;\n  let rescaledPoints;\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    rescaledElementPointsY = rescalePoints(1, eleNewHeight, stateAtResizeStart.points, true);\n    rescaledPoints = rescalePoints(0, eleNewWidth, rescaledElementPointsY, true);\n  }\n\n  // For linear elements (x,y) are the coordinates of the first drawn point not the top-left corner\n  // So we need to readjust (x,y) to be where the first point should be\n  const newOrigin = [...newTopLeft];\n  newOrigin[0] += stateAtResizeStart.x - newBoundsX1;\n  newOrigin[1] += stateAtResizeStart.y - newBoundsY1;\n  const resizedElement = {\n    width: Math.abs(eleNewWidth),\n    height: Math.abs(eleNewHeight),\n    x: newOrigin[0],\n    y: newOrigin[1],\n    points: rescaledPoints\n  };\n  if (\"scale\" in element && \"scale\" in stateAtResizeStart) {\n    mutateElement(element, {\n      scale: [\n      // defaulting because scaleX/Y can be 0/-0\n      (Math.sign(newBoundsX2 - stateAtResizeStart.x) || stateAtResizeStart.scale[0]) * stateAtResizeStart.scale[0], (Math.sign(newBoundsY2 - stateAtResizeStart.y) || stateAtResizeStart.scale[1]) * stateAtResizeStart.scale[1]]\n    });\n  }\n  if (resizedElement.width !== 0 && resizedElement.height !== 0 && Number.isFinite(resizedElement.x) && Number.isFinite(resizedElement.y)) {\n    updateBoundElements(element, {\n      newSize: {\n        width: resizedElement.width,\n        height: resizedElement.height\n      }\n    });\n    mutateElement(element, resizedElement);\n    if (boundTextElement && boundTextFont != null) {\n      mutateElement(boundTextElement, {\n        fontSize: boundTextFont.fontSize,\n        baseline: boundTextFont.baseline\n      });\n    }\n    handleBindTextResize(element, transformHandleDirection);\n  }\n};\nexport const resizeMultipleElements = (pointerDownState, selectedElements, transformHandleType, shouldResizeFromCenter, pointerX, pointerY) => {\n  var _Scene$getScene2;\n  // map selected elements to the original elements. While it never should\n  // happen that pointerDownState.originalElements won't contain the selected\n  // elements during resize, this coupling isn't guaranteed, so to ensure\n  // type safety we need to transform only those elements we filter.\n  const targetElements = selectedElements.reduce((acc, element) => {\n    const origElement = pointerDownState.originalElements.get(element.id);\n    if (origElement) {\n      acc.push({\n        orig: origElement,\n        latest: element\n      });\n    }\n    return acc;\n  }, []);\n\n  // getCommonBoundingBox() uses getBoundTextElement() which returns null for\n  // original elements from pointerDownState, so we have to find and add these\n  // bound text elements manually. Additionally, the coordinates of bound text\n  // elements aren't always up to date.\n  const boundTextElements = targetElements.reduce((acc, _ref) => {\n    var _pointerDownState$ori;\n    let {\n      orig\n    } = _ref;\n    if (!isLinearElement(orig)) {\n      return acc;\n    }\n    const textId = getBoundTextElementId(orig);\n    if (!textId) {\n      return acc;\n    }\n    const text = (_pointerDownState$ori = pointerDownState.originalElements.get(textId)) !== null && _pointerDownState$ori !== void 0 ? _pointerDownState$ori : null;\n    if (!isBoundToContainer(text)) {\n      return acc;\n    }\n    const xy = LinearElementEditor.getBoundTextElementPosition(orig, text);\n    return [...acc, {\n      ...text,\n      ...xy\n    }];\n  }, []);\n  const {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    midX,\n    midY\n  } = getCommonBoundingBox(targetElements.map(_ref2 => {\n    let {\n      orig\n    } = _ref2;\n    return orig;\n  }).concat(boundTextElements));\n  const direction = transformHandleType;\n  const mapDirectionsToAnchors = {\n    ne: [minX, maxY],\n    se: [minX, minY],\n    sw: [maxX, minY],\n    nw: [maxX, maxY]\n  };\n\n  // anchor point must be on the opposite side of the dragged selection handle\n  // or be the center of the selection if shouldResizeFromCenter\n  const [anchorX, anchorY] = shouldResizeFromCenter ? [midX, midY] : mapDirectionsToAnchors[direction];\n  const scale = Math.max(Math.abs(pointerX - anchorX) / (maxX - minX) || 0, Math.abs(pointerY - anchorY) / (maxY - minY) || 0) * (shouldResizeFromCenter ? 2 : 1);\n  if (scale === 0) {\n    return;\n  }\n  const mapDirectionsToPointerPositions = {\n    ne: [pointerX >= anchorX, pointerY <= anchorY],\n    se: [pointerX >= anchorX, pointerY >= anchorY],\n    sw: [pointerX <= anchorX, pointerY >= anchorY],\n    nw: [pointerX <= anchorX, pointerY <= anchorY]\n  };\n\n  /**\n   * to flip an element:\n   * 1. determine over which axis is the element being flipped\n   *    (could be x, y, or both) indicated by `flipFactorX` & `flipFactorY`\n   * 2. shift element's position by the amount of width or height (or both) or\n   *    mirror points in the case of linear & freedraw elemenets\n   * 3. adjust element angle\n   */\n  const [flipFactorX, flipFactorY] = mapDirectionsToPointerPositions[direction].map(condition => condition ? 1 : -1);\n  const isFlippedByX = flipFactorX < 0;\n  const isFlippedByY = flipFactorY < 0;\n  const elementsAndUpdates = [];\n  for (const {\n    orig,\n    latest\n  } of targetElements) {\n    // bounded text elements are updated along with their container elements\n    if (isTextElement(orig) && isBoundToContainer(orig)) {\n      continue;\n    }\n    const width = orig.width * scale;\n    const height = orig.height * scale;\n    const angle = normalizeAngle(orig.angle * flipFactorX * flipFactorY);\n    const isLinearOrFreeDraw = isLinearElement(orig) || isFreeDrawElement(orig);\n    const offsetX = orig.x - anchorX;\n    const offsetY = orig.y - anchorY;\n    const shiftX = isFlippedByX && !isLinearOrFreeDraw ? width : 0;\n    const shiftY = isFlippedByY && !isLinearOrFreeDraw ? height : 0;\n    const x = anchorX + flipFactorX * (offsetX * scale + shiftX);\n    const y = anchorY + flipFactorY * (offsetY * scale + shiftY);\n    const rescaledPoints = rescalePointsInElement(orig, width * flipFactorX, height * flipFactorY, false);\n    const update = {\n      x,\n      y,\n      width,\n      height,\n      angle,\n      ...rescaledPoints\n    };\n    if (isImageElement(orig) && targetElements.length === 1) {\n      update.scale = [orig.scale[0] * flipFactorX, orig.scale[1] * flipFactorY];\n    }\n    if (isLinearElement(orig) && (isFlippedByX || isFlippedByY)) {\n      const origBounds = getElementPointsCoords(orig, orig.points);\n      const newBounds = getElementPointsCoords({\n        ...orig,\n        x,\n        y\n      }, rescaledPoints.points);\n      const origXY = [orig.x, orig.y];\n      const newXY = [x, y];\n      const linearShift = axis => {\n        const i = axis === \"x\" ? 0 : 1;\n        return (newBounds[i + 2] - newXY[i] - (origXY[i] - origBounds[i]) * scale + (origBounds[i + 2] - origXY[i]) * scale - (newXY[i] - newBounds[i])) / 2;\n      };\n      if (isFlippedByX) {\n        update.x -= linearShift(\"x\");\n      }\n      if (isFlippedByY) {\n        update.y -= linearShift(\"y\");\n      }\n    }\n    let boundText = null;\n    const boundTextElement = getBoundTextElement(latest);\n    if (boundTextElement || isTextElement(orig)) {\n      const updatedElement = {\n        ...latest,\n        width,\n        height\n      };\n      const metrics = measureFontSizeFromWidth(boundTextElement !== null && boundTextElement !== void 0 ? boundTextElement : orig, boundTextElement ? getBoundTextMaxWidth(updatedElement) : updatedElement.width, boundTextElement ? getBoundTextMaxHeight(updatedElement, boundTextElement) : updatedElement.height);\n      if (!metrics) {\n        return;\n      }\n      if (isTextElement(orig)) {\n        update.fontSize = metrics.size;\n        update.baseline = metrics.baseline;\n      }\n      if (boundTextElement) {\n        boundText = {\n          element: boundTextElement,\n          fontSize: metrics.size,\n          baseline: metrics.baseline\n        };\n      }\n    }\n    elementsAndUpdates.push({\n      element: latest,\n      update,\n      boundText\n    });\n  }\n  const elementsToUpdate = elementsAndUpdates.map(_ref3 => {\n    let {\n      element\n    } = _ref3;\n    return element;\n  });\n  for (const {\n    element,\n    update,\n    boundText\n  } of elementsAndUpdates) {\n    const {\n      width,\n      height,\n      angle\n    } = update;\n    mutateElement(element, update, false);\n    updateBoundElements(element, {\n      simultaneouslyUpdated: elementsToUpdate,\n      newSize: {\n        width,\n        height\n      }\n    });\n    if (boundText) {\n      const {\n        element: boundTextElement,\n        ...boundTextUpdates\n      } = boundText;\n      mutateElement(boundTextElement, {\n        ...boundTextUpdates,\n        angle: isLinearElement(element) ? undefined : angle\n      }, false);\n      handleBindTextResize(element, transformHandleType);\n    }\n  }\n  (_Scene$getScene2 = Scene.getScene(elementsAndUpdates[0].element)) === null || _Scene$getScene2 === void 0 ? void 0 : _Scene$getScene2.informMutation();\n};\nconst rotateMultipleElements = (pointerDownState, elements, pointerX, pointerY, shouldRotateWithDiscreteAngle, centerX, centerY) => {\n  var _Scene$getScene3;\n  let centerAngle = 5 * Math.PI / 2 + Math.atan2(pointerY - centerY, pointerX - centerX);\n  if (shouldRotateWithDiscreteAngle) {\n    centerAngle += SHIFT_LOCKING_ANGLE / 2;\n    centerAngle -= centerAngle % SHIFT_LOCKING_ANGLE;\n  }\n  elements.filter(element => element.type !== \"frame\").forEach(element => {\n    var _pointerDownState$ori2, _pointerDownState$ori3;\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const origAngle = (_pointerDownState$ori2 = (_pointerDownState$ori3 = pointerDownState.originalElements.get(element.id)) === null || _pointerDownState$ori3 === void 0 ? void 0 : _pointerDownState$ori3.angle) !== null && _pointerDownState$ori2 !== void 0 ? _pointerDownState$ori2 : element.angle;\n    const [rotatedCX, rotatedCY] = rotate(cx, cy, centerX, centerY, centerAngle + origAngle - element.angle);\n    mutateElement(element, {\n      x: element.x + (rotatedCX - cx),\n      y: element.y + (rotatedCY - cy),\n      angle: normalizeAngle(centerAngle + origAngle)\n    }, false);\n    updateBoundElements(element, {\n      simultaneouslyUpdated: elements\n    });\n    const boundText = getBoundTextElement(element);\n    if (boundText && !isArrowElement(element)) {\n      mutateElement(boundText, {\n        x: boundText.x + (rotatedCX - cx),\n        y: boundText.y + (rotatedCY - cy),\n        angle: normalizeAngle(centerAngle + origAngle)\n      }, false);\n    }\n  });\n  (_Scene$getScene3 = Scene.getScene(elements[0])) === null || _Scene$getScene3 === void 0 ? void 0 : _Scene$getScene3.informMutation();\n};\nexport const getResizeOffsetXY = (transformHandleType, selectedElements, x, y) => {\n  const [x1, y1, x2, y2] = selectedElements.length === 1 ? getElementAbsoluteCoords(selectedElements[0]) : getCommonBounds(selectedElements);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  const angle = selectedElements.length === 1 ? selectedElements[0].angle : 0;\n  [x, y] = rotate(x, y, cx, cy, -angle);\n  switch (transformHandleType) {\n    case \"n\":\n      return rotate(x - (x1 + x2) / 2, y - y1, 0, 0, angle);\n    case \"s\":\n      return rotate(x - (x1 + x2) / 2, y - y2, 0, 0, angle);\n    case \"w\":\n      return rotate(x - x1, y - (y1 + y2) / 2, 0, 0, angle);\n    case \"e\":\n      return rotate(x - x2, y - (y1 + y2) / 2, 0, 0, angle);\n    case \"nw\":\n      return rotate(x - x1, y - y1, 0, 0, angle);\n    case \"ne\":\n      return rotate(x - x2, y - y1, 0, 0, angle);\n    case \"sw\":\n      return rotate(x - x1, y - y2, 0, 0, angle);\n    case \"se\":\n      return rotate(x - x2, y - y2, 0, 0, angle);\n    default:\n      return [0, 0];\n  }\n};\nexport const getResizeArrowDirection = (transformHandleType, element) => {\n  const [, [px, py]] = element.points;\n  const isResizeEnd = transformHandleType === \"nw\" && (px < 0 || py < 0) || transformHandleType === \"ne\" && px >= 0 || transformHandleType === \"sw\" && px <= 0 || transformHandleType === \"se\" && (px > 0 || py > 0);\n  return isResizeEnd ? \"end\" : \"origin\";\n};","map":{"version":3,"names":["SHIFT_LOCKING_ANGLE","rescalePoints","rotate","adjustXYWithRotation","centerPoint","rotatePoint","getElementAbsoluteCoords","getCommonBounds","getResizedElementAbsoluteCoords","getCommonBoundingBox","getElementPointsCoords","isArrowElement","isBoundToContainer","isFrameElement","isFreeDrawElement","isImageElement","isLinearElement","isTextElement","mutateElement","getFontString","updateBoundElements","Scene","getApproxMinLineWidth","getBoundTextElement","getBoundTextElementId","getContainerElement","handleBindTextResize","getBoundTextMaxWidth","getApproxMinLineHeight","measureText","getBoundTextMaxHeight","LinearElementEditor","normalizeAngle","angle","Math","PI","transformElements","pointerDownState","transformHandleType","selectedElements","resizeArrowDirection","shouldRotateWithDiscreteAngle","shouldResizeFromCenter","shouldMaintainAspectRatio","pointerX","pointerY","centerX","centerY","length","element","rotateSingleElement","originalElements","resizeSingleTextElement","resizeSingleElement","rotateMultipleElements","resizeMultipleElements","x1","y1","x2","y2","cx","cy","atan2","boundTextElementId","_Scene$getScene","textElement","getScene","getElement","rescalePointsInElement","width","height","normalizePoints","points","MIN_FONT_SIZE","measureFontSizeFromWidth","nextWidth","nextHeight","hasContainer","container","nextFontSize","fontSize","metrics","text","fontFamily","lineHeight","size","baseline","getSidesForTransformHandle","n","test","s","w","e","rotatedX","rotatedY","scale","max","nextX1","nextY1","nextX2","nextY2","deltaX1","deltaY1","deltaX2","deltaY2","nextElementX","nextElementY","x","y","transformHandleDirection","stateAtResizeStart","get","id","startTopLeft","startBottomRight","startCenter","rotatedPointer","esx1","esy1","esx2","esy2","boundsCurrentWidth","boundsCurrentHeight","atStartBoundsWidth","atStartBoundsHeight","scaleX","scaleY","boundTextFont","boundTextElement","includes","eleInitialWidth","eleInitialHeight","eleNewWidth","eleNewHeight","widthRatio","abs","heightRatio","ratio","sign","stateOfBoundTextElementAtResize","updatedElement","nextFont","minWidth","minHeight","ceil","newBoundsX1","newBoundsY1","newBoundsX2","newBoundsY2","newBoundsWidth","newBoundsHeight","newTopLeft","bottomLeft","topRight","rotatedTopLeft","newCenter","rotatedNewCenter","rescaledElementPointsY","rescaledPoints","newOrigin","resizedElement","Number","isFinite","newSize","_Scene$getScene2","targetElements","reduce","acc","origElement","push","orig","latest","boundTextElements","_ref","_pointerDownState$ori","textId","xy","getBoundTextElementPosition","minX","minY","maxX","maxY","midX","midY","map","_ref2","concat","direction","mapDirectionsToAnchors","ne","se","sw","nw","anchorX","anchorY","mapDirectionsToPointerPositions","flipFactorX","flipFactorY","condition","isFlippedByX","isFlippedByY","elementsAndUpdates","isLinearOrFreeDraw","offsetX","offsetY","shiftX","shiftY","update","origBounds","newBounds","origXY","newXY","linearShift","axis","i","boundText","elementsToUpdate","_ref3","simultaneouslyUpdated","boundTextUpdates","undefined","informMutation","elements","_Scene$getScene3","centerAngle","filter","type","forEach","_pointerDownState$ori2","_pointerDownState$ori3","origAngle","rotatedCX","rotatedCY","getResizeOffsetXY","getResizeArrowDirection","px","py","isResizeEnd"],"sources":["D:/project/excalidraw-cn/src/element/resizeElements.ts"],"sourcesContent":["import { SHIFT_LOCKING_ANGLE } from \"../constants\";\nimport { rescalePoints } from \"../points\";\n\nimport {\n  rotate,\n  adjustXYWithRotation,\n  centerPoint,\n  rotatePoint,\n} from \"../math\";\nimport {\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ExcalidrawElement,\n  ExcalidrawTextElementWithContainer,\n  ExcalidrawImageElement,\n} from \"./types\";\nimport type { Mutable } from \"../utility-types\";\nimport {\n  getElementAbsoluteCoords,\n  getCommonBounds,\n  getResizedElementAbsoluteCoords,\n  getCommonBoundingBox,\n  getElementPointsCoords,\n} from \"./bounds\";\nimport {\n  isArrowElement,\n  isBoundToContainer,\n  isFrameElement,\n  isFreeDrawElement,\n  isImageElement,\n  isLinearElement,\n  isTextElement,\n} from \"./typeChecks\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getFontString } from \"../utils\";\nimport { updateBoundElements } from \"./binding\";\nimport {\n  TransformHandleType,\n  MaybeTransformHandleType,\n  TransformHandleDirection,\n} from \"./transformHandles\";\nimport { Point, PointerDownState } from \"../types\";\nimport Scene from \"../scene/Scene\";\nimport {\n  getApproxMinLineWidth,\n  getBoundTextElement,\n  getBoundTextElementId,\n  getContainerElement,\n  handleBindTextResize,\n  getBoundTextMaxWidth,\n  getApproxMinLineHeight,\n  measureText,\n  getBoundTextMaxHeight,\n} from \"./textElement\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\n\nexport const normalizeAngle = (angle: number): number => {\n  if (angle < 0) {\n    return angle + 2 * Math.PI;\n  }\n  if (angle >= 2 * Math.PI) {\n    return angle - 2 * Math.PI;\n  }\n  return angle;\n};\n\n// Returns true when transform (resizing/rotation) happened\nexport const transformElements = (\n  pointerDownState: PointerDownState,\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  resizeArrowDirection: \"origin\" | \"end\",\n  shouldRotateWithDiscreteAngle: boolean,\n  shouldResizeFromCenter: boolean,\n  shouldMaintainAspectRatio: boolean,\n  pointerX: number,\n  pointerY: number,\n  centerX: number,\n  centerY: number,\n) => {\n  if (selectedElements.length === 1) {\n    const [element] = selectedElements;\n    if (transformHandleType === \"rotation\") {\n      rotateSingleElement(\n        element,\n        pointerX,\n        pointerY,\n        shouldRotateWithDiscreteAngle,\n        pointerDownState.originalElements,\n      );\n      updateBoundElements(element);\n    } else if (\n      isTextElement(element) &&\n      (transformHandleType === \"nw\" ||\n        transformHandleType === \"ne\" ||\n        transformHandleType === \"sw\" ||\n        transformHandleType === \"se\")\n    ) {\n      resizeSingleTextElement(\n        element,\n        transformHandleType,\n        shouldResizeFromCenter,\n        pointerX,\n        pointerY,\n      );\n      updateBoundElements(element);\n    } else if (transformHandleType) {\n      resizeSingleElement(\n        pointerDownState.originalElements,\n        shouldMaintainAspectRatio,\n        element,\n        transformHandleType,\n        shouldResizeFromCenter,\n        pointerX,\n        pointerY,\n      );\n    }\n\n    return true;\n  } else if (selectedElements.length > 1) {\n    if (transformHandleType === \"rotation\") {\n      rotateMultipleElements(\n        pointerDownState,\n        selectedElements,\n        pointerX,\n        pointerY,\n        shouldRotateWithDiscreteAngle,\n        centerX,\n        centerY,\n      );\n      return true;\n    } else if (\n      transformHandleType === \"nw\" ||\n      transformHandleType === \"ne\" ||\n      transformHandleType === \"sw\" ||\n      transformHandleType === \"se\"\n    ) {\n      resizeMultipleElements(\n        pointerDownState,\n        selectedElements,\n        transformHandleType,\n        shouldResizeFromCenter,\n        pointerX,\n        pointerY,\n      );\n      return true;\n    }\n  }\n  return false;\n};\n\nconst rotateSingleElement = (\n  element: NonDeletedExcalidrawElement,\n  pointerX: number,\n  pointerY: number,\n  shouldRotateWithDiscreteAngle: boolean,\n  originalElements: Map<string, NonDeleted<ExcalidrawElement>>,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  let angle: number;\n  if (isFrameElement(element)) {\n    angle = 0;\n  } else {\n    angle = (5 * Math.PI) / 2 + Math.atan2(pointerY - cy, pointerX - cx);\n    if (shouldRotateWithDiscreteAngle) {\n      angle += SHIFT_LOCKING_ANGLE / 2;\n      angle -= angle % SHIFT_LOCKING_ANGLE;\n    }\n    angle = normalizeAngle(angle);\n  }\n  const boundTextElementId = getBoundTextElementId(element);\n\n  mutateElement(element, { angle });\n  if (boundTextElementId) {\n    const textElement =\n      Scene.getScene(element)?.getElement<ExcalidrawTextElementWithContainer>(\n        boundTextElementId,\n      );\n\n    if (textElement && !isArrowElement(element)) {\n      mutateElement(textElement, { angle });\n    }\n  }\n};\n\nconst rescalePointsInElement = (\n  element: NonDeletedExcalidrawElement,\n  width: number,\n  height: number,\n  normalizePoints: boolean,\n) =>\n  isLinearElement(element) || isFreeDrawElement(element)\n    ? {\n        points: rescalePoints(\n          0,\n          width,\n          rescalePoints(1, height, element.points, normalizePoints),\n          normalizePoints,\n        ),\n      }\n    : {};\n\nconst MIN_FONT_SIZE = 1;\n\nconst measureFontSizeFromWidth = (\n  element: NonDeleted<ExcalidrawTextElement>,\n  nextWidth: number,\n  nextHeight: number,\n): { size: number; baseline: number } | null => {\n  // We only use width to scale font on resize\n  let width = element.width;\n\n  const hasContainer = isBoundToContainer(element);\n  if (hasContainer) {\n    const container = getContainerElement(element);\n    if (container) {\n      width = getBoundTextMaxWidth(container);\n    }\n  }\n  const nextFontSize = element.fontSize * (nextWidth / width);\n  if (nextFontSize < MIN_FONT_SIZE) {\n    return null;\n  }\n  const metrics = measureText(\n    element.text,\n    getFontString({ fontSize: nextFontSize, fontFamily: element.fontFamily }),\n    element.lineHeight,\n  );\n  return {\n    size: nextFontSize,\n    baseline: metrics.baseline + (nextHeight - metrics.height),\n  };\n};\n\nconst getSidesForTransformHandle = (\n  transformHandleType: TransformHandleType,\n  shouldResizeFromCenter: boolean,\n) => {\n  return {\n    n:\n      /^(n|ne|nw)$/.test(transformHandleType) ||\n      (shouldResizeFromCenter && /^(s|se|sw)$/.test(transformHandleType)),\n    s:\n      /^(s|se|sw)$/.test(transformHandleType) ||\n      (shouldResizeFromCenter && /^(n|ne|nw)$/.test(transformHandleType)),\n    w:\n      /^(w|nw|sw)$/.test(transformHandleType) ||\n      (shouldResizeFromCenter && /^(e|ne|se)$/.test(transformHandleType)),\n    e:\n      /^(e|ne|se)$/.test(transformHandleType) ||\n      (shouldResizeFromCenter && /^(w|nw|sw)$/.test(transformHandleType)),\n  };\n};\n\nconst resizeSingleTextElement = (\n  element: NonDeleted<ExcalidrawTextElement>,\n  transformHandleType: \"nw\" | \"ne\" | \"sw\" | \"se\",\n  shouldResizeFromCenter: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  // rotation pointer with reverse angle\n  const [rotatedX, rotatedY] = rotate(\n    pointerX,\n    pointerY,\n    cx,\n    cy,\n    -element.angle,\n  );\n  let scale: number;\n  switch (transformHandleType) {\n    case \"se\":\n      scale = Math.max(\n        (rotatedX - x1) / (x2 - x1),\n        (rotatedY - y1) / (y2 - y1),\n      );\n      break;\n    case \"nw\":\n      scale = Math.max(\n        (x2 - rotatedX) / (x2 - x1),\n        (y2 - rotatedY) / (y2 - y1),\n      );\n      break;\n    case \"ne\":\n      scale = Math.max(\n        (rotatedX - x1) / (x2 - x1),\n        (y2 - rotatedY) / (y2 - y1),\n      );\n      break;\n    case \"sw\":\n      scale = Math.max(\n        (x2 - rotatedX) / (x2 - x1),\n        (rotatedY - y1) / (y2 - y1),\n      );\n      break;\n  }\n  if (scale > 0) {\n    const nextWidth = element.width * scale;\n    const nextHeight = element.height * scale;\n    const metrics = measureFontSizeFromWidth(element, nextWidth, nextHeight);\n    if (metrics === null) {\n      return;\n    }\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n      false,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n    const [nextElementX, nextElementY] = adjustXYWithRotation(\n      getSidesForTransformHandle(transformHandleType, shouldResizeFromCenter),\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n    mutateElement(element, {\n      fontSize: metrics.size,\n      width: nextWidth,\n      height: nextHeight,\n      baseline: metrics.baseline,\n      x: nextElementX,\n      y: nextElementY,\n    });\n  }\n};\n\nexport const resizeSingleElement = (\n  originalElements: PointerDownState[\"originalElements\"],\n  shouldMaintainAspectRatio: boolean,\n  element: NonDeletedExcalidrawElement,\n  transformHandleDirection: TransformHandleDirection,\n  shouldResizeFromCenter: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  const stateAtResizeStart = originalElements.get(element.id)!;\n  // Gets bounds corners\n  const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(\n    stateAtResizeStart,\n    stateAtResizeStart.width,\n    stateAtResizeStart.height,\n    true,\n  );\n  const startTopLeft: Point = [x1, y1];\n  const startBottomRight: Point = [x2, y2];\n  const startCenter: Point = centerPoint(startTopLeft, startBottomRight);\n\n  // Calculate new dimensions based on cursor position\n  const rotatedPointer = rotatePoint(\n    [pointerX, pointerY],\n    startCenter,\n    -stateAtResizeStart.angle,\n  );\n\n  // Get bounds corners rendered on screen\n  const [esx1, esy1, esx2, esy2] = getResizedElementAbsoluteCoords(\n    element,\n    element.width,\n    element.height,\n    true,\n  );\n\n  const boundsCurrentWidth = esx2 - esx1;\n  const boundsCurrentHeight = esy2 - esy1;\n\n  // It's important we set the initial scale value based on the width and height at resize start,\n  // otherwise previous dimensions affected by modifiers will be taken into account.\n  const atStartBoundsWidth = startBottomRight[0] - startTopLeft[0];\n  const atStartBoundsHeight = startBottomRight[1] - startTopLeft[1];\n  let scaleX = atStartBoundsWidth / boundsCurrentWidth;\n  let scaleY = atStartBoundsHeight / boundsCurrentHeight;\n\n  let boundTextFont: { fontSize?: number; baseline?: number } = {};\n  const boundTextElement = getBoundTextElement(element);\n\n  if (transformHandleDirection.includes(\"e\")) {\n    scaleX = (rotatedPointer[0] - startTopLeft[0]) / boundsCurrentWidth;\n  }\n  if (transformHandleDirection.includes(\"s\")) {\n    scaleY = (rotatedPointer[1] - startTopLeft[1]) / boundsCurrentHeight;\n  }\n  if (transformHandleDirection.includes(\"w\")) {\n    scaleX = (startBottomRight[0] - rotatedPointer[0]) / boundsCurrentWidth;\n  }\n  if (transformHandleDirection.includes(\"n\")) {\n    scaleY = (startBottomRight[1] - rotatedPointer[1]) / boundsCurrentHeight;\n  }\n\n  // Linear elements dimensions differ from bounds dimensions\n  const eleInitialWidth = stateAtResizeStart.width;\n  const eleInitialHeight = stateAtResizeStart.height;\n  // We have to use dimensions of element on screen, otherwise the scaling of the\n  // dimensions won't match the cursor for linear elements.\n  let eleNewWidth = element.width * scaleX;\n  let eleNewHeight = element.height * scaleY;\n\n  // adjust dimensions for resizing from center\n  if (shouldResizeFromCenter) {\n    eleNewWidth = 2 * eleNewWidth - eleInitialWidth;\n    eleNewHeight = 2 * eleNewHeight - eleInitialHeight;\n  }\n\n  // adjust dimensions to keep sides ratio\n  if (shouldMaintainAspectRatio) {\n    const widthRatio = Math.abs(eleNewWidth) / eleInitialWidth;\n    const heightRatio = Math.abs(eleNewHeight) / eleInitialHeight;\n    if (transformHandleDirection.length === 1) {\n      eleNewHeight *= widthRatio;\n      eleNewWidth *= heightRatio;\n    }\n    if (transformHandleDirection.length === 2) {\n      const ratio = Math.max(widthRatio, heightRatio);\n      eleNewWidth = eleInitialWidth * ratio * Math.sign(eleNewWidth);\n      eleNewHeight = eleInitialHeight * ratio * Math.sign(eleNewHeight);\n    }\n  }\n\n  if (boundTextElement) {\n    const stateOfBoundTextElementAtResize = originalElements.get(\n      boundTextElement.id,\n    ) as typeof boundTextElement | undefined;\n    if (stateOfBoundTextElementAtResize) {\n      boundTextFont = {\n        fontSize: stateOfBoundTextElementAtResize.fontSize,\n        baseline: stateOfBoundTextElementAtResize.baseline,\n      };\n    }\n    if (shouldMaintainAspectRatio) {\n      const updatedElement = {\n        ...element,\n        width: eleNewWidth,\n        height: eleNewHeight,\n      };\n\n      const nextFont = measureFontSizeFromWidth(\n        boundTextElement,\n        getBoundTextMaxWidth(updatedElement),\n        getBoundTextMaxHeight(updatedElement, boundTextElement),\n      );\n      if (nextFont === null) {\n        return;\n      }\n      boundTextFont = {\n        fontSize: nextFont.size,\n        baseline: nextFont.baseline,\n      };\n    } else {\n      const minWidth = getApproxMinLineWidth(\n        getFontString(boundTextElement),\n        boundTextElement.lineHeight,\n      );\n      const minHeight = getApproxMinLineHeight(\n        boundTextElement.fontSize,\n        boundTextElement.lineHeight,\n      );\n      eleNewWidth = Math.ceil(Math.max(eleNewWidth, minWidth));\n      eleNewHeight = Math.ceil(Math.max(eleNewHeight, minHeight));\n    }\n  }\n\n  const [newBoundsX1, newBoundsY1, newBoundsX2, newBoundsY2] =\n    getResizedElementAbsoluteCoords(\n      stateAtResizeStart,\n      eleNewWidth,\n      eleNewHeight,\n      true,\n    );\n  const newBoundsWidth = newBoundsX2 - newBoundsX1;\n  const newBoundsHeight = newBoundsY2 - newBoundsY1;\n\n  // Calculate new topLeft based on fixed corner during resize\n  let newTopLeft = [...startTopLeft] as [number, number];\n  if ([\"n\", \"w\", \"nw\"].includes(transformHandleDirection)) {\n    newTopLeft = [\n      startBottomRight[0] - Math.abs(newBoundsWidth),\n      startBottomRight[1] - Math.abs(newBoundsHeight),\n    ];\n  }\n  if (transformHandleDirection === \"ne\") {\n    const bottomLeft = [startTopLeft[0], startBottomRight[1]];\n    newTopLeft = [bottomLeft[0], bottomLeft[1] - Math.abs(newBoundsHeight)];\n  }\n  if (transformHandleDirection === \"sw\") {\n    const topRight = [startBottomRight[0], startTopLeft[1]];\n    newTopLeft = [topRight[0] - Math.abs(newBoundsWidth), topRight[1]];\n  }\n\n  // Keeps opposite handle fixed during resize\n  if (shouldMaintainAspectRatio) {\n    if ([\"s\", \"n\"].includes(transformHandleDirection)) {\n      newTopLeft[0] = startCenter[0] - newBoundsWidth / 2;\n    }\n    if ([\"e\", \"w\"].includes(transformHandleDirection)) {\n      newTopLeft[1] = startCenter[1] - newBoundsHeight / 2;\n    }\n  }\n\n  // Flip horizontally\n  if (eleNewWidth < 0) {\n    if (transformHandleDirection.includes(\"e\")) {\n      newTopLeft[0] -= Math.abs(newBoundsWidth);\n    }\n    if (transformHandleDirection.includes(\"w\")) {\n      newTopLeft[0] += Math.abs(newBoundsWidth);\n    }\n  }\n  // Flip vertically\n  if (eleNewHeight < 0) {\n    if (transformHandleDirection.includes(\"s\")) {\n      newTopLeft[1] -= Math.abs(newBoundsHeight);\n    }\n    if (transformHandleDirection.includes(\"n\")) {\n      newTopLeft[1] += Math.abs(newBoundsHeight);\n    }\n  }\n\n  if (shouldResizeFromCenter) {\n    newTopLeft[0] = startCenter[0] - Math.abs(newBoundsWidth) / 2;\n    newTopLeft[1] = startCenter[1] - Math.abs(newBoundsHeight) / 2;\n  }\n\n  // adjust topLeft to new rotation point\n  const angle = stateAtResizeStart.angle;\n  const rotatedTopLeft = rotatePoint(newTopLeft, startCenter, angle);\n  const newCenter: Point = [\n    newTopLeft[0] + Math.abs(newBoundsWidth) / 2,\n    newTopLeft[1] + Math.abs(newBoundsHeight) / 2,\n  ];\n  const rotatedNewCenter = rotatePoint(newCenter, startCenter, angle);\n  newTopLeft = rotatePoint(rotatedTopLeft, rotatedNewCenter, -angle);\n\n  // Readjust points for linear elements\n  let rescaledElementPointsY;\n  let rescaledPoints;\n\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    rescaledElementPointsY = rescalePoints(\n      1,\n      eleNewHeight,\n      (stateAtResizeStart as ExcalidrawLinearElement).points,\n      true,\n    );\n\n    rescaledPoints = rescalePoints(\n      0,\n      eleNewWidth,\n      rescaledElementPointsY,\n      true,\n    );\n  }\n\n  // For linear elements (x,y) are the coordinates of the first drawn point not the top-left corner\n  // So we need to readjust (x,y) to be where the first point should be\n  const newOrigin = [...newTopLeft];\n  newOrigin[0] += stateAtResizeStart.x - newBoundsX1;\n  newOrigin[1] += stateAtResizeStart.y - newBoundsY1;\n  const resizedElement = {\n    width: Math.abs(eleNewWidth),\n    height: Math.abs(eleNewHeight),\n    x: newOrigin[0],\n    y: newOrigin[1],\n    points: rescaledPoints,\n  };\n\n  if (\"scale\" in element && \"scale\" in stateAtResizeStart) {\n    mutateElement(element, {\n      scale: [\n        // defaulting because scaleX/Y can be 0/-0\n        (Math.sign(newBoundsX2 - stateAtResizeStart.x) ||\n          stateAtResizeStart.scale[0]) * stateAtResizeStart.scale[0],\n        (Math.sign(newBoundsY2 - stateAtResizeStart.y) ||\n          stateAtResizeStart.scale[1]) * stateAtResizeStart.scale[1],\n      ],\n    });\n  }\n\n  if (\n    resizedElement.width !== 0 &&\n    resizedElement.height !== 0 &&\n    Number.isFinite(resizedElement.x) &&\n    Number.isFinite(resizedElement.y)\n  ) {\n    updateBoundElements(element, {\n      newSize: { width: resizedElement.width, height: resizedElement.height },\n    });\n\n    mutateElement(element, resizedElement);\n    if (boundTextElement && boundTextFont != null) {\n      mutateElement(boundTextElement, {\n        fontSize: boundTextFont.fontSize,\n        baseline: boundTextFont.baseline,\n      });\n    }\n    handleBindTextResize(element, transformHandleDirection);\n  }\n};\n\nexport const resizeMultipleElements = (\n  pointerDownState: PointerDownState,\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  transformHandleType: \"nw\" | \"ne\" | \"sw\" | \"se\",\n  shouldResizeFromCenter: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  // map selected elements to the original elements. While it never should\n  // happen that pointerDownState.originalElements won't contain the selected\n  // elements during resize, this coupling isn't guaranteed, so to ensure\n  // type safety we need to transform only those elements we filter.\n  const targetElements = selectedElements.reduce(\n    (\n      acc: {\n        /** element at resize start */\n        orig: NonDeletedExcalidrawElement;\n        /** latest element */\n        latest: NonDeletedExcalidrawElement;\n      }[],\n      element,\n    ) => {\n      const origElement = pointerDownState.originalElements.get(element.id);\n      if (origElement) {\n        acc.push({ orig: origElement, latest: element });\n      }\n      return acc;\n    },\n    [],\n  );\n\n  // getCommonBoundingBox() uses getBoundTextElement() which returns null for\n  // original elements from pointerDownState, so we have to find and add these\n  // bound text elements manually. Additionally, the coordinates of bound text\n  // elements aren't always up to date.\n  const boundTextElements = targetElements.reduce((acc, { orig }) => {\n    if (!isLinearElement(orig)) {\n      return acc;\n    }\n    const textId = getBoundTextElementId(orig);\n    if (!textId) {\n      return acc;\n    }\n    const text = pointerDownState.originalElements.get(textId) ?? null;\n    if (!isBoundToContainer(text)) {\n      return acc;\n    }\n    const xy = LinearElementEditor.getBoundTextElementPosition(orig, text);\n    return [...acc, { ...text, ...xy }];\n  }, [] as ExcalidrawTextElementWithContainer[]);\n\n  const { minX, minY, maxX, maxY, midX, midY } = getCommonBoundingBox(\n    targetElements.map(({ orig }) => orig).concat(boundTextElements),\n  );\n  const direction = transformHandleType;\n\n  const mapDirectionsToAnchors: Record<typeof direction, Point> = {\n    ne: [minX, maxY],\n    se: [minX, minY],\n    sw: [maxX, minY],\n    nw: [maxX, maxY],\n  };\n\n  // anchor point must be on the opposite side of the dragged selection handle\n  // or be the center of the selection if shouldResizeFromCenter\n  const [anchorX, anchorY]: Point = shouldResizeFromCenter\n    ? [midX, midY]\n    : mapDirectionsToAnchors[direction];\n\n  const scale =\n    Math.max(\n      Math.abs(pointerX - anchorX) / (maxX - minX) || 0,\n      Math.abs(pointerY - anchorY) / (maxY - minY) || 0,\n    ) * (shouldResizeFromCenter ? 2 : 1);\n\n  if (scale === 0) {\n    return;\n  }\n\n  const mapDirectionsToPointerPositions: Record<\n    typeof direction,\n    [x: boolean, y: boolean]\n  > = {\n    ne: [pointerX >= anchorX, pointerY <= anchorY],\n    se: [pointerX >= anchorX, pointerY >= anchorY],\n    sw: [pointerX <= anchorX, pointerY >= anchorY],\n    nw: [pointerX <= anchorX, pointerY <= anchorY],\n  };\n\n  /**\n   * to flip an element:\n   * 1. determine over which axis is the element being flipped\n   *    (could be x, y, or both) indicated by `flipFactorX` & `flipFactorY`\n   * 2. shift element's position by the amount of width or height (or both) or\n   *    mirror points in the case of linear & freedraw elemenets\n   * 3. adjust element angle\n   */\n  const [flipFactorX, flipFactorY] = mapDirectionsToPointerPositions[\n    direction\n  ].map((condition) => (condition ? 1 : -1));\n  const isFlippedByX = flipFactorX < 0;\n  const isFlippedByY = flipFactorY < 0;\n\n  const elementsAndUpdates: {\n    element: NonDeletedExcalidrawElement;\n    update: Mutable<\n      Pick<ExcalidrawElement, \"x\" | \"y\" | \"width\" | \"height\" | \"angle\">\n    > & {\n      points?: ExcalidrawLinearElement[\"points\"];\n      fontSize?: ExcalidrawTextElement[\"fontSize\"];\n      baseline?: ExcalidrawTextElement[\"baseline\"];\n      scale?: ExcalidrawImageElement[\"scale\"];\n    };\n    boundText: {\n      element: ExcalidrawTextElementWithContainer;\n      fontSize: ExcalidrawTextElement[\"fontSize\"];\n      baseline: ExcalidrawTextElement[\"baseline\"];\n    } | null;\n  }[] = [];\n\n  for (const { orig, latest } of targetElements) {\n    // bounded text elements are updated along with their container elements\n    if (isTextElement(orig) && isBoundToContainer(orig)) {\n      continue;\n    }\n\n    const width = orig.width * scale;\n    const height = orig.height * scale;\n    const angle = normalizeAngle(orig.angle * flipFactorX * flipFactorY);\n\n    const isLinearOrFreeDraw = isLinearElement(orig) || isFreeDrawElement(orig);\n    const offsetX = orig.x - anchorX;\n    const offsetY = orig.y - anchorY;\n    const shiftX = isFlippedByX && !isLinearOrFreeDraw ? width : 0;\n    const shiftY = isFlippedByY && !isLinearOrFreeDraw ? height : 0;\n    const x = anchorX + flipFactorX * (offsetX * scale + shiftX);\n    const y = anchorY + flipFactorY * (offsetY * scale + shiftY);\n\n    const rescaledPoints = rescalePointsInElement(\n      orig,\n      width * flipFactorX,\n      height * flipFactorY,\n      false,\n    );\n\n    const update: typeof elementsAndUpdates[0][\"update\"] = {\n      x,\n      y,\n      width,\n      height,\n      angle,\n      ...rescaledPoints,\n    };\n\n    if (isImageElement(orig) && targetElements.length === 1) {\n      update.scale = [orig.scale[0] * flipFactorX, orig.scale[1] * flipFactorY];\n    }\n\n    if (isLinearElement(orig) && (isFlippedByX || isFlippedByY)) {\n      const origBounds = getElementPointsCoords(orig, orig.points);\n      const newBounds = getElementPointsCoords(\n        { ...orig, x, y },\n        rescaledPoints.points!,\n      );\n      const origXY = [orig.x, orig.y];\n      const newXY = [x, y];\n\n      const linearShift = (axis: \"x\" | \"y\") => {\n        const i = axis === \"x\" ? 0 : 1;\n        return (\n          (newBounds[i + 2] -\n            newXY[i] -\n            (origXY[i] - origBounds[i]) * scale +\n            (origBounds[i + 2] - origXY[i]) * scale -\n            (newXY[i] - newBounds[i])) /\n          2\n        );\n      };\n\n      if (isFlippedByX) {\n        update.x -= linearShift(\"x\");\n      }\n\n      if (isFlippedByY) {\n        update.y -= linearShift(\"y\");\n      }\n    }\n\n    let boundText: typeof elementsAndUpdates[0][\"boundText\"] = null;\n\n    const boundTextElement = getBoundTextElement(latest);\n\n    if (boundTextElement || isTextElement(orig)) {\n      const updatedElement = {\n        ...latest,\n        width,\n        height,\n      };\n      const metrics = measureFontSizeFromWidth(\n        boundTextElement ?? (orig as ExcalidrawTextElement),\n        boundTextElement\n          ? getBoundTextMaxWidth(updatedElement)\n          : updatedElement.width,\n        boundTextElement\n          ? getBoundTextMaxHeight(updatedElement, boundTextElement)\n          : updatedElement.height,\n      );\n\n      if (!metrics) {\n        return;\n      }\n\n      if (isTextElement(orig)) {\n        update.fontSize = metrics.size;\n        update.baseline = metrics.baseline;\n      }\n\n      if (boundTextElement) {\n        boundText = {\n          element: boundTextElement,\n          fontSize: metrics.size,\n          baseline: metrics.baseline,\n        };\n      }\n    }\n\n    elementsAndUpdates.push({ element: latest, update, boundText });\n  }\n\n  const elementsToUpdate = elementsAndUpdates.map(({ element }) => element);\n\n  for (const { element, update, boundText } of elementsAndUpdates) {\n    const { width, height, angle } = update;\n\n    mutateElement(element, update, false);\n\n    updateBoundElements(element, {\n      simultaneouslyUpdated: elementsToUpdate,\n      newSize: { width, height },\n    });\n\n    if (boundText) {\n      const { element: boundTextElement, ...boundTextUpdates } = boundText;\n      mutateElement(\n        boundTextElement,\n        {\n          ...boundTextUpdates,\n          angle: isLinearElement(element) ? undefined : angle,\n        },\n        false,\n      );\n      handleBindTextResize(element, transformHandleType);\n    }\n  }\n\n  Scene.getScene(elementsAndUpdates[0].element)?.informMutation();\n};\n\nconst rotateMultipleElements = (\n  pointerDownState: PointerDownState,\n  elements: readonly NonDeletedExcalidrawElement[],\n  pointerX: number,\n  pointerY: number,\n  shouldRotateWithDiscreteAngle: boolean,\n  centerX: number,\n  centerY: number,\n) => {\n  let centerAngle =\n    (5 * Math.PI) / 2 + Math.atan2(pointerY - centerY, pointerX - centerX);\n  if (shouldRotateWithDiscreteAngle) {\n    centerAngle += SHIFT_LOCKING_ANGLE / 2;\n    centerAngle -= centerAngle % SHIFT_LOCKING_ANGLE;\n  }\n\n  elements\n    .filter((element) => element.type !== \"frame\")\n    .forEach((element) => {\n      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n      const cx = (x1 + x2) / 2;\n      const cy = (y1 + y2) / 2;\n      const origAngle =\n        pointerDownState.originalElements.get(element.id)?.angle ??\n        element.angle;\n      const [rotatedCX, rotatedCY] = rotate(\n        cx,\n        cy,\n        centerX,\n        centerY,\n        centerAngle + origAngle - element.angle,\n      );\n      mutateElement(\n        element,\n        {\n          x: element.x + (rotatedCX - cx),\n          y: element.y + (rotatedCY - cy),\n          angle: normalizeAngle(centerAngle + origAngle),\n        },\n        false,\n      );\n      updateBoundElements(element, { simultaneouslyUpdated: elements });\n\n      const boundText = getBoundTextElement(element);\n      if (boundText && !isArrowElement(element)) {\n        mutateElement(\n          boundText,\n          {\n            x: boundText.x + (rotatedCX - cx),\n            y: boundText.y + (rotatedCY - cy),\n            angle: normalizeAngle(centerAngle + origAngle),\n          },\n          false,\n        );\n      }\n    });\n\n  Scene.getScene(elements[0])?.informMutation();\n};\n\nexport const getResizeOffsetXY = (\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: NonDeletedExcalidrawElement[],\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1, x2, y2] =\n    selectedElements.length === 1\n      ? getElementAbsoluteCoords(selectedElements[0])\n      : getCommonBounds(selectedElements);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  const angle = selectedElements.length === 1 ? selectedElements[0].angle : 0;\n  [x, y] = rotate(x, y, cx, cy, -angle);\n  switch (transformHandleType) {\n    case \"n\":\n      return rotate(x - (x1 + x2) / 2, y - y1, 0, 0, angle);\n    case \"s\":\n      return rotate(x - (x1 + x2) / 2, y - y2, 0, 0, angle);\n    case \"w\":\n      return rotate(x - x1, y - (y1 + y2) / 2, 0, 0, angle);\n    case \"e\":\n      return rotate(x - x2, y - (y1 + y2) / 2, 0, 0, angle);\n    case \"nw\":\n      return rotate(x - x1, y - y1, 0, 0, angle);\n    case \"ne\":\n      return rotate(x - x2, y - y1, 0, 0, angle);\n    case \"sw\":\n      return rotate(x - x1, y - y2, 0, 0, angle);\n    case \"se\":\n      return rotate(x - x2, y - y2, 0, 0, angle);\n    default:\n      return [0, 0];\n  }\n};\n\nexport const getResizeArrowDirection = (\n  transformHandleType: MaybeTransformHandleType,\n  element: NonDeleted<ExcalidrawLinearElement>,\n): \"origin\" | \"end\" => {\n  const [, [px, py]] = element.points;\n  const isResizeEnd =\n    (transformHandleType === \"nw\" && (px < 0 || py < 0)) ||\n    (transformHandleType === \"ne\" && px >= 0) ||\n    (transformHandleType === \"sw\" && px <= 0) ||\n    (transformHandleType === \"se\" && (px > 0 || py > 0));\n  return isResizeEnd ? \"end\" : \"origin\";\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}