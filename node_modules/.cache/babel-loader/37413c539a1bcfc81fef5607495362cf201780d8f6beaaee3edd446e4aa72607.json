{"ast":null,"code":"import { getElementAbsoluteCoords, getElementBounds } from \"../element\";\nimport { isBoundToContainer } from \"../element/typeChecks\";\nimport { elementOverlapsWithFrame, getContainingFrame, getFrameElements } from \"../frame\";\nimport { isShallowEqual } from \"../utils\";\n\n/**\n * Frames and their containing elements are not to be selected at the same time.\n * Given an array of selected elements, if there are frames and their containing elements\n * we only keep the frames.\n * @param selectedElements\n */\nexport const excludeElementsInFramesFromSelection = selectedElements => {\n  const framesInSelection = new Set();\n  selectedElements.forEach(element => {\n    if (element.type === \"frame\") {\n      framesInSelection.add(element.id);\n    }\n  });\n  return selectedElements.filter(element => {\n    if (element.frameId && framesInSelection.has(element.frameId)) {\n      return false;\n    }\n    return true;\n  });\n};\nexport const getElementsWithinSelection = function (elements, selection) {\n  let excludeElementsInFrames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const [selectionX1, selectionY1, selectionX2, selectionY2] = getElementAbsoluteCoords(selection);\n  let elementsInSelection = elements.filter(element => {\n    let [elementX1, elementY1, elementX2, elementY2] = getElementBounds(element);\n    const containingFrame = getContainingFrame(element);\n    if (containingFrame) {\n      const [fx1, fy1, fx2, fy2] = getElementBounds(containingFrame);\n      elementX1 = Math.max(fx1, elementX1);\n      elementY1 = Math.max(fy1, elementY1);\n      elementX2 = Math.min(fx2, elementX2);\n      elementY2 = Math.min(fy2, elementY2);\n    }\n    return element.locked === false && element.type !== \"selection\" && !isBoundToContainer(element) && selectionX1 <= elementX1 && selectionY1 <= elementY1 && selectionX2 >= elementX2 && selectionY2 >= elementY2;\n  });\n  elementsInSelection = excludeElementsInFrames ? excludeElementsInFramesFromSelection(elementsInSelection) : elementsInSelection;\n  elementsInSelection = elementsInSelection.filter(element => {\n    const containingFrame = getContainingFrame(element);\n    if (containingFrame) {\n      return elementOverlapsWithFrame(element, containingFrame);\n    }\n    return true;\n  });\n  return elementsInSelection;\n};\n\n// FIXME move this into the editor instance to keep utility methods stateless\nexport const isSomeElementSelected = function () {\n  let lastElements = null;\n  let lastSelectedElementIds = null;\n  let isSelected = null;\n  const ret = (elements, appState) => {\n    if (isSelected != null && elements === lastElements && appState.selectedElementIds === lastSelectedElementIds) {\n      return isSelected;\n    }\n    isSelected = elements.some(element => appState.selectedElementIds[element.id]);\n    lastElements = elements;\n    lastSelectedElementIds = appState.selectedElementIds;\n    return isSelected;\n  };\n  ret.clearCache = () => {\n    lastElements = null;\n    lastSelectedElementIds = null;\n    isSelected = null;\n  };\n  return ret;\n}();\n\n/**\n * Returns common attribute (picked by `getAttribute` callback) of selected\n *  elements. If elements don't share the same value, returns `null`.\n */\nexport const getCommonAttributeOfSelectedElements = (elements, appState, getAttribute) => {\n  const attributes = Array.from(new Set(getSelectedElements(elements, appState).map(element => getAttribute(element))));\n  return attributes.length === 1 ? attributes[0] : null;\n};\nexport const getSelectedElements = (elements, appState, opts) => {\n  const selectedElements = elements.filter(element => {\n    if (appState.selectedElementIds[element.id]) {\n      return element;\n    }\n    if (opts !== null && opts !== void 0 && opts.includeBoundTextElement && isBoundToContainer(element) && appState.selectedElementIds[element === null || element === void 0 ? void 0 : element.containerId]) {\n      return element;\n    }\n    return null;\n  });\n  if (opts !== null && opts !== void 0 && opts.includeElementsInFrames) {\n    const elementsToInclude = [];\n    selectedElements.forEach(element => {\n      if (element.type === \"frame\") {\n        getFrameElements(elements, element.id).forEach(e => elementsToInclude.push(e));\n      }\n      elementsToInclude.push(element);\n    });\n    return elementsToInclude;\n  }\n  return selectedElements;\n};\nexport const getTargetElements = (elements, appState) => appState.editingElement ? [appState.editingElement] : getSelectedElements(elements, appState, {\n  includeBoundTextElement: true\n});\n\n/**\n * returns prevState's selectedElementids if no change from previous, so as to\n * retain reference identity for memoization\n */\nexport const makeNextSelectedElementIds = (nextSelectedElementIds, prevState) => {\n  if (isShallowEqual(prevState.selectedElementIds, nextSelectedElementIds)) {\n    return prevState.selectedElementIds;\n  }\n  return nextSelectedElementIds;\n};","map":{"version":3,"names":["getElementAbsoluteCoords","getElementBounds","isBoundToContainer","elementOverlapsWithFrame","getContainingFrame","getFrameElements","isShallowEqual","excludeElementsInFramesFromSelection","selectedElements","framesInSelection","Set","forEach","element","type","add","id","filter","frameId","has","getElementsWithinSelection","elements","selection","excludeElementsInFrames","arguments","length","undefined","selectionX1","selectionY1","selectionX2","selectionY2","elementsInSelection","elementX1","elementY1","elementX2","elementY2","containingFrame","fx1","fy1","fx2","fy2","Math","max","min","locked","isSomeElementSelected","lastElements","lastSelectedElementIds","isSelected","ret","appState","selectedElementIds","some","clearCache","getCommonAttributeOfSelectedElements","getAttribute","attributes","Array","from","getSelectedElements","map","opts","includeBoundTextElement","containerId","includeElementsInFrames","elementsToInclude","e","push","getTargetElements","editingElement","makeNextSelectedElementIds","nextSelectedElementIds","prevState"],"sources":["D:/project/excalidraw-cn/src/scene/selection.ts"],"sourcesContent":["import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport { getElementAbsoluteCoords, getElementBounds } from \"../element\";\nimport { AppState } from \"../types\";\nimport { isBoundToContainer } from \"../element/typeChecks\";\nimport {\n  elementOverlapsWithFrame,\n  getContainingFrame,\n  getFrameElements,\n} from \"../frame\";\nimport { isShallowEqual } from \"../utils\";\n\n/**\n * Frames and their containing elements are not to be selected at the same time.\n * Given an array of selected elements, if there are frames and their containing elements\n * we only keep the frames.\n * @param selectedElements\n */\nexport const excludeElementsInFramesFromSelection = <\n  T extends ExcalidrawElement,\n>(\n  selectedElements: readonly T[],\n) => {\n  const framesInSelection = new Set<T[\"id\"]>();\n\n  selectedElements.forEach((element) => {\n    if (element.type === \"frame\") {\n      framesInSelection.add(element.id);\n    }\n  });\n\n  return selectedElements.filter((element) => {\n    if (element.frameId && framesInSelection.has(element.frameId)) {\n      return false;\n    }\n    return true;\n  });\n};\n\nexport const getElementsWithinSelection = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selection: NonDeletedExcalidrawElement,\n  excludeElementsInFrames: boolean = true,\n) => {\n  const [selectionX1, selectionY1, selectionX2, selectionY2] =\n    getElementAbsoluteCoords(selection);\n\n  let elementsInSelection = elements.filter((element) => {\n    let [elementX1, elementY1, elementX2, elementY2] =\n      getElementBounds(element);\n\n    const containingFrame = getContainingFrame(element);\n    if (containingFrame) {\n      const [fx1, fy1, fx2, fy2] = getElementBounds(containingFrame);\n\n      elementX1 = Math.max(fx1, elementX1);\n      elementY1 = Math.max(fy1, elementY1);\n      elementX2 = Math.min(fx2, elementX2);\n      elementY2 = Math.min(fy2, elementY2);\n    }\n\n    return (\n      element.locked === false &&\n      element.type !== \"selection\" &&\n      !isBoundToContainer(element) &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2\n    );\n  });\n\n  elementsInSelection = excludeElementsInFrames\n    ? excludeElementsInFramesFromSelection(elementsInSelection)\n    : elementsInSelection;\n\n  elementsInSelection = elementsInSelection.filter((element) => {\n    const containingFrame = getContainingFrame(element);\n\n    if (containingFrame) {\n      return elementOverlapsWithFrame(element, containingFrame);\n    }\n\n    return true;\n  });\n\n  return elementsInSelection;\n};\n\n// FIXME move this into the editor instance to keep utility methods stateless\nexport const isSomeElementSelected = (function () {\n  let lastElements: readonly NonDeletedExcalidrawElement[] | null = null;\n  let lastSelectedElementIds: AppState[\"selectedElementIds\"] | null = null;\n  let isSelected: boolean | null = null;\n\n  const ret = (\n    elements: readonly NonDeletedExcalidrawElement[],\n    appState: Pick<AppState, \"selectedElementIds\">,\n  ): boolean => {\n    if (\n      isSelected != null &&\n      elements === lastElements &&\n      appState.selectedElementIds === lastSelectedElementIds\n    ) {\n      return isSelected;\n    }\n\n    isSelected = elements.some(\n      (element) => appState.selectedElementIds[element.id],\n    );\n    lastElements = elements;\n    lastSelectedElementIds = appState.selectedElementIds;\n\n    return isSelected;\n  };\n\n  ret.clearCache = () => {\n    lastElements = null;\n    lastSelectedElementIds = null;\n    isSelected = null;\n  };\n\n  return ret;\n})();\n\n/**\n * Returns common attribute (picked by `getAttribute` callback) of selected\n *  elements. If elements don't share the same value, returns `null`.\n */\nexport const getCommonAttributeOfSelectedElements = <T>(\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: Pick<AppState, \"selectedElementIds\">,\n  getAttribute: (element: ExcalidrawElement) => T,\n): T | null => {\n  const attributes = Array.from(\n    new Set(\n      getSelectedElements(elements, appState).map((element) =>\n        getAttribute(element),\n      ),\n    ),\n  );\n  return attributes.length === 1 ? attributes[0] : null;\n};\n\nexport const getSelectedElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: Pick<AppState, \"selectedElementIds\">,\n  opts?: {\n    includeBoundTextElement?: boolean;\n    includeElementsInFrames?: boolean;\n  },\n) => {\n  const selectedElements = elements.filter((element) => {\n    if (appState.selectedElementIds[element.id]) {\n      return element;\n    }\n    if (\n      opts?.includeBoundTextElement &&\n      isBoundToContainer(element) &&\n      appState.selectedElementIds[element?.containerId]\n    ) {\n      return element;\n    }\n    return null;\n  });\n\n  if (opts?.includeElementsInFrames) {\n    const elementsToInclude: ExcalidrawElement[] = [];\n    selectedElements.forEach((element) => {\n      if (element.type === \"frame\") {\n        getFrameElements(elements, element.id).forEach((e) =>\n          elementsToInclude.push(e),\n        );\n      }\n      elementsToInclude.push(element);\n    });\n\n    return elementsToInclude;\n  }\n\n  return selectedElements;\n};\n\nexport const getTargetElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: Pick<AppState, \"selectedElementIds\" | \"editingElement\">,\n) =>\n  appState.editingElement\n    ? [appState.editingElement]\n    : getSelectedElements(elements, appState, {\n        includeBoundTextElement: true,\n      });\n\n/**\n * returns prevState's selectedElementids if no change from previous, so as to\n * retain reference identity for memoization\n */\nexport const makeNextSelectedElementIds = (\n  nextSelectedElementIds: AppState[\"selectedElementIds\"],\n  prevState: Pick<AppState, \"selectedElementIds\">,\n) => {\n  if (isShallowEqual(prevState.selectedElementIds, nextSelectedElementIds)) {\n    return prevState.selectedElementIds;\n  }\n\n  return nextSelectedElementIds;\n};\n"],"mappings":"AAIA,SAASA,wBAAwB,EAAEC,gBAAgB,QAAQ,YAAY;AAEvE,SAASC,kBAAkB,QAAQ,uBAAuB;AAC1D,SACEC,wBAAwB,EACxBC,kBAAkB,EAClBC,gBAAgB,QACX,UAAU;AACjB,SAASC,cAAc,QAAQ,UAAU;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,oCAAoC,GAG/CC,gBAA8B,IAC3B;EACH,MAAMC,iBAAiB,GAAG,IAAIC,GAAG,EAAW;EAE5CF,gBAAgB,CAACG,OAAO,CAAEC,OAAO,IAAK;IACpC,IAAIA,OAAO,CAACC,IAAI,KAAK,OAAO,EAAE;MAC5BJ,iBAAiB,CAACK,GAAG,CAACF,OAAO,CAACG,EAAE,CAAC;IACnC;EACF,CAAC,CAAC;EAEF,OAAOP,gBAAgB,CAACQ,MAAM,CAAEJ,OAAO,IAAK;IAC1C,IAAIA,OAAO,CAACK,OAAO,IAAIR,iBAAiB,CAACS,GAAG,CAACN,OAAO,CAACK,OAAO,CAAC,EAAE;MAC7D,OAAO,KAAK;IACd;IACA,OAAO,IAAI;EACb,CAAC,CAAC;AACJ,CAAC;AAED,OAAO,MAAME,0BAA0B,GAAG,SAAAA,CACxCC,QAAgD,EAChDC,SAAsC,EAEnC;EAAA,IADHC,uBAAgC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EAEvC,MAAM,CAACG,WAAW,EAAEC,WAAW,EAAEC,WAAW,EAAEC,WAAW,CAAC,GACxD7B,wBAAwB,CAACqB,SAAS,CAAC;EAErC,IAAIS,mBAAmB,GAAGV,QAAQ,CAACJ,MAAM,CAAEJ,OAAO,IAAK;IACrD,IAAI,CAACmB,SAAS,EAAEC,SAAS,EAAEC,SAAS,EAAEC,SAAS,CAAC,GAC9CjC,gBAAgB,CAACW,OAAO,CAAC;IAE3B,MAAMuB,eAAe,GAAG/B,kBAAkB,CAACQ,OAAO,CAAC;IACnD,IAAIuB,eAAe,EAAE;MACnB,MAAM,CAACC,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG,CAAC,GAAGtC,gBAAgB,CAACkC,eAAe,CAAC;MAE9DJ,SAAS,GAAGS,IAAI,CAACC,GAAG,CAACL,GAAG,EAAEL,SAAS,CAAC;MACpCC,SAAS,GAAGQ,IAAI,CAACC,GAAG,CAACJ,GAAG,EAAEL,SAAS,CAAC;MACpCC,SAAS,GAAGO,IAAI,CAACE,GAAG,CAACJ,GAAG,EAAEL,SAAS,CAAC;MACpCC,SAAS,GAAGM,IAAI,CAACE,GAAG,CAACH,GAAG,EAAEL,SAAS,CAAC;IACtC;IAEA,OACEtB,OAAO,CAAC+B,MAAM,KAAK,KAAK,IACxB/B,OAAO,CAACC,IAAI,KAAK,WAAW,IAC5B,CAACX,kBAAkB,CAACU,OAAO,CAAC,IAC5Bc,WAAW,IAAIK,SAAS,IACxBJ,WAAW,IAAIK,SAAS,IACxBJ,WAAW,IAAIK,SAAS,IACxBJ,WAAW,IAAIK,SAAS;EAE5B,CAAC,CAAC;EAEFJ,mBAAmB,GAAGR,uBAAuB,GACzCf,oCAAoC,CAACuB,mBAAmB,CAAC,GACzDA,mBAAmB;EAEvBA,mBAAmB,GAAGA,mBAAmB,CAACd,MAAM,CAAEJ,OAAO,IAAK;IAC5D,MAAMuB,eAAe,GAAG/B,kBAAkB,CAACQ,OAAO,CAAC;IAEnD,IAAIuB,eAAe,EAAE;MACnB,OAAOhC,wBAAwB,CAACS,OAAO,EAAEuB,eAAe,CAAC;IAC3D;IAEA,OAAO,IAAI;EACb,CAAC,CAAC;EAEF,OAAOL,mBAAmB;AAC5B,CAAC;;AAED;AACA,OAAO,MAAMc,qBAAqB,GAAI,YAAY;EAChD,IAAIC,YAA2D,GAAG,IAAI;EACtE,IAAIC,sBAA6D,GAAG,IAAI;EACxE,IAAIC,UAA0B,GAAG,IAAI;EAErC,MAAMC,GAAG,GAAGA,CACV5B,QAAgD,EAChD6B,QAA8C,KAClC;IACZ,IACEF,UAAU,IAAI,IAAI,IAClB3B,QAAQ,KAAKyB,YAAY,IACzBI,QAAQ,CAACC,kBAAkB,KAAKJ,sBAAsB,EACtD;MACA,OAAOC,UAAU;IACnB;IAEAA,UAAU,GAAG3B,QAAQ,CAAC+B,IAAI,CACvBvC,OAAO,IAAKqC,QAAQ,CAACC,kBAAkB,CAACtC,OAAO,CAACG,EAAE,CAAC,CACrD;IACD8B,YAAY,GAAGzB,QAAQ;IACvB0B,sBAAsB,GAAGG,QAAQ,CAACC,kBAAkB;IAEpD,OAAOH,UAAU;EACnB,CAAC;EAEDC,GAAG,CAACI,UAAU,GAAG,MAAM;IACrBP,YAAY,GAAG,IAAI;IACnBC,sBAAsB,GAAG,IAAI;IAC7BC,UAAU,GAAG,IAAI;EACnB,CAAC;EAED,OAAOC,GAAG;AACZ,CAAC,EAAG;;AAEJ;AACA;AACA;AACA;AACA,OAAO,MAAMK,oCAAoC,GAAGA,CAClDjC,QAAgD,EAChD6B,QAA8C,EAC9CK,YAA+C,KAClC;EACb,MAAMC,UAAU,GAAGC,KAAK,CAACC,IAAI,CAC3B,IAAI/C,GAAG,CACLgD,mBAAmB,CAACtC,QAAQ,EAAE6B,QAAQ,CAAC,CAACU,GAAG,CAAE/C,OAAO,IAClD0C,YAAY,CAAC1C,OAAO,CAAC,CACtB,CACF,CACF;EACD,OAAO2C,UAAU,CAAC/B,MAAM,KAAK,CAAC,GAAG+B,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI;AACvD,CAAC;AAED,OAAO,MAAMG,mBAAmB,GAAGA,CACjCtC,QAAgD,EAChD6B,QAA8C,EAC9CW,IAGC,KACE;EACH,MAAMpD,gBAAgB,GAAGY,QAAQ,CAACJ,MAAM,CAAEJ,OAAO,IAAK;IACpD,IAAIqC,QAAQ,CAACC,kBAAkB,CAACtC,OAAO,CAACG,EAAE,CAAC,EAAE;MAC3C,OAAOH,OAAO;IAChB;IACA,IACEgD,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEC,uBAAuB,IAC7B3D,kBAAkB,CAACU,OAAO,CAAC,IAC3BqC,QAAQ,CAACC,kBAAkB,CAACtC,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEkD,WAAW,CAAC,EACjD;MACA,OAAOlD,OAAO;IAChB;IACA,OAAO,IAAI;EACb,CAAC,CAAC;EAEF,IAAIgD,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEG,uBAAuB,EAAE;IACjC,MAAMC,iBAAsC,GAAG,EAAE;IACjDxD,gBAAgB,CAACG,OAAO,CAAEC,OAAO,IAAK;MACpC,IAAIA,OAAO,CAACC,IAAI,KAAK,OAAO,EAAE;QAC5BR,gBAAgB,CAACe,QAAQ,EAAER,OAAO,CAACG,EAAE,CAAC,CAACJ,OAAO,CAAEsD,CAAC,IAC/CD,iBAAiB,CAACE,IAAI,CAACD,CAAC,CAAC,CAC1B;MACH;MACAD,iBAAiB,CAACE,IAAI,CAACtD,OAAO,CAAC;IACjC,CAAC,CAAC;IAEF,OAAOoD,iBAAiB;EAC1B;EAEA,OAAOxD,gBAAgB;AACzB,CAAC;AAED,OAAO,MAAM2D,iBAAiB,GAAGA,CAC/B/C,QAAgD,EAChD6B,QAAiE,KAEjEA,QAAQ,CAACmB,cAAc,GACnB,CAACnB,QAAQ,CAACmB,cAAc,CAAC,GACzBV,mBAAmB,CAACtC,QAAQ,EAAE6B,QAAQ,EAAE;EACtCY,uBAAuB,EAAE;AAC3B,CAAC,CAAC;;AAER;AACA;AACA;AACA;AACA,OAAO,MAAMQ,0BAA0B,GAAGA,CACxCC,sBAAsD,EACtDC,SAA+C,KAC5C;EACH,IAAIjE,cAAc,CAACiE,SAAS,CAACrB,kBAAkB,EAAEoB,sBAAsB,CAAC,EAAE;IACxE,OAAOC,SAAS,CAACrB,kBAAkB;EACrC;EAEA,OAAOoB,sBAAsB;AAC/B,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}