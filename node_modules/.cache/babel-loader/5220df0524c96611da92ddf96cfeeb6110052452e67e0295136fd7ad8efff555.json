{"ast":null,"code":"import _toConsumableArray from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport var DashedFiller = /*#__PURE__*/function () {\n  function DashedFiller(helper) {\n    _classCallCheck(this, DashedFiller);\n    this.helper = helper;\n  }\n  _createClass(DashedFiller, [{\n    key: \"fillPolygons\",\n    value: function fillPolygons(polygonList, o) {\n      var lines = polygonHachureLines(polygonList, o);\n      return {\n        type: 'fillSketch',\n        ops: this.dashedLine(lines, o)\n      };\n    }\n  }, {\n    key: \"dashedLine\",\n    value: function dashedLine(lines, o) {\n      var _this = this;\n      var offset = o.dashOffset < 0 ? o.hachureGap < 0 ? o.strokeWidth * 4 : o.hachureGap : o.dashOffset;\n      var gap = o.dashGap < 0 ? o.hachureGap < 0 ? o.strokeWidth * 4 : o.hachureGap : o.dashGap;\n      var ops = [];\n      lines.forEach(function (line) {\n        var length = lineLength(line);\n        var count = Math.floor(length / (offset + gap));\n        var startOffset = (length + gap - count * (offset + gap)) / 2;\n        var p1 = line[0];\n        var p2 = line[1];\n        if (p1[0] > p2[0]) {\n          p1 = line[1];\n          p2 = line[0];\n        }\n        var alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n        for (var i = 0; i < count; i++) {\n          var lstart = i * (offset + gap);\n          var lend = lstart + offset;\n          var start = [p1[0] + lstart * Math.cos(alpha) + startOffset * Math.cos(alpha), p1[1] + lstart * Math.sin(alpha) + startOffset * Math.sin(alpha)];\n          var end = [p1[0] + lend * Math.cos(alpha) + startOffset * Math.cos(alpha), p1[1] + lend * Math.sin(alpha) + startOffset * Math.sin(alpha)];\n          ops.push.apply(ops, _toConsumableArray(_this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o)));\n        }\n      });\n      return ops;\n    }\n  }]);\n  return DashedFiller;\n}();","map":{"version":3,"names":["lineLength","polygonHachureLines","DashedFiller","helper","_classCallCheck","_createClass","key","value","fillPolygons","polygonList","o","lines","type","ops","dashedLine","_this","offset","dashOffset","hachureGap","strokeWidth","gap","dashGap","forEach","line","length","count","Math","floor","startOffset","p1","p2","alpha","atan","i","lstart","lend","start","cos","sin","end","push","apply","_toConsumableArray","doubleLineOps"],"sources":["D:/project/excalidraw-cn/node_modules/roughjs/bin/fillers/dashed-filler.js"],"sourcesContent":["import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DashedFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const lines = polygonHachureLines(polygonList, o);\n        return { type: 'fillSketch', ops: this.dashedLine(lines, o) };\n    }\n    dashedLine(lines, o) {\n        const offset = o.dashOffset < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashOffset;\n        const gap = o.dashGap < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashGap;\n        const ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.floor(length / (offset + gap));\n            const startOffset = (length + gap - (count * (offset + gap))) / 2;\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * (offset + gap);\n                const lend = lstart + offset;\n                const start = [p1[0] + (lstart * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha) + (startOffset * Math.sin(alpha))];\n                const end = [p1[0] + (lend * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha)) + (startOffset * Math.sin(alpha))];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}