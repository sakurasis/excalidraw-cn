{"ast":null,"code":"import { bumpVersion } from \"./element/mutateElement\";\nimport { isFrameElement } from \"./element/typeChecks\";\nimport { groupByFrames } from \"./frame\";\nimport { getElementsInGroup } from \"./groups\";\nimport { getSelectedElements } from \"./scene\";\nimport Scene from \"./scene/Scene\";\nimport { arrayToMap, findIndex, findLastIndex } from \"./utils\";\n\n// elements that do not belong to a frame are considered a root element\nconst isRootElement = element => {\n  return !element.frameId;\n};\n\n/**\n * Returns indices of elements to move based on selected elements.\n * Includes contiguous deleted elements that are between two selected elements,\n *  e.g.: [0 (selected), 1 (deleted), 2 (deleted), 3 (selected)]\n *\n * Specified elements (elementsToBeMoved) take precedence over\n * appState.selectedElementsIds\n */\nconst getIndicesToMove = (elements, appState, elementsToBeMoved) => {\n  let selectedIndices = [];\n  let deletedIndices = [];\n  let includeDeletedIndex = null;\n  let index = -1;\n  const selectedElementIds = arrayToMap(elementsToBeMoved ? elementsToBeMoved : getSelectedElements(elements, appState, {\n    includeBoundTextElement: true\n  }));\n  while (++index < elements.length) {\n    const element = elements[index];\n    if (selectedElementIds.get(element.id)) {\n      if (deletedIndices.length) {\n        selectedIndices = selectedIndices.concat(deletedIndices);\n        deletedIndices = [];\n      }\n      selectedIndices.push(index);\n      includeDeletedIndex = index + 1;\n    } else if (element.isDeleted && includeDeletedIndex === index) {\n      includeDeletedIndex = index + 1;\n      deletedIndices.push(index);\n    } else {\n      deletedIndices = [];\n    }\n  }\n  return selectedIndices;\n};\nconst toContiguousGroups = array => {\n  let cursor = 0;\n  return array.reduce((acc, value, index) => {\n    if (index > 0 && array[index - 1] !== value - 1) {\n      cursor = ++cursor;\n    }\n    (acc[cursor] || (acc[cursor] = [])).push(value);\n    return acc;\n  }, []);\n};\n\n/**\n * @returns index of target element, consindering tightly-bound elements\n * (currently non-linear elements bound to a container) as a one unit.\n * If no binding present, returns `undefined`.\n */\nconst getTargetIndexAccountingForBinding = (nextElement, elements, direction) => {\n  if (\"containerId\" in nextElement && nextElement.containerId) {\n    if (direction === \"left\") {\n      const containerElement = Scene.getScene(nextElement).getElement(nextElement.containerId);\n      if (containerElement) {\n        return elements.indexOf(containerElement);\n      }\n    } else {\n      return elements.indexOf(nextElement);\n    }\n  } else {\n    var _nextElement$boundEle, _nextElement$boundEle2;\n    const boundElementId = (_nextElement$boundEle = nextElement.boundElements) === null || _nextElement$boundEle === void 0 ? void 0 : (_nextElement$boundEle2 = _nextElement$boundEle.find(binding => binding.type !== \"arrow\")) === null || _nextElement$boundEle2 === void 0 ? void 0 : _nextElement$boundEle2.id;\n    if (boundElementId) {\n      if (direction === \"left\") {\n        return elements.indexOf(nextElement);\n      }\n      const boundTextElement = Scene.getScene(nextElement).getElement(boundElementId);\n      if (boundTextElement) {\n        return elements.indexOf(boundTextElement);\n      }\n    }\n  }\n};\n\n/**\n * Returns next candidate index that's available to be moved to. Currently that\n *  is a non-deleted element, and not inside a group (unless we're editing it).\n */\nconst getTargetIndex = (appState, elements, boundaryIndex, direction) => {\n  const sourceElement = elements[boundaryIndex];\n  const indexFilter = element => {\n    if (element.isDeleted) {\n      return false;\n    }\n    // if we're editing group, find closest sibling irrespective of whether\n    // there's a different-group element between them (for legacy reasons)\n    if (appState.editingGroupId) {\n      return element.groupIds.includes(appState.editingGroupId);\n    }\n    return true;\n  };\n  const candidateIndex = direction === \"left\" ? findLastIndex(elements, indexFilter, Math.max(0, boundaryIndex - 1)) : findIndex(elements, indexFilter, boundaryIndex + 1);\n  const nextElement = elements[candidateIndex];\n  if (!nextElement) {\n    return -1;\n  }\n  if (appState.editingGroupId) {\n    if (\n    // candidate element is a sibling in current editing group → return\n    (sourceElement === null || sourceElement === void 0 ? void 0 : sourceElement.groupIds.join(\"\")) === (nextElement === null || nextElement === void 0 ? void 0 : nextElement.groupIds.join(\"\"))) {\n      var _getTargetIndexAccoun;\n      return (_getTargetIndexAccoun = getTargetIndexAccountingForBinding(nextElement, elements, direction)) !== null && _getTargetIndexAccoun !== void 0 ? _getTargetIndexAccoun : candidateIndex;\n    } else if (!(nextElement !== null && nextElement !== void 0 && nextElement.groupIds.includes(appState.editingGroupId))) {\n      // candidate element is outside current editing group → prevent\n      return -1;\n    }\n  }\n  if (!nextElement.groupIds.length) {\n    var _getTargetIndexAccoun2;\n    return (_getTargetIndexAccoun2 = getTargetIndexAccountingForBinding(nextElement, elements, direction)) !== null && _getTargetIndexAccoun2 !== void 0 ? _getTargetIndexAccoun2 : candidateIndex;\n  }\n  const siblingGroupId = appState.editingGroupId ? nextElement.groupIds[nextElement.groupIds.indexOf(appState.editingGroupId) - 1] : nextElement.groupIds[nextElement.groupIds.length - 1];\n  const elementsInSiblingGroup = getElementsInGroup(elements, siblingGroupId);\n  if (elementsInSiblingGroup.length) {\n    // assumes getElementsInGroup() returned elements are sorted\n    // by zIndex (ascending)\n    return direction === \"left\" ? elements.indexOf(elementsInSiblingGroup[0]) : elements.indexOf(elementsInSiblingGroup[elementsInSiblingGroup.length - 1]);\n  }\n  return candidateIndex;\n};\nconst getTargetElementsMap = (elements, indices) => {\n  return indices.reduce((acc, index) => {\n    const element = elements[index];\n    acc[element.id] = element;\n    return acc;\n  }, {});\n};\nconst _shiftElements = (elements, appState, direction, elementsToBeMoved) => {\n  const indicesToMove = getIndicesToMove(elements, appState, elementsToBeMoved);\n  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);\n  let groupedIndices = toContiguousGroups(indicesToMove);\n  if (direction === \"right\") {\n    groupedIndices = groupedIndices.reverse();\n  }\n  groupedIndices.forEach((indices, i) => {\n    const leadingIndex = indices[0];\n    const trailingIndex = indices[indices.length - 1];\n    const boundaryIndex = direction === \"left\" ? leadingIndex : trailingIndex;\n    const targetIndex = getTargetIndex(appState, elements, boundaryIndex, direction);\n    if (targetIndex === -1 || boundaryIndex === targetIndex) {\n      return;\n    }\n    const leadingElements = direction === \"left\" ? elements.slice(0, targetIndex) : elements.slice(0, leadingIndex);\n    const targetElements = elements.slice(leadingIndex, trailingIndex + 1);\n    const displacedElements = direction === \"left\" ? elements.slice(targetIndex, leadingIndex) : elements.slice(trailingIndex + 1, targetIndex + 1);\n    const trailingElements = direction === \"left\" ? elements.slice(trailingIndex + 1) : elements.slice(targetIndex + 1);\n    elements = direction === \"left\" ? [...leadingElements, ...targetElements, ...displacedElements, ...trailingElements] : [...leadingElements, ...displacedElements, ...targetElements, ...trailingElements];\n  });\n  return elements.map(element => {\n    if (targetElementsMap[element.id]) {\n      return bumpVersion(element);\n    }\n    return element;\n  });\n};\nconst shiftElements = (appState, elements, direction, elementsToBeMoved) => {\n  return shift(elements, appState, direction, _shiftElements, elementsToBeMoved);\n};\nconst _shiftElementsToEnd = (elements, appState, direction) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);\n  const displacedElements = [];\n  let leadingIndex;\n  let trailingIndex;\n  if (direction === \"left\") {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(elements, appState.editingGroupId);\n      if (!groupElements.length) {\n        return elements;\n      }\n      leadingIndex = elements.indexOf(groupElements[0]);\n    } else {\n      leadingIndex = 0;\n    }\n    trailingIndex = indicesToMove[indicesToMove.length - 1];\n  } else {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(elements, appState.editingGroupId);\n      if (!groupElements.length) {\n        return elements;\n      }\n      trailingIndex = elements.indexOf(groupElements[groupElements.length - 1]);\n    } else {\n      trailingIndex = elements.length - 1;\n    }\n    leadingIndex = indicesToMove[0];\n  }\n  for (let index = leadingIndex; index < trailingIndex + 1; index++) {\n    if (!indicesToMove.includes(index)) {\n      displacedElements.push(elements[index]);\n    }\n  }\n  const targetElements = Object.values(targetElementsMap).map(element => {\n    return bumpVersion(element);\n  });\n  const leadingElements = elements.slice(0, leadingIndex);\n  const trailingElements = elements.slice(trailingIndex + 1);\n  return direction === \"left\" ? [...leadingElements, ...targetElements, ...displacedElements, ...trailingElements] : [...leadingElements, ...displacedElements, ...targetElements, ...trailingElements];\n};\nconst shiftElementsToEnd = (elements, appState, direction, elementsToBeMoved) => {\n  return shift(elements, appState, direction, _shiftElementsToEnd, elementsToBeMoved);\n};\nfunction shift(elements, appState, direction, shiftFunction, elementsToBeMoved) {\n  const elementsMap = arrayToMap(elements);\n  const frameElementsMap = groupByFrames(elements);\n\n  // in case root is non-existent, we promote children elements to root\n  let rootElements = elements.filter(element => isRootElement(element) || element.frameId && !elementsMap.has(element.frameId));\n  // and remove non-existet root\n  for (const frameId of frameElementsMap.keys()) {\n    if (!elementsMap.has(frameId)) {\n      frameElementsMap.delete(frameId);\n    }\n  }\n\n  // shift the root elements first\n  rootElements = shiftFunction(rootElements, appState, direction, elementsToBeMoved);\n\n  // shift the elements in frames if needed\n  frameElementsMap.forEach((frameElements, frameId) => {\n    if (!appState.selectedElementIds[frameId]) {\n      frameElementsMap.set(frameId, shiftFunction(frameElements, appState, direction, elementsToBeMoved));\n    }\n  });\n\n  // return the final elements\n  let finalElements = [];\n  rootElements.forEach(element => {\n    if (isFrameElement(element)) {\n      var _frameElementsMap$get;\n      finalElements = [...finalElements, ...((_frameElementsMap$get = frameElementsMap.get(element.id)) !== null && _frameElementsMap$get !== void 0 ? _frameElementsMap$get : []), element];\n    } else {\n      finalElements = [...finalElements, element];\n    }\n  });\n  return finalElements;\n}\n\n// public API\n// -----------------------------------------------------------------------------\n\nexport const moveOneLeft = (elements, appState, elementsToBeMoved) => {\n  return shiftElements(appState, elements, \"left\", elementsToBeMoved);\n};\nexport const moveOneRight = (elements, appState, elementsToBeMoved) => {\n  return shiftElements(appState, elements, \"right\", elementsToBeMoved);\n};\nexport const moveAllLeft = (elements, appState, elementsToBeMoved) => {\n  return shiftElementsToEnd(elements, appState, \"left\", elementsToBeMoved);\n};\nexport const moveAllRight = (elements, appState, elementsToBeMoved) => {\n  return shiftElementsToEnd(elements, appState, \"right\", elementsToBeMoved);\n};","map":{"version":3,"names":["bumpVersion","isFrameElement","groupByFrames","getElementsInGroup","getSelectedElements","Scene","arrayToMap","findIndex","findLastIndex","isRootElement","element","frameId","getIndicesToMove","elements","appState","elementsToBeMoved","selectedIndices","deletedIndices","includeDeletedIndex","index","selectedElementIds","includeBoundTextElement","length","get","id","concat","push","isDeleted","toContiguousGroups","array","cursor","reduce","acc","value","getTargetIndexAccountingForBinding","nextElement","direction","containerId","containerElement","getScene","getElement","indexOf","_nextElement$boundEle","_nextElement$boundEle2","boundElementId","boundElements","find","binding","type","boundTextElement","getTargetIndex","boundaryIndex","sourceElement","indexFilter","editingGroupId","groupIds","includes","candidateIndex","Math","max","join","_getTargetIndexAccoun","_getTargetIndexAccoun2","siblingGroupId","elementsInSiblingGroup","getTargetElementsMap","indices","_shiftElements","indicesToMove","targetElementsMap","groupedIndices","reverse","forEach","i","leadingIndex","trailingIndex","targetIndex","leadingElements","slice","targetElements","displacedElements","trailingElements","map","shiftElements","shift","_shiftElementsToEnd","groupElements","Object","values","shiftElementsToEnd","shiftFunction","elementsMap","frameElementsMap","rootElements","filter","has","keys","delete","frameElements","set","finalElements","_frameElementsMap$get","moveOneLeft","moveOneRight","moveAllLeft","moveAllRight"],"sources":["D:/project/excalidraw-cn/src/zindex.ts"],"sourcesContent":["import { bumpVersion } from \"./element/mutateElement\";\nimport { isFrameElement } from \"./element/typeChecks\";\nimport { ExcalidrawElement } from \"./element/types\";\nimport { groupByFrames } from \"./frame\";\nimport { getElementsInGroup } from \"./groups\";\nimport { getSelectedElements } from \"./scene\";\nimport Scene from \"./scene/Scene\";\nimport { AppState } from \"./types\";\nimport { arrayToMap, findIndex, findLastIndex } from \"./utils\";\n\n// elements that do not belong to a frame are considered a root element\nconst isRootElement = (element: ExcalidrawElement) => {\n  return !element.frameId;\n};\n\n/**\n * Returns indices of elements to move based on selected elements.\n * Includes contiguous deleted elements that are between two selected elements,\n *  e.g.: [0 (selected), 1 (deleted), 2 (deleted), 3 (selected)]\n *\n * Specified elements (elementsToBeMoved) take precedence over\n * appState.selectedElementsIds\n */\nconst getIndicesToMove = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  let selectedIndices: number[] = [];\n  let deletedIndices: number[] = [];\n  let includeDeletedIndex = null;\n  let index = -1;\n  const selectedElementIds = arrayToMap(\n    elementsToBeMoved\n      ? elementsToBeMoved\n      : getSelectedElements(elements, appState, {\n          includeBoundTextElement: true,\n        }),\n  );\n  while (++index < elements.length) {\n    const element = elements[index];\n    if (selectedElementIds.get(element.id)) {\n      if (deletedIndices.length) {\n        selectedIndices = selectedIndices.concat(deletedIndices);\n        deletedIndices = [];\n      }\n      selectedIndices.push(index);\n      includeDeletedIndex = index + 1;\n    } else if (element.isDeleted && includeDeletedIndex === index) {\n      includeDeletedIndex = index + 1;\n      deletedIndices.push(index);\n    } else {\n      deletedIndices = [];\n    }\n  }\n  return selectedIndices;\n};\n\nconst toContiguousGroups = (array: number[]) => {\n  let cursor = 0;\n  return array.reduce((acc, value, index) => {\n    if (index > 0 && array[index - 1] !== value - 1) {\n      cursor = ++cursor;\n    }\n    (acc[cursor] || (acc[cursor] = [])).push(value);\n    return acc;\n  }, [] as number[][]);\n};\n\n/**\n * @returns index of target element, consindering tightly-bound elements\n * (currently non-linear elements bound to a container) as a one unit.\n * If no binding present, returns `undefined`.\n */\nconst getTargetIndexAccountingForBinding = (\n  nextElement: ExcalidrawElement,\n  elements: readonly ExcalidrawElement[],\n  direction: \"left\" | \"right\",\n) => {\n  if (\"containerId\" in nextElement && nextElement.containerId) {\n    if (direction === \"left\") {\n      const containerElement = Scene.getScene(nextElement)!.getElement(\n        nextElement.containerId,\n      );\n      if (containerElement) {\n        return elements.indexOf(containerElement);\n      }\n    } else {\n      return elements.indexOf(nextElement);\n    }\n  } else {\n    const boundElementId = nextElement.boundElements?.find(\n      (binding) => binding.type !== \"arrow\",\n    )?.id;\n    if (boundElementId) {\n      if (direction === \"left\") {\n        return elements.indexOf(nextElement);\n      }\n      const boundTextElement =\n        Scene.getScene(nextElement)!.getElement(boundElementId);\n\n      if (boundTextElement) {\n        return elements.indexOf(boundTextElement);\n      }\n    }\n  }\n};\n\n/**\n * Returns next candidate index that's available to be moved to. Currently that\n *  is a non-deleted element, and not inside a group (unless we're editing it).\n */\nconst getTargetIndex = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n  boundaryIndex: number,\n  direction: \"left\" | \"right\",\n) => {\n  const sourceElement = elements[boundaryIndex];\n\n  const indexFilter = (element: ExcalidrawElement) => {\n    if (element.isDeleted) {\n      return false;\n    }\n    // if we're editing group, find closest sibling irrespective of whether\n    // there's a different-group element between them (for legacy reasons)\n    if (appState.editingGroupId) {\n      return element.groupIds.includes(appState.editingGroupId);\n    }\n    return true;\n  };\n\n  const candidateIndex =\n    direction === \"left\"\n      ? findLastIndex(elements, indexFilter, Math.max(0, boundaryIndex - 1))\n      : findIndex(elements, indexFilter, boundaryIndex + 1);\n\n  const nextElement = elements[candidateIndex];\n\n  if (!nextElement) {\n    return -1;\n  }\n\n  if (appState.editingGroupId) {\n    if (\n      // candidate element is a sibling in current editing group → return\n      sourceElement?.groupIds.join(\"\") === nextElement?.groupIds.join(\"\")\n    ) {\n      return (\n        getTargetIndexAccountingForBinding(nextElement, elements, direction) ??\n        candidateIndex\n      );\n    } else if (!nextElement?.groupIds.includes(appState.editingGroupId)) {\n      // candidate element is outside current editing group → prevent\n      return -1;\n    }\n  }\n\n  if (!nextElement.groupIds.length) {\n    return (\n      getTargetIndexAccountingForBinding(nextElement, elements, direction) ??\n      candidateIndex\n    );\n  }\n\n  const siblingGroupId = appState.editingGroupId\n    ? nextElement.groupIds[\n        nextElement.groupIds.indexOf(appState.editingGroupId) - 1\n      ]\n    : nextElement.groupIds[nextElement.groupIds.length - 1];\n\n  const elementsInSiblingGroup = getElementsInGroup(elements, siblingGroupId);\n\n  if (elementsInSiblingGroup.length) {\n    // assumes getElementsInGroup() returned elements are sorted\n    // by zIndex (ascending)\n    return direction === \"left\"\n      ? elements.indexOf(elementsInSiblingGroup[0])\n      : elements.indexOf(\n          elementsInSiblingGroup[elementsInSiblingGroup.length - 1],\n        );\n  }\n\n  return candidateIndex;\n};\n\nconst getTargetElementsMap = <T extends ExcalidrawElement>(\n  elements: readonly T[],\n  indices: number[],\n) => {\n  return indices.reduce((acc, index) => {\n    const element = elements[index];\n    acc[element.id] = element;\n    return acc;\n  }, {} as Record<string, ExcalidrawElement>);\n};\n\nconst _shiftElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState, elementsToBeMoved);\n  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);\n  let groupedIndices = toContiguousGroups(indicesToMove);\n\n  if (direction === \"right\") {\n    groupedIndices = groupedIndices.reverse();\n  }\n\n  groupedIndices.forEach((indices, i) => {\n    const leadingIndex = indices[0];\n    const trailingIndex = indices[indices.length - 1];\n    const boundaryIndex = direction === \"left\" ? leadingIndex : trailingIndex;\n\n    const targetIndex = getTargetIndex(\n      appState,\n      elements,\n      boundaryIndex,\n      direction,\n    );\n\n    if (targetIndex === -1 || boundaryIndex === targetIndex) {\n      return;\n    }\n\n    const leadingElements =\n      direction === \"left\"\n        ? elements.slice(0, targetIndex)\n        : elements.slice(0, leadingIndex);\n    const targetElements = elements.slice(leadingIndex, trailingIndex + 1);\n    const displacedElements =\n      direction === \"left\"\n        ? elements.slice(targetIndex, leadingIndex)\n        : elements.slice(trailingIndex + 1, targetIndex + 1);\n    const trailingElements =\n      direction === \"left\"\n        ? elements.slice(trailingIndex + 1)\n        : elements.slice(targetIndex + 1);\n\n    elements =\n      direction === \"left\"\n        ? [\n            ...leadingElements,\n            ...targetElements,\n            ...displacedElements,\n            ...trailingElements,\n          ]\n        : [\n            ...leadingElements,\n            ...displacedElements,\n            ...targetElements,\n            ...trailingElements,\n          ];\n  });\n\n  return elements.map((element) => {\n    if (targetElementsMap[element.id]) {\n      return bumpVersion(element);\n    }\n    return element;\n  });\n};\n\nconst shiftElements = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n  direction: \"left\" | \"right\",\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  return shift(\n    elements,\n    appState,\n    direction,\n    _shiftElements,\n    elementsToBeMoved,\n  );\n};\n\nconst _shiftElementsToEnd = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);\n  const displacedElements: ExcalidrawElement[] = [];\n\n  let leadingIndex: number;\n  let trailingIndex: number;\n  if (direction === \"left\") {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      leadingIndex = elements.indexOf(groupElements[0]);\n    } else {\n      leadingIndex = 0;\n    }\n\n    trailingIndex = indicesToMove[indicesToMove.length - 1];\n  } else {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      trailingIndex = elements.indexOf(groupElements[groupElements.length - 1]);\n    } else {\n      trailingIndex = elements.length - 1;\n    }\n\n    leadingIndex = indicesToMove[0];\n  }\n\n  for (let index = leadingIndex; index < trailingIndex + 1; index++) {\n    if (!indicesToMove.includes(index)) {\n      displacedElements.push(elements[index]);\n    }\n  }\n\n  const targetElements = Object.values(targetElementsMap).map((element) => {\n    return bumpVersion(element);\n  });\n\n  const leadingElements = elements.slice(0, leadingIndex);\n  const trailingElements = elements.slice(trailingIndex + 1);\n\n  return direction === \"left\"\n    ? [\n        ...leadingElements,\n        ...targetElements,\n        ...displacedElements,\n        ...trailingElements,\n      ]\n    : [\n        ...leadingElements,\n        ...displacedElements,\n        ...targetElements,\n        ...trailingElements,\n      ];\n};\n\nconst shiftElementsToEnd = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  return shift(\n    elements,\n    appState,\n    direction,\n    _shiftElementsToEnd,\n    elementsToBeMoved,\n  );\n};\n\nfunction shift(\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n  shiftFunction: (\n    elements: ExcalidrawElement[],\n    appState: AppState,\n    direction: \"left\" | \"right\",\n    elementsToBeMoved?: readonly ExcalidrawElement[],\n  ) => ExcalidrawElement[] | readonly ExcalidrawElement[],\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) {\n  const elementsMap = arrayToMap(elements);\n  const frameElementsMap = groupByFrames(elements);\n\n  // in case root is non-existent, we promote children elements to root\n  let rootElements = elements.filter(\n    (element) =>\n      isRootElement(element) ||\n      (element.frameId && !elementsMap.has(element.frameId)),\n  );\n  // and remove non-existet root\n  for (const frameId of frameElementsMap.keys()) {\n    if (!elementsMap.has(frameId)) {\n      frameElementsMap.delete(frameId);\n    }\n  }\n\n  // shift the root elements first\n  rootElements = shiftFunction(\n    rootElements,\n    appState,\n    direction,\n    elementsToBeMoved,\n  ) as ExcalidrawElement[];\n\n  // shift the elements in frames if needed\n  frameElementsMap.forEach((frameElements, frameId) => {\n    if (!appState.selectedElementIds[frameId]) {\n      frameElementsMap.set(\n        frameId,\n        shiftFunction(\n          frameElements,\n          appState,\n          direction,\n          elementsToBeMoved,\n        ) as ExcalidrawElement[],\n      );\n    }\n  });\n\n  // return the final elements\n  let finalElements: ExcalidrawElement[] = [];\n\n  rootElements.forEach((element) => {\n    if (isFrameElement(element)) {\n      finalElements = [\n        ...finalElements,\n        ...(frameElementsMap.get(element.id) ?? []),\n        element,\n      ];\n    } else {\n      finalElements = [...finalElements, element];\n    }\n  });\n\n  return finalElements;\n}\n\n// public API\n// -----------------------------------------------------------------------------\n\nexport const moveOneLeft = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  return shiftElements(appState, elements, \"left\", elementsToBeMoved);\n};\n\nexport const moveOneRight = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  return shiftElements(appState, elements, \"right\", elementsToBeMoved);\n};\n\nexport const moveAllLeft = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  return shiftElementsToEnd(elements, appState, \"left\", elementsToBeMoved);\n};\n\nexport const moveAllRight = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  return shiftElementsToEnd(elements, appState, \"right\", elementsToBeMoved);\n};\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,yBAAyB;AACrD,SAASC,cAAc,QAAQ,sBAAsB;AAErD,SAASC,aAAa,QAAQ,SAAS;AACvC,SAASC,kBAAkB,QAAQ,UAAU;AAC7C,SAASC,mBAAmB,QAAQ,SAAS;AAC7C,OAAOC,KAAK,MAAM,eAAe;AAEjC,SAASC,UAAU,EAAEC,SAAS,EAAEC,aAAa,QAAQ,SAAS;;AAE9D;AACA,MAAMC,aAAa,GAAIC,OAA0B,IAAK;EACpD,OAAO,CAACA,OAAO,CAACC,OAAO;AACzB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,GAAGA,CACvBC,QAAsC,EACtCC,QAAkB,EAClBC,iBAAgD,KAC7C;EACH,IAAIC,eAAyB,GAAG,EAAE;EAClC,IAAIC,cAAwB,GAAG,EAAE;EACjC,IAAIC,mBAAmB,GAAG,IAAI;EAC9B,IAAIC,KAAK,GAAG,CAAC,CAAC;EACd,MAAMC,kBAAkB,GAAGd,UAAU,CACnCS,iBAAiB,GACbA,iBAAiB,GACjBX,mBAAmB,CAACS,QAAQ,EAAEC,QAAQ,EAAE;IACtCO,uBAAuB,EAAE;EAC3B,CAAC,CAAC,CACP;EACD,OAAO,EAAEF,KAAK,GAAGN,QAAQ,CAACS,MAAM,EAAE;IAChC,MAAMZ,OAAO,GAAGG,QAAQ,CAACM,KAAK,CAAC;IAC/B,IAAIC,kBAAkB,CAACG,GAAG,CAACb,OAAO,CAACc,EAAE,CAAC,EAAE;MACtC,IAAIP,cAAc,CAACK,MAAM,EAAE;QACzBN,eAAe,GAAGA,eAAe,CAACS,MAAM,CAACR,cAAc,CAAC;QACxDA,cAAc,GAAG,EAAE;MACrB;MACAD,eAAe,CAACU,IAAI,CAACP,KAAK,CAAC;MAC3BD,mBAAmB,GAAGC,KAAK,GAAG,CAAC;IACjC,CAAC,MAAM,IAAIT,OAAO,CAACiB,SAAS,IAAIT,mBAAmB,KAAKC,KAAK,EAAE;MAC7DD,mBAAmB,GAAGC,KAAK,GAAG,CAAC;MAC/BF,cAAc,CAACS,IAAI,CAACP,KAAK,CAAC;IAC5B,CAAC,MAAM;MACLF,cAAc,GAAG,EAAE;IACrB;EACF;EACA,OAAOD,eAAe;AACxB,CAAC;AAED,MAAMY,kBAAkB,GAAIC,KAAe,IAAK;EAC9C,IAAIC,MAAM,GAAG,CAAC;EACd,OAAOD,KAAK,CAACE,MAAM,CAAC,CAACC,GAAG,EAAEC,KAAK,EAAEd,KAAK,KAAK;IACzC,IAAIA,KAAK,GAAG,CAAC,IAAIU,KAAK,CAACV,KAAK,GAAG,CAAC,CAAC,KAAKc,KAAK,GAAG,CAAC,EAAE;MAC/CH,MAAM,GAAG,EAAEA,MAAM;IACnB;IACA,CAACE,GAAG,CAACF,MAAM,CAAC,KAAKE,GAAG,CAACF,MAAM,CAAC,GAAG,EAAE,CAAC,EAAEJ,IAAI,CAACO,KAAK,CAAC;IAC/C,OAAOD,GAAG;EACZ,CAAC,EAAE,EAAE,CAAe;AACtB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAME,kCAAkC,GAAGA,CACzCC,WAA8B,EAC9BtB,QAAsC,EACtCuB,SAA2B,KACxB;EACH,IAAI,aAAa,IAAID,WAAW,IAAIA,WAAW,CAACE,WAAW,EAAE;IAC3D,IAAID,SAAS,KAAK,MAAM,EAAE;MACxB,MAAME,gBAAgB,GAAGjC,KAAK,CAACkC,QAAQ,CAACJ,WAAW,CAAC,CAAEK,UAAU,CAC9DL,WAAW,CAACE,WAAW,CACxB;MACD,IAAIC,gBAAgB,EAAE;QACpB,OAAOzB,QAAQ,CAAC4B,OAAO,CAACH,gBAAgB,CAAC;MAC3C;IACF,CAAC,MAAM;MACL,OAAOzB,QAAQ,CAAC4B,OAAO,CAACN,WAAW,CAAC;IACtC;EACF,CAAC,MAAM;IAAA,IAAAO,qBAAA,EAAAC,sBAAA;IACL,MAAMC,cAAc,IAAAF,qBAAA,GAAGP,WAAW,CAACU,aAAa,cAAAH,qBAAA,wBAAAC,sBAAA,GAAzBD,qBAAA,CAA2BI,IAAI,CACnDC,OAAO,IAAKA,OAAO,CAACC,IAAI,KAAK,OAAO,CACtC,cAAAL,sBAAA,uBAFsBA,sBAAA,CAEpBnB,EAAE;IACL,IAAIoB,cAAc,EAAE;MAClB,IAAIR,SAAS,KAAK,MAAM,EAAE;QACxB,OAAOvB,QAAQ,CAAC4B,OAAO,CAACN,WAAW,CAAC;MACtC;MACA,MAAMc,gBAAgB,GACpB5C,KAAK,CAACkC,QAAQ,CAACJ,WAAW,CAAC,CAAEK,UAAU,CAACI,cAAc,CAAC;MAEzD,IAAIK,gBAAgB,EAAE;QACpB,OAAOpC,QAAQ,CAAC4B,OAAO,CAACQ,gBAAgB,CAAC;MAC3C;IACF;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,cAAc,GAAGA,CACrBpC,QAAkB,EAClBD,QAAsC,EACtCsC,aAAqB,EACrBf,SAA2B,KACxB;EACH,MAAMgB,aAAa,GAAGvC,QAAQ,CAACsC,aAAa,CAAC;EAE7C,MAAME,WAAW,GAAI3C,OAA0B,IAAK;IAClD,IAAIA,OAAO,CAACiB,SAAS,EAAE;MACrB,OAAO,KAAK;IACd;IACA;IACA;IACA,IAAIb,QAAQ,CAACwC,cAAc,EAAE;MAC3B,OAAO5C,OAAO,CAAC6C,QAAQ,CAACC,QAAQ,CAAC1C,QAAQ,CAACwC,cAAc,CAAC;IAC3D;IACA,OAAO,IAAI;EACb,CAAC;EAED,MAAMG,cAAc,GAClBrB,SAAS,KAAK,MAAM,GAChB5B,aAAa,CAACK,QAAQ,EAAEwC,WAAW,EAAEK,IAAI,CAACC,GAAG,CAAC,CAAC,EAAER,aAAa,GAAG,CAAC,CAAC,CAAC,GACpE5C,SAAS,CAACM,QAAQ,EAAEwC,WAAW,EAAEF,aAAa,GAAG,CAAC,CAAC;EAEzD,MAAMhB,WAAW,GAAGtB,QAAQ,CAAC4C,cAAc,CAAC;EAE5C,IAAI,CAACtB,WAAW,EAAE;IAChB,OAAO,CAAC,CAAC;EACX;EAEA,IAAIrB,QAAQ,CAACwC,cAAc,EAAE;IAC3B;IACE;IACA,CAAAF,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEG,QAAQ,CAACK,IAAI,CAAC,EAAE,CAAC,OAAKzB,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEoB,QAAQ,CAACK,IAAI,CAAC,EAAE,CAAC,GACnE;MAAA,IAAAC,qBAAA;MACA,QAAAA,qBAAA,GACE3B,kCAAkC,CAACC,WAAW,EAAEtB,QAAQ,EAAEuB,SAAS,CAAC,cAAAyB,qBAAA,cAAAA,qBAAA,GACpEJ,cAAc;IAElB,CAAC,MAAM,IAAI,EAACtB,WAAW,aAAXA,WAAW,eAAXA,WAAW,CAAEoB,QAAQ,CAACC,QAAQ,CAAC1C,QAAQ,CAACwC,cAAc,CAAC,GAAE;MACnE;MACA,OAAO,CAAC,CAAC;IACX;EACF;EAEA,IAAI,CAACnB,WAAW,CAACoB,QAAQ,CAACjC,MAAM,EAAE;IAAA,IAAAwC,sBAAA;IAChC,QAAAA,sBAAA,GACE5B,kCAAkC,CAACC,WAAW,EAAEtB,QAAQ,EAAEuB,SAAS,CAAC,cAAA0B,sBAAA,cAAAA,sBAAA,GACpEL,cAAc;EAElB;EAEA,MAAMM,cAAc,GAAGjD,QAAQ,CAACwC,cAAc,GAC1CnB,WAAW,CAACoB,QAAQ,CAClBpB,WAAW,CAACoB,QAAQ,CAACd,OAAO,CAAC3B,QAAQ,CAACwC,cAAc,CAAC,GAAG,CAAC,CAC1D,GACDnB,WAAW,CAACoB,QAAQ,CAACpB,WAAW,CAACoB,QAAQ,CAACjC,MAAM,GAAG,CAAC,CAAC;EAEzD,MAAM0C,sBAAsB,GAAG7D,kBAAkB,CAACU,QAAQ,EAAEkD,cAAc,CAAC;EAE3E,IAAIC,sBAAsB,CAAC1C,MAAM,EAAE;IACjC;IACA;IACA,OAAOc,SAAS,KAAK,MAAM,GACvBvB,QAAQ,CAAC4B,OAAO,CAACuB,sBAAsB,CAAC,CAAC,CAAC,CAAC,GAC3CnD,QAAQ,CAAC4B,OAAO,CACduB,sBAAsB,CAACA,sBAAsB,CAAC1C,MAAM,GAAG,CAAC,CAAC,CAC1D;EACP;EAEA,OAAOmC,cAAc;AACvB,CAAC;AAED,MAAMQ,oBAAoB,GAAGA,CAC3BpD,QAAsB,EACtBqD,OAAiB,KACd;EACH,OAAOA,OAAO,CAACnC,MAAM,CAAC,CAACC,GAAG,EAAEb,KAAK,KAAK;IACpC,MAAMT,OAAO,GAAGG,QAAQ,CAACM,KAAK,CAAC;IAC/Ba,GAAG,CAACtB,OAAO,CAACc,EAAE,CAAC,GAAGd,OAAO;IACzB,OAAOsB,GAAG;EACZ,CAAC,EAAE,CAAC,CAAC,CAAsC;AAC7C,CAAC;AAED,MAAMmC,cAAc,GAAGA,CACrBtD,QAAsC,EACtCC,QAAkB,EAClBsB,SAA2B,EAC3BrB,iBAAgD,KAC7C;EACH,MAAMqD,aAAa,GAAGxD,gBAAgB,CAACC,QAAQ,EAAEC,QAAQ,EAAEC,iBAAiB,CAAC;EAC7E,MAAMsD,iBAAiB,GAAGJ,oBAAoB,CAACpD,QAAQ,EAAEuD,aAAa,CAAC;EACvE,IAAIE,cAAc,GAAG1C,kBAAkB,CAACwC,aAAa,CAAC;EAEtD,IAAIhC,SAAS,KAAK,OAAO,EAAE;IACzBkC,cAAc,GAAGA,cAAc,CAACC,OAAO,EAAE;EAC3C;EAEAD,cAAc,CAACE,OAAO,CAAC,CAACN,OAAO,EAAEO,CAAC,KAAK;IACrC,MAAMC,YAAY,GAAGR,OAAO,CAAC,CAAC,CAAC;IAC/B,MAAMS,aAAa,GAAGT,OAAO,CAACA,OAAO,CAAC5C,MAAM,GAAG,CAAC,CAAC;IACjD,MAAM6B,aAAa,GAAGf,SAAS,KAAK,MAAM,GAAGsC,YAAY,GAAGC,aAAa;IAEzE,MAAMC,WAAW,GAAG1B,cAAc,CAChCpC,QAAQ,EACRD,QAAQ,EACRsC,aAAa,EACbf,SAAS,CACV;IAED,IAAIwC,WAAW,KAAK,CAAC,CAAC,IAAIzB,aAAa,KAAKyB,WAAW,EAAE;MACvD;IACF;IAEA,MAAMC,eAAe,GACnBzC,SAAS,KAAK,MAAM,GAChBvB,QAAQ,CAACiE,KAAK,CAAC,CAAC,EAAEF,WAAW,CAAC,GAC9B/D,QAAQ,CAACiE,KAAK,CAAC,CAAC,EAAEJ,YAAY,CAAC;IACrC,MAAMK,cAAc,GAAGlE,QAAQ,CAACiE,KAAK,CAACJ,YAAY,EAAEC,aAAa,GAAG,CAAC,CAAC;IACtE,MAAMK,iBAAiB,GACrB5C,SAAS,KAAK,MAAM,GAChBvB,QAAQ,CAACiE,KAAK,CAACF,WAAW,EAAEF,YAAY,CAAC,GACzC7D,QAAQ,CAACiE,KAAK,CAACH,aAAa,GAAG,CAAC,EAAEC,WAAW,GAAG,CAAC,CAAC;IACxD,MAAMK,gBAAgB,GACpB7C,SAAS,KAAK,MAAM,GAChBvB,QAAQ,CAACiE,KAAK,CAACH,aAAa,GAAG,CAAC,CAAC,GACjC9D,QAAQ,CAACiE,KAAK,CAACF,WAAW,GAAG,CAAC,CAAC;IAErC/D,QAAQ,GACNuB,SAAS,KAAK,MAAM,GAChB,CACE,GAAGyC,eAAe,EAClB,GAAGE,cAAc,EACjB,GAAGC,iBAAiB,EACpB,GAAGC,gBAAgB,CACpB,GACD,CACE,GAAGJ,eAAe,EAClB,GAAGG,iBAAiB,EACpB,GAAGD,cAAc,EACjB,GAAGE,gBAAgB,CACpB;EACT,CAAC,CAAC;EAEF,OAAOpE,QAAQ,CAACqE,GAAG,CAAExE,OAAO,IAAK;IAC/B,IAAI2D,iBAAiB,CAAC3D,OAAO,CAACc,EAAE,CAAC,EAAE;MACjC,OAAOxB,WAAW,CAACU,OAAO,CAAC;IAC7B;IACA,OAAOA,OAAO;EAChB,CAAC,CAAC;AACJ,CAAC;AAED,MAAMyE,aAAa,GAAGA,CACpBrE,QAAkB,EAClBD,QAAsC,EACtCuB,SAA2B,EAC3BrB,iBAAgD,KAC7C;EACH,OAAOqE,KAAK,CACVvE,QAAQ,EACRC,QAAQ,EACRsB,SAAS,EACT+B,cAAc,EACdpD,iBAAiB,CAClB;AACH,CAAC;AAED,MAAMsE,mBAAmB,GAAGA,CAC1BxE,QAAsC,EACtCC,QAAkB,EAClBsB,SAA2B,KACxB;EACH,MAAMgC,aAAa,GAAGxD,gBAAgB,CAACC,QAAQ,EAAEC,QAAQ,CAAC;EAC1D,MAAMuD,iBAAiB,GAAGJ,oBAAoB,CAACpD,QAAQ,EAAEuD,aAAa,CAAC;EACvE,MAAMY,iBAAsC,GAAG,EAAE;EAEjD,IAAIN,YAAoB;EACxB,IAAIC,aAAqB;EACzB,IAAIvC,SAAS,KAAK,MAAM,EAAE;IACxB,IAAItB,QAAQ,CAACwC,cAAc,EAAE;MAC3B,MAAMgC,aAAa,GAAGnF,kBAAkB,CACtCU,QAAQ,EACRC,QAAQ,CAACwC,cAAc,CACxB;MACD,IAAI,CAACgC,aAAa,CAAChE,MAAM,EAAE;QACzB,OAAOT,QAAQ;MACjB;MACA6D,YAAY,GAAG7D,QAAQ,CAAC4B,OAAO,CAAC6C,aAAa,CAAC,CAAC,CAAC,CAAC;IACnD,CAAC,MAAM;MACLZ,YAAY,GAAG,CAAC;IAClB;IAEAC,aAAa,GAAGP,aAAa,CAACA,aAAa,CAAC9C,MAAM,GAAG,CAAC,CAAC;EACzD,CAAC,MAAM;IACL,IAAIR,QAAQ,CAACwC,cAAc,EAAE;MAC3B,MAAMgC,aAAa,GAAGnF,kBAAkB,CACtCU,QAAQ,EACRC,QAAQ,CAACwC,cAAc,CACxB;MACD,IAAI,CAACgC,aAAa,CAAChE,MAAM,EAAE;QACzB,OAAOT,QAAQ;MACjB;MACA8D,aAAa,GAAG9D,QAAQ,CAAC4B,OAAO,CAAC6C,aAAa,CAACA,aAAa,CAAChE,MAAM,GAAG,CAAC,CAAC,CAAC;IAC3E,CAAC,MAAM;MACLqD,aAAa,GAAG9D,QAAQ,CAACS,MAAM,GAAG,CAAC;IACrC;IAEAoD,YAAY,GAAGN,aAAa,CAAC,CAAC,CAAC;EACjC;EAEA,KAAK,IAAIjD,KAAK,GAAGuD,YAAY,EAAEvD,KAAK,GAAGwD,aAAa,GAAG,CAAC,EAAExD,KAAK,EAAE,EAAE;IACjE,IAAI,CAACiD,aAAa,CAACZ,QAAQ,CAACrC,KAAK,CAAC,EAAE;MAClC6D,iBAAiB,CAACtD,IAAI,CAACb,QAAQ,CAACM,KAAK,CAAC,CAAC;IACzC;EACF;EAEA,MAAM4D,cAAc,GAAGQ,MAAM,CAACC,MAAM,CAACnB,iBAAiB,CAAC,CAACa,GAAG,CAAExE,OAAO,IAAK;IACvE,OAAOV,WAAW,CAACU,OAAO,CAAC;EAC7B,CAAC,CAAC;EAEF,MAAMmE,eAAe,GAAGhE,QAAQ,CAACiE,KAAK,CAAC,CAAC,EAAEJ,YAAY,CAAC;EACvD,MAAMO,gBAAgB,GAAGpE,QAAQ,CAACiE,KAAK,CAACH,aAAa,GAAG,CAAC,CAAC;EAE1D,OAAOvC,SAAS,KAAK,MAAM,GACvB,CACE,GAAGyC,eAAe,EAClB,GAAGE,cAAc,EACjB,GAAGC,iBAAiB,EACpB,GAAGC,gBAAgB,CACpB,GACD,CACE,GAAGJ,eAAe,EAClB,GAAGG,iBAAiB,EACpB,GAAGD,cAAc,EACjB,GAAGE,gBAAgB,CACpB;AACP,CAAC;AAED,MAAMQ,kBAAkB,GAAGA,CACzB5E,QAAsC,EACtCC,QAAkB,EAClBsB,SAA2B,EAC3BrB,iBAAgD,KAC7C;EACH,OAAOqE,KAAK,CACVvE,QAAQ,EACRC,QAAQ,EACRsB,SAAS,EACTiD,mBAAmB,EACnBtE,iBAAiB,CAClB;AACH,CAAC;AAED,SAASqE,KAAKA,CACZvE,QAAsC,EACtCC,QAAkB,EAClBsB,SAA2B,EAC3BsD,aAKuD,EACvD3E,iBAAgD,EAChD;EACA,MAAM4E,WAAW,GAAGrF,UAAU,CAACO,QAAQ,CAAC;EACxC,MAAM+E,gBAAgB,GAAG1F,aAAa,CAACW,QAAQ,CAAC;;EAEhD;EACA,IAAIgF,YAAY,GAAGhF,QAAQ,CAACiF,MAAM,CAC/BpF,OAAO,IACND,aAAa,CAACC,OAAO,CAAC,IACrBA,OAAO,CAACC,OAAO,IAAI,CAACgF,WAAW,CAACI,GAAG,CAACrF,OAAO,CAACC,OAAO,CAAE,CACzD;EACD;EACA,KAAK,MAAMA,OAAO,IAAIiF,gBAAgB,CAACI,IAAI,EAAE,EAAE;IAC7C,IAAI,CAACL,WAAW,CAACI,GAAG,CAACpF,OAAO,CAAC,EAAE;MAC7BiF,gBAAgB,CAACK,MAAM,CAACtF,OAAO,CAAC;IAClC;EACF;;EAEA;EACAkF,YAAY,GAAGH,aAAa,CAC1BG,YAAY,EACZ/E,QAAQ,EACRsB,SAAS,EACTrB,iBAAiB,CACK;;EAExB;EACA6E,gBAAgB,CAACpB,OAAO,CAAC,CAAC0B,aAAa,EAAEvF,OAAO,KAAK;IACnD,IAAI,CAACG,QAAQ,CAACM,kBAAkB,CAACT,OAAO,CAAC,EAAE;MACzCiF,gBAAgB,CAACO,GAAG,CAClBxF,OAAO,EACP+E,aAAa,CACXQ,aAAa,EACbpF,QAAQ,EACRsB,SAAS,EACTrB,iBAAiB,CAClB,CACF;IACH;EACF,CAAC,CAAC;;EAEF;EACA,IAAIqF,aAAkC,GAAG,EAAE;EAE3CP,YAAY,CAACrB,OAAO,CAAE9D,OAAO,IAAK;IAChC,IAAIT,cAAc,CAACS,OAAO,CAAC,EAAE;MAAA,IAAA2F,qBAAA;MAC3BD,aAAa,GAAG,CACd,GAAGA,aAAa,EAChB,KAAAC,qBAAA,GAAIT,gBAAgB,CAACrE,GAAG,CAACb,OAAO,CAACc,EAAE,CAAC,cAAA6E,qBAAA,cAAAA,qBAAA,GAAI,EAAE,CAAC,EAC3C3F,OAAO,CACR;IACH,CAAC,MAAM;MACL0F,aAAa,GAAG,CAAC,GAAGA,aAAa,EAAE1F,OAAO,CAAC;IAC7C;EACF,CAAC,CAAC;EAEF,OAAO0F,aAAa;AACtB;;AAEA;AACA;;AAEA,OAAO,MAAME,WAAW,GAAGA,CACzBzF,QAAsC,EACtCC,QAAkB,EAClBC,iBAAgD,KAC7C;EACH,OAAOoE,aAAa,CAACrE,QAAQ,EAAED,QAAQ,EAAE,MAAM,EAAEE,iBAAiB,CAAC;AACrE,CAAC;AAED,OAAO,MAAMwF,YAAY,GAAGA,CAC1B1F,QAAsC,EACtCC,QAAkB,EAClBC,iBAAgD,KAC7C;EACH,OAAOoE,aAAa,CAACrE,QAAQ,EAAED,QAAQ,EAAE,OAAO,EAAEE,iBAAiB,CAAC;AACtE,CAAC;AAED,OAAO,MAAMyF,WAAW,GAAGA,CACzB3F,QAAsC,EACtCC,QAAkB,EAClBC,iBAAgD,KAC7C;EACH,OAAO0E,kBAAkB,CAAC5E,QAAQ,EAAEC,QAAQ,EAAE,MAAM,EAAEC,iBAAiB,CAAC;AAC1E,CAAC;AAED,OAAO,MAAM0F,YAAY,GAAGA,CAC1B5F,QAAsC,EACtCC,QAAkB,EAClBC,iBAAgD,KAC7C;EACH,OAAO0E,kBAAkB,CAAC5E,QAAQ,EAAEC,QAAQ,EAAE,OAAO,EAAEC,iBAAiB,CAAC;AAC3E,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}