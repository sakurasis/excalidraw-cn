{"ast":null,"code":"import { isLinearElement } from \"./element/typeChecks\";\nimport { deepCopyElement } from \"./element/newElement\";\nconst clearAppStatePropertiesForHistory = appState => {\n  return {\n    selectedElementIds: appState.selectedElementIds,\n    selectedGroupIds: appState.selectedGroupIds,\n    viewBackgroundColor: appState.viewBackgroundColor,\n    editingLinearElement: appState.editingLinearElement,\n    editingGroupId: appState.editingGroupId,\n    name: appState.name\n  };\n};\nclass History {\n  constructor() {\n    this.elementCache = new Map();\n    this.recording = true;\n    this.stateHistory = [];\n    this.redoStack = [];\n    this.lastEntry = null;\n    this.generateEntry = (appState, elements) => this.dehydrateHistoryEntry({\n      appState: clearAppStatePropertiesForHistory(appState),\n      elements: elements.reduce((elements, element) => {\n        if (isLinearElement(element) && appState.multiElement && appState.multiElement.id === element.id) {\n          // don't store multi-point arrow if still has only one point\n          if (appState.multiElement && appState.multiElement.id === element.id && element.points.length < 2) {\n            return elements;\n          }\n          elements.push({\n            ...element,\n            // don't store last point if not committed\n            points: element.lastCommittedPoint !== element.points[element.points.length - 1] ? element.points.slice(0, -1) : element.points\n          });\n        } else {\n          elements.push(element);\n        }\n        return elements;\n      }, [])\n    });\n  }\n  hydrateHistoryEntry(_ref) {\n    let {\n      appState,\n      elements\n    } = _ref;\n    return {\n      appState: JSON.parse(appState),\n      elements: elements.map(dehydratedExcalidrawElement => {\n        var _this$elementCache$ge;\n        const element = (_this$elementCache$ge = this.elementCache.get(dehydratedExcalidrawElement.id)) === null || _this$elementCache$ge === void 0 ? void 0 : _this$elementCache$ge.get(dehydratedExcalidrawElement.versionNonce);\n        if (!element) {\n          throw new Error(`Element not found: ${dehydratedExcalidrawElement.id}:${dehydratedExcalidrawElement.versionNonce}`);\n        }\n        return element;\n      })\n    };\n  }\n  dehydrateHistoryEntry(_ref2) {\n    let {\n      appState,\n      elements\n    } = _ref2;\n    return {\n      appState: JSON.stringify(appState),\n      elements: elements.map(element => {\n        if (!this.elementCache.has(element.id)) {\n          this.elementCache.set(element.id, new Map());\n        }\n        const versions = this.elementCache.get(element.id);\n        if (!versions.has(element.versionNonce)) {\n          versions.set(element.versionNonce, deepCopyElement(element));\n        }\n        return {\n          id: element.id,\n          versionNonce: element.versionNonce\n        };\n      })\n    };\n  }\n  getSnapshotForTest() {\n    return {\n      recording: this.recording,\n      stateHistory: this.stateHistory.map(dehydratedHistoryEntry => this.hydrateHistoryEntry(dehydratedHistoryEntry)),\n      redoStack: this.redoStack.map(dehydratedHistoryEntry => this.hydrateHistoryEntry(dehydratedHistoryEntry))\n    };\n  }\n  clear() {\n    this.stateHistory.length = 0;\n    this.redoStack.length = 0;\n    this.lastEntry = null;\n    this.elementCache.clear();\n  }\n  shouldCreateEntry(nextEntry) {\n    const {\n      lastEntry\n    } = this;\n    if (!lastEntry) {\n      return true;\n    }\n    if (nextEntry.elements.length !== lastEntry.elements.length) {\n      return true;\n    }\n\n    // loop from right to left as changes are likelier to happen on new elements\n    for (let i = nextEntry.elements.length - 1; i > -1; i--) {\n      const prev = nextEntry.elements[i];\n      const next = lastEntry.elements[i];\n      if (!prev || !next || prev.id !== next.id || prev.versionNonce !== next.versionNonce) {\n        return true;\n      }\n    }\n\n    // note: this is safe because entry's appState is guaranteed no excess props\n    let key;\n    for (key in nextEntry.appState) {\n      if (key === \"editingLinearElement\") {\n        var _nextEntry$appState$k, _lastEntry$appState$k;\n        if (((_nextEntry$appState$k = nextEntry.appState[key]) === null || _nextEntry$appState$k === void 0 ? void 0 : _nextEntry$appState$k.elementId) === ((_lastEntry$appState$k = lastEntry.appState[key]) === null || _lastEntry$appState$k === void 0 ? void 0 : _lastEntry$appState$k.elementId)) {\n          continue;\n        }\n      }\n      if (key === \"selectedElementIds\" || key === \"selectedGroupIds\") {\n        continue;\n      }\n      if (nextEntry.appState[key] !== lastEntry.appState[key]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  pushEntry(appState, elements) {\n    const newEntryDehydrated = this.generateEntry(appState, elements);\n    const newEntry = this.hydrateHistoryEntry(newEntryDehydrated);\n    if (newEntry) {\n      if (!this.shouldCreateEntry(newEntry)) {\n        return;\n      }\n      this.stateHistory.push(newEntryDehydrated);\n      this.lastEntry = newEntry;\n      // As a new entry was pushed, we invalidate the redo stack\n      this.clearRedoStack();\n    }\n  }\n  clearRedoStack() {\n    this.redoStack.splice(0, this.redoStack.length);\n  }\n  redoOnce() {\n    if (this.redoStack.length === 0) {\n      return null;\n    }\n    const entryToRestore = this.redoStack.pop();\n    if (entryToRestore !== undefined) {\n      this.stateHistory.push(entryToRestore);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n    return null;\n  }\n  undoOnce() {\n    if (this.stateHistory.length === 1) {\n      return null;\n    }\n    const currentEntry = this.stateHistory.pop();\n    const entryToRestore = this.stateHistory[this.stateHistory.length - 1];\n    if (currentEntry !== undefined) {\n      this.redoStack.push(currentEntry);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n    return null;\n  }\n\n  /**\n   * Updates history's `lastEntry` to latest app state. This is necessary\n   *  when doing undo/redo which itself doesn't commit to history, but updates\n   *  app state in a way that would break `shouldCreateEntry` which relies on\n   *  `lastEntry` to reflect last comittable history state.\n   * We can't update `lastEntry` from within history when calling undo/redo\n   *  because the action potentially mutates appState/elements before storing\n   *  it.\n   */\n  setCurrentState(appState, elements) {\n    this.lastEntry = this.hydrateHistoryEntry(this.generateEntry(appState, elements));\n  }\n\n  // Suspicious that this is called so many places. Seems error-prone.\n  resumeRecording() {\n    this.recording = true;\n  }\n  record(state, elements) {\n    if (this.recording) {\n      this.pushEntry(state, elements);\n      this.recording = false;\n    }\n  }\n}\nexport default History;","map":{"version":3,"names":["isLinearElement","deepCopyElement","clearAppStatePropertiesForHistory","appState","selectedElementIds","selectedGroupIds","viewBackgroundColor","editingLinearElement","editingGroupId","name","History","constructor","elementCache","Map","recording","stateHistory","redoStack","lastEntry","generateEntry","elements","dehydrateHistoryEntry","reduce","element","multiElement","id","points","length","push","lastCommittedPoint","slice","hydrateHistoryEntry","_ref","JSON","parse","map","dehydratedExcalidrawElement","_this$elementCache$ge","get","versionNonce","Error","_ref2","stringify","has","set","versions","getSnapshotForTest","dehydratedHistoryEntry","clear","shouldCreateEntry","nextEntry","i","prev","next","key","_nextEntry$appState$k","_lastEntry$appState$k","elementId","pushEntry","newEntryDehydrated","newEntry","clearRedoStack","splice","redoOnce","entryToRestore","pop","undefined","undoOnce","currentEntry","setCurrentState","resumeRecording","record","state"],"sources":["D:/project/excalidraw-cn/src/history.ts"],"sourcesContent":["import { AppState } from \"./types\";\nimport { ExcalidrawElement } from \"./element/types\";\nimport { isLinearElement } from \"./element/typeChecks\";\nimport { deepCopyElement } from \"./element/newElement\";\nimport { Mutable } from \"./utility-types\";\n\nexport interface HistoryEntry {\n  appState: ReturnType<typeof clearAppStatePropertiesForHistory>;\n  elements: ExcalidrawElement[];\n}\n\ninterface DehydratedExcalidrawElement {\n  id: string;\n  versionNonce: number;\n}\n\ninterface DehydratedHistoryEntry {\n  appState: string;\n  elements: DehydratedExcalidrawElement[];\n}\n\nconst clearAppStatePropertiesForHistory = (appState: AppState) => {\n  return {\n    selectedElementIds: appState.selectedElementIds,\n    selectedGroupIds: appState.selectedGroupIds,\n    viewBackgroundColor: appState.viewBackgroundColor,\n    editingLinearElement: appState.editingLinearElement,\n    editingGroupId: appState.editingGroupId,\n    name: appState.name,\n  };\n};\n\nclass History {\n  private elementCache = new Map<string, Map<number, ExcalidrawElement>>();\n  private recording: boolean = true;\n  private stateHistory: DehydratedHistoryEntry[] = [];\n  private redoStack: DehydratedHistoryEntry[] = [];\n  private lastEntry: HistoryEntry | null = null;\n\n  private hydrateHistoryEntry({\n    appState,\n    elements,\n  }: DehydratedHistoryEntry): HistoryEntry {\n    return {\n      appState: JSON.parse(appState),\n      elements: elements.map((dehydratedExcalidrawElement) => {\n        const element = this.elementCache\n          .get(dehydratedExcalidrawElement.id)\n          ?.get(dehydratedExcalidrawElement.versionNonce);\n        if (!element) {\n          throw new Error(\n            `Element not found: ${dehydratedExcalidrawElement.id}:${dehydratedExcalidrawElement.versionNonce}`,\n          );\n        }\n        return element;\n      }),\n    };\n  }\n\n  private dehydrateHistoryEntry({\n    appState,\n    elements,\n  }: HistoryEntry): DehydratedHistoryEntry {\n    return {\n      appState: JSON.stringify(appState),\n      elements: elements.map((element: ExcalidrawElement) => {\n        if (!this.elementCache.has(element.id)) {\n          this.elementCache.set(element.id, new Map());\n        }\n        const versions = this.elementCache.get(element.id)!;\n        if (!versions.has(element.versionNonce)) {\n          versions.set(element.versionNonce, deepCopyElement(element));\n        }\n        return {\n          id: element.id,\n          versionNonce: element.versionNonce,\n        };\n      }),\n    };\n  }\n\n  getSnapshotForTest() {\n    return {\n      recording: this.recording,\n      stateHistory: this.stateHistory.map((dehydratedHistoryEntry) =>\n        this.hydrateHistoryEntry(dehydratedHistoryEntry),\n      ),\n      redoStack: this.redoStack.map((dehydratedHistoryEntry) =>\n        this.hydrateHistoryEntry(dehydratedHistoryEntry),\n      ),\n    };\n  }\n\n  clear() {\n    this.stateHistory.length = 0;\n    this.redoStack.length = 0;\n    this.lastEntry = null;\n    this.elementCache.clear();\n  }\n\n  private generateEntry = (\n    appState: AppState,\n    elements: readonly ExcalidrawElement[],\n  ): DehydratedHistoryEntry =>\n    this.dehydrateHistoryEntry({\n      appState: clearAppStatePropertiesForHistory(appState),\n      elements: elements.reduce((elements, element) => {\n        if (\n          isLinearElement(element) &&\n          appState.multiElement &&\n          appState.multiElement.id === element.id\n        ) {\n          // don't store multi-point arrow if still has only one point\n          if (\n            appState.multiElement &&\n            appState.multiElement.id === element.id &&\n            element.points.length < 2\n          ) {\n            return elements;\n          }\n\n          elements.push({\n            ...element,\n            // don't store last point if not committed\n            points:\n              element.lastCommittedPoint !==\n              element.points[element.points.length - 1]\n                ? element.points.slice(0, -1)\n                : element.points,\n          });\n        } else {\n          elements.push(element);\n        }\n        return elements;\n      }, [] as Mutable<typeof elements>),\n    });\n\n  shouldCreateEntry(nextEntry: HistoryEntry): boolean {\n    const { lastEntry } = this;\n\n    if (!lastEntry) {\n      return true;\n    }\n\n    if (nextEntry.elements.length !== lastEntry.elements.length) {\n      return true;\n    }\n\n    // loop from right to left as changes are likelier to happen on new elements\n    for (let i = nextEntry.elements.length - 1; i > -1; i--) {\n      const prev = nextEntry.elements[i];\n      const next = lastEntry.elements[i];\n      if (\n        !prev ||\n        !next ||\n        prev.id !== next.id ||\n        prev.versionNonce !== next.versionNonce\n      ) {\n        return true;\n      }\n    }\n\n    // note: this is safe because entry's appState is guaranteed no excess props\n    let key: keyof typeof nextEntry.appState;\n    for (key in nextEntry.appState) {\n      if (key === \"editingLinearElement\") {\n        if (\n          nextEntry.appState[key]?.elementId ===\n          lastEntry.appState[key]?.elementId\n        ) {\n          continue;\n        }\n      }\n      if (key === \"selectedElementIds\" || key === \"selectedGroupIds\") {\n        continue;\n      }\n      if (nextEntry.appState[key] !== lastEntry.appState[key]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  pushEntry(appState: AppState, elements: readonly ExcalidrawElement[]) {\n    const newEntryDehydrated = this.generateEntry(appState, elements);\n    const newEntry: HistoryEntry = this.hydrateHistoryEntry(newEntryDehydrated);\n\n    if (newEntry) {\n      if (!this.shouldCreateEntry(newEntry)) {\n        return;\n      }\n\n      this.stateHistory.push(newEntryDehydrated);\n      this.lastEntry = newEntry;\n      // As a new entry was pushed, we invalidate the redo stack\n      this.clearRedoStack();\n    }\n  }\n\n  clearRedoStack() {\n    this.redoStack.splice(0, this.redoStack.length);\n  }\n\n  redoOnce(): HistoryEntry | null {\n    if (this.redoStack.length === 0) {\n      return null;\n    }\n\n    const entryToRestore = this.redoStack.pop();\n\n    if (entryToRestore !== undefined) {\n      this.stateHistory.push(entryToRestore);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  undoOnce(): HistoryEntry | null {\n    if (this.stateHistory.length === 1) {\n      return null;\n    }\n\n    const currentEntry = this.stateHistory.pop();\n\n    const entryToRestore = this.stateHistory[this.stateHistory.length - 1];\n\n    if (currentEntry !== undefined) {\n      this.redoStack.push(currentEntry);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  /**\n   * Updates history's `lastEntry` to latest app state. This is necessary\n   *  when doing undo/redo which itself doesn't commit to history, but updates\n   *  app state in a way that would break `shouldCreateEntry` which relies on\n   *  `lastEntry` to reflect last comittable history state.\n   * We can't update `lastEntry` from within history when calling undo/redo\n   *  because the action potentially mutates appState/elements before storing\n   *  it.\n   */\n  setCurrentState(appState: AppState, elements: readonly ExcalidrawElement[]) {\n    this.lastEntry = this.hydrateHistoryEntry(\n      this.generateEntry(appState, elements),\n    );\n  }\n\n  // Suspicious that this is called so many places. Seems error-prone.\n  resumeRecording() {\n    this.recording = true;\n  }\n\n  record(state: AppState, elements: readonly ExcalidrawElement[]) {\n    if (this.recording) {\n      this.pushEntry(state, elements);\n      this.recording = false;\n    }\n  }\n}\n\nexport default History;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}