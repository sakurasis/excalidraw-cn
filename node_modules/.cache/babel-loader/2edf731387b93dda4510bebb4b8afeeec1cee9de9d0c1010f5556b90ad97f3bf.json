{"ast":null,"code":"// -----------------------------------------------------------------------------\n// ExcalidrawImageElement & related helpers\n// -----------------------------------------------------------------------------\n\nimport { MIME_TYPES, SVG_NS } from \"../constants\";\nimport { t } from \"../i18n\";\nimport { isInitializedImageElement } from \"./typeChecks\";\nexport const loadHTMLImageElement = dataURL => {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n    image.onload = () => {\n      resolve(image);\n    };\n    image.onerror = error => {\n      reject(error);\n    };\n    image.src = dataURL;\n  });\n};\n\n/** NOTE: updates cache even if already populated with given image. Thus,\n * you should filter out the images upstream if you want to optimize this. */\nexport const updateImageCache = async _ref => {\n  let {\n    fileIds,\n    files,\n    imageCache\n  } = _ref;\n  const updatedFiles = new Map();\n  const erroredFiles = new Map();\n  await Promise.all(fileIds.reduce((promises, fileId) => {\n    const fileData = files[fileId];\n    if (fileData && !updatedFiles.has(fileId)) {\n      updatedFiles.set(fileId, true);\n      return promises.concat((async () => {\n        try {\n          if (fileData.mimeType === MIME_TYPES.binary) {\n            throw new Error(\"Only images can be added to ImageCache\");\n          }\n          const imagePromise = loadHTMLImageElement(fileData.dataURL);\n          const data = {\n            image: imagePromise,\n            mimeType: fileData.mimeType\n          };\n          // store the promise immediately to indicate there's an in-progress\n          // initialization\n          imageCache.set(fileId, data);\n          const image = await imagePromise;\n          imageCache.set(fileId, {\n            ...data,\n            image\n          });\n        } catch (error) {\n          erroredFiles.set(fileId, true);\n        }\n      })());\n    }\n    return promises;\n  }, []));\n  return {\n    imageCache,\n    /** includes errored files because they cache was updated nonetheless */\n    updatedFiles,\n    /** files that failed when creating HTMLImageElement */\n    erroredFiles\n  };\n};\nexport const getInitializedImageElements = elements => elements.filter(element => isInitializedImageElement(element));\nexport const isHTMLSVGElement = node => {\n  // lower-casing due to XML/HTML convention differences\n  // https://johnresig.com/blog/nodename-case-sensitivity\n  return (node === null || node === void 0 ? void 0 : node.nodeName.toLowerCase()) === \"svg\";\n};\nexport const normalizeSVG = async SVGString => {\n  const doc = new DOMParser().parseFromString(SVGString, MIME_TYPES.svg);\n  const svg = doc.querySelector(\"svg\");\n  const errorNode = doc.querySelector(\"parsererror\");\n  if (errorNode || !isHTMLSVGElement(svg)) {\n    throw new Error(t(\"errors.invalidSVGString\"));\n  } else {\n    if (!svg.hasAttribute(\"xmlns\")) {\n      svg.setAttribute(\"xmlns\", SVG_NS);\n    }\n    if (!svg.hasAttribute(\"width\") || !svg.hasAttribute(\"height\")) {\n      const viewBox = svg.getAttribute(\"viewBox\");\n      let width = svg.getAttribute(\"width\") || \"50\";\n      let height = svg.getAttribute(\"height\") || \"50\";\n      if (viewBox) {\n        const match = viewBox.match(/\\d+ +\\d+ +(\\d+) +(\\d+)/);\n        if (match) {\n          [, width, height] = match;\n        }\n      }\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n    return svg.outerHTML;\n  }\n};","map":{"version":3,"names":["MIME_TYPES","SVG_NS","t","isInitializedImageElement","loadHTMLImageElement","dataURL","Promise","resolve","reject","image","Image","onload","onerror","error","src","updateImageCache","_ref","fileIds","files","imageCache","updatedFiles","Map","erroredFiles","all","reduce","promises","fileId","fileData","has","set","concat","mimeType","binary","Error","imagePromise","data","getInitializedImageElements","elements","filter","element","isHTMLSVGElement","node","nodeName","toLowerCase","normalizeSVG","SVGString","doc","DOMParser","parseFromString","svg","querySelector","errorNode","hasAttribute","setAttribute","viewBox","getAttribute","width","height","match","outerHTML"],"sources":["D:/project/excalidraw-cn/src/element/image.ts"],"sourcesContent":["// -----------------------------------------------------------------------------\n// ExcalidrawImageElement & related helpers\n// -----------------------------------------------------------------------------\n\nimport { MIME_TYPES, SVG_NS } from \"../constants\";\nimport { t } from \"../i18n\";\nimport { AppClassProperties, DataURL, BinaryFiles } from \"../types\";\nimport { isInitializedImageElement } from \"./typeChecks\";\nimport {\n  ExcalidrawElement,\n  FileId,\n  InitializedExcalidrawImageElement,\n} from \"./types\";\n\nexport const loadHTMLImageElement = (dataURL: DataURL) => {\n  return new Promise<HTMLImageElement>((resolve, reject) => {\n    const image = new Image();\n    image.onload = () => {\n      resolve(image);\n    };\n    image.onerror = (error) => {\n      reject(error);\n    };\n    image.src = dataURL;\n  });\n};\n\n/** NOTE: updates cache even if already populated with given image. Thus,\n * you should filter out the images upstream if you want to optimize this. */\nexport const updateImageCache = async ({\n  fileIds,\n  files,\n  imageCache,\n}: {\n  fileIds: FileId[];\n  files: BinaryFiles;\n  imageCache: AppClassProperties[\"imageCache\"];\n}) => {\n  const updatedFiles = new Map<FileId, true>();\n  const erroredFiles = new Map<FileId, true>();\n\n  await Promise.all(\n    fileIds.reduce((promises, fileId) => {\n      const fileData = files[fileId as string];\n      if (fileData && !updatedFiles.has(fileId)) {\n        updatedFiles.set(fileId, true);\n        return promises.concat(\n          (async () => {\n            try {\n              if (fileData.mimeType === MIME_TYPES.binary) {\n                throw new Error(\"Only images can be added to ImageCache\");\n              }\n\n              const imagePromise = loadHTMLImageElement(fileData.dataURL);\n              const data = {\n                image: imagePromise,\n                mimeType: fileData.mimeType,\n              } as const;\n              // store the promise immediately to indicate there's an in-progress\n              // initialization\n              imageCache.set(fileId, data);\n\n              const image = await imagePromise;\n\n              imageCache.set(fileId, { ...data, image });\n            } catch (error: any) {\n              erroredFiles.set(fileId, true);\n            }\n          })(),\n        );\n      }\n      return promises;\n    }, [] as Promise<any>[]),\n  );\n\n  return {\n    imageCache,\n    /** includes errored files because they cache was updated nonetheless */\n    updatedFiles,\n    /** files that failed when creating HTMLImageElement */\n    erroredFiles,\n  };\n};\n\nexport const getInitializedImageElements = (\n  elements: readonly ExcalidrawElement[],\n) =>\n  elements.filter((element) =>\n    isInitializedImageElement(element),\n  ) as InitializedExcalidrawImageElement[];\n\nexport const isHTMLSVGElement = (node: Node | null): node is SVGElement => {\n  // lower-casing due to XML/HTML convention differences\n  // https://johnresig.com/blog/nodename-case-sensitivity\n  return node?.nodeName.toLowerCase() === \"svg\";\n};\n\nexport const normalizeSVG = async (SVGString: string) => {\n  const doc = new DOMParser().parseFromString(SVGString, MIME_TYPES.svg);\n  const svg = doc.querySelector(\"svg\");\n  const errorNode = doc.querySelector(\"parsererror\");\n  if (errorNode || !isHTMLSVGElement(svg)) {\n    throw new Error(t(\"errors.invalidSVGString\"));\n  } else {\n    if (!svg.hasAttribute(\"xmlns\")) {\n      svg.setAttribute(\"xmlns\", SVG_NS);\n    }\n\n    if (!svg.hasAttribute(\"width\") || !svg.hasAttribute(\"height\")) {\n      const viewBox = svg.getAttribute(\"viewBox\");\n      let width = svg.getAttribute(\"width\") || \"50\";\n      let height = svg.getAttribute(\"height\") || \"50\";\n      if (viewBox) {\n        const match = viewBox.match(/\\d+ +\\d+ +(\\d+) +(\\d+)/);\n        if (match) {\n          [, width, height] = match;\n        }\n      }\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n\n    return svg.outerHTML;\n  }\n};\n"],"mappings":"AAAA;AACA;AACA;;AAEA,SAASA,UAAU,EAAEC,MAAM,QAAQ,cAAc;AACjD,SAASC,CAAC,QAAQ,SAAS;AAE3B,SAASC,yBAAyB,QAAQ,cAAc;AAOxD,OAAO,MAAMC,oBAAoB,GAAIC,OAAgB,IAAK;EACxD,OAAO,IAAIC,OAAO,CAAmB,CAACC,OAAO,EAAEC,MAAM,KAAK;IACxD,MAAMC,KAAK,GAAG,IAAIC,KAAK,EAAE;IACzBD,KAAK,CAACE,MAAM,GAAG,MAAM;MACnBJ,OAAO,CAACE,KAAK,CAAC;IAChB,CAAC;IACDA,KAAK,CAACG,OAAO,GAAIC,KAAK,IAAK;MACzBL,MAAM,CAACK,KAAK,CAAC;IACf,CAAC;IACDJ,KAAK,CAACK,GAAG,GAAGT,OAAO;EACrB,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA,OAAO,MAAMU,gBAAgB,GAAG,MAAAC,IAAA,IAQ1B;EAAA,IARiC;IACrCC,OAAO;IACPC,KAAK;IACLC;EAKF,CAAC,GAAAH,IAAA;EACC,MAAMI,YAAY,GAAG,IAAIC,GAAG,EAAgB;EAC5C,MAAMC,YAAY,GAAG,IAAID,GAAG,EAAgB;EAE5C,MAAMf,OAAO,CAACiB,GAAG,CACfN,OAAO,CAACO,MAAM,CAAC,CAACC,QAAQ,EAAEC,MAAM,KAAK;IACnC,MAAMC,QAAQ,GAAGT,KAAK,CAACQ,MAAM,CAAW;IACxC,IAAIC,QAAQ,IAAI,CAACP,YAAY,CAACQ,GAAG,CAACF,MAAM,CAAC,EAAE;MACzCN,YAAY,CAACS,GAAG,CAACH,MAAM,EAAE,IAAI,CAAC;MAC9B,OAAOD,QAAQ,CAACK,MAAM,CACpB,CAAC,YAAY;QACX,IAAI;UACF,IAAIH,QAAQ,CAACI,QAAQ,KAAK/B,UAAU,CAACgC,MAAM,EAAE;YAC3C,MAAM,IAAIC,KAAK,CAAC,wCAAwC,CAAC;UAC3D;UAEA,MAAMC,YAAY,GAAG9B,oBAAoB,CAACuB,QAAQ,CAACtB,OAAO,CAAC;UAC3D,MAAM8B,IAAI,GAAG;YACX1B,KAAK,EAAEyB,YAAY;YACnBH,QAAQ,EAAEJ,QAAQ,CAACI;UACrB,CAAU;UACV;UACA;UACAZ,UAAU,CAACU,GAAG,CAACH,MAAM,EAAES,IAAI,CAAC;UAE5B,MAAM1B,KAAK,GAAG,MAAMyB,YAAY;UAEhCf,UAAU,CAACU,GAAG,CAACH,MAAM,EAAE;YAAE,GAAGS,IAAI;YAAE1B;UAAM,CAAC,CAAC;QAC5C,CAAC,CAAC,OAAOI,KAAU,EAAE;UACnBS,YAAY,CAACO,GAAG,CAACH,MAAM,EAAE,IAAI,CAAC;QAChC;MACF,CAAC,GAAG,CACL;IACH;IACA,OAAOD,QAAQ;EACjB,CAAC,EAAE,EAAE,CAAmB,CACzB;EAED,OAAO;IACLN,UAAU;IACV;IACAC,YAAY;IACZ;IACAE;EACF,CAAC;AACH,CAAC;AAED,OAAO,MAAMc,2BAA2B,GACtCC,QAAsC,IAEtCA,QAAQ,CAACC,MAAM,CAAEC,OAAO,IACtBpC,yBAAyB,CAACoC,OAAO,CAAC,CACI;AAE1C,OAAO,MAAMC,gBAAgB,GAAIC,IAAiB,IAAyB;EACzE;EACA;EACA,OAAO,CAAAA,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEC,QAAQ,CAACC,WAAW,EAAE,MAAK,KAAK;AAC/C,CAAC;AAED,OAAO,MAAMC,YAAY,GAAG,MAAOC,SAAiB,IAAK;EACvD,MAAMC,GAAG,GAAG,IAAIC,SAAS,EAAE,CAACC,eAAe,CAACH,SAAS,EAAE7C,UAAU,CAACiD,GAAG,CAAC;EACtE,MAAMA,GAAG,GAAGH,GAAG,CAACI,aAAa,CAAC,KAAK,CAAC;EACpC,MAAMC,SAAS,GAAGL,GAAG,CAACI,aAAa,CAAC,aAAa,CAAC;EAClD,IAAIC,SAAS,IAAI,CAACX,gBAAgB,CAACS,GAAG,CAAC,EAAE;IACvC,MAAM,IAAIhB,KAAK,CAAC/B,CAAC,CAAC,yBAAyB,CAAC,CAAC;EAC/C,CAAC,MAAM;IACL,IAAI,CAAC+C,GAAG,CAACG,YAAY,CAAC,OAAO,CAAC,EAAE;MAC9BH,GAAG,CAACI,YAAY,CAAC,OAAO,EAAEpD,MAAM,CAAC;IACnC;IAEA,IAAI,CAACgD,GAAG,CAACG,YAAY,CAAC,OAAO,CAAC,IAAI,CAACH,GAAG,CAACG,YAAY,CAAC,QAAQ,CAAC,EAAE;MAC7D,MAAME,OAAO,GAAGL,GAAG,CAACM,YAAY,CAAC,SAAS,CAAC;MAC3C,IAAIC,KAAK,GAAGP,GAAG,CAACM,YAAY,CAAC,OAAO,CAAC,IAAI,IAAI;MAC7C,IAAIE,MAAM,GAAGR,GAAG,CAACM,YAAY,CAAC,QAAQ,CAAC,IAAI,IAAI;MAC/C,IAAID,OAAO,EAAE;QACX,MAAMI,KAAK,GAAGJ,OAAO,CAACI,KAAK,CAAC,wBAAwB,CAAC;QACrD,IAAIA,KAAK,EAAE;UACT,GAAGF,KAAK,EAAEC,MAAM,CAAC,GAAGC,KAAK;QAC3B;MACF;MACAT,GAAG,CAACI,YAAY,CAAC,OAAO,EAAEG,KAAK,CAAC;MAChCP,GAAG,CAACI,YAAY,CAAC,QAAQ,EAAEI,MAAM,CAAC;IACpC;IAEA,OAAOR,GAAG,CAACU,SAAS;EACtB;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}