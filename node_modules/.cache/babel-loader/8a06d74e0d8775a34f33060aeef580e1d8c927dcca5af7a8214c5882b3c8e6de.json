{"ast":null,"code":"export const hasBackground = type => type === \"rectangle\" || type === \"ellipse\" || type === \"diamond\" || type === \"line\" || type === \"freedraw\";\nexport const hasStrokeColor = type => type !== \"image\" && type !== \"frame\";\nexport const hasStrokeWidth = type => type === \"rectangle\" || type === \"ellipse\" || type === \"diamond\" || type === \"freedraw\" || type === \"arrow\" || type === \"line\";\nexport const hasStrokeStyle = type => type === \"rectangle\" || type === \"ellipse\" || type === \"diamond\" || type === \"arrow\" || type === \"line\";\nexport const canChangeRoundness = type => type === \"rectangle\" || type === \"arrow\" || type === \"line\" || type === \"diamond\";\nexport const hasText = type => type === \"text\";\nexport const canHaveArrowheads = type => type === \"arrow\";\nexport const getElementAtPosition = (elements, isAtPositionFn) => {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  // because array is ordered from lower z-index to highest and we want element z-index\n  // with higher z-index\n  for (let index = elements.length - 1; index >= 0; --index) {\n    const element = elements[index];\n    if (element.isDeleted) {\n      continue;\n    }\n    if (isAtPositionFn(element)) {\n      hitElement = element;\n      break;\n    }\n  }\n  return hitElement;\n};\nexport const getElementsAtPosition = (elements, isAtPositionFn) => {\n  // The parameter elements comes ordered from lower z-index to higher.\n  // We want to preserve that order on the returned array.\n  return elements.filter(element => !element.isDeleted && isAtPositionFn(element));\n};","map":{"version":3,"names":["hasBackground","type","hasStrokeColor","hasStrokeWidth","hasStrokeStyle","canChangeRoundness","hasText","canHaveArrowheads","getElementAtPosition","elements","isAtPositionFn","hitElement","index","length","element","isDeleted","getElementsAtPosition","filter"],"sources":["D:/project/excalidraw-cn/src/scene/comparisons.ts"],"sourcesContent":["import { NonDeletedExcalidrawElement } from \"../element/types\";\n\nexport const hasBackground = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"line\" ||\n  type === \"freedraw\";\n\nexport const hasStrokeColor = (type: string) =>\n  type !== \"image\" && type !== \"frame\";\n\nexport const hasStrokeWidth = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"freedraw\" ||\n  type === \"arrow\" ||\n  type === \"line\";\n\nexport const hasStrokeStyle = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"arrow\" ||\n  type === \"line\";\n\nexport const canChangeRoundness = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"arrow\" ||\n  type === \"line\" ||\n  type === \"diamond\";\n\nexport const hasText = (type: string) => type === \"text\";\n\nexport const canHaveArrowheads = (type: string) => type === \"arrow\";\n\nexport const getElementAtPosition = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  // because array is ordered from lower z-index to highest and we want element z-index\n  // with higher z-index\n  for (let index = elements.length - 1; index >= 0; --index) {\n    const element = elements[index];\n    if (element.isDeleted) {\n      continue;\n    }\n    if (isAtPositionFn(element)) {\n      hitElement = element;\n      break;\n    }\n  }\n\n  return hitElement;\n};\n\nexport const getElementsAtPosition = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  // The parameter elements comes ordered from lower z-index to higher.\n  // We want to preserve that order on the returned array.\n  return elements.filter(\n    (element) => !element.isDeleted && isAtPositionFn(element),\n  );\n};\n"],"mappings":"AAEA,OAAO,MAAMA,aAAa,GAAIC,IAAY,IACxCA,IAAI,KAAK,WAAW,IACpBA,IAAI,KAAK,SAAS,IAClBA,IAAI,KAAK,SAAS,IAClBA,IAAI,KAAK,MAAM,IACfA,IAAI,KAAK,UAAU;AAErB,OAAO,MAAMC,cAAc,GAAID,IAAY,IACzCA,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,OAAO;AAEtC,OAAO,MAAME,cAAc,GAAIF,IAAY,IACzCA,IAAI,KAAK,WAAW,IACpBA,IAAI,KAAK,SAAS,IAClBA,IAAI,KAAK,SAAS,IAClBA,IAAI,KAAK,UAAU,IACnBA,IAAI,KAAK,OAAO,IAChBA,IAAI,KAAK,MAAM;AAEjB,OAAO,MAAMG,cAAc,GAAIH,IAAY,IACzCA,IAAI,KAAK,WAAW,IACpBA,IAAI,KAAK,SAAS,IAClBA,IAAI,KAAK,SAAS,IAClBA,IAAI,KAAK,OAAO,IAChBA,IAAI,KAAK,MAAM;AAEjB,OAAO,MAAMI,kBAAkB,GAAIJ,IAAY,IAC7CA,IAAI,KAAK,WAAW,IACpBA,IAAI,KAAK,OAAO,IAChBA,IAAI,KAAK,MAAM,IACfA,IAAI,KAAK,SAAS;AAEpB,OAAO,MAAMK,OAAO,GAAIL,IAAY,IAAKA,IAAI,KAAK,MAAM;AAExD,OAAO,MAAMM,iBAAiB,GAAIN,IAAY,IAAKA,IAAI,KAAK,OAAO;AAEnE,OAAO,MAAMO,oBAAoB,GAAGA,CAClCC,QAAgD,EAChDC,cAAiE,KAC9D;EACH,IAAIC,UAAU,GAAG,IAAI;EACrB;EACA;EACA;EACA,KAAK,IAAIC,KAAK,GAAGH,QAAQ,CAACI,MAAM,GAAG,CAAC,EAAED,KAAK,IAAI,CAAC,EAAE,EAAEA,KAAK,EAAE;IACzD,MAAME,OAAO,GAAGL,QAAQ,CAACG,KAAK,CAAC;IAC/B,IAAIE,OAAO,CAACC,SAAS,EAAE;MACrB;IACF;IACA,IAAIL,cAAc,CAACI,OAAO,CAAC,EAAE;MAC3BH,UAAU,GAAGG,OAAO;MACpB;IACF;EACF;EAEA,OAAOH,UAAU;AACnB,CAAC;AAED,OAAO,MAAMK,qBAAqB,GAAGA,CACnCP,QAAgD,EAChDC,cAAiE,KAC9D;EACH;EACA;EACA,OAAOD,QAAQ,CAACQ,MAAM,CACnBH,OAAO,IAAK,CAACA,OAAO,CAACC,SAAS,IAAIL,cAAc,CAACI,OAAO,CAAC,CAC3D;AACH,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}