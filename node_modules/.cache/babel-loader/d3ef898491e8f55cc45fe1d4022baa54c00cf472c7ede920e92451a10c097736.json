{"ast":null,"code":"import _defineProperty from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { createContext, useState, useEffect, useRef, createElement, useContext, useReducer, useDebugValue, useCallback } from 'react';\nimport { atom as atom$1 } from 'jotai/vanilla';\nvar SUSPENSE_PROMISE = Symbol();\nvar isSuspensePromise = function isSuspensePromise(promise) {\n  return !!promise[SUSPENSE_PROMISE];\n};\nvar isSuspensePromiseAlreadyCancelled = function isSuspensePromiseAlreadyCancelled(suspensePromise) {\n  return !suspensePromise[SUSPENSE_PROMISE].c;\n};\nvar cancelSuspensePromise = function cancelSuspensePromise(suspensePromise) {\n  var _a;\n  var _suspensePromise$SUSP = suspensePromise[SUSPENSE_PROMISE],\n    basePromise = _suspensePromise$SUSP.b,\n    cancelPromise = _suspensePromise$SUSP.c;\n  if (cancelPromise) {\n    cancelPromise();\n    (_a = promiseAbortMap.get(basePromise)) == null ? void 0 : _a();\n  }\n};\nvar isEqualSuspensePromise = function isEqualSuspensePromise(oldSuspensePromise, newSuspensePromise) {\n  var oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  var newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nvar createSuspensePromise = function createSuspensePromise(basePromise, promise) {\n  var suspensePromiseExtra = {\n    b: basePromise,\n    o: promise,\n    c: null\n  };\n  var suspensePromise = new Promise(function (resolve) {\n    suspensePromiseExtra.c = function () {\n      suspensePromiseExtra.c = null;\n      resolve();\n    };\n    promise.finally(suspensePromiseExtra.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;\n  return suspensePromise;\n};\nvar copySuspensePromise = function copySuspensePromise(suspensePromise) {\n  return createSuspensePromise(suspensePromise[SUSPENSE_PROMISE].b, suspensePromise[SUSPENSE_PROMISE].o);\n};\nvar promiseAbortMap = /* @__PURE__ */new WeakMap();\nvar registerPromiseAbort = function registerPromiseAbort(basePromise, abort) {\n  promiseAbortMap.set(basePromise, abort);\n};\nvar hasInitialValue = function hasInitialValue(atom) {\n  return \"init\" in atom;\n};\nvar READ_ATOM = \"r\";\nvar WRITE_ATOM = \"w\";\nvar COMMIT_ATOM = \"c\";\nvar SUBSCRIBE_ATOM = \"s\";\nvar RESTORE_ATOMS = \"h\";\nvar DEV_SUBSCRIBE_STATE = \"n\";\nvar DEV_GET_MOUNTED_ATOMS = \"l\";\nvar DEV_GET_ATOM_STATE = \"a\";\nvar DEV_GET_MOUNTED = \"m\";\nvar createStore = function createStore(initialValues) {\n  var _ref6;\n  var committedAtomStateMap = /* @__PURE__ */new WeakMap();\n  var mountedMap = /* @__PURE__ */new WeakMap();\n  var pendingMap = /* @__PURE__ */new Map();\n  var stateListeners;\n  var mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */new Set();\n    mountedAtoms = /* @__PURE__ */new Set();\n  }\n  if (initialValues) {\n    var _iterator = _createForOfIteratorHelper(initialValues),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n          _atom2 = _step$value[0],\n          value = _step$value[1];\n        var atomState = {\n          v: value,\n          r: 0,\n          y: true,\n          // not invalidated\n          d: /* @__PURE__ */new Map()\n        };\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          Object.freeze(atomState);\n          if (!hasInitialValue(_atom2)) {\n            console.warn(\"Found initial value for derived atom which can cause unexpected behavior\", _atom2);\n          }\n        }\n        committedAtomStateMap.set(_atom2, atomState);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  var suspensePromiseCacheMap = /* @__PURE__ */new WeakMap();\n  var addSuspensePromiseToCache = function addSuspensePromiseToCache(version, atom, suspensePromise) {\n    var cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(function () {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  var cancelAllSuspensePromiseInCache = function cancelAllSuspensePromiseInCache(atom) {\n    var versionSet = /* @__PURE__ */new Set();\n    var cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach(function (suspensePromise, version) {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  var versionedAtomStateMapMap = /* @__PURE__ */new WeakMap();\n  var getVersionedAtomStateMap = function getVersionedAtomStateMap(version) {\n    var versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  var getAtomState = function getAtomState(version, atom) {\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      var _atomState = versionedAtomStateMap.get(atom);\n      if (!_atomState) {\n        _atomState = getAtomState(version.p, atom);\n        if (_atomState && \"p\" in _atomState && isSuspensePromiseAlreadyCancelled(_atomState.p)) {\n          _atomState = void 0;\n        }\n        if (_atomState) {\n          versionedAtomStateMap.set(atom, _atomState);\n        }\n      }\n      return _atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  var setAtomState = function setAtomState(version, atom, atomState) {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      var prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  var createReadDependencies = function createReadDependencies(version) {\n    var prevReadDependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /* @__PURE__ */new Map();\n    var dependencies = arguments.length > 2 ? arguments[2] : undefined;\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    var readDependencies = /* @__PURE__ */new Map();\n    var changed = false;\n    dependencies.forEach(function (atom) {\n      var _a;\n      var revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  var setAtomValue = function setAtomValue(version, atom, value, dependencies, suspensePromise) {\n    var atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    var nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    var changed = !(atomState == null ? void 0 : atomState.y);\n    if (!atomState || !(\"v\" in atomState) ||\n    // new value, or\n    !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every(function (a) {\n      return atomState.d.has(a);\n    }))) {\n      changed = true;\n      Promise.resolve().then(function () {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  var setAtomReadError = function setAtomReadError(version, atom, error, dependencies, suspensePromise) {\n    var atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    var nextAtomState = {\n      e: error,\n      // set read error\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  var setAtomSuspensePromise = function setAtomSuspensePromise(version, atom, suspensePromise, dependencies) {\n    var atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n        if (!atomState.y) {\n          return _objectSpread(_objectSpread({}, atomState), {}, {\n            y: true\n          });\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    var nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  var setAtomPromiseOrValue = function setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies) {\n    if (promiseOrValue instanceof Promise) {\n      var suspensePromise = createSuspensePromise(promiseOrValue, promiseOrValue.then(function (value) {\n        setAtomValue(version, atom, value, dependencies, suspensePromise);\n      }).catch(function (e) {\n        if (e instanceof Promise) {\n          if (isSuspensePromise(e)) {\n            return e.then(function () {\n              readAtomState(version, atom, true);\n            });\n          }\n          return e;\n        }\n        setAtomReadError(version, atom, e, dependencies, suspensePromise);\n      }));\n      return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n    }\n    return setAtomValue(version, atom, promiseOrValue, dependencies);\n  };\n  var setAtomInvalidated = function setAtomInvalidated(version, atom) {\n    var atomState = getAtomState(version, atom);\n    if (atomState) {\n      var nextAtomState = _objectSpread(_objectSpread({}, atomState), {}, {\n        // copy everything\n        y: false\n        // invalidated\n      });\n\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  var readAtomState = function readAtomState(version, atom, force) {\n    if (!force) {\n      var _atomState2 = getAtomState(version, atom);\n      if (_atomState2) {\n        if (_atomState2.y &&\n        // not invalidated\n        \"p\" in _atomState2 && !isSuspensePromiseAlreadyCancelled(_atomState2.p)) {\n          return _atomState2;\n        }\n        _atomState2.d.forEach(function (_, a) {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              var aState = getAtomState(version, a);\n              if (aState && !aState.y) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(_atomState2.d).every(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            a = _ref2[0],\n            r = _ref2[1];\n          var aState = getAtomState(version, a);\n          return aState && !(\"p\" in aState) &&\n          // has no suspense promise\n          aState.r === r;\n        })) {\n          if (!_atomState2.y) {\n            return _objectSpread(_objectSpread({}, _atomState2), {}, {\n              y: true\n            });\n          }\n          return _atomState2;\n        }\n      }\n    }\n    var dependencies = /* @__PURE__ */new Set();\n    try {\n      var promiseOrValue = atom.read(function (a) {\n        dependencies.add(a);\n        var aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        var suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);\n        return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  var readAtom = function readAtom(readingAtom, version) {\n    var atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  var addAtom = function addAtom(version, addingAtom) {\n    var mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  };\n  var delAtom = function delAtom(version, deletingAtom) {\n    var mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  var invalidateDependents = function invalidateDependents(version, atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(function (dependent) {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  var writeAtomState = function writeAtomState(version, atom, update) {\n    var isSync = true;\n    var writeGetter = function writeGetter(a, options) {\n      var aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(function () {\n            var s = getAtomState(version, a);\n            if (s && \"p\" in s && s.p === aState.p) {\n              return new Promise(function (resolve) {\n                return setTimeout(resolve);\n              }).then(function () {\n                return writeGetter(a, options);\n              });\n            }\n            return writeGetter(a, options);\n          });\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\"Reading pending atom state in write operation. We throw a promise for now.\", a);\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] no value found while reading atom in write operation. This is probably a bug.\", a);\n      }\n      throw new Error(\"no value found\");\n    };\n    var setter = function setter(a, v) {\n      var promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        var versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach(function (cancelledVersion) {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        var prevAtomState = getAtomState(version, a);\n        var nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  var writeAtom = function writeAtom(writingAtom, update, version) {\n    var promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n    return !!atom.write;\n  };\n  var mountAtom = function mountAtom(version, atom, initialDependent) {\n    var mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    var atomState = readAtomState(void 0, atom);\n    atomState.d.forEach(function (_, a) {\n      var aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var setAtom = function setAtom(update) {\n        return writeAtom(atom, update, version);\n      };\n      var onUnmount = atom.onMount(setAtom);\n      version = void 0;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  var unmountAtom = function unmountAtom(version, atom) {\n    var _a;\n    var onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    var atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  var mountDependencies = function mountDependencies(version, atom, atomState, prevReadDependencies) {\n    var dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach(function (_, a) {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  var flushPending = function flushPending(version) {\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach(function (atomState, atom) {\n        var committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          var mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n            return listener(version);\n          });\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      var pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          atom = _ref4[0],\n          prevAtomState = _ref4[1];\n        var atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && (\n        // invalidated\n        atomState == null ? void 0 : atomState.y)) {\n          return;\n        }\n        var mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n          return listener();\n        });\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach(function (l) {\n        return l();\n      });\n    }\n  };\n  var commitVersionedAtomStateMap = function commitVersionedAtomStateMap(version) {\n    var versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach(function (atomState, atom) {\n      var prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  var commitAtom = function commitAtom(_atom, version) {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  var subscribeAtom = function subscribeAtom(atom, callback, version) {\n    var mounted = addAtom(version, atom);\n    var listeners = mounted.l;\n    listeners.add(callback);\n    return function () {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  var restoreAtoms = function restoreAtoms(values, version) {\n    var _iterator2 = _createForOfIteratorHelper(values),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n          _atom3 = _step2$value[0],\n          _value = _step2$value[1];\n        if (hasInitialValue(_atom3)) {\n          setAtomPromiseOrValue(version, _atom3, _value);\n          invalidateDependents(version, _atom3);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    var _ref5;\n    return _ref5 = {}, _defineProperty(_ref5, READ_ATOM, readAtom), _defineProperty(_ref5, WRITE_ATOM, writeAtom), _defineProperty(_ref5, COMMIT_ATOM, commitAtom), _defineProperty(_ref5, SUBSCRIBE_ATOM, subscribeAtom), _defineProperty(_ref5, RESTORE_ATOMS, restoreAtoms), _defineProperty(_ref5, DEV_SUBSCRIBE_STATE, function (l) {\n      stateListeners.add(l);\n      return function () {\n        stateListeners.delete(l);\n      };\n    }), _defineProperty(_ref5, DEV_GET_MOUNTED_ATOMS, function () {\n      return mountedAtoms.values();\n    }), _defineProperty(_ref5, DEV_GET_ATOM_STATE, function (a) {\n      return committedAtomStateMap.get(a);\n    }), _defineProperty(_ref5, DEV_GET_MOUNTED, function (a) {\n      return mountedMap.get(a);\n    }), _ref5;\n  }\n  return _ref6 = {}, _defineProperty(_ref6, READ_ATOM, readAtom), _defineProperty(_ref6, WRITE_ATOM, writeAtom), _defineProperty(_ref6, COMMIT_ATOM, commitAtom), _defineProperty(_ref6, SUBSCRIBE_ATOM, subscribeAtom), _defineProperty(_ref6, RESTORE_ATOMS, restoreAtoms), _ref6;\n};\nvar createStoreForExport = function createStoreForExport(initialValues) {\n  var store = createStore(initialValues);\n  var get = function get(atom) {\n    var atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  var asyncGet = function asyncGet(atom) {\n    return new Promise(function (resolve, reject) {\n      var atomState = store[READ_ATOM](atom);\n      if (\"e\" in atomState) {\n        reject(atomState.e);\n      } else if (\"p\" in atomState) {\n        resolve(atomState.p.then(function () {\n          return asyncGet(atom);\n        }));\n      } else {\n        resolve(atomState.v);\n      }\n    });\n  };\n  var set = function set(atom, update) {\n    return store[WRITE_ATOM](atom, update);\n  };\n  var sub = function sub(atom, callback) {\n    return store[SUBSCRIBE_ATOM](atom, callback);\n  };\n  return {\n    get: get,\n    asyncGet: asyncGet,\n    set: set,\n    sub: sub,\n    SECRET_INTERNAL_store: store\n  };\n};\nvar createScopeContainer = function createScopeContainer(initialValues, unstable_createStore) {\n  var store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return {\n    s: store\n  };\n};\nvar ScopeContextMap = /* @__PURE__ */new Map();\nvar getScopeContext = function getScopeContext(scope) {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\nvar Provider = function Provider(_ref7) {\n  var children = _ref7.children,\n    initialValues = _ref7.initialValues,\n    scope = _ref7.scope,\n    unstable_createStore = _ref7.unstable_createStore,\n    unstable_enableVersionedWrite = _ref7.unstable_enableVersionedWrite;\n  var _useState = useState({}),\n    _useState2 = _slicedToArray(_useState, 2),\n    version = _useState2[0],\n    setVersion = _useState2[1];\n  useEffect(function () {\n    var scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  var scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    var scopeContainer = createScopeContainer(initialValues, unstable_createStore);\n    if (unstable_enableVersionedWrite) {\n      var retrying = 0;\n      scopeContainer.w = function (write) {\n        setVersion(function (parentVersion) {\n          var nextVersion = retrying ? parentVersion : {\n            p: parentVersion\n          };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = function (fn) {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  var ScopeContainerContext = getScopeContext(scope);\n  return createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\nfunction atom(read, write) {\n  return atom$1(read, write);\n}\nfunction useAtomValue(atom, scope) {\n  var ScopeContext = getScopeContext(scope);\n  var scopeContainer = useContext(ScopeContext);\n  var store = scopeContainer.s,\n    versionFromProvider = scopeContainer.v;\n  var getAtomValue = function getAtomValue(version2) {\n    var atomState = store[READ_ATOM](atom, version2);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !atomState.y) {\n      throw new Error(\"should not be invalidated\");\n    }\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  };\n  var _useReducer = useReducer(function (prev, nextVersion) {\n      var nextValue = getAtomValue(nextVersion);\n      if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n        return prev;\n      }\n      return [nextVersion, nextValue, atom];\n    }, versionFromProvider, function (initialVersion) {\n      var initialValue = getAtomValue(initialVersion);\n      return [initialVersion, initialValue, atom];\n    }),\n    _useReducer2 = _slicedToArray(_useReducer, 2),\n    _useReducer2$ = _slicedToArray(_useReducer2[0], 3),\n    version = _useReducer2$[0],\n    valueFromReducer = _useReducer2$[1],\n    atomFromReducer = _useReducer2$[2],\n    rerenderIfChanged = _useReducer2[1];\n  var value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  useEffect(function () {\n    var versionFromProvider2 = scopeContainer.v;\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom, versionFromProvider2);\n    }\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, rerenderIfChanged, versionFromProvider2);\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  useEffect(function () {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\nfunction useSetAtom(atom, scope) {\n  var ScopeContext = getScopeContext(scope);\n  var _useContext = useContext(ScopeContext),\n    store = _useContext.s,\n    versionedWrite = _useContext.w;\n  var setAtom = useCallback(function (update) {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n      throw new Error(\"not writable atom\");\n    }\n    var write = function write(version) {\n      return store[WRITE_ATOM](atom, update, version);\n    };\n    return versionedWrite ? versionedWrite(write) : write();\n  }, [store, versionedWrite, atom]);\n  return setAtom;\n}\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\");\n    scope = atom.scope;\n  }\n  return [useAtomValue(atom, scope),\n  // We do wrong type assertion here, which results in throwing an error.\n  useSetAtom(atom, scope)];\n}\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, registerPromiseAbort as SECRET_INTERNAL_registerPromiseAbort, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };","map":{"version":3,"names":["createContext","useState","useEffect","useRef","createElement","useContext","useReducer","useDebugValue","useCallback","atom","atom$1","SUSPENSE_PROMISE","Symbol","isSuspensePromise","promise","isSuspensePromiseAlreadyCancelled","suspensePromise","c","cancelSuspensePromise","_a","_suspensePromise$SUSP","basePromise","b","cancelPromise","promiseAbortMap","get","isEqualSuspensePromise","oldSuspensePromise","newSuspensePromise","oldOriginalPromise","o","newOriginalPromise","createSuspensePromise","suspensePromiseExtra","Promise","resolve","finally","copySuspensePromise","WeakMap","registerPromiseAbort","abort","set","hasInitialValue","READ_ATOM","WRITE_ATOM","COMMIT_ATOM","SUBSCRIBE_ATOM","RESTORE_ATOMS","DEV_SUBSCRIBE_STATE","DEV_GET_MOUNTED_ATOMS","DEV_GET_ATOM_STATE","DEV_GET_MOUNTED","createStore","initialValues","_ref6","committedAtomStateMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","import","meta","env","MODE","Set","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","value","atomState","v","r","y","d","Object","freeze","console","warn","err","e","f","suspensePromiseCacheMap","addSuspensePromiseToCache","version","cache","then","delete","size","cancelAllSuspensePromiseInCache","versionSet","forEach","add","versionedAtomStateMapMap","getVersionedAtomStateMap","versionedAtomStateMap","getAtomState","p","setAtomState","prevAtomState","has","createReadDependencies","prevReadDependencies","arguments","length","undefined","dependencies","readDependencies","changed","revision","setAtomValue","nextAtomState","is","Array","from","keys","every","a","flushPending","setAtomReadError","error","setAtomSuspensePromise","_objectSpread","setAtomPromiseOrValue","promiseOrValue","catch","readAtomState","setAtomInvalidated","force","_","aState","_ref","_ref2","read","init","Error","errorOrPromise","readAtom","readingAtom","addAtom","addingAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","deletingAtom","unmountAtom","invalidateDependents","dependent","writeAtomState","update","isSync","writeGetter","options","unstable_promise","setTimeout","info","setter","promiseOrVoid2","cancelledVersion","promiseOrVoid","write","writeAtom","writingAtom","isActuallyWritableAtom","initialDependent","aMounted","onMount","setAtom","onUnmount","u","mountDependencies","committedAtomState","listener","pending","clear","_ref3","_ref4","commitVersionedAtomStateMap","commitAtom","_atom","subscribeAtom","callback","listeners","restoreAtoms","values","_iterator2","_step2","_step2$value","_ref5","_defineProperty","createStoreForExport","store","asyncGet","reject","sub","SECRET_INTERNAL_store","createScopeContainer","unstable_createStore","ScopeContextMap","getScopeContext","scope","Provider","_ref7","children","unstable_enableVersionedWrite","_useState","_useState2","setVersion","scopeContainer","scopeContainerRef","current","w","retrying","parentVersion","nextVersion","fn","ScopeContainerContext","useAtomValue","ScopeContext","versionFromProvider","getAtomValue","version2","_useReducer","prev","nextValue","initialVersion","initialValue","_useReducer2","_useReducer2$","valueFromReducer","atomFromReducer","rerenderIfChanged","versionFromProvider2","unsubscribe","useSetAtom","_useContext","versionedWrite","useAtom","SECRET_INTERNAL_getScopeContext","SECRET_INTERNAL_registerPromiseAbort"],"sources":["D:/project/excalidraw-cn/node_modules/jotai/esm/index.mjs"],"sourcesContent":["import { createContext, useState, useEffect, useRef, createElement, useContext, useReducer, useDebugValue, useCallback } from 'react';\nimport { atom as atom$1 } from 'jotai/vanilla';\n\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = (suspensePromise) => {\n  var _a;\n  const { b: basePromise, c: cancelPromise } = suspensePromise[SUSPENSE_PROMISE];\n  if (cancelPromise) {\n    cancelPromise();\n    (_a = promiseAbortMap.get(basePromise)) == null ? void 0 : _a();\n  }\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (basePromise, promise) => {\n  const suspensePromiseExtra = {\n    b: basePromise,\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise((resolve) => {\n    suspensePromiseExtra.c = () => {\n      suspensePromiseExtra.c = null;\n      resolve();\n    };\n    promise.finally(suspensePromiseExtra.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;\n  return suspensePromise;\n};\nconst copySuspensePromise = (suspensePromise) => createSuspensePromise(\n  suspensePromise[SUSPENSE_PROMISE].b,\n  suspensePromise[SUSPENSE_PROMISE].o\n);\nconst promiseAbortMap = /* @__PURE__ */ new WeakMap();\nconst registerPromiseAbort = (basePromise, abort) => {\n  promiseAbortMap.set(basePromise, abort);\n};\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = (initialValues) => {\n  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        y: true,\n        // not invalidated\n        d: /* @__PURE__ */ new Map()\n      };\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\n            \"Found initial value for derived atom which can cause unexpected behavior\",\n            atom\n          );\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */ new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = (atom) => {\n    const versionSet = /* @__PURE__ */ new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();\n  const getVersionedAtomStateMap = (version) => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */ new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState && \"p\" in atomState && isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          atomState = void 0;\n        }\n        if (atomState) {\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    dependencies.forEach((atom) => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = !(atomState == null ? void 0 : atomState.y);\n    if (!atomState || !(\"v\" in atomState) || // new value, or\n    !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      // set read error\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n        if (!atomState.y) {\n          return { ...atomState, y: true };\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(\n        promiseOrValue,\n        promiseOrValue.then((value) => {\n          setAtomValue(version, atom, value, dependencies, suspensePromise);\n        }).catch((e) => {\n          if (e instanceof Promise) {\n            if (isSuspensePromise(e)) {\n              return e.then(() => {\n                readAtomState(version, atom, true);\n              });\n            }\n            return e;\n          }\n          setAtomReadError(version, atom, e, dependencies, suspensePromise);\n        })\n      );\n      return setAtomSuspensePromise(\n        version,\n        atom,\n        suspensePromise,\n        dependencies\n      );\n    }\n    return setAtomValue(\n      version,\n      atom,\n      promiseOrValue,\n      dependencies\n    );\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = {\n        ...atomState,\n        // copy everything\n        y: false\n        // invalidated\n      };\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.y && // not invalidated\n        \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && !aState.y) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(([a, r]) => {\n          const aState = getAtomState(version, a);\n          return aState && !(\"p\" in aState) && // has no suspense promise\n          aState.r === r;\n        })) {\n          if (!atomState.y) {\n            return { ...atomState, y: true };\n          }\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */ new Set();\n    try {\n      const promiseOrValue = atom.read((a) => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);\n        return setAtomSuspensePromise(\n          version,\n          atom,\n          suspensePromise,\n          dependencies\n        );\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (version, addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (version, deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(() => {\n            const s = getAtomState(version, a);\n            if (s && \"p\" in s && s.p === aState.p) {\n              return new Promise((resolve) => setTimeout(resolve)).then(\n                () => writeGetter(a, options)\n              );\n            }\n            return writeGetter(a, options);\n          });\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\n            \"Reading pending atom state in write operation. We throw a promise for now.\",\n            a\n          );\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\n          \"[Bug] no value found while reading atom in write operation. This is probably a bug.\",\n          a\n        );\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach((cancelledVersion) => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom) => !!atom.write;\n  const mountAtom = (version, atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = (update) => writeAtom(atom, update, version);\n      const onUnmount = atom.onMount(setAtom);\n      version = void 0;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (version, atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (version, atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  const flushPending = (version) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && // invalidated\n        (atomState == null ? void 0 : atomState.y)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const commitVersionedAtomStateMap = (version) => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback, version) => {\n    const mounted = addAtom(version, atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = (initialValues) => {\n  const store = createStore(initialValues);\n  const get = (atom) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = (atom) => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return { s: store };\n};\nconst ScopeContextMap = /* @__PURE__ */ new Map();\nconst getScopeContext = (scope) => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nconst Provider = ({\n  children,\n  initialValues,\n  scope,\n  unstable_createStore,\n  unstable_enableVersionedWrite\n}) => {\n  const [version, setVersion] = useState({});\n  useEffect(() => {\n    const scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    const scopeContainer = createScopeContainer(\n      initialValues,\n      unstable_createStore\n    );\n    if (unstable_enableVersionedWrite) {\n      let retrying = 0;\n      scopeContainer.w = (write) => {\n        setVersion((parentVersion) => {\n          const nextVersion = retrying ? parentVersion : { p: parentVersion };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = (fn) => {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(\n    ScopeContainerContext.Provider,\n    {\n      value: scopeContainerRef.current\n    },\n    children\n  );\n};\n\nfunction atom(read, write) {\n  return atom$1(read, write);\n}\n\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const { s: store, v: versionFromProvider } = scopeContainer;\n  const getAtomValue = (version2) => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !atomState.y) {\n      throw new Error(\"should not be invalidated\");\n    }\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  };\n  const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] = useReducer(\n    (prev, nextVersion) => {\n      const nextValue = getAtomValue(nextVersion);\n      if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n        return prev;\n      }\n      return [nextVersion, nextValue, atom];\n    },\n    versionFromProvider,\n    (initialVersion) => {\n      const initialValue = getAtomValue(initialVersion);\n      return [initialVersion, initialValue, atom];\n    }\n  );\n  let value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  useEffect(() => {\n    const { v: versionFromProvider2 } = scopeContainer;\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom, versionFromProvider2);\n    }\n    const unsubscribe = store[SUBSCRIBE_ATOM](\n      atom,\n      rerenderIfChanged,\n      versionFromProvider2\n    );\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store, w: versionedWrite } = useContext(ScopeContext);\n  const setAtom = useCallback(\n    (update) => {\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      const write = (version) => store[WRITE_ATOM](atom, update, version);\n      return versionedWrite ? versionedWrite(write) : write();\n    },\n    [store, versionedWrite, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\n      \"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\"\n    );\n    scope = atom.scope;\n  }\n  return [\n    useAtomValue(atom, scope),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, scope)\n  ];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, registerPromiseAbort as SECRET_INTERNAL_registerPromiseAbort, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}