{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { line as _line, solidFillPolygon, patternFillPolygons, rectangle as _rectangle, ellipseWithParams, generateEllipseParams, linearPath as _linearPath, arc as _arc, patternFillArc, curve as _curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math.js';\nimport { curveToBezier } from 'points-on-curve/lib/curve-to-bezier.js';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { pointsOnPath } from 'points-on-path';\nvar NOS = 'none';\nexport var RoughGenerator = /*#__PURE__*/function () {\n  function RoughGenerator(config) {\n    _classCallCheck(this, RoughGenerator);\n    this.defaultOptions = {\n      maxRandomnessOffset: 2,\n      roughness: 1,\n      bowing: 1,\n      stroke: '#000',\n      strokeWidth: 1,\n      curveTightness: 0,\n      curveFitting: 0.95,\n      curveStepCount: 9,\n      fillStyle: 'hachure',\n      fillWeight: -1,\n      hachureAngle: -41,\n      hachureGap: -1,\n      dashOffset: -1,\n      dashGap: -1,\n      zigzagOffset: -1,\n      seed: 0,\n      disableMultiStroke: false,\n      disableMultiStrokeFill: false,\n      preserveVertices: false\n    };\n    this.config = config || {};\n    if (this.config.options) {\n      this.defaultOptions = this._o(this.config.options);\n    }\n  }\n  _createClass(RoughGenerator, [{\n    key: \"_o\",\n    value: function _o(options) {\n      return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n  }, {\n    key: \"_d\",\n    value: function _d(shape, sets, options) {\n      return {\n        shape: shape,\n        sets: sets || [],\n        options: options || this.defaultOptions\n      };\n    }\n  }, {\n    key: \"line\",\n    value: function line(x1, y1, x2, y2, options) {\n      var o = this._o(options);\n      return this._d('line', [_line(x1, y1, x2, y2, o)], o);\n    }\n  }, {\n    key: \"rectangle\",\n    value: function rectangle(x, y, width, height, options) {\n      var o = this._o(options);\n      var paths = [];\n      var outline = _rectangle(x, y, width, height, o);\n      if (o.fill) {\n        var points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n        if (o.fillStyle === 'solid') {\n          paths.push(solidFillPolygon([points], o));\n        } else {\n          paths.push(patternFillPolygons([points], o));\n        }\n      }\n      if (o.stroke !== NOS) {\n        paths.push(outline);\n      }\n      return this._d('rectangle', paths, o);\n    }\n  }, {\n    key: \"ellipse\",\n    value: function ellipse(x, y, width, height, options) {\n      var o = this._o(options);\n      var paths = [];\n      var ellipseParams = generateEllipseParams(width, height, o);\n      var ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n      if (o.fill) {\n        if (o.fillStyle === 'solid') {\n          var shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n          shape.type = 'fillPath';\n          paths.push(shape);\n        } else {\n          paths.push(patternFillPolygons([ellipseResponse.estimatedPoints], o));\n        }\n      }\n      if (o.stroke !== NOS) {\n        paths.push(ellipseResponse.opset);\n      }\n      return this._d('ellipse', paths, o);\n    }\n  }, {\n    key: \"circle\",\n    value: function circle(x, y, diameter, options) {\n      var ret = this.ellipse(x, y, diameter, diameter, options);\n      ret.shape = 'circle';\n      return ret;\n    }\n  }, {\n    key: \"linearPath\",\n    value: function linearPath(points, options) {\n      var o = this._o(options);\n      return this._d('linearPath', [_linearPath(points, false, o)], o);\n    }\n  }, {\n    key: \"arc\",\n    value: function arc(x, y, width, height, start, stop) {\n      var closed = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n      var options = arguments.length > 7 ? arguments[7] : undefined;\n      var o = this._o(options);\n      var paths = [];\n      var outline = _arc(x, y, width, height, start, stop, closed, true, o);\n      if (closed && o.fill) {\n        if (o.fillStyle === 'solid') {\n          var fillOptions = Object.assign({}, o);\n          fillOptions.disableMultiStroke = true;\n          var shape = _arc(x, y, width, height, start, stop, true, false, fillOptions);\n          shape.type = 'fillPath';\n          paths.push(shape);\n        } else {\n          paths.push(patternFillArc(x, y, width, height, start, stop, o));\n        }\n      }\n      if (o.stroke !== NOS) {\n        paths.push(outline);\n      }\n      return this._d('arc', paths, o);\n    }\n  }, {\n    key: \"curve\",\n    value: function curve(points, options) {\n      var o = this._o(options);\n      var paths = [];\n      var outline = _curve(points, o);\n      if (o.fill && o.fill !== NOS && points.length >= 3) {\n        var bcurve = curveToBezier(points);\n        var polyPoints = pointsOnBezierCurves(bcurve, 10, (1 + o.roughness) / 2);\n        if (o.fillStyle === 'solid') {\n          paths.push(solidFillPolygon([polyPoints], o));\n        } else {\n          paths.push(patternFillPolygons([polyPoints], o));\n        }\n      }\n      if (o.stroke !== NOS) {\n        paths.push(outline);\n      }\n      return this._d('curve', paths, o);\n    }\n  }, {\n    key: \"polygon\",\n    value: function polygon(points, options) {\n      var o = this._o(options);\n      var paths = [];\n      var outline = _linearPath(points, true, o);\n      if (o.fill) {\n        if (o.fillStyle === 'solid') {\n          paths.push(solidFillPolygon([points], o));\n        } else {\n          paths.push(patternFillPolygons([points], o));\n        }\n      }\n      if (o.stroke !== NOS) {\n        paths.push(outline);\n      }\n      return this._d('polygon', paths, o);\n    }\n  }, {\n    key: \"path\",\n    value: function path(d, options) {\n      var o = this._o(options);\n      var paths = [];\n      if (!d) {\n        return this._d('path', paths, o);\n      }\n      d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n      var hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n      var hasStroke = o.stroke !== NOS;\n      var simplified = !!(o.simplification && o.simplification < 1);\n      var distance = simplified ? 4 - 4 * o.simplification : (1 + o.roughness) / 2;\n      var sets = pointsOnPath(d, 1, distance);\n      if (hasFill) {\n        if (o.fillStyle === 'solid') {\n          paths.push(solidFillPolygon(sets, o));\n        } else {\n          paths.push(patternFillPolygons(sets, o));\n        }\n      }\n      if (hasStroke) {\n        if (simplified) {\n          sets.forEach(function (set) {\n            paths.push(_linearPath(set, false, o));\n          });\n        } else {\n          paths.push(svgPath(d, o));\n        }\n      }\n      return this._d('path', paths, o);\n    }\n  }, {\n    key: \"opsToPath\",\n    value: function opsToPath(drawing, fixedDecimals) {\n      var path = '';\n      var _iterator = _createForOfIteratorHelper(drawing.ops),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          var data = typeof fixedDecimals === 'number' && fixedDecimals >= 0 ? item.data.map(function (d) {\n            return +d.toFixed(fixedDecimals);\n          }) : item.data;\n          switch (item.op) {\n            case 'move':\n              path += \"M\".concat(data[0], \" \").concat(data[1], \" \");\n              break;\n            case 'bcurveTo':\n              path += \"C\".concat(data[0], \" \").concat(data[1], \", \").concat(data[2], \" \").concat(data[3], \", \").concat(data[4], \" \").concat(data[5], \" \");\n              break;\n            case 'lineTo':\n              path += \"L\".concat(data[0], \" \").concat(data[1], \" \");\n              break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return path.trim();\n    }\n  }, {\n    key: \"toPaths\",\n    value: function toPaths(drawable) {\n      var sets = drawable.sets || [];\n      var o = drawable.options || this.defaultOptions;\n      var paths = [];\n      var _iterator2 = _createForOfIteratorHelper(sets),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var drawing = _step2.value;\n          var path = null;\n          switch (drawing.type) {\n            case 'path':\n              path = {\n                d: this.opsToPath(drawing),\n                stroke: o.stroke,\n                strokeWidth: o.strokeWidth,\n                fill: NOS\n              };\n              break;\n            case 'fillPath':\n              path = {\n                d: this.opsToPath(drawing),\n                stroke: NOS,\n                strokeWidth: 0,\n                fill: o.fill || NOS\n              };\n              break;\n            case 'fillSketch':\n              path = this.fillSketch(drawing, o);\n              break;\n          }\n          if (path) {\n            paths.push(path);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return paths;\n    }\n  }, {\n    key: \"fillSketch\",\n    value: function fillSketch(drawing, o) {\n      var fweight = o.fillWeight;\n      if (fweight < 0) {\n        fweight = o.strokeWidth / 2;\n      }\n      return {\n        d: this.opsToPath(drawing),\n        stroke: o.fill || NOS,\n        strokeWidth: fweight,\n        fill: NOS\n      };\n    }\n  }], [{\n    key: \"newSeed\",\n    value: function newSeed() {\n      return randomSeed();\n    }\n  }]);\n  return RoughGenerator;\n}();","map":{"version":3,"names":["line","solidFillPolygon","patternFillPolygons","rectangle","ellipseWithParams","generateEllipseParams","linearPath","arc","patternFillArc","curve","svgPath","randomSeed","curveToBezier","pointsOnBezierCurves","pointsOnPath","NOS","RoughGenerator","config","_classCallCheck","defaultOptions","maxRandomnessOffset","roughness","bowing","stroke","strokeWidth","curveTightness","curveFitting","curveStepCount","fillStyle","fillWeight","hachureAngle","hachureGap","dashOffset","dashGap","zigzagOffset","seed","disableMultiStroke","disableMultiStrokeFill","preserveVertices","options","_o","_createClass","key","value","Object","assign","_d","shape","sets","x1","y1","x2","y2","o","x","y","width","height","paths","outline","fill","points","push","ellipse","ellipseParams","ellipseResponse","opset","type","estimatedPoints","circle","diameter","ret","start","stop","closed","arguments","length","undefined","fillOptions","bcurve","polyPoints","polygon","path","d","replace","hasFill","hasStroke","simplified","simplification","distance","forEach","set","opsToPath","drawing","fixedDecimals","_iterator","_createForOfIteratorHelper","ops","_step","s","n","done","item","data","map","toFixed","op","concat","err","e","f","trim","toPaths","drawable","_iterator2","_step2","fillSketch","fweight","newSeed"],"sources":["D:/project/excalidraw-cn/node_modules/roughjs/bin/generator.js"],"sourcesContent":["import { line, solidFillPolygon, patternFillPolygons, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math.js';\nimport { curveToBezier } from 'points-on-curve/lib/curve-to-bezier.js';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { pointsOnPath } from 'points-on-path';\nconst NOS = 'none';\nexport class RoughGenerator {\n    constructor(config) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            disableMultiStroke: false,\n            disableMultiStrokeFill: false,\n            preserveVertices: false,\n        };\n        this.config = config || {};\n        if (this.config.options) {\n            this.defaultOptions = this._o(this.config.options);\n        }\n    }\n    static newSeed() {\n        return randomSeed();\n    }\n    _o(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _d(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._o(options);\n        return this._d('line', [line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = rectangle(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const ellipseParams = generateEllipseParams(width, height, o);\n        const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillPolygons([ellipseResponse.estimatedPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._d('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._o(options);\n        return this._d('linearPath', [linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = arc(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const fillOptions = Object.assign({}, o);\n                fillOptions.disableMultiStroke = true;\n                const shape = arc(x, y, width, height, start, stop, true, false, fillOptions);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = curve(points, o);\n        if (o.fill && o.fill !== NOS && points.length >= 3) {\n            const bcurve = curveToBezier(points);\n            const polyPoints = pointsOnBezierCurves(bcurve, 10, (1 + o.roughness) / 2);\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([polyPoints], o));\n            }\n            else {\n                paths.push(patternFillPolygons([polyPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('curve', paths, o);\n    }\n    polygon(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = linearPath(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._o(options);\n        const paths = [];\n        if (!d) {\n            return this._d('path', paths, o);\n        }\n        d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n        const hasStroke = o.stroke !== NOS;\n        const simplified = !!(o.simplification && (o.simplification < 1));\n        const distance = simplified ? (4 - 4 * (o.simplification)) : ((1 + o.roughness) / 2);\n        const sets = pointsOnPath(d, 1, distance);\n        if (hasFill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon(sets, o));\n            }\n            else {\n                paths.push(patternFillPolygons(sets, o));\n            }\n        }\n        if (hasStroke) {\n            if (simplified) {\n                sets.forEach((set) => {\n                    paths.push(linearPath(set, false, o));\n                });\n            }\n            else {\n                paths.push(svgPath(d, o));\n            }\n        }\n        return this._d('path', paths, o);\n    }\n    opsToPath(drawing, fixedDecimals) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS,\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS,\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS,\n        };\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}