{"ast":null,"code":"// distance between 2 points\nfunction distance(p1, p2) {\n  return Math.sqrt(distanceSq(p1, p2));\n}\n// distance between 2 points squared\nfunction distanceSq(p1, p2) {\n  return Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);\n}\n// Sistance squared from a point p to the line segment vw\nfunction distanceToSegmentSq(p, v, w) {\n  var l2 = distanceSq(v, w);\n  if (l2 === 0) {\n    return distanceSq(p, v);\n  }\n  var t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n  t = Math.max(0, Math.min(1, t));\n  return distanceSq(p, lerp(v, w, t));\n}\nfunction lerp(a, b, t) {\n  return [a[0] + (b[0] - a[0]) * t, a[1] + (b[1] - a[1]) * t];\n}\n// Adapted from https://seant23.wordpress.com/2010/11/12/offset-bezier-curves/\nfunction flatness(points, offset) {\n  var p1 = points[offset + 0];\n  var p2 = points[offset + 1];\n  var p3 = points[offset + 2];\n  var p4 = points[offset + 3];\n  var ux = 3 * p2[0] - 2 * p1[0] - p4[0];\n  ux *= ux;\n  var uy = 3 * p2[1] - 2 * p1[1] - p4[1];\n  uy *= uy;\n  var vx = 3 * p3[0] - 2 * p4[0] - p1[0];\n  vx *= vx;\n  var vy = 3 * p3[1] - 2 * p4[1] - p1[1];\n  vy *= vy;\n  if (ux < vx) {\n    ux = vx;\n  }\n  if (uy < vy) {\n    uy = vy;\n  }\n  return ux + uy;\n}\nfunction getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {\n  var outPoints = newPoints || [];\n  if (flatness(points, offset) < tolerance) {\n    var p0 = points[offset + 0];\n    if (outPoints.length) {\n      var d = distance(outPoints[outPoints.length - 1], p0);\n      if (d > 1) {\n        outPoints.push(p0);\n      }\n    } else {\n      outPoints.push(p0);\n    }\n    outPoints.push(points[offset + 3]);\n  } else {\n    // subdivide\n    var t = .5;\n    var p1 = points[offset + 0];\n    var p2 = points[offset + 1];\n    var p3 = points[offset + 2];\n    var p4 = points[offset + 3];\n    var q1 = lerp(p1, p2, t);\n    var q2 = lerp(p2, p3, t);\n    var q3 = lerp(p3, p4, t);\n    var r1 = lerp(q1, q2, t);\n    var r2 = lerp(q2, q3, t);\n    var red = lerp(r1, r2, t);\n    getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);\n    getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);\n  }\n  return outPoints;\n}\nexport function simplify(points, distance) {\n  return simplifyPoints(points, 0, points.length, distance);\n}\n// Ramer–Douglas–Peucker algorithm\n// https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\nfunction simplifyPoints(points, start, end, epsilon, newPoints) {\n  var outPoints = newPoints || [];\n  // find the most distance point from the endpoints\n  var s = points[start];\n  var e = points[end - 1];\n  var maxDistSq = 0;\n  var maxNdx = 1;\n  for (var i = start + 1; i < end - 1; ++i) {\n    var distSq = distanceToSegmentSq(points[i], s, e);\n    if (distSq > maxDistSq) {\n      maxDistSq = distSq;\n      maxNdx = i;\n    }\n  }\n  // if that point is too far, split\n  if (Math.sqrt(maxDistSq) > epsilon) {\n    simplifyPoints(points, start, maxNdx + 1, epsilon, outPoints);\n    simplifyPoints(points, maxNdx, end, epsilon, outPoints);\n  } else {\n    if (!outPoints.length) {\n      outPoints.push(s);\n    }\n    outPoints.push(e);\n  }\n  return outPoints;\n}\nexport function pointsOnBezierCurves(points) {\n  var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.15;\n  var distance = arguments.length > 2 ? arguments[2] : undefined;\n  var newPoints = [];\n  var numSegments = (points.length - 1) / 3;\n  for (var i = 0; i < numSegments; i++) {\n    var offset = i * 3;\n    getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);\n  }\n  if (distance && distance > 0) {\n    return simplifyPoints(newPoints, 0, newPoints.length, distance);\n  }\n  return newPoints;\n}","map":{"version":3,"names":["distance","p1","p2","Math","sqrt","distanceSq","pow","distanceToSegmentSq","p","v","w","l2","t","max","min","lerp","a","b","flatness","points","offset","p3","p4","ux","uy","vx","vy","getPointsOnBezierCurveWithSplitting","tolerance","newPoints","outPoints","p0","length","d","push","q1","q2","q3","r1","r2","red","simplify","simplifyPoints","start","end","epsilon","s","e","maxDistSq","maxNdx","i","distSq","pointsOnBezierCurves","arguments","undefined","numSegments"],"sources":["D:/project/excalidraw-cn/node_modules/points-on-curve/lib/index.js"],"sourcesContent":["// distance between 2 points\nfunction distance(p1, p2) {\n    return Math.sqrt(distanceSq(p1, p2));\n}\n// distance between 2 points squared\nfunction distanceSq(p1, p2) {\n    return Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);\n}\n// Sistance squared from a point p to the line segment vw\nfunction distanceToSegmentSq(p, v, w) {\n    const l2 = distanceSq(v, w);\n    if (l2 === 0) {\n        return distanceSq(p, v);\n    }\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n    t = Math.max(0, Math.min(1, t));\n    return distanceSq(p, lerp(v, w, t));\n}\nfunction lerp(a, b, t) {\n    return [\n        a[0] + (b[0] - a[0]) * t,\n        a[1] + (b[1] - a[1]) * t,\n    ];\n}\n// Adapted from https://seant23.wordpress.com/2010/11/12/offset-bezier-curves/\nfunction flatness(points, offset) {\n    const p1 = points[offset + 0];\n    const p2 = points[offset + 1];\n    const p3 = points[offset + 2];\n    const p4 = points[offset + 3];\n    let ux = 3 * p2[0] - 2 * p1[0] - p4[0];\n    ux *= ux;\n    let uy = 3 * p2[1] - 2 * p1[1] - p4[1];\n    uy *= uy;\n    let vx = 3 * p3[0] - 2 * p4[0] - p1[0];\n    vx *= vx;\n    let vy = 3 * p3[1] - 2 * p4[1] - p1[1];\n    vy *= vy;\n    if (ux < vx) {\n        ux = vx;\n    }\n    if (uy < vy) {\n        uy = vy;\n    }\n    return ux + uy;\n}\nfunction getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {\n    const outPoints = newPoints || [];\n    if (flatness(points, offset) < tolerance) {\n        const p0 = points[offset + 0];\n        if (outPoints.length) {\n            const d = distance(outPoints[outPoints.length - 1], p0);\n            if (d > 1) {\n                outPoints.push(p0);\n            }\n        }\n        else {\n            outPoints.push(p0);\n        }\n        outPoints.push(points[offset + 3]);\n    }\n    else {\n        // subdivide\n        const t = .5;\n        const p1 = points[offset + 0];\n        const p2 = points[offset + 1];\n        const p3 = points[offset + 2];\n        const p4 = points[offset + 3];\n        const q1 = lerp(p1, p2, t);\n        const q2 = lerp(p2, p3, t);\n        const q3 = lerp(p3, p4, t);\n        const r1 = lerp(q1, q2, t);\n        const r2 = lerp(q2, q3, t);\n        const red = lerp(r1, r2, t);\n        getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);\n        getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);\n    }\n    return outPoints;\n}\nexport function simplify(points, distance) {\n    return simplifyPoints(points, 0, points.length, distance);\n}\n// Ramer–Douglas–Peucker algorithm\n// https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\nfunction simplifyPoints(points, start, end, epsilon, newPoints) {\n    const outPoints = newPoints || [];\n    // find the most distance point from the endpoints\n    const s = points[start];\n    const e = points[end - 1];\n    let maxDistSq = 0;\n    let maxNdx = 1;\n    for (let i = start + 1; i < end - 1; ++i) {\n        const distSq = distanceToSegmentSq(points[i], s, e);\n        if (distSq > maxDistSq) {\n            maxDistSq = distSq;\n            maxNdx = i;\n        }\n    }\n    // if that point is too far, split\n    if (Math.sqrt(maxDistSq) > epsilon) {\n        simplifyPoints(points, start, maxNdx + 1, epsilon, outPoints);\n        simplifyPoints(points, maxNdx, end, epsilon, outPoints);\n    }\n    else {\n        if (!outPoints.length) {\n            outPoints.push(s);\n        }\n        outPoints.push(e);\n    }\n    return outPoints;\n}\nexport function pointsOnBezierCurves(points, tolerance = 0.15, distance) {\n    const newPoints = [];\n    const numSegments = (points.length - 1) / 3;\n    for (let i = 0; i < numSegments; i++) {\n        const offset = i * 3;\n        getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);\n    }\n    if (distance && distance > 0) {\n        return simplifyPoints(newPoints, 0, newPoints.length, distance);\n    }\n    return newPoints;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}