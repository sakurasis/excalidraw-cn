{"ast":null,"code":"import _toConsumableArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _classCallCheck from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createClass.js\";import{getNonDeletedElements,getNonDeletedFrames,isNonDeletedElement}from\"../element\";import{isFrameElement}from\"../element/typeChecks\";import{getSelectedElements as _getSelectedElements}from\"./selection\";var hashSelectionOpts=function hashSelectionOpts(opts){var keys=[\"includeBoundTextElement\",\"includeElementsInFrames\"];// just to ensure we're hashing all expected keys\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nvar hash=\"\";for(var _i=0,_keys=keys;_i<_keys.length;_i++){var key=_keys[_i];hash+=\"\".concat(key,\":\").concat(opts[key]?\"1\":\"0\");}return hash;};// ideally this would be a branded type but it'd be insanely hard to work with\n// in our codebase\nvar isIdKey=function isIdKey(elementKey){if(typeof elementKey===\"string\"){return true;}return false;};var Scene=/*#__PURE__*/function(){function Scene(){var _this=this;_classCallCheck(this,Scene);// ---------------------------------------------------------------------------\n// instance methods/props\n// ---------------------------------------------------------------------------\nthis.callbacks=new Set();this.nonDeletedElements=[];this.elements=[];this.nonDeletedFrames=[];this.frames=[];this.elementsMap=new Map();this.selectedElementsCache={selectedElementIds:null,elements:null,cache:new Map()};this.addNewElement=function(element){if(element.frameId){_this.insertElementAtIndex(element,_this.getElementIndex(element.frameId));}else{_this.replaceAllElements([].concat(_toConsumableArray(_this.elements),[element]));}};}_createClass(Scene,[{key:\"getElementsIncludingDeleted\",value:function getElementsIncludingDeleted(){return this.elements;}},{key:\"getNonDeletedElements\",value:function getNonDeletedElements(){return this.nonDeletedElements;}},{key:\"getFramesIncludingDeleted\",value:function getFramesIncludingDeleted(){return this.frames;}},{key:\"getSelectedElements\",value:function getSelectedElements(opts){var hash=hashSelectionOpts(opts);var elements=(opts===null||opts===void 0?void 0:opts.elements)||this.nonDeletedElements;if(this.selectedElementsCache.elements===elements&&this.selectedElementsCache.selectedElementIds===opts.selectedElementIds){var cached=this.selectedElementsCache.cache.get(hash);if(cached){return cached;}}else if((opts===null||opts===void 0?void 0:opts.elements)==null){// if we're operating on latest scene elements and the cache is not\n//  storing the latest elements, clear the cache\nthis.selectedElementsCache.cache.clear();}var selectedElements=_getSelectedElements(elements,{selectedElementIds:opts.selectedElementIds},opts);// cache only if we're not using custom elements\nif((opts===null||opts===void 0?void 0:opts.elements)==null){this.selectedElementsCache.selectedElementIds=opts.selectedElementIds;this.selectedElementsCache.elements=this.nonDeletedElements;this.selectedElementsCache.cache.set(hash,selectedElements);}return selectedElements;}},{key:\"getNonDeletedFrames\",value:function getNonDeletedFrames(){return this.nonDeletedFrames;}},{key:\"getElement\",value:function getElement(id){return this.elementsMap.get(id)||null;}},{key:\"getNonDeletedElement\",value:function getNonDeletedElement(id){var element=this.getElement(id);if(element&&isNonDeletedElement(element)){return element;}return null;}/**\n   * A utility method to help with updating all scene elements, with the added\n   * performance optimization of not renewing the array if no change is made.\n   *\n   * Maps all current excalidraw elements, invoking the callback for each\n   * element. The callback should either return a new mapped element, or the\n   * original element if no changes are made. If no changes are made to any\n   * element, this results in a no-op. Otherwise, the newly mapped elements\n   * are set as the next scene's elements.\n   *\n   * @returns whether a change was made\n   */},{key:\"mapElements\",value:function mapElements(iteratee){var didChange=false;var newElements=this.elements.map(function(element){var nextElement=iteratee(element);if(nextElement!==element){didChange=true;}return nextElement;});if(didChange){this.replaceAllElements(newElements);}return didChange;}},{key:\"replaceAllElements\",value:function replaceAllElements(nextElements){var _this2=this;this.elements=nextElements;var nextFrames=[];this.elementsMap.clear();nextElements.forEach(function(element){if(isFrameElement(element)){nextFrames.push(element);}_this2.elementsMap.set(element.id,element);Scene.mapElementToScene(element,_this2);});this.nonDeletedElements=getNonDeletedElements(this.elements);this.frames=nextFrames;this.nonDeletedFrames=getNonDeletedFrames(this.frames);this.informMutation();}},{key:\"informMutation\",value:function informMutation(){for(var _i2=0,_Array$from=Array.from(this.callbacks);_i2<_Array$from.length;_i2++){var callback=_Array$from[_i2];callback();}}},{key:\"addCallback\",value:function addCallback(cb){var _this3=this;if(this.callbacks.has(cb)){throw new Error();}this.callbacks.add(cb);return function(){if(!_this3.callbacks.has(cb)){throw new Error();}_this3.callbacks.delete(cb);};}},{key:\"destroy\",value:function destroy(){var _this4=this;this.nonDeletedElements=[];this.elements=[];this.nonDeletedFrames=[];this.frames=[];this.elementsMap.clear();this.selectedElementsCache.selectedElementIds=null;this.selectedElementsCache.elements=null;this.selectedElementsCache.cache.clear();Scene.sceneMapById.forEach(function(scene,elementKey){if(scene===_this4){Scene.sceneMapById.delete(elementKey);}});// done not for memory leaks, but to guard against possible late fires\n// (I guess?)\nthis.callbacks.clear();}},{key:\"insertElementAtIndex\",value:function insertElementAtIndex(element,index){if(!Number.isFinite(index)||index<0){throw new Error(\"insertElementAtIndex can only be called with index >= 0\");}var nextElements=[].concat(_toConsumableArray(this.elements.slice(0,index)),[element],_toConsumableArray(this.elements.slice(index)));this.replaceAllElements(nextElements);}},{key:\"insertElementsAtIndex\",value:function insertElementsAtIndex(elements,index){if(!Number.isFinite(index)||index<0){throw new Error(\"insertElementAtIndex can only be called with index >= 0\");}var nextElements=[].concat(_toConsumableArray(this.elements.slice(0,index)),_toConsumableArray(elements),_toConsumableArray(this.elements.slice(index)));this.replaceAllElements(nextElements);}},{key:\"getElementIndex\",value:function getElementIndex(elementId){return this.elements.findIndex(function(element){return element.id===elementId;});}}],[{key:\"mapElementToScene\",value:function mapElementToScene(elementKey,scene){if(isIdKey(elementKey)){// for cases where we don't have access to the element object\n// (e.g. restore serialized appState with id references)\nthis.sceneMapById.set(elementKey,scene);}else{this.sceneMapByElement.set(elementKey,scene);// if mapping element objects, also cache the id string when later\n// looking up by id alone\nthis.sceneMapById.set(elementKey.id,scene);}}},{key:\"getScene\",value:function getScene(elementKey){if(isIdKey(elementKey)){return this.sceneMapById.get(elementKey)||null;}return this.sceneMapByElement.get(elementKey)||null;}}]);return Scene;}();// ---------------------------------------------------------------------------\n// static methods/props\n// ---------------------------------------------------------------------------\nScene.sceneMapByElement=new WeakMap();Scene.sceneMapById=new Map();export default Scene;","map":{"version":3,"names":["getNonDeletedElements","getNonDeletedFrames","isNonDeletedElement","isFrameElement","getSelectedElements","hashSelectionOpts","opts","keys","hash","_i","_keys","length","key","concat","isIdKey","elementKey","Scene","_this","_classCallCheck","callbacks","Set","nonDeletedElements","elements","nonDeletedFrames","frames","elementsMap","Map","selectedElementsCache","selectedElementIds","cache","addNewElement","element","frameId","insertElementAtIndex","getElementIndex","replaceAllElements","_toConsumableArray","_createClass","value","getElementsIncludingDeleted","getFramesIncludingDeleted","cached","get","clear","selectedElements","set","getElement","id","getNonDeletedElement","mapElements","iteratee","didChange","newElements","map","nextElement","nextElements","_this2","nextFrames","forEach","push","mapElementToScene","informMutation","_i2","_Array$from","Array","from","callback","addCallback","cb","_this3","has","Error","add","delete","destroy","_this4","sceneMapById","scene","index","Number","isFinite","slice","insertElementsAtIndex","elementId","findIndex","sceneMapByElement","getScene","WeakMap"],"sources":["D:/project/excalidraw-cn/src/scene/Scene.ts"],"sourcesContent":["import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ExcalidrawFrameElement,\n} from \"../element/types\";\nimport {\n  getNonDeletedElements,\n  getNonDeletedFrames,\n  isNonDeletedElement,\n} from \"../element\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { isFrameElement } from \"../element/typeChecks\";\nimport { getSelectedElements } from \"./selection\";\nimport { AppState } from \"../types\";\nimport { Assert, SameType } from \"../utility-types\";\n\ntype ElementIdKey = InstanceType<typeof LinearElementEditor>[\"elementId\"];\ntype ElementKey = ExcalidrawElement | ElementIdKey;\n\ntype SceneStateCallback = () => void;\ntype SceneStateCallbackRemover = () => void;\n\ntype SelectionHash = string & { __brand: \"selectionHash\" };\n\nconst hashSelectionOpts = (\n  opts: Parameters<InstanceType<typeof Scene>[\"getSelectedElements\"]>[0],\n) => {\n  const keys = [\"includeBoundTextElement\", \"includeElementsInFrames\"] as const;\n\n  type HashableKeys = Omit<typeof opts, \"selectedElementIds\" | \"elements\">;\n\n  // just to ensure we're hashing all expected keys\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  type _ = Assert<\n    SameType<\n      Required<HashableKeys>,\n      Pick<Required<HashableKeys>, typeof keys[number]>\n    >\n  >;\n\n  let hash = \"\";\n  for (const key of keys) {\n    hash += `${key}:${opts[key] ? \"1\" : \"0\"}`;\n  }\n  return hash as SelectionHash;\n};\n\n// ideally this would be a branded type but it'd be insanely hard to work with\n// in our codebase\nexport type ExcalidrawElementsIncludingDeleted = readonly ExcalidrawElement[];\n\nconst isIdKey = (elementKey: ElementKey): elementKey is ElementIdKey => {\n  if (typeof elementKey === \"string\") {\n    return true;\n  }\n  return false;\n};\n\nclass Scene {\n  // ---------------------------------------------------------------------------\n  // static methods/props\n  // ---------------------------------------------------------------------------\n\n  private static sceneMapByElement = new WeakMap<ExcalidrawElement, Scene>();\n  private static sceneMapById = new Map<string, Scene>();\n\n  static mapElementToScene(elementKey: ElementKey, scene: Scene) {\n    if (isIdKey(elementKey)) {\n      // for cases where we don't have access to the element object\n      // (e.g. restore serialized appState with id references)\n      this.sceneMapById.set(elementKey, scene);\n    } else {\n      this.sceneMapByElement.set(elementKey, scene);\n      // if mapping element objects, also cache the id string when later\n      // looking up by id alone\n      this.sceneMapById.set(elementKey.id, scene);\n    }\n  }\n\n  static getScene(elementKey: ElementKey): Scene | null {\n    if (isIdKey(elementKey)) {\n      return this.sceneMapById.get(elementKey) || null;\n    }\n    return this.sceneMapByElement.get(elementKey) || null;\n  }\n\n  // ---------------------------------------------------------------------------\n  // instance methods/props\n  // ---------------------------------------------------------------------------\n\n  private callbacks: Set<SceneStateCallback> = new Set();\n\n  private nonDeletedElements: readonly NonDeletedExcalidrawElement[] = [];\n  private elements: readonly ExcalidrawElement[] = [];\n  private nonDeletedFrames: readonly NonDeleted<ExcalidrawFrameElement>[] = [];\n  private frames: readonly ExcalidrawFrameElement[] = [];\n  private elementsMap = new Map<ExcalidrawElement[\"id\"], ExcalidrawElement>();\n  private selectedElementsCache: {\n    selectedElementIds: AppState[\"selectedElementIds\"] | null;\n    elements: readonly NonDeletedExcalidrawElement[] | null;\n    cache: Map<SelectionHash, NonDeletedExcalidrawElement[]>;\n  } = {\n    selectedElementIds: null,\n    elements: null,\n    cache: new Map(),\n  };\n\n  getElementsIncludingDeleted() {\n    return this.elements;\n  }\n\n  getNonDeletedElements(): readonly NonDeletedExcalidrawElement[] {\n    return this.nonDeletedElements;\n  }\n\n  getFramesIncludingDeleted() {\n    return this.frames;\n  }\n\n  getSelectedElements(opts: {\n    // NOTE can be ommitted by making Scene constructor require App instance\n    selectedElementIds: AppState[\"selectedElementIds\"];\n    /**\n     * for specific cases where you need to use elements not from current\n     * scene state. This in effect will likely result in cache-miss, and\n     * the cache won't be updated in this case.\n     */\n    elements?: readonly ExcalidrawElement[];\n    // selection-related options\n    includeBoundTextElement?: boolean;\n    includeElementsInFrames?: boolean;\n  }): NonDeleted<ExcalidrawElement>[] {\n    const hash = hashSelectionOpts(opts);\n\n    const elements = opts?.elements || this.nonDeletedElements;\n    if (\n      this.selectedElementsCache.elements === elements &&\n      this.selectedElementsCache.selectedElementIds === opts.selectedElementIds\n    ) {\n      const cached = this.selectedElementsCache.cache.get(hash);\n      if (cached) {\n        return cached;\n      }\n    } else if (opts?.elements == null) {\n      // if we're operating on latest scene elements and the cache is not\n      //  storing the latest elements, clear the cache\n      this.selectedElementsCache.cache.clear();\n    }\n\n    const selectedElements = getSelectedElements(\n      elements,\n      { selectedElementIds: opts.selectedElementIds },\n      opts,\n    );\n\n    // cache only if we're not using custom elements\n    if (opts?.elements == null) {\n      this.selectedElementsCache.selectedElementIds = opts.selectedElementIds;\n      this.selectedElementsCache.elements = this.nonDeletedElements;\n      this.selectedElementsCache.cache.set(hash, selectedElements);\n    }\n\n    return selectedElements;\n  }\n\n  getNonDeletedFrames(): readonly NonDeleted<ExcalidrawFrameElement>[] {\n    return this.nonDeletedFrames;\n  }\n\n  getElement<T extends ExcalidrawElement>(id: T[\"id\"]): T | null {\n    return (this.elementsMap.get(id) as T | undefined) || null;\n  }\n\n  getNonDeletedElement(\n    id: ExcalidrawElement[\"id\"],\n  ): NonDeleted<ExcalidrawElement> | null {\n    const element = this.getElement(id);\n    if (element && isNonDeletedElement(element)) {\n      return element;\n    }\n    return null;\n  }\n\n  /**\n   * A utility method to help with updating all scene elements, with the added\n   * performance optimization of not renewing the array if no change is made.\n   *\n   * Maps all current excalidraw elements, invoking the callback for each\n   * element. The callback should either return a new mapped element, or the\n   * original element if no changes are made. If no changes are made to any\n   * element, this results in a no-op. Otherwise, the newly mapped elements\n   * are set as the next scene's elements.\n   *\n   * @returns whether a change was made\n   */\n  mapElements(\n    iteratee: (element: ExcalidrawElement) => ExcalidrawElement,\n  ): boolean {\n    let didChange = false;\n    const newElements = this.elements.map((element) => {\n      const nextElement = iteratee(element);\n      if (nextElement !== element) {\n        didChange = true;\n      }\n      return nextElement;\n    });\n    if (didChange) {\n      this.replaceAllElements(newElements);\n    }\n    return didChange;\n  }\n\n  replaceAllElements(nextElements: readonly ExcalidrawElement[]) {\n    this.elements = nextElements;\n    const nextFrames: ExcalidrawFrameElement[] = [];\n    this.elementsMap.clear();\n    nextElements.forEach((element) => {\n      if (isFrameElement(element)) {\n        nextFrames.push(element);\n      }\n      this.elementsMap.set(element.id, element);\n      Scene.mapElementToScene(element, this);\n    });\n    this.nonDeletedElements = getNonDeletedElements(this.elements);\n    this.frames = nextFrames;\n    this.nonDeletedFrames = getNonDeletedFrames(this.frames);\n\n    this.informMutation();\n  }\n\n  informMutation() {\n    for (const callback of Array.from(this.callbacks)) {\n      callback();\n    }\n  }\n\n  addCallback(cb: SceneStateCallback): SceneStateCallbackRemover {\n    if (this.callbacks.has(cb)) {\n      throw new Error();\n    }\n\n    this.callbacks.add(cb);\n\n    return () => {\n      if (!this.callbacks.has(cb)) {\n        throw new Error();\n      }\n      this.callbacks.delete(cb);\n    };\n  }\n\n  destroy() {\n    this.nonDeletedElements = [];\n    this.elements = [];\n    this.nonDeletedFrames = [];\n    this.frames = [];\n    this.elementsMap.clear();\n    this.selectedElementsCache.selectedElementIds = null;\n    this.selectedElementsCache.elements = null;\n    this.selectedElementsCache.cache.clear();\n\n    Scene.sceneMapById.forEach((scene, elementKey) => {\n      if (scene === this) {\n        Scene.sceneMapById.delete(elementKey);\n      }\n    });\n\n    // done not for memory leaks, but to guard against possible late fires\n    // (I guess?)\n    this.callbacks.clear();\n  }\n\n  insertElementAtIndex(element: ExcalidrawElement, index: number) {\n    if (!Number.isFinite(index) || index < 0) {\n      throw new Error(\n        \"insertElementAtIndex can only be called with index >= 0\",\n      );\n    }\n    const nextElements = [\n      ...this.elements.slice(0, index),\n      element,\n      ...this.elements.slice(index),\n    ];\n    this.replaceAllElements(nextElements);\n  }\n\n  insertElementsAtIndex(elements: ExcalidrawElement[], index: number) {\n    if (!Number.isFinite(index) || index < 0) {\n      throw new Error(\n        \"insertElementAtIndex can only be called with index >= 0\",\n      );\n    }\n    const nextElements = [\n      ...this.elements.slice(0, index),\n      ...elements,\n      ...this.elements.slice(index),\n    ];\n\n    this.replaceAllElements(nextElements);\n  }\n\n  addNewElement = (element: ExcalidrawElement) => {\n    if (element.frameId) {\n      this.insertElementAtIndex(element, this.getElementIndex(element.frameId));\n    } else {\n      this.replaceAllElements([...this.elements, element]);\n    }\n  };\n\n  getElementIndex(elementId: string) {\n    return this.elements.findIndex((element) => element.id === elementId);\n  }\n}\n\nexport default Scene;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}