{"ast":null,"code":"var _jsxFileName = \"D:\\\\project\\\\excalidraw-cn\\\\src\\\\actions\\\\actionDeleteSelected.tsx\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { KEYS } from \"../keys\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { getNonDeletedElements } from \"../element\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { getElementsInGroup } from \"../groups\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { fixBindingsAfterDeletion } from \"../element/binding\";\nimport { isBoundToContainer } from \"../element/typeChecks\";\nimport { updateActiveTool } from \"../utils\";\nimport { TrashIcon } from \"../components/icons\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst deleteSelectedElements = (elements, appState) => {\n  const framesToBeDeleted = new Set(getSelectedElements(elements.filter(el => el.type === \"frame\"), appState).map(el => el.id));\n  return {\n    elements: elements.map(el => {\n      if (appState.selectedElementIds[el.id]) {\n        return newElementWith(el, {\n          isDeleted: true\n        });\n      }\n      if (el.frameId && framesToBeDeleted.has(el.frameId)) {\n        return newElementWith(el, {\n          isDeleted: true\n        });\n      }\n      if (isBoundToContainer(el) && appState.selectedElementIds[el.containerId]) {\n        return newElementWith(el, {\n          isDeleted: true\n        });\n      }\n      return el;\n    }),\n    appState: {\n      ...appState,\n      selectedElementIds: {}\n    }\n  };\n};\nconst handleGroupEditingState = (appState, elements) => {\n  if (appState.editingGroupId) {\n    const siblingElements = getElementsInGroup(getNonDeletedElements(elements), appState.editingGroupId);\n    if (siblingElements.length) {\n      return {\n        ...appState,\n        selectedElementIds: {\n          [siblingElements[0].id]: true\n        }\n      };\n    }\n  }\n  return appState;\n};\nexport const actionDeleteSelected = register({\n  name: \"deleteSelectedElements\",\n  trackEvent: {\n    category: \"element\",\n    action: \"delete\"\n  },\n  perform: (elements, appState) => {\n    if (appState.editingLinearElement) {\n      const {\n        elementId,\n        selectedPointsIndices,\n        startBindingElement,\n        endBindingElement\n      } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n      if (!element) {\n        return false;\n      }\n      // case: no point selected → do nothing, as deleting the whole element\n      // is most likely a mistake, where you wanted to delete a specific point\n      // but failed to select it (or you thought it's selected, while it was\n      // only in a hover state)\n      if (selectedPointsIndices == null) {\n        return false;\n      }\n\n      // case: deleting last remaining point\n      if (element.points.length < 2) {\n        const nextElements = elements.map(el => {\n          if (el.id === element.id) {\n            return newElementWith(el, {\n              isDeleted: true\n            });\n          }\n          return el;\n        });\n        const nextAppState = handleGroupEditingState(appState, nextElements);\n        return {\n          elements: nextElements,\n          appState: {\n            ...nextAppState,\n            editingLinearElement: null\n          },\n          commitToHistory: false\n        };\n      }\n\n      // We cannot do this inside `movePoint` because it is also called\n      // when deleting the uncommitted point (which hasn't caused any binding)\n      const binding = {\n        startBindingElement: selectedPointsIndices !== null && selectedPointsIndices !== void 0 && selectedPointsIndices.includes(0) ? null : startBindingElement,\n        endBindingElement: selectedPointsIndices !== null && selectedPointsIndices !== void 0 && selectedPointsIndices.includes(element.points.length - 1) ? null : endBindingElement\n      };\n      LinearElementEditor.deletePoints(element, selectedPointsIndices);\n      return {\n        elements,\n        appState: {\n          ...appState,\n          editingLinearElement: {\n            ...appState.editingLinearElement,\n            ...binding,\n            selectedPointsIndices: (selectedPointsIndices === null || selectedPointsIndices === void 0 ? void 0 : selectedPointsIndices[0]) > 0 ? [selectedPointsIndices[0] - 1] : [0]\n          }\n        },\n        commitToHistory: true\n      };\n    }\n    let {\n      elements: nextElements,\n      appState: nextAppState\n    } = deleteSelectedElements(elements, appState);\n    fixBindingsAfterDeletion(nextElements, elements.filter(_ref => {\n      let {\n        id\n      } = _ref;\n      return appState.selectedElementIds[id];\n    }));\n    nextAppState = handleGroupEditingState(nextAppState, nextElements);\n    return {\n      elements: nextElements,\n      appState: {\n        ...nextAppState,\n        activeTool: updateActiveTool(appState, {\n          type: \"selection\"\n        }),\n        multiElement: null\n      },\n      commitToHistory: isSomeElementSelected(getNonDeletedElements(elements), appState)\n    };\n  },\n  contextItemLabel: \"labels.delete\",\n  keyTest: (event, appState, elements) => (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE) && !event[KEYS.CTRL_OR_CMD],\n  PanelComponent: _ref2 => {\n    let {\n      elements,\n      appState,\n      updateData\n    } = _ref2;\n    return /*#__PURE__*/_jsxDEV(ToolButton, {\n      type: \"button\",\n      icon: TrashIcon,\n      title: t(\"labels.delete\"),\n      \"aria-label\": t(\"labels.delete\"),\n      onClick: () => updateData(null),\n      visible: isSomeElementSelected(getNonDeletedElements(elements), appState)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 173,\n      columnNumber: 5\n    }, this);\n  }\n});","map":{"version":3,"names":["getSelectedElements","isSomeElementSelected","KEYS","ToolButton","t","register","getNonDeletedElements","newElementWith","getElementsInGroup","LinearElementEditor","fixBindingsAfterDeletion","isBoundToContainer","updateActiveTool","TrashIcon","jsxDEV","_jsxDEV","deleteSelectedElements","elements","appState","framesToBeDeleted","Set","filter","el","type","map","id","selectedElementIds","isDeleted","frameId","has","containerId","handleGroupEditingState","editingGroupId","siblingElements","length","actionDeleteSelected","name","trackEvent","category","action","perform","editingLinearElement","elementId","selectedPointsIndices","startBindingElement","endBindingElement","element","getElement","points","nextElements","nextAppState","commitToHistory","binding","includes","deletePoints","_ref","activeTool","multiElement","contextItemLabel","keyTest","event","key","BACKSPACE","DELETE","CTRL_OR_CMD","PanelComponent","_ref2","updateData","icon","title","onClick","visible","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["D:/project/excalidraw-cn/src/actions/actionDeleteSelected.tsx"],"sourcesContent":["import { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { KEYS } from \"../keys\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { getElementsInGroup } from \"../groups\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { fixBindingsAfterDeletion } from \"../element/binding\";\nimport { isBoundToContainer } from \"../element/typeChecks\";\nimport { updateActiveTool } from \"../utils\";\nimport { TrashIcon } from \"../components/icons\";\n\nconst deleteSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const framesToBeDeleted = new Set(\n    getSelectedElements(\n      elements.filter((el) => el.type === \"frame\"),\n      appState,\n    ).map((el) => el.id),\n  );\n\n  return {\n    elements: elements.map((el) => {\n      if (appState.selectedElementIds[el.id]) {\n        return newElementWith(el, { isDeleted: true });\n      }\n\n      if (el.frameId && framesToBeDeleted.has(el.frameId)) {\n        return newElementWith(el, { isDeleted: true });\n      }\n\n      if (\n        isBoundToContainer(el) &&\n        appState.selectedElementIds[el.containerId]\n      ) {\n        return newElementWith(el, { isDeleted: true });\n      }\n      return el;\n    }),\n    appState: {\n      ...appState,\n      selectedElementIds: {},\n    },\n  };\n};\n\nconst handleGroupEditingState = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n): AppState => {\n  if (appState.editingGroupId) {\n    const siblingElements = getElementsInGroup(\n      getNonDeletedElements(elements),\n      appState.editingGroupId!,\n    );\n    if (siblingElements.length) {\n      return {\n        ...appState,\n        selectedElementIds: { [siblingElements[0].id]: true },\n      };\n    }\n  }\n  return appState;\n};\n\nexport const actionDeleteSelected = register({\n  name: \"deleteSelectedElements\",\n  trackEvent: { category: \"element\", action: \"delete\" },\n  perform: (elements, appState) => {\n    if (appState.editingLinearElement) {\n      const {\n        elementId,\n        selectedPointsIndices,\n        startBindingElement,\n        endBindingElement,\n      } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n      if (!element) {\n        return false;\n      }\n      // case: no point selected → do nothing, as deleting the whole element\n      // is most likely a mistake, where you wanted to delete a specific point\n      // but failed to select it (or you thought it's selected, while it was\n      // only in a hover state)\n      if (selectedPointsIndices == null) {\n        return false;\n      }\n\n      // case: deleting last remaining point\n      if (element.points.length < 2) {\n        const nextElements = elements.map((el) => {\n          if (el.id === element.id) {\n            return newElementWith(el, { isDeleted: true });\n          }\n          return el;\n        });\n        const nextAppState = handleGroupEditingState(appState, nextElements);\n\n        return {\n          elements: nextElements,\n          appState: {\n            ...nextAppState,\n            editingLinearElement: null,\n          },\n          commitToHistory: false,\n        };\n      }\n\n      // We cannot do this inside `movePoint` because it is also called\n      // when deleting the uncommitted point (which hasn't caused any binding)\n      const binding = {\n        startBindingElement: selectedPointsIndices?.includes(0)\n          ? null\n          : startBindingElement,\n        endBindingElement: selectedPointsIndices?.includes(\n          element.points.length - 1,\n        )\n          ? null\n          : endBindingElement,\n      };\n\n      LinearElementEditor.deletePoints(element, selectedPointsIndices);\n\n      return {\n        elements,\n        appState: {\n          ...appState,\n          editingLinearElement: {\n            ...appState.editingLinearElement,\n            ...binding,\n            selectedPointsIndices:\n              selectedPointsIndices?.[0] > 0\n                ? [selectedPointsIndices[0] - 1]\n                : [0],\n          },\n        },\n        commitToHistory: true,\n      };\n    }\n    let { elements: nextElements, appState: nextAppState } =\n      deleteSelectedElements(elements, appState);\n    fixBindingsAfterDeletion(\n      nextElements,\n      elements.filter(({ id }) => appState.selectedElementIds[id]),\n    );\n\n    nextAppState = handleGroupEditingState(nextAppState, nextElements);\n\n    return {\n      elements: nextElements,\n      appState: {\n        ...nextAppState,\n        activeTool: updateActiveTool(appState, { type: \"selection\" }),\n        multiElement: null,\n      },\n      commitToHistory: isSomeElementSelected(\n        getNonDeletedElements(elements),\n        appState,\n      ),\n    };\n  },\n  contextItemLabel: \"labels.delete\",\n  keyTest: (event, appState, elements) =>\n    (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE) &&\n    !event[KEYS.CTRL_OR_CMD],\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={TrashIcon}\n      title={t(\"labels.delete\")}\n      aria-label={t(\"labels.delete\")}\n      onClick={() => updateData(null)}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}