{"ast":null,"code":"var _jsxFileName = \"D:\\\\project\\\\excalidraw-cn\\\\src\\\\components\\\\Popover.tsx\";\nimport React, { useLayoutEffect, useRef, useEffect } from \"react\";\nimport \"./Popover.scss\";\nimport { unstable_batchedUpdates } from \"react-dom\";\nimport { queryFocusableElements } from \"../utils\";\nimport { KEYS } from \"../keys\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const Popover = _ref => {\n  let {\n    children,\n    left,\n    top,\n    onCloseRequest,\n    fitInViewport = false,\n    offsetLeft = 0,\n    offsetTop = 0,\n    viewportWidth = window.innerWidth,\n    viewportHeight = window.innerHeight\n  } = _ref;\n  const popoverRef = useRef(null);\n  useEffect(() => {\n    const container = popoverRef.current;\n    if (!container) {\n      return;\n    }\n\n    // focus popover only if the caller didn't focus on something else nested\n    // within the popover, which should take precedence. Fixes cases\n    // like color picker listening to keydown events on containers nested\n    // in the popover.\n    if (!container.contains(document.activeElement)) {\n      container.focus();\n    }\n    const handleKeyDown = event => {\n      if (event.key === KEYS.TAB) {\n        const focusableElements = queryFocusableElements(container);\n        const {\n          activeElement\n        } = document;\n        const currentIndex = focusableElements.findIndex(element => element === activeElement);\n        if (activeElement === container) {\n          if (event.shiftKey) {\n            var _focusableElements;\n            (_focusableElements = focusableElements[focusableElements.length - 1]) === null || _focusableElements === void 0 ? void 0 : _focusableElements.focus();\n          } else {\n            focusableElements[0].focus();\n          }\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        } else if (currentIndex === 0 && event.shiftKey) {\n          var _focusableElements2;\n          (_focusableElements2 = focusableElements[focusableElements.length - 1]) === null || _focusableElements2 === void 0 ? void 0 : _focusableElements2.focus();\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        } else if (currentIndex === focusableElements.length - 1 && !event.shiftKey) {\n          var _focusableElements$;\n          (_focusableElements$ = focusableElements[0]) === null || _focusableElements$ === void 0 ? void 0 : _focusableElements$.focus();\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        }\n      }\n    };\n    container.addEventListener(\"keydown\", handleKeyDown);\n    return () => container.removeEventListener(\"keydown\", handleKeyDown);\n  }, []);\n  const lastInitializedPosRef = useRef(null);\n\n  // ensure the popover doesn't overflow the viewport\n  useLayoutEffect(() => {\n    if (fitInViewport && popoverRef.current && top != null && left != null) {\n      var _lastInitializedPosRe, _lastInitializedPosRe2;\n      const container = popoverRef.current;\n      const {\n        width,\n        height\n      } = container.getBoundingClientRect();\n\n      // hack for StrictMode so this effect only runs once for\n      // the same top/left position, otherwise\n      // we'd potentically reposition twice (once for viewport overflow)\n      // and once for top/left position afterwards\n      if (((_lastInitializedPosRe = lastInitializedPosRef.current) === null || _lastInitializedPosRe === void 0 ? void 0 : _lastInitializedPosRe.top) === top && ((_lastInitializedPosRe2 = lastInitializedPosRef.current) === null || _lastInitializedPosRe2 === void 0 ? void 0 : _lastInitializedPosRe2.left) === left) {\n        return;\n      }\n      lastInitializedPosRef.current = {\n        top,\n        left\n      };\n      if (width >= viewportWidth) {\n        container.style.width = `${viewportWidth}px`;\n        container.style.left = \"0px\";\n        container.style.overflowX = \"scroll\";\n      } else if (left + width - offsetLeft > viewportWidth) {\n        container.style.left = `${viewportWidth - width - 10}px`;\n      } else {\n        container.style.left = `${left}px`;\n      }\n      if (height >= viewportHeight) {\n        container.style.height = `${viewportHeight - 20}px`;\n        container.style.top = \"10px\";\n        container.style.overflowY = \"scroll\";\n      } else if (top + height - offsetTop > viewportHeight) {\n        container.style.top = `${viewportHeight - height}px`;\n      } else {\n        container.style.top = `${top}px`;\n      }\n    }\n  }, [top, left, fitInViewport, viewportWidth, viewportHeight, offsetLeft, offsetTop]);\n  useEffect(() => {\n    if (onCloseRequest) {\n      const handler = event => {\n        var _popoverRef$current;\n        if (!((_popoverRef$current = popoverRef.current) !== null && _popoverRef$current !== void 0 && _popoverRef$current.contains(event.target))) {\n          unstable_batchedUpdates(() => onCloseRequest(event));\n        }\n      };\n      document.addEventListener(\"pointerdown\", handler, false);\n      return () => document.removeEventListener(\"pointerdown\", handler, false);\n    }\n  }, [onCloseRequest]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"popover\",\n    ref: popoverRef,\n    tabIndex: -1,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 148,\n    columnNumber: 5\n  }, this);\n};","map":{"version":3,"names":["React","useLayoutEffect","useRef","useEffect","unstable_batchedUpdates","queryFocusableElements","KEYS","jsxDEV","_jsxDEV","Popover","_ref","children","left","top","onCloseRequest","fitInViewport","offsetLeft","offsetTop","viewportWidth","window","innerWidth","viewportHeight","innerHeight","popoverRef","container","current","contains","document","activeElement","focus","handleKeyDown","event","key","TAB","focusableElements","currentIndex","findIndex","element","shiftKey","_focusableElements","length","preventDefault","stopImmediatePropagation","_focusableElements2","_focusableElements$","addEventListener","removeEventListener","lastInitializedPosRef","_lastInitializedPosRe","_lastInitializedPosRe2","width","height","getBoundingClientRect","style","overflowX","overflowY","handler","_popoverRef$current","target","className","ref","tabIndex","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["D:/project/excalidraw-cn/src/components/Popover.tsx"],"sourcesContent":["import React, { useLayoutEffect, useRef, useEffect } from \"react\";\nimport \"./Popover.scss\";\nimport { unstable_batchedUpdates } from \"react-dom\";\nimport { queryFocusableElements } from \"../utils\";\nimport { KEYS } from \"../keys\";\n\ntype Props = {\n  top?: number;\n  left?: number;\n  children?: React.ReactNode;\n  onCloseRequest?(event: PointerEvent): void;\n  fitInViewport?: boolean;\n  offsetLeft?: number;\n  offsetTop?: number;\n  viewportWidth?: number;\n  viewportHeight?: number;\n};\n\nexport const Popover = ({\n  children,\n  left,\n  top,\n  onCloseRequest,\n  fitInViewport = false,\n  offsetLeft = 0,\n  offsetTop = 0,\n  viewportWidth = window.innerWidth,\n  viewportHeight = window.innerHeight,\n}: Props) => {\n  const popoverRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const container = popoverRef.current;\n\n    if (!container) {\n      return;\n    }\n\n    // focus popover only if the caller didn't focus on something else nested\n    // within the popover, which should take precedence. Fixes cases\n    // like color picker listening to keydown events on containers nested\n    // in the popover.\n    if (!container.contains(document.activeElement)) {\n      container.focus();\n    }\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === KEYS.TAB) {\n        const focusableElements = queryFocusableElements(container);\n        const { activeElement } = document;\n        const currentIndex = focusableElements.findIndex(\n          (element) => element === activeElement,\n        );\n\n        if (activeElement === container) {\n          if (event.shiftKey) {\n            focusableElements[focusableElements.length - 1]?.focus();\n          } else {\n            focusableElements[0].focus();\n          }\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        } else if (currentIndex === 0 && event.shiftKey) {\n          focusableElements[focusableElements.length - 1]?.focus();\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        } else if (\n          currentIndex === focusableElements.length - 1 &&\n          !event.shiftKey\n        ) {\n          focusableElements[0]?.focus();\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        }\n      }\n    };\n\n    container.addEventListener(\"keydown\", handleKeyDown);\n\n    return () => container.removeEventListener(\"keydown\", handleKeyDown);\n  }, []);\n\n  const lastInitializedPosRef = useRef<{ top: number; left: number } | null>(\n    null,\n  );\n\n  // ensure the popover doesn't overflow the viewport\n  useLayoutEffect(() => {\n    if (fitInViewport && popoverRef.current && top != null && left != null) {\n      const container = popoverRef.current;\n      const { width, height } = container.getBoundingClientRect();\n\n      // hack for StrictMode so this effect only runs once for\n      // the same top/left position, otherwise\n      // we'd potentically reposition twice (once for viewport overflow)\n      // and once for top/left position afterwards\n      if (\n        lastInitializedPosRef.current?.top === top &&\n        lastInitializedPosRef.current?.left === left\n      ) {\n        return;\n      }\n      lastInitializedPosRef.current = { top, left };\n\n      if (width >= viewportWidth) {\n        container.style.width = `${viewportWidth}px`;\n        container.style.left = \"0px\";\n        container.style.overflowX = \"scroll\";\n      } else if (left + width - offsetLeft > viewportWidth) {\n        container.style.left = `${viewportWidth - width - 10}px`;\n      } else {\n        container.style.left = `${left}px`;\n      }\n\n      if (height >= viewportHeight) {\n        container.style.height = `${viewportHeight - 20}px`;\n        container.style.top = \"10px\";\n        container.style.overflowY = \"scroll\";\n      } else if (top + height - offsetTop > viewportHeight) {\n        container.style.top = `${viewportHeight - height}px`;\n      } else {\n        container.style.top = `${top}px`;\n      }\n    }\n  }, [\n    top,\n    left,\n    fitInViewport,\n    viewportWidth,\n    viewportHeight,\n    offsetLeft,\n    offsetTop,\n  ]);\n\n  useEffect(() => {\n    if (onCloseRequest) {\n      const handler = (event: PointerEvent) => {\n        if (!popoverRef.current?.contains(event.target as Node)) {\n          unstable_batchedUpdates(() => onCloseRequest(event));\n        }\n      };\n      document.addEventListener(\"pointerdown\", handler, false);\n      return () => document.removeEventListener(\"pointerdown\", handler, false);\n    }\n  }, [onCloseRequest]);\n\n  return (\n    <div className=\"popover\" ref={popoverRef} tabIndex={-1}>\n      {children}\n    </div>\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}