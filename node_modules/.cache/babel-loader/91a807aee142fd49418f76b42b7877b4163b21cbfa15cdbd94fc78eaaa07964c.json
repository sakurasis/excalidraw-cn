{"ast":null,"code":"import { exportToCanvas as _exportToCanvas, exportToSvg as _exportToSvg } from \"../scene/export\";\nimport { getDefaultAppState } from \"../appState\";\nimport { restore } from \"../data/restore\";\nimport { MIME_TYPES } from \"../constants\";\nimport { encodePngMetadata } from \"../data/image\";\nimport { serializeAsJSON } from \"../data/json\";\nimport { copyBlobToClipboardAsPng, copyTextToSystemClipboard, copyToClipboard } from \"../clipboard\";\nimport Scene from \"../scene/Scene\";\nimport { duplicateElements } from \"../element/newElement\";\n\n// getContainerElement and getBoundTextElement and potentially other helpers\n// depend on `Scene` which will not be available when these pure utils are\n// called outside initialized Excalidraw editor instance or even if called\n// from inside Excalidraw if the elements were never cached by Scene (e.g.\n// for library elements).\n//\n// As such, before passing the elements down, we need to initialize a custom\n// Scene instance and assign them to it.\n//\n// FIXME This is a super hacky workaround and we'll need to rewrite this soon.\nconst passElementsSafely = elements => {\n  const scene = new Scene();\n  scene.replaceAllElements(duplicateElements(elements));\n  return scene.getNonDeletedElements();\n};\nexport { MIME_TYPES };\nexport const exportToCanvas = _ref => {\n  let {\n    elements,\n    appState,\n    files,\n    maxWidthOrHeight,\n    getDimensions,\n    exportPadding\n  } = _ref;\n  const {\n    elements: restoredElements,\n    appState: restoredAppState\n  } = restore({\n    elements,\n    appState\n  }, null, null);\n  const {\n    exportBackground,\n    viewBackgroundColor\n  } = restoredAppState;\n  return _exportToCanvas(passElementsSafely(restoredElements), {\n    ...restoredAppState,\n    offsetTop: 0,\n    offsetLeft: 0,\n    width: 0,\n    height: 0\n  }, files || {}, {\n    exportBackground,\n    exportPadding,\n    viewBackgroundColor\n  }, (width, height) => {\n    var _ret$scale;\n    const canvas = document.createElement(\"canvas\");\n    if (maxWidthOrHeight) {\n      var _appState$exportScale;\n      if (typeof getDimensions === \"function\") {\n        console.warn(\"`getDimensions()` is ignored when `maxWidthOrHeight` is supplied.\");\n      }\n      const max = Math.max(width, height);\n\n      // if content is less then maxWidthOrHeight, fallback on supplied scale\n      const scale = maxWidthOrHeight < max ? maxWidthOrHeight / max : (_appState$exportScale = appState === null || appState === void 0 ? void 0 : appState.exportScale) !== null && _appState$exportScale !== void 0 ? _appState$exportScale : 1;\n      canvas.width = width * scale;\n      canvas.height = height * scale;\n      return {\n        canvas,\n        scale\n      };\n    }\n    const ret = (getDimensions === null || getDimensions === void 0 ? void 0 : getDimensions(width, height)) || {\n      width,\n      height\n    };\n    canvas.width = ret.width;\n    canvas.height = ret.height;\n    return {\n      canvas,\n      scale: (_ret$scale = ret.scale) !== null && _ret$scale !== void 0 ? _ret$scale : 1\n    };\n  });\n};\nexport const exportToBlob = async opts => {\n  var _opts$appState;\n  let {\n    mimeType = MIME_TYPES.png,\n    quality\n  } = opts;\n  if (mimeType === MIME_TYPES.png && typeof quality === \"number\") {\n    console.warn(`\"quality\" will be ignored for \"${MIME_TYPES.png}\" mimeType`);\n  }\n\n  // typo in MIME type (should be \"jpeg\")\n  if (mimeType === \"image/jpg\") {\n    mimeType = MIME_TYPES.jpg;\n  }\n  if (mimeType === MIME_TYPES.jpg && !((_opts$appState = opts.appState) !== null && _opts$appState !== void 0 && _opts$appState.exportBackground)) {\n    console.warn(`Defaulting \"exportBackground\" to \"true\" for \"${MIME_TYPES.jpg}\" mimeType`);\n    opts = {\n      ...opts,\n      appState: {\n        ...opts.appState,\n        exportBackground: true\n      }\n    };\n  }\n  const canvas = await exportToCanvas({\n    ...opts,\n    elements: passElementsSafely(opts.elements)\n  });\n  quality = quality ? quality : /image\\/jpe?g/.test(mimeType) ? 0.92 : 0.8;\n  return new Promise((resolve, reject) => {\n    canvas.toBlob(async blob => {\n      var _opts$appState2;\n      if (!blob) {\n        return reject(new Error(\"couldn't export to blob\"));\n      }\n      if (blob && mimeType === MIME_TYPES.png && (_opts$appState2 = opts.appState) !== null && _opts$appState2 !== void 0 && _opts$appState2.exportEmbedScene) {\n        blob = await encodePngMetadata({\n          blob,\n          metadata: serializeAsJSON(\n          // NOTE as long as we're using the Scene hack, we need to ensure\n          // we pass the original, uncloned elements when serializing\n          // so that we keep ids stable\n          opts.elements, opts.appState, opts.files || {}, \"local\")\n        });\n      }\n      resolve(blob);\n    }, mimeType, quality);\n  });\n};\nexport const exportToSvg = async _ref2 => {\n  let {\n    elements,\n    appState = getDefaultAppState(),\n    files = {},\n    exportPadding\n  } = _ref2;\n  const {\n    elements: restoredElements,\n    appState: restoredAppState\n  } = restore({\n    elements,\n    appState\n  }, null, null);\n  const exportAppState = {\n    ...restoredAppState,\n    exportPadding\n  };\n  return _exportToSvg(passElementsSafely(restoredElements), exportAppState, files, {\n    // NOTE as long as we're using the Scene hack, we need to ensure\n    // we pass the original, uncloned elements when serializing\n    // so that we keep ids stable. Hence adding the serializeAsJSON helper\n    // support into the downstream exportToSvg function.\n    serializeAsJSON: () => serializeAsJSON(restoredElements, exportAppState, files || {}, \"local\")\n  });\n};\nexport const exportToClipboard = async opts => {\n  if (opts.type === \"svg\") {\n    const svg = await exportToSvg(opts);\n    await copyTextToSystemClipboard(svg.outerHTML);\n  } else if (opts.type === \"png\") {\n    await copyBlobToClipboardAsPng(exportToBlob(opts));\n  } else if (opts.type === \"json\") {\n    await copyToClipboard(opts.elements, opts.files);\n  } else {\n    throw new Error(\"Invalid export type\");\n  }\n};\nexport { serializeAsJSON, serializeLibraryAsJSON } from \"../data/json\";\nexport { loadFromBlob, loadSceneOrLibraryFromBlob, loadLibraryFromBlob } from \"../data/blob\";\nexport { getFreeDrawSvgPath } from \"../renderer/renderElement\";\nexport { mergeLibraryItems } from \"../data/library\";","map":{"version":3,"names":["exportToCanvas","_exportToCanvas","exportToSvg","_exportToSvg","getDefaultAppState","restore","MIME_TYPES","encodePngMetadata","serializeAsJSON","copyBlobToClipboardAsPng","copyTextToSystemClipboard","copyToClipboard","Scene","duplicateElements","passElementsSafely","elements","scene","replaceAllElements","getNonDeletedElements","_ref","appState","files","maxWidthOrHeight","getDimensions","exportPadding","restoredElements","restoredAppState","exportBackground","viewBackgroundColor","offsetTop","offsetLeft","width","height","_ret$scale","canvas","document","createElement","_appState$exportScale","console","warn","max","Math","scale","exportScale","ret","exportToBlob","opts","_opts$appState","mimeType","png","quality","jpg","test","Promise","resolve","reject","toBlob","blob","_opts$appState2","Error","exportEmbedScene","metadata","_ref2","exportAppState","exportToClipboard","type","svg","outerHTML","serializeLibraryAsJSON","loadFromBlob","loadSceneOrLibraryFromBlob","loadLibraryFromBlob","getFreeDrawSvgPath","mergeLibraryItems"],"sources":["D:/project/excalidraw-cn/src/packages/utils.ts"],"sourcesContent":["import {\n  exportToCanvas as _exportToCanvas,\n  exportToSvg as _exportToSvg,\n} from \"../scene/export\";\nimport { getDefaultAppState } from \"../appState\";\nimport { AppState, BinaryFiles } from \"../types\";\nimport { ExcalidrawElement, NonDeleted } from \"../element/types\";\nimport { restore } from \"../data/restore\";\nimport { MIME_TYPES } from \"../constants\";\nimport { encodePngMetadata } from \"../data/image\";\nimport { serializeAsJSON } from \"../data/json\";\nimport {\n  copyBlobToClipboardAsPng,\n  copyTextToSystemClipboard,\n  copyToClipboard,\n} from \"../clipboard\";\nimport Scene from \"../scene/Scene\";\nimport { duplicateElements } from \"../element/newElement\";\n\n// getContainerElement and getBoundTextElement and potentially other helpers\n// depend on `Scene` which will not be available when these pure utils are\n// called outside initialized Excalidraw editor instance or even if called\n// from inside Excalidraw if the elements were never cached by Scene (e.g.\n// for library elements).\n//\n// As such, before passing the elements down, we need to initialize a custom\n// Scene instance and assign them to it.\n//\n// FIXME This is a super hacky workaround and we'll need to rewrite this soon.\nconst passElementsSafely = (elements: readonly ExcalidrawElement[]) => {\n  const scene = new Scene();\n  scene.replaceAllElements(duplicateElements(elements));\n  return scene.getNonDeletedElements();\n};\n\nexport { MIME_TYPES };\n\ntype ExportOpts = {\n  elements: readonly NonDeleted<ExcalidrawElement>[];\n  appState?: Partial<Omit<AppState, \"offsetTop\" | \"offsetLeft\">>;\n  files: BinaryFiles | null;\n  maxWidthOrHeight?: number;\n  getDimensions?: (\n    width: number,\n    height: number,\n  ) => { width: number; height: number; scale?: number };\n};\n\nexport const exportToCanvas = ({\n  elements,\n  appState,\n  files,\n  maxWidthOrHeight,\n  getDimensions,\n  exportPadding,\n}: ExportOpts & {\n  exportPadding?: number;\n}) => {\n  const { elements: restoredElements, appState: restoredAppState } = restore(\n    { elements, appState },\n    null,\n    null,\n  );\n  const { exportBackground, viewBackgroundColor } = restoredAppState;\n  return _exportToCanvas(\n    passElementsSafely(restoredElements),\n    { ...restoredAppState, offsetTop: 0, offsetLeft: 0, width: 0, height: 0 },\n    files || {},\n    { exportBackground, exportPadding, viewBackgroundColor },\n    (width: number, height: number) => {\n      const canvas = document.createElement(\"canvas\");\n\n      if (maxWidthOrHeight) {\n        if (typeof getDimensions === \"function\") {\n          console.warn(\n            \"`getDimensions()` is ignored when `maxWidthOrHeight` is supplied.\",\n          );\n        }\n\n        const max = Math.max(width, height);\n\n        // if content is less then maxWidthOrHeight, fallback on supplied scale\n        const scale =\n          maxWidthOrHeight < max\n            ? maxWidthOrHeight / max\n            : appState?.exportScale ?? 1;\n\n        canvas.width = width * scale;\n        canvas.height = height * scale;\n\n        return {\n          canvas,\n          scale,\n        };\n      }\n\n      const ret = getDimensions?.(width, height) || { width, height };\n\n      canvas.width = ret.width;\n      canvas.height = ret.height;\n\n      return {\n        canvas,\n        scale: ret.scale ?? 1,\n      };\n    },\n  );\n};\n\nexport const exportToBlob = async (\n  opts: ExportOpts & {\n    mimeType?: string;\n    quality?: number;\n    exportPadding?: number;\n  },\n): Promise<Blob> => {\n  let { mimeType = MIME_TYPES.png, quality } = opts;\n\n  if (mimeType === MIME_TYPES.png && typeof quality === \"number\") {\n    console.warn(`\"quality\" will be ignored for \"${MIME_TYPES.png}\" mimeType`);\n  }\n\n  // typo in MIME type (should be \"jpeg\")\n  if (mimeType === \"image/jpg\") {\n    mimeType = MIME_TYPES.jpg;\n  }\n\n  if (mimeType === MIME_TYPES.jpg && !opts.appState?.exportBackground) {\n    console.warn(\n      `Defaulting \"exportBackground\" to \"true\" for \"${MIME_TYPES.jpg}\" mimeType`,\n    );\n    opts = {\n      ...opts,\n      appState: { ...opts.appState, exportBackground: true },\n    };\n  }\n\n  const canvas = await exportToCanvas({\n    ...opts,\n    elements: passElementsSafely(opts.elements),\n  });\n  quality = quality ? quality : /image\\/jpe?g/.test(mimeType) ? 0.92 : 0.8;\n\n  return new Promise((resolve, reject) => {\n    canvas.toBlob(\n      async (blob) => {\n        if (!blob) {\n          return reject(new Error(\"couldn't export to blob\"));\n        }\n        if (\n          blob &&\n          mimeType === MIME_TYPES.png &&\n          opts.appState?.exportEmbedScene\n        ) {\n          blob = await encodePngMetadata({\n            blob,\n            metadata: serializeAsJSON(\n              // NOTE as long as we're using the Scene hack, we need to ensure\n              // we pass the original, uncloned elements when serializing\n              // so that we keep ids stable\n              opts.elements,\n              opts.appState,\n              opts.files || {},\n              \"local\",\n            ),\n          });\n        }\n        resolve(blob);\n      },\n      mimeType,\n      quality,\n    );\n  });\n};\n\nexport const exportToSvg = async ({\n  elements,\n  appState = getDefaultAppState(),\n  files = {},\n  exportPadding,\n}: Omit<ExportOpts, \"getDimensions\"> & {\n  exportPadding?: number;\n}): Promise<SVGSVGElement> => {\n  const { elements: restoredElements, appState: restoredAppState } = restore(\n    { elements, appState },\n    null,\n    null,\n  );\n\n  const exportAppState = {\n    ...restoredAppState,\n    exportPadding,\n  };\n\n  return _exportToSvg(\n    passElementsSafely(restoredElements),\n    exportAppState,\n    files,\n    {\n      // NOTE as long as we're using the Scene hack, we need to ensure\n      // we pass the original, uncloned elements when serializing\n      // so that we keep ids stable. Hence adding the serializeAsJSON helper\n      // support into the downstream exportToSvg function.\n      serializeAsJSON: () =>\n        serializeAsJSON(restoredElements, exportAppState, files || {}, \"local\"),\n    },\n  );\n};\n\nexport const exportToClipboard = async (\n  opts: ExportOpts & {\n    mimeType?: string;\n    quality?: number;\n    type: \"png\" | \"svg\" | \"json\";\n  },\n) => {\n  if (opts.type === \"svg\") {\n    const svg = await exportToSvg(opts);\n    await copyTextToSystemClipboard(svg.outerHTML);\n  } else if (opts.type === \"png\") {\n    await copyBlobToClipboardAsPng(exportToBlob(opts));\n  } else if (opts.type === \"json\") {\n    await copyToClipboard(opts.elements, opts.files);\n  } else {\n    throw new Error(\"Invalid export type\");\n  }\n};\n\nexport { serializeAsJSON, serializeLibraryAsJSON } from \"../data/json\";\nexport {\n  loadFromBlob,\n  loadSceneOrLibraryFromBlob,\n  loadLibraryFromBlob,\n} from \"../data/blob\";\nexport { getFreeDrawSvgPath } from \"../renderer/renderElement\";\nexport { mergeLibraryItems } from \"../data/library\";\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}