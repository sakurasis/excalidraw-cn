{"ast":null,"code":"var _jsxFileName = \"D:\\\\project\\\\excalidraw-cn\\\\src\\\\actions\\\\actionDuplicateSelection.tsx\";\nimport { KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { duplicateElement, getNonDeletedElements } from \"../element\";\nimport { isSomeElementSelected } from \"../scene\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { t } from \"../i18n\";\nimport { arrayToMap, getShortcutKey } from \"../utils\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { selectGroupsForSelectedElements, getSelectedGroupForElement, getElementsInGroup } from \"../groups\";\nimport { fixBindingsAfterDuplication } from \"../element/binding\";\nimport { GRID_SIZE } from \"../constants\";\nimport { bindTextToShapeAfterDuplication, getBoundTextElement } from \"../element/textElement\";\nimport { isBoundToContainer, isFrameElement } from \"../element/typeChecks\";\nimport { normalizeElementOrder } from \"../element/sortElements\";\nimport { DuplicateIcon } from \"../components/icons\";\nimport { bindElementsToFramesAfterDuplication, getFrameElements } from \"../frame\";\nimport { excludeElementsInFramesFromSelection, getSelectedElements } from \"../scene/selection\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const actionDuplicateSelection = register({\n  name: \"duplicateSelection\",\n  trackEvent: {\n    category: \"element\"\n  },\n  perform: (elements, appState) => {\n    // duplicate selected point(s) if editing a line\n    if (appState.editingLinearElement) {\n      const ret = LinearElementEditor.duplicateSelectedPoints(appState);\n      if (!ret) {\n        return false;\n      }\n      return {\n        elements,\n        appState: ret.appState,\n        commitToHistory: true\n      };\n    }\n    return {\n      ...duplicateElements(elements, appState),\n      commitToHistory: true\n    };\n  },\n  contextItemLabel: \"labels.duplicateSelection\",\n  keyTest: event => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.D,\n  PanelComponent: _ref => {\n    let {\n      elements,\n      appState,\n      updateData\n    } = _ref;\n    return /*#__PURE__*/_jsxDEV(ToolButton, {\n      type: \"button\",\n      icon: DuplicateIcon,\n      title: `${t(\"labels.duplicateSelection\")} — ${getShortcutKey(\"CtrlOrCmd+D\")}`,\n      \"aria-label\": t(\"labels.duplicateSelection\"),\n      onClick: () => updateData(null),\n      visible: isSomeElementSelected(getNonDeletedElements(elements), appState)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 62,\n      columnNumber: 5\n    }, this);\n  }\n});\nconst duplicateElements = (elements, appState) => {\n  // ---------------------------------------------------------------------------\n\n  // step (1)\n\n  const sortedElements = normalizeElementOrder(elements);\n  const groupIdMap = new Map();\n  const newElements = [];\n  const oldElements = [];\n  const oldIdToDuplicatedId = new Map();\n  const duplicateAndOffsetElement = element => {\n    const newElement = duplicateElement(appState.editingGroupId, groupIdMap, element, {\n      x: element.x + GRID_SIZE / 2,\n      y: element.y + GRID_SIZE / 2\n    });\n    oldIdToDuplicatedId.set(element.id, newElement.id);\n    oldElements.push(element);\n    newElements.push(newElement);\n    return newElement;\n  };\n  const idsOfElementsToDuplicate = arrayToMap(getSelectedElements(sortedElements, appState, {\n    includeBoundTextElement: true,\n    includeElementsInFrames: true\n  }));\n\n  // Ids of elements that have already been processed so we don't push them\n  // into the array twice if we end up backtracking when retrieving\n  // discontiguous group of elements (can happen due to a bug, or in edge\n  // cases such as a group containing deleted elements which were not selected).\n  //\n  // This is not enough to prevent duplicates, so we do a second loop afterwards\n  // to remove them.\n  //\n  // For convenience we mark even the newly created ones even though we don't\n  // loop over them.\n  const processedIds = new Map();\n  const markAsProcessed = elements => {\n    for (const element of elements) {\n      processedIds.set(element.id, true);\n    }\n    return elements;\n  };\n  const elementsWithClones = [];\n  let index = -1;\n  while (++index < sortedElements.length) {\n    const element = sortedElements[index];\n    if (processedIds.get(element.id)) {\n      continue;\n    }\n    const boundTextElement = getBoundTextElement(element);\n    const isElementAFrame = isFrameElement(element);\n    if (idsOfElementsToDuplicate.get(element.id)) {\n      // if a group or a container/bound-text or frame, duplicate atomically\n      if (element.groupIds.length || boundTextElement || isElementAFrame) {\n        const groupId = getSelectedGroupForElement(appState, element);\n        if (groupId) {\n          // TODO:\n          // remove `.flatMap...`\n          // if the elements in a frame are grouped when the frame is grouped\n          const groupElements = getElementsInGroup(sortedElements, groupId).flatMap(element => isFrameElement(element) ? [...getFrameElements(elements, element.id), element] : [element]);\n          elementsWithClones.push(...markAsProcessed([...groupElements, ...groupElements.map(element => duplicateAndOffsetElement(element))]));\n          continue;\n        }\n        if (boundTextElement) {\n          elementsWithClones.push(...markAsProcessed([element, boundTextElement, duplicateAndOffsetElement(element), duplicateAndOffsetElement(boundTextElement)]));\n          continue;\n        }\n        if (isElementAFrame) {\n          const elementsInFrame = getFrameElements(sortedElements, element.id);\n          elementsWithClones.push(...markAsProcessed([...elementsInFrame, element, ...elementsInFrame.map(e => duplicateAndOffsetElement(e)), duplicateAndOffsetElement(element)]));\n          continue;\n        }\n      }\n      // since elements in frames have a lower z-index than the frame itself,\n      // they will be looped first and if their frames are selected as well,\n      // they will have been copied along with the frame atomically in the\n      // above branch, so we must skip those elements here\n      //\n      // now, for elements do not belong any frames or elements whose frames\n      // are selected (or elements that are left out from the above\n      // steps for whatever reason) we (should at least) duplicate them here\n      if (!element.frameId || !idsOfElementsToDuplicate.has(element.frameId)) {\n        elementsWithClones.push(...markAsProcessed([element, duplicateAndOffsetElement(element)]));\n      }\n    } else {\n      elementsWithClones.push(...markAsProcessed([element]));\n    }\n  }\n\n  // step (2)\n\n  // second pass to remove duplicates. We loop from the end as it's likelier\n  // that the last elements are in the correct order (contiguous or otherwise).\n  // Thus we need to reverse as the last step (3).\n\n  const finalElementsReversed = [];\n  const finalElementIds = new Map();\n  index = elementsWithClones.length;\n  while (--index >= 0) {\n    const element = elementsWithClones[index];\n    if (!finalElementIds.get(element.id)) {\n      finalElementIds.set(element.id, true);\n      finalElementsReversed.push(element);\n    }\n  }\n\n  // step (3)\n\n  const finalElements = finalElementsReversed.reverse();\n\n  // ---------------------------------------------------------------------------\n\n  bindTextToShapeAfterDuplication(elementsWithClones, oldElements, oldIdToDuplicatedId);\n  fixBindingsAfterDuplication(elementsWithClones, oldElements, oldIdToDuplicatedId);\n  bindElementsToFramesAfterDuplication(finalElements, oldElements, oldIdToDuplicatedId);\n  const nextElementsToSelect = excludeElementsInFramesFromSelection(newElements);\n  return {\n    elements: finalElements,\n    appState: selectGroupsForSelectedElements({\n      ...appState,\n      selectedGroupIds: {},\n      selectedElementIds: nextElementsToSelect.reduce((acc, element) => {\n        if (!isBoundToContainer(element)) {\n          acc[element.id] = true;\n        }\n        return acc;\n      }, {})\n    }, getNonDeletedElements(finalElements), appState, null)\n  };\n};","map":{"version":3,"names":["KEYS","register","duplicateElement","getNonDeletedElements","isSomeElementSelected","ToolButton","t","arrayToMap","getShortcutKey","LinearElementEditor","selectGroupsForSelectedElements","getSelectedGroupForElement","getElementsInGroup","fixBindingsAfterDuplication","GRID_SIZE","bindTextToShapeAfterDuplication","getBoundTextElement","isBoundToContainer","isFrameElement","normalizeElementOrder","DuplicateIcon","bindElementsToFramesAfterDuplication","getFrameElements","excludeElementsInFramesFromSelection","getSelectedElements","jsxDEV","_jsxDEV","actionDuplicateSelection","name","trackEvent","category","perform","elements","appState","editingLinearElement","ret","duplicateSelectedPoints","commitToHistory","duplicateElements","contextItemLabel","keyTest","event","CTRL_OR_CMD","key","D","PanelComponent","_ref","updateData","type","icon","title","onClick","visible","fileName","_jsxFileName","lineNumber","columnNumber","sortedElements","groupIdMap","Map","newElements","oldElements","oldIdToDuplicatedId","duplicateAndOffsetElement","element","newElement","editingGroupId","x","y","set","id","push","idsOfElementsToDuplicate","includeBoundTextElement","includeElementsInFrames","processedIds","markAsProcessed","elementsWithClones","index","length","get","boundTextElement","isElementAFrame","groupIds","groupId","groupElements","flatMap","map","elementsInFrame","e","frameId","has","finalElementsReversed","finalElementIds","finalElements","reverse","nextElementsToSelect","selectedGroupIds","selectedElementIds","reduce","acc"],"sources":["D:/project/excalidraw-cn/src/actions/actionDuplicateSelection.tsx"],"sourcesContent":["import { KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { duplicateElement, getNonDeletedElements } from \"../element\";\nimport { isSomeElementSelected } from \"../scene\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { t } from \"../i18n\";\nimport { arrayToMap, getShortcutKey } from \"../utils\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport {\n  selectGroupsForSelectedElements,\n  getSelectedGroupForElement,\n  getElementsInGroup,\n} from \"../groups\";\nimport { AppState } from \"../types\";\nimport { fixBindingsAfterDuplication } from \"../element/binding\";\nimport { ActionResult } from \"./types\";\nimport { GRID_SIZE } from \"../constants\";\nimport {\n  bindTextToShapeAfterDuplication,\n  getBoundTextElement,\n} from \"../element/textElement\";\nimport { isBoundToContainer, isFrameElement } from \"../element/typeChecks\";\nimport { normalizeElementOrder } from \"../element/sortElements\";\nimport { DuplicateIcon } from \"../components/icons\";\nimport {\n  bindElementsToFramesAfterDuplication,\n  getFrameElements,\n} from \"../frame\";\nimport {\n  excludeElementsInFramesFromSelection,\n  getSelectedElements,\n} from \"../scene/selection\";\n\nexport const actionDuplicateSelection = register({\n  name: \"duplicateSelection\",\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState) => {\n    // duplicate selected point(s) if editing a line\n    if (appState.editingLinearElement) {\n      const ret = LinearElementEditor.duplicateSelectedPoints(appState);\n\n      if (!ret) {\n        return false;\n      }\n\n      return {\n        elements,\n        appState: ret.appState,\n        commitToHistory: true,\n      };\n    }\n\n    return {\n      ...duplicateElements(elements, appState),\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.duplicateSelection\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.D,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={DuplicateIcon}\n      title={`${t(\"labels.duplicateSelection\")} — ${getShortcutKey(\n        \"CtrlOrCmd+D\",\n      )}`}\n      aria-label={t(\"labels.duplicateSelection\")}\n      onClick={() => updateData(null)}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nconst duplicateElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n): Partial<ActionResult> => {\n  // ---------------------------------------------------------------------------\n\n  // step (1)\n\n  const sortedElements = normalizeElementOrder(elements);\n  const groupIdMap = new Map();\n  const newElements: ExcalidrawElement[] = [];\n  const oldElements: ExcalidrawElement[] = [];\n  const oldIdToDuplicatedId = new Map();\n\n  const duplicateAndOffsetElement = (element: ExcalidrawElement) => {\n    const newElement = duplicateElement(\n      appState.editingGroupId,\n      groupIdMap,\n      element,\n      {\n        x: element.x + GRID_SIZE / 2,\n        y: element.y + GRID_SIZE / 2,\n      },\n    );\n    oldIdToDuplicatedId.set(element.id, newElement.id);\n    oldElements.push(element);\n    newElements.push(newElement);\n    return newElement;\n  };\n\n  const idsOfElementsToDuplicate = arrayToMap(\n    getSelectedElements(sortedElements, appState, {\n      includeBoundTextElement: true,\n      includeElementsInFrames: true,\n    }),\n  );\n\n  // Ids of elements that have already been processed so we don't push them\n  // into the array twice if we end up backtracking when retrieving\n  // discontiguous group of elements (can happen due to a bug, or in edge\n  // cases such as a group containing deleted elements which were not selected).\n  //\n  // This is not enough to prevent duplicates, so we do a second loop afterwards\n  // to remove them.\n  //\n  // For convenience we mark even the newly created ones even though we don't\n  // loop over them.\n  const processedIds = new Map<ExcalidrawElement[\"id\"], true>();\n\n  const markAsProcessed = (elements: ExcalidrawElement[]) => {\n    for (const element of elements) {\n      processedIds.set(element.id, true);\n    }\n    return elements;\n  };\n\n  const elementsWithClones: ExcalidrawElement[] = [];\n\n  let index = -1;\n\n  while (++index < sortedElements.length) {\n    const element = sortedElements[index];\n\n    if (processedIds.get(element.id)) {\n      continue;\n    }\n\n    const boundTextElement = getBoundTextElement(element);\n    const isElementAFrame = isFrameElement(element);\n\n    if (idsOfElementsToDuplicate.get(element.id)) {\n      // if a group or a container/bound-text or frame, duplicate atomically\n      if (element.groupIds.length || boundTextElement || isElementAFrame) {\n        const groupId = getSelectedGroupForElement(appState, element);\n        if (groupId) {\n          // TODO:\n          // remove `.flatMap...`\n          // if the elements in a frame are grouped when the frame is grouped\n          const groupElements = getElementsInGroup(\n            sortedElements,\n            groupId,\n          ).flatMap((element) =>\n            isFrameElement(element)\n              ? [...getFrameElements(elements, element.id), element]\n              : [element],\n          );\n\n          elementsWithClones.push(\n            ...markAsProcessed([\n              ...groupElements,\n              ...groupElements.map((element) =>\n                duplicateAndOffsetElement(element),\n              ),\n            ]),\n          );\n          continue;\n        }\n        if (boundTextElement) {\n          elementsWithClones.push(\n            ...markAsProcessed([\n              element,\n              boundTextElement,\n              duplicateAndOffsetElement(element),\n              duplicateAndOffsetElement(boundTextElement),\n            ]),\n          );\n          continue;\n        }\n        if (isElementAFrame) {\n          const elementsInFrame = getFrameElements(sortedElements, element.id);\n\n          elementsWithClones.push(\n            ...markAsProcessed([\n              ...elementsInFrame,\n              element,\n              ...elementsInFrame.map((e) => duplicateAndOffsetElement(e)),\n              duplicateAndOffsetElement(element),\n            ]),\n          );\n\n          continue;\n        }\n      }\n      // since elements in frames have a lower z-index than the frame itself,\n      // they will be looped first and if their frames are selected as well,\n      // they will have been copied along with the frame atomically in the\n      // above branch, so we must skip those elements here\n      //\n      // now, for elements do not belong any frames or elements whose frames\n      // are selected (or elements that are left out from the above\n      // steps for whatever reason) we (should at least) duplicate them here\n      if (!element.frameId || !idsOfElementsToDuplicate.has(element.frameId)) {\n        elementsWithClones.push(\n          ...markAsProcessed([element, duplicateAndOffsetElement(element)]),\n        );\n      }\n    } else {\n      elementsWithClones.push(...markAsProcessed([element]));\n    }\n  }\n\n  // step (2)\n\n  // second pass to remove duplicates. We loop from the end as it's likelier\n  // that the last elements are in the correct order (contiguous or otherwise).\n  // Thus we need to reverse as the last step (3).\n\n  const finalElementsReversed: ExcalidrawElement[] = [];\n\n  const finalElementIds = new Map<ExcalidrawElement[\"id\"], true>();\n  index = elementsWithClones.length;\n\n  while (--index >= 0) {\n    const element = elementsWithClones[index];\n    if (!finalElementIds.get(element.id)) {\n      finalElementIds.set(element.id, true);\n      finalElementsReversed.push(element);\n    }\n  }\n\n  // step (3)\n\n  const finalElements = finalElementsReversed.reverse();\n\n  // ---------------------------------------------------------------------------\n\n  bindTextToShapeAfterDuplication(\n    elementsWithClones,\n    oldElements,\n    oldIdToDuplicatedId,\n  );\n  fixBindingsAfterDuplication(\n    elementsWithClones,\n    oldElements,\n    oldIdToDuplicatedId,\n  );\n  bindElementsToFramesAfterDuplication(\n    finalElements,\n    oldElements,\n    oldIdToDuplicatedId,\n  );\n\n  const nextElementsToSelect =\n    excludeElementsInFramesFromSelection(newElements);\n\n  return {\n    elements: finalElements,\n    appState: selectGroupsForSelectedElements(\n      {\n        ...appState,\n        selectedGroupIds: {},\n        selectedElementIds: nextElementsToSelect.reduce(\n          (acc: Record<ExcalidrawElement[\"id\"], true>, element) => {\n            if (!isBoundToContainer(element)) {\n              acc[element.id] = true;\n            }\n            return acc;\n          },\n          {},\n        ),\n      },\n      getNonDeletedElements(finalElements),\n      appState,\n      null,\n    ),\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}