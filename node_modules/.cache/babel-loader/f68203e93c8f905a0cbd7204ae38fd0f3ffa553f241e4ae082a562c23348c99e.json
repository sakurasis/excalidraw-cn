{"ast":null,"code":"let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = get => get(config);\n    config.write = (get, set, arg) => set(config, typeof arg === \"function\" ? arg(get(config)) : arg);\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nconst hasInitialValue = atom => \"init\" in atom;\nconst isActuallyWritableAtom = atom => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {}).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isEqualAtomValue = (a, b) => \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = a => \"v\" in a && a.v instanceof Promise;\nconst returnAtomValue = atomState => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */new WeakMap();\n  const mountedMap = /* @__PURE__ */new WeakMap();\n  const pendingMap = /* @__PURE__ */new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */new Set();\n    mountedAtoms = /* @__PURE__ */new Set();\n  }\n  const getAtomState = atom => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, depSet) => {\n    const dependencies = /* @__PURE__ */new Map();\n    let changed = false;\n    depSet.forEach(a => {\n      const aState = a === atom ? nextAtomState : getAtomState(a);\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */new Map(),\n      v: value\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomError = (atom, error, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */new Map(),\n      e: error\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = atom => {\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(_ref => {\n        let [a, s] = _ref;\n        return a === atom || getAtomState(a) === s;\n      })) {\n        return atomState;\n      }\n    }\n    const depSet = /* @__PURE__ */new Set();\n    let isSync = true;\n    const getter = a => {\n      depSet.add(a);\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = function () {\n            if ((import.meta.env && import.meta.env.MODE) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const value = atom.read(getter, options);\n      if (value instanceof Promise) {\n        let continuePromise;\n        const promise = new Promise((resolve, reject) => {\n          let settled = false;\n          value.then(v => {\n            if (!settled) {\n              resolvePromise(promise, v);\n              resolve(v);\n            }\n          }, e => {\n            if (!settled) {\n              rejectPromise(promise, e);\n              reject(e);\n            }\n          }).finally(() => {\n            if (!settled) {\n              settled = true;\n              setAtomValue(atom, promise, depSet);\n            }\n          });\n          continuePromise = next => {\n            if (!settled) {\n              settled = true;\n              next.then(v => resolvePromise(promise, v), e => rejectPromise(promise, e));\n              resolve(next);\n            }\n          };\n        });\n        promise.status = \"pending\";\n        registerCancelPromise(promise, next => {\n          if (next) {\n            continuePromise(next);\n          }\n          controller == null ? void 0 : controller.abort();\n        });\n        return setAtomValue(atom, promise, depSet);\n      }\n      return setAtomValue(atom, value, depSet);\n    } catch (error) {\n      return setAtomError(atom, error, depSet);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = atom => returnAtomValue(readAtomState(atom));\n  const addAtom = atom => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = atom => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = atom => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(dependent => {\n      if (dependent !== atom) {\n        const prevAtomState = getAtomState(dependent);\n        const nextAtomState = readAtomState(dependent);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(dependent);\n        }\n      }\n    });\n  };\n  const writeAtomState = function (atom) {\n    let isSync = true;\n    const getter = a => returnAtomValue(readAtomState(a));\n    const setter = function (a) {\n      let r;\n      for (var _len3 = arguments.length, args2 = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args2[_key3 - 1] = arguments[_key3];\n      }\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValue(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = function (atom) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    const result = writeAtomState(atom, ...args);\n    flushPending();\n    return result;\n  };\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const onUnmount = atom.onMount(function () {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n        return writeAtom(atom, ...args);\n      });\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = atom => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach(a => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(_ref2 => {\n        let [atom, prevAtomState] = _ref2;\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          const mounted = mountedMap.get(atom);\n          if (mounted && !(\n          // TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach(listener => listener());\n          }\n        } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach(l => l());\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n    };\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change)\n      dev_subscribe_state: l => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: a => atomStateMap.get(a),\n      dev_get_mounted: a => mountedMap.get(a),\n      dev_restore_atoms: values => {\n        for (const [atom, value] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValue(atom, value);\n            recomputeDependents(atom);\n          }\n        }\n        flushPending();\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\nexport { atom, createStore, getDefaultStore };","map":{"version":3,"names":["keyCount","atom","read","write","key","config","toString","init","get","set","arg","hasInitialValue","isActuallyWritableAtom","cancelPromiseMap","WeakMap","registerCancelPromise","promise","cancel","catch","finally","delete","cancelPromise","next","resolvePromise","value","status","rejectPromise","e","reason","isEqualAtomValue","a","b","Object","is","v","isEqualAtomError","hasPromiseAtomValue","Promise","returnAtomValue","atomState","createStore","atomStateMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","import","meta","env","MODE","Set","getAtomState","setAtomState","freeze","prevAtomState","has","resolve","reject","updateDependencies","nextAtomState","depSet","dependencies","changed","forEach","aState","d","console","warn","size","setAtomValue","setAtomError","error","readAtomState","_","Array","from","every","_ref","s","isSync","getter","add","aState2","Error","controller","setSelf","options","signal","AbortController","_len","arguments","length","args","_key","writeAtom","continuePromise","settled","then","abort","readAtom","addAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","unmountAtom","recomputeDependents","dependent","writeAtomState","setter","r","_len3","args2","_key3","flushPending","_len2","_key2","result","_len4","_key4","initialDependent","aMounted","onMount","onUnmount","_len5","_key5","u","_a","mountDependencies","prevDependencies","keys","pending","clear","_ref2","listener","subscribeAtom","listeners","sub","dev_subscribe_state","dev_get_mounted_atoms","values","dev_get_atom_state","dev_get_mounted","dev_restore_atoms","defaultStore","getDefaultStore"],"sources":["D:/project/excalidraw-cn/node_modules/jotai/esm/vanilla.mjs"],"sourcesContent":["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, arg) => set(\n      config,\n      typeof arg === \"function\" ? arg(get(config)) : arg\n    );\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isEqualAtomValue = (a, b) => \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => \"v\" in a && a.v instanceof Promise;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, depSet) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    depSet.forEach((a) => {\n      const aState = a === atom ? nextAtomState : getAtomState(a);\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomError = (atom, error, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom) => {\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(\n        ([a, s]) => a === atom || getAtomState(a) === s\n      )) {\n        return atomState;\n      }\n    }\n    const depSet = /* @__PURE__ */ new Set();\n    let isSync = true;\n    const getter = (a) => {\n      depSet.add(a);\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env && import.meta.env.MODE) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const value = atom.read(getter, options);\n      if (value instanceof Promise) {\n        let continuePromise;\n        const promise = new Promise((resolve, reject) => {\n          let settled = false;\n          value.then(\n            (v) => {\n              if (!settled) {\n                resolvePromise(promise, v);\n                resolve(v);\n              }\n            },\n            (e) => {\n              if (!settled) {\n                rejectPromise(promise, e);\n                reject(e);\n              }\n            }\n          ).finally(() => {\n            if (!settled) {\n              settled = true;\n              setAtomValue(atom, promise, depSet);\n            }\n          });\n          continuePromise = (next) => {\n            if (!settled) {\n              settled = true;\n              next.then(\n                (v) => resolvePromise(promise, v),\n                (e) => rejectPromise(promise, e)\n              );\n              resolve(next);\n            }\n          };\n        });\n        promise.status = \"pending\";\n        registerCancelPromise(promise, (next) => {\n          if (next) {\n            continuePromise(next);\n          }\n          controller == null ? void 0 : controller.abort();\n        });\n        return setAtomValue(atom, promise, depSet);\n      }\n      return setAtomValue(atom, value, depSet);\n    } catch (error) {\n      return setAtomError(atom, error, depSet);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        const prevAtomState = getAtomState(dependent);\n        const nextAtomState = readAtomState(dependent);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(dependent);\n        }\n      }\n    });\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValue(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    flushPending();\n    return result;\n  };\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const onUnmount = atom.onMount((...args) => writeAtom(atom, ...args));\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          const mounted = mountedMap.get(atom);\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n          }\n        } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n    };\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change)\n      dev_subscribe_state: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, value] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValue(atom, value);\n            recomputeDependents(atom);\n          }\n        }\n        flushPending();\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}