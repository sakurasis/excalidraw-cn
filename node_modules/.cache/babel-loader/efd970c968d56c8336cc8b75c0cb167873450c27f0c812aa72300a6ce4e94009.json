{"ast":null,"code":"import { getElementAtPosition } from \"../scene\";\nimport { isBindableElement, isBindingElement, isLinearElement } from \"./typeChecks\";\nimport { bindingBorderTest, distanceToBindableElement, maxBindingGap, determineFocusDistance, intersectElementWithLine, determineFocusPoint } from \"./collision\";\nimport { mutateElement } from \"./mutateElement\";\nimport Scene from \"../scene/Scene\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { arrayToMap, tupleToCoors } from \"../utils\";\nimport { KEYS } from \"../keys\";\nimport { getBoundTextElement, handleBindTextResize } from \"./textElement\";\nexport const shouldEnableBindingForPointerEvent = event => {\n  return !event[KEYS.CTRL_OR_CMD];\n};\nexport const isBindingEnabled = appState => {\n  return appState.isBindingEnabled;\n};\nconst getNonDeletedElements = (scene, ids) => {\n  const result = [];\n  ids.forEach(id => {\n    const element = scene.getNonDeletedElement(id);\n    if (element != null) {\n      result.push(element);\n    }\n  });\n  return result;\n};\nexport const bindOrUnbindLinearElement = (linearElement, startBindingElement, endBindingElement) => {\n  const boundToElementIds = new Set();\n  const unboundFromElementIds = new Set();\n  bindOrUnbindLinearElementEdge(linearElement, startBindingElement, endBindingElement, \"start\", boundToElementIds, unboundFromElementIds);\n  bindOrUnbindLinearElementEdge(linearElement, endBindingElement, startBindingElement, \"end\", boundToElementIds, unboundFromElementIds);\n  const onlyUnbound = Array.from(unboundFromElementIds).filter(id => !boundToElementIds.has(id));\n  getNonDeletedElements(Scene.getScene(linearElement), onlyUnbound).forEach(element => {\n    var _element$boundElement;\n    mutateElement(element, {\n      boundElements: (_element$boundElement = element.boundElements) === null || _element$boundElement === void 0 ? void 0 : _element$boundElement.filter(element => element.type !== \"arrow\" || element.id !== linearElement.id)\n    });\n  });\n};\nconst bindOrUnbindLinearElementEdge = (linearElement, bindableElement, otherEdgeBindableElement, startOrEnd, boundToElementIds, unboundFromElementIds) => {\n  if (bindableElement !== \"keep\") {\n    if (bindableElement != null) {\n      // Don't bind if we're trying to bind or are already bound to the same\n      // element on the other edge already (\"start\" edge takes precedence).\n      if (otherEdgeBindableElement == null || (otherEdgeBindableElement === \"keep\" ? !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(linearElement, bindableElement, startOrEnd) : startOrEnd === \"start\" || otherEdgeBindableElement.id !== bindableElement.id)) {\n        bindLinearElement(linearElement, bindableElement, startOrEnd);\n        boundToElementIds.add(bindableElement.id);\n      }\n    } else {\n      const unbound = unbindLinearElement(linearElement, startOrEnd);\n      if (unbound != null) {\n        unboundFromElementIds.add(unbound);\n      }\n    }\n  }\n};\nexport const bindOrUnbindSelectedElements = elements => {\n  elements.forEach(element => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(element, getElligibleElementForBindingElement(element, \"start\"), getElligibleElementForBindingElement(element, \"end\"));\n    } else if (isBindableElement(element)) {\n      maybeBindBindableElement(element);\n    }\n  });\n};\nconst maybeBindBindableElement = bindableElement => {\n  getElligibleElementsForBindableElementAndWhere(bindableElement).forEach(_ref => {\n    let [linearElement, where] = _ref;\n    return bindOrUnbindLinearElement(linearElement, where === \"end\" ? \"keep\" : bindableElement, where === \"start\" ? \"keep\" : bindableElement);\n  });\n};\nexport const maybeBindLinearElement = (linearElement, appState, scene, pointerCoords) => {\n  if (appState.startBoundElement != null) {\n    bindLinearElement(linearElement, appState.startBoundElement, \"start\");\n  }\n  const hoveredElement = getHoveredElementForBinding(pointerCoords, scene);\n  if (hoveredElement != null && !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(linearElement, hoveredElement, \"end\")) {\n    bindLinearElement(linearElement, hoveredElement, \"end\");\n  }\n};\nconst bindLinearElement = (linearElement, hoveredElement, startOrEnd) => {\n  mutateElement(linearElement, {\n    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: {\n      elementId: hoveredElement.id,\n      ...calculateFocusAndGap(linearElement, hoveredElement, startOrEnd)\n    }\n  });\n  const boundElementsMap = arrayToMap(hoveredElement.boundElements || []);\n  if (!boundElementsMap.has(linearElement.id)) {\n    mutateElement(hoveredElement, {\n      boundElements: (hoveredElement.boundElements || []).concat({\n        id: linearElement.id,\n        type: \"arrow\"\n      })\n    });\n  }\n};\n\n// Don't bind both ends of a simple segment\nconst isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (linearElement, bindableElement, startOrEnd) => {\n  const otherBinding = linearElement[startOrEnd === \"start\" ? \"endBinding\" : \"startBinding\"];\n  return isLinearElementSimpleAndAlreadyBound(linearElement, otherBinding === null || otherBinding === void 0 ? void 0 : otherBinding.elementId, bindableElement);\n};\nexport const isLinearElementSimpleAndAlreadyBound = (linearElement, alreadyBoundToId, bindableElement) => {\n  return alreadyBoundToId === bindableElement.id && linearElement.points.length < 3;\n};\nexport const unbindLinearElements = elements => {\n  elements.forEach(element => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(element, null, null);\n    }\n  });\n};\nconst unbindLinearElement = (linearElement, startOrEnd) => {\n  const field = startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\";\n  const binding = linearElement[field];\n  if (binding == null) {\n    return null;\n  }\n  mutateElement(linearElement, {\n    [field]: null\n  });\n  return binding.elementId;\n};\nexport const getHoveredElementForBinding = (pointerCoords, scene) => {\n  const hoveredElement = getElementAtPosition(scene.getNonDeletedElements(), element => isBindableElement(element, false) && bindingBorderTest(element, pointerCoords));\n  return hoveredElement;\n};\nconst calculateFocusAndGap = (linearElement, hoveredElement, startOrEnd) => {\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, edgePointIndex);\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, adjacentPointIndex);\n  return {\n    focus: determineFocusDistance(hoveredElement, adjacentPoint, edgePoint),\n    gap: Math.max(1, distanceToBindableElement(hoveredElement, edgePoint))\n  };\n};\n\n// Supports translating, rotating and scaling `changedElement` with bound\n// linear elements.\n// Because scaling involves moving the focus points as well, it is\n// done before the `changedElement` is updated, and the `newSize` is passed\n// in explicitly.\nexport const updateBoundElements = (changedElement, options) => {\n  var _changedElement$bound;\n  const boundLinearElements = ((_changedElement$bound = changedElement.boundElements) !== null && _changedElement$bound !== void 0 ? _changedElement$bound : []).filter(el => el.type === \"arrow\");\n  if (boundLinearElements.length === 0) {\n    return;\n  }\n  const {\n    newSize,\n    simultaneouslyUpdated\n  } = options !== null && options !== void 0 ? options : {};\n  const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(simultaneouslyUpdated);\n  getNonDeletedElements(Scene.getScene(changedElement), boundLinearElements.map(el => el.id)).forEach(element => {\n    if (!isLinearElement(element)) {\n      return;\n    }\n    const bindableElement = changedElement;\n    // In case the boundElements are stale\n    if (!doesNeedUpdate(element, bindableElement)) {\n      return;\n    }\n    const startBinding = maybeCalculateNewGapWhenScaling(bindableElement, element.startBinding, newSize);\n    const endBinding = maybeCalculateNewGapWhenScaling(bindableElement, element.endBinding, newSize);\n    // `linearElement` is being moved/scaled already, just update the binding\n    if (simultaneouslyUpdatedElementIds.has(element.id)) {\n      mutateElement(element, {\n        startBinding,\n        endBinding\n      });\n      return;\n    }\n    updateBoundPoint(element, \"start\", startBinding, changedElement);\n    updateBoundPoint(element, \"end\", endBinding, changedElement);\n    const boundText = getBoundTextElement(element);\n    if (boundText) {\n      handleBindTextResize(element, false);\n    }\n  });\n};\nconst doesNeedUpdate = (boundElement, changedElement) => {\n  var _boundElement$startBi, _boundElement$endBind;\n  return ((_boundElement$startBi = boundElement.startBinding) === null || _boundElement$startBi === void 0 ? void 0 : _boundElement$startBi.elementId) === changedElement.id || ((_boundElement$endBind = boundElement.endBinding) === null || _boundElement$endBind === void 0 ? void 0 : _boundElement$endBind.elementId) === changedElement.id;\n};\nconst getSimultaneouslyUpdatedElementIds = simultaneouslyUpdated => {\n  return new Set((simultaneouslyUpdated || []).map(element => element.id));\n};\nconst updateBoundPoint = (linearElement, startOrEnd, binding, changedElement) => {\n  if (binding == null ||\n  // We only need to update the other end if this is a 2 point line element\n  binding.elementId !== changedElement.id && linearElement.points.length > 2) {\n    return;\n  }\n  const bindingElement = Scene.getScene(linearElement).getElement(binding.elementId);\n  if (bindingElement == null) {\n    // We're not cleaning up after deleted elements atm., so handle this case\n    return;\n  }\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, adjacentPointIndex);\n  const focusPointAbsolute = determineFocusPoint(bindingElement, binding.focus, adjacentPoint);\n  let newEdgePoint;\n  // The linear element was not originally pointing inside the bound shape,\n  // we can point directly at the focus point\n  if (binding.gap === 0) {\n    newEdgePoint = focusPointAbsolute;\n  } else {\n    const intersections = intersectElementWithLine(bindingElement, adjacentPoint, focusPointAbsolute, binding.gap);\n    if (intersections.length === 0) {\n      // This should never happen, since focusPoint should always be\n      // inside the element, but just in case, bail out\n      newEdgePoint = focusPointAbsolute;\n    } else {\n      // Guaranteed to intersect because focusPoint is always inside the shape\n      newEdgePoint = intersections[0];\n    }\n  }\n  LinearElementEditor.movePoints(linearElement, [{\n    index: edgePointIndex,\n    point: LinearElementEditor.pointFromAbsoluteCoords(linearElement, newEdgePoint)\n  }], {\n    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: binding\n  });\n};\nconst maybeCalculateNewGapWhenScaling = (changedElement, currentBinding, newSize) => {\n  if (currentBinding == null || newSize == null) {\n    return currentBinding;\n  }\n  const {\n    gap,\n    focus,\n    elementId\n  } = currentBinding;\n  const {\n    width: newWidth,\n    height: newHeight\n  } = newSize;\n  const {\n    width,\n    height\n  } = changedElement;\n  const newGap = Math.max(1, Math.min(maxBindingGap(changedElement, newWidth, newHeight), gap * (newWidth < newHeight ? newWidth / width : newHeight / height)));\n  return {\n    elementId,\n    gap: newGap,\n    focus\n  };\n};\nexport const getEligibleElementsForBinding = elements => {\n  const includedElementIds = new Set(elements.map(_ref2 => {\n    let {\n      id\n    } = _ref2;\n    return id;\n  }));\n  return elements.flatMap(element => isBindingElement(element, false) ? getElligibleElementsForBindingElement(element).filter(element => !includedElementIds.has(element.id)) : isBindableElement(element, false) ? getElligibleElementsForBindableElementAndWhere(element).filter(binding => !includedElementIds.has(binding[0].id)) : []);\n};\nconst getElligibleElementsForBindingElement = linearElement => {\n  return [getElligibleElementForBindingElement(linearElement, \"start\"), getElligibleElementForBindingElement(linearElement, \"end\")].filter(element => element != null);\n};\nconst getElligibleElementForBindingElement = (linearElement, startOrEnd) => {\n  return getHoveredElementForBinding(getLinearElementEdgeCoors(linearElement, startOrEnd), Scene.getScene(linearElement));\n};\nconst getLinearElementEdgeCoors = (linearElement, startOrEnd) => {\n  const index = startOrEnd === \"start\" ? 0 : -1;\n  return tupleToCoors(LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, index));\n};\nconst getElligibleElementsForBindableElementAndWhere = bindableElement => {\n  return Scene.getScene(bindableElement).getNonDeletedElements().map(element => {\n    if (!isBindingElement(element, false)) {\n      return null;\n    }\n    const canBindStart = isLinearElementEligibleForNewBindingByBindable(element, \"start\", bindableElement);\n    const canBindEnd = isLinearElementEligibleForNewBindingByBindable(element, \"end\", bindableElement);\n    if (!canBindStart && !canBindEnd) {\n      return null;\n    }\n    return [element, canBindStart && canBindEnd ? \"both\" : canBindStart ? \"start\" : \"end\", bindableElement];\n  }).filter(maybeElement => maybeElement != null);\n};\nconst isLinearElementEligibleForNewBindingByBindable = (linearElement, startOrEnd, bindableElement) => {\n  const existingBinding = linearElement[startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"];\n  return existingBinding == null && !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(linearElement, bindableElement, startOrEnd) && bindingBorderTest(bindableElement, getLinearElementEdgeCoors(linearElement, startOrEnd));\n};\n\n// We need to:\n// 1: Update elements not selected to point to duplicated elements\n// 2: Update duplicated elements to point to other duplicated elements\nexport const fixBindingsAfterDuplication = (sceneElements, oldElements, oldIdToDuplicatedId, duplicatesServeAsOld) => {\n  // First collect all the binding/bindable elements, so we only update\n  // each once, regardless of whether they were duplicated or not.\n  const allBoundElementIds = new Set();\n  const allBindableElementIds = new Set();\n  const shouldReverseRoles = duplicatesServeAsOld === \"duplicatesServeAsOld\";\n  oldElements.forEach(oldElement => {\n    const {\n      boundElements\n    } = oldElement;\n    if (boundElements != null && boundElements.length > 0) {\n      boundElements.forEach(boundElement => {\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(boundElement.id)) {\n          allBoundElementIds.add(boundElement.id);\n        }\n      });\n      allBindableElementIds.add(oldIdToDuplicatedId.get(oldElement.id));\n    }\n    if (isBindingElement(oldElement)) {\n      if (oldElement.startBinding != null) {\n        const {\n          elementId\n        } = oldElement.startBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.endBinding != null) {\n        const {\n          elementId\n        } = oldElement.endBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.startBinding != null || oldElement.endBinding != null) {\n        allBoundElementIds.add(oldIdToDuplicatedId.get(oldElement.id));\n      }\n    }\n  });\n\n  // Update the linear elements\n  sceneElements.filter(_ref3 => {\n    let {\n      id\n    } = _ref3;\n    return allBoundElementIds.has(id);\n  }).forEach(element => {\n    const {\n      startBinding,\n      endBinding\n    } = element;\n    mutateElement(element, {\n      startBinding: newBindingAfterDuplication(startBinding, oldIdToDuplicatedId),\n      endBinding: newBindingAfterDuplication(endBinding, oldIdToDuplicatedId)\n    });\n  });\n\n  // Update the bindable shapes\n  sceneElements.filter(_ref4 => {\n    let {\n      id\n    } = _ref4;\n    return allBindableElementIds.has(id);\n  }).forEach(bindableElement => {\n    const {\n      boundElements\n    } = bindableElement;\n    if (boundElements != null && boundElements.length > 0) {\n      mutateElement(bindableElement, {\n        boundElements: boundElements.map(boundElement => oldIdToDuplicatedId.has(boundElement.id) ? {\n          id: oldIdToDuplicatedId.get(boundElement.id),\n          type: boundElement.type\n        } : boundElement)\n      });\n    }\n  });\n};\nconst newBindingAfterDuplication = (binding, oldIdToDuplicatedId) => {\n  var _oldIdToDuplicatedId$;\n  if (binding == null) {\n    return null;\n  }\n  const {\n    elementId,\n    focus,\n    gap\n  } = binding;\n  return {\n    focus,\n    gap,\n    elementId: (_oldIdToDuplicatedId$ = oldIdToDuplicatedId.get(elementId)) !== null && _oldIdToDuplicatedId$ !== void 0 ? _oldIdToDuplicatedId$ : elementId\n  };\n};\nexport const fixBindingsAfterDeletion = (sceneElements, deletedElements) => {\n  const deletedElementIds = new Set(deletedElements.map(element => element.id));\n  // non-deleted which bindings need to be updated\n  const affectedElements = new Set();\n  deletedElements.forEach(deletedElement => {\n    if (isBindableElement(deletedElement)) {\n      var _deletedElement$bound;\n      (_deletedElement$bound = deletedElement.boundElements) === null || _deletedElement$bound === void 0 ? void 0 : _deletedElement$bound.forEach(element => {\n        if (!deletedElementIds.has(element.id)) {\n          affectedElements.add(element.id);\n        }\n      });\n    } else if (isBindingElement(deletedElement)) {\n      if (deletedElement.startBinding) {\n        affectedElements.add(deletedElement.startBinding.elementId);\n      }\n      if (deletedElement.endBinding) {\n        affectedElements.add(deletedElement.endBinding.elementId);\n      }\n    }\n  });\n  sceneElements.filter(_ref5 => {\n    let {\n      id\n    } = _ref5;\n    return affectedElements.has(id);\n  }).forEach(element => {\n    if (isBindableElement(element)) {\n      mutateElement(element, {\n        boundElements: newBoundElementsAfterDeletion(element.boundElements, deletedElementIds)\n      });\n    } else if (isBindingElement(element)) {\n      mutateElement(element, {\n        startBinding: newBindingAfterDeletion(element.startBinding, deletedElementIds),\n        endBinding: newBindingAfterDeletion(element.endBinding, deletedElementIds)\n      });\n    }\n  });\n};\nconst newBindingAfterDeletion = (binding, deletedElementIds) => {\n  if (binding == null || deletedElementIds.has(binding.elementId)) {\n    return null;\n  }\n  return binding;\n};\nconst newBoundElementsAfterDeletion = (boundElements, deletedElementIds) => {\n  if (!boundElements) {\n    return null;\n  }\n  return boundElements.filter(ele => !deletedElementIds.has(ele.id));\n};","map":{"version":3,"names":["getElementAtPosition","isBindableElement","isBindingElement","isLinearElement","bindingBorderTest","distanceToBindableElement","maxBindingGap","determineFocusDistance","intersectElementWithLine","determineFocusPoint","mutateElement","Scene","LinearElementEditor","arrayToMap","tupleToCoors","KEYS","getBoundTextElement","handleBindTextResize","shouldEnableBindingForPointerEvent","event","CTRL_OR_CMD","isBindingEnabled","appState","getNonDeletedElements","scene","ids","result","forEach","id","element","getNonDeletedElement","push","bindOrUnbindLinearElement","linearElement","startBindingElement","endBindingElement","boundToElementIds","Set","unboundFromElementIds","bindOrUnbindLinearElementEdge","onlyUnbound","Array","from","filter","has","getScene","_element$boundElement","boundElements","type","bindableElement","otherEdgeBindableElement","startOrEnd","isLinearElementSimpleAndAlreadyBoundOnOppositeEdge","bindLinearElement","add","unbound","unbindLinearElement","bindOrUnbindSelectedElements","elements","getElligibleElementForBindingElement","maybeBindBindableElement","getElligibleElementsForBindableElementAndWhere","_ref","where","maybeBindLinearElement","pointerCoords","startBoundElement","hoveredElement","getHoveredElementForBinding","elementId","calculateFocusAndGap","boundElementsMap","concat","otherBinding","isLinearElementSimpleAndAlreadyBound","alreadyBoundToId","points","length","unbindLinearElements","field","binding","direction","edgePointIndex","adjacentPointIndex","edgePoint","getPointAtIndexGlobalCoordinates","adjacentPoint","focus","gap","Math","max","updateBoundElements","changedElement","options","_changedElement$bound","boundLinearElements","el","newSize","simultaneouslyUpdated","simultaneouslyUpdatedElementIds","getSimultaneouslyUpdatedElementIds","map","doesNeedUpdate","startBinding","maybeCalculateNewGapWhenScaling","endBinding","updateBoundPoint","boundText","boundElement","_boundElement$startBi","_boundElement$endBind","bindingElement","getElement","focusPointAbsolute","newEdgePoint","intersections","movePoints","index","point","pointFromAbsoluteCoords","currentBinding","width","newWidth","height","newHeight","newGap","min","getEligibleElementsForBinding","includedElementIds","_ref2","flatMap","getElligibleElementsForBindingElement","getLinearElementEdgeCoors","canBindStart","isLinearElementEligibleForNewBindingByBindable","canBindEnd","maybeElement","existingBinding","fixBindingsAfterDuplication","sceneElements","oldElements","oldIdToDuplicatedId","duplicatesServeAsOld","allBoundElementIds","allBindableElementIds","shouldReverseRoles","oldElement","get","_ref3","newBindingAfterDuplication","_ref4","_oldIdToDuplicatedId$","fixBindingsAfterDeletion","deletedElements","deletedElementIds","affectedElements","deletedElement","_deletedElement$bound","_ref5","newBoundElementsAfterDeletion","newBindingAfterDeletion","ele"],"sources":["D:/project/excalidraw-cn/src/element/binding.ts"],"sourcesContent":["import {\n  ExcalidrawLinearElement,\n  ExcalidrawBindableElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n  PointBinding,\n  ExcalidrawElement,\n} from \"./types\";\nimport { getElementAtPosition } from \"../scene\";\nimport { AppState } from \"../types\";\nimport {\n  isBindableElement,\n  isBindingElement,\n  isLinearElement,\n} from \"./typeChecks\";\nimport {\n  bindingBorderTest,\n  distanceToBindableElement,\n  maxBindingGap,\n  determineFocusDistance,\n  intersectElementWithLine,\n  determineFocusPoint,\n} from \"./collision\";\nimport { mutateElement } from \"./mutateElement\";\nimport Scene from \"../scene/Scene\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { arrayToMap, tupleToCoors } from \"../utils\";\nimport { KEYS } from \"../keys\";\nimport { getBoundTextElement, handleBindTextResize } from \"./textElement\";\n\nexport type SuggestedBinding =\n  | NonDeleted<ExcalidrawBindableElement>\n  | SuggestedPointBinding;\n\nexport type SuggestedPointBinding = [\n  NonDeleted<ExcalidrawLinearElement>,\n  \"start\" | \"end\" | \"both\",\n  NonDeleted<ExcalidrawBindableElement>,\n];\n\nexport const shouldEnableBindingForPointerEvent = (\n  event: React.PointerEvent<HTMLElement>,\n) => {\n  return !event[KEYS.CTRL_OR_CMD];\n};\n\nexport const isBindingEnabled = (appState: AppState): boolean => {\n  return appState.isBindingEnabled;\n};\n\nconst getNonDeletedElements = (\n  scene: Scene,\n  ids: readonly ExcalidrawElement[\"id\"][],\n): NonDeleted<ExcalidrawElement>[] => {\n  const result: NonDeleted<ExcalidrawElement>[] = [];\n  ids.forEach((id) => {\n    const element = scene.getNonDeletedElement(id);\n    if (element != null) {\n      result.push(element);\n    }\n  });\n  return result;\n};\n\nexport const bindOrUnbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startBindingElement: ExcalidrawBindableElement | null | \"keep\",\n  endBindingElement: ExcalidrawBindableElement | null | \"keep\",\n): void => {\n  const boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  const unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    startBindingElement,\n    endBindingElement,\n    \"start\",\n    boundToElementIds,\n    unboundFromElementIds,\n  );\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    endBindingElement,\n    startBindingElement,\n    \"end\",\n    boundToElementIds,\n    unboundFromElementIds,\n  );\n\n  const onlyUnbound = Array.from(unboundFromElementIds).filter(\n    (id) => !boundToElementIds.has(id),\n  );\n\n  getNonDeletedElements(Scene.getScene(linearElement)!, onlyUnbound).forEach(\n    (element) => {\n      mutateElement(element, {\n        boundElements: element.boundElements?.filter(\n          (element) =>\n            element.type !== \"arrow\" || element.id !== linearElement.id,\n        ),\n      });\n    },\n  );\n};\n\nconst bindOrUnbindLinearElementEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement | null | \"keep\",\n  otherEdgeBindableElement: ExcalidrawBindableElement | null | \"keep\",\n  startOrEnd: \"start\" | \"end\",\n  // Is mutated\n  boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n  // Is mutated\n  unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n): void => {\n  if (bindableElement !== \"keep\") {\n    if (bindableElement != null) {\n      // Don't bind if we're trying to bind or are already bound to the same\n      // element on the other edge already (\"start\" edge takes precedence).\n      if (\n        otherEdgeBindableElement == null ||\n        (otherEdgeBindableElement === \"keep\"\n          ? !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n              linearElement,\n              bindableElement,\n              startOrEnd,\n            )\n          : startOrEnd === \"start\" ||\n            otherEdgeBindableElement.id !== bindableElement.id)\n      ) {\n        bindLinearElement(linearElement, bindableElement, startOrEnd);\n        boundToElementIds.add(bindableElement.id);\n      }\n    } else {\n      const unbound = unbindLinearElement(linearElement, startOrEnd);\n      if (unbound != null) {\n        unboundFromElementIds.add(unbound);\n      }\n    }\n  }\n};\n\nexport const bindOrUnbindSelectedElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): void => {\n  elements.forEach((element) => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(\n        element,\n        getElligibleElementForBindingElement(element, \"start\"),\n        getElligibleElementForBindingElement(element, \"end\"),\n      );\n    } else if (isBindableElement(element)) {\n      maybeBindBindableElement(element);\n    }\n  });\n};\n\nconst maybeBindBindableElement = (\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): void => {\n  getElligibleElementsForBindableElementAndWhere(bindableElement).forEach(\n    ([linearElement, where]) =>\n      bindOrUnbindLinearElement(\n        linearElement,\n        where === \"end\" ? \"keep\" : bindableElement,\n        where === \"start\" ? \"keep\" : bindableElement,\n      ),\n  );\n};\n\nexport const maybeBindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  appState: AppState,\n  scene: Scene,\n  pointerCoords: { x: number; y: number },\n): void => {\n  if (appState.startBoundElement != null) {\n    bindLinearElement(linearElement, appState.startBoundElement, \"start\");\n  }\n  const hoveredElement = getHoveredElementForBinding(pointerCoords, scene);\n  if (\n    hoveredElement != null &&\n    !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n      linearElement,\n      hoveredElement,\n      \"end\",\n    )\n  ) {\n    bindLinearElement(linearElement, hoveredElement, \"end\");\n  }\n};\n\nconst bindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): void => {\n  mutateElement(linearElement, {\n    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: {\n      elementId: hoveredElement.id,\n      ...calculateFocusAndGap(linearElement, hoveredElement, startOrEnd),\n    } as PointBinding,\n  });\n\n  const boundElementsMap = arrayToMap(hoveredElement.boundElements || []);\n  if (!boundElementsMap.has(linearElement.id)) {\n    mutateElement(hoveredElement, {\n      boundElements: (hoveredElement.boundElements || []).concat({\n        id: linearElement.id,\n        type: \"arrow\",\n      }),\n    });\n  }\n};\n\n// Don't bind both ends of a simple segment\nconst isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): boolean => {\n  const otherBinding =\n    linearElement[startOrEnd === \"start\" ? \"endBinding\" : \"startBinding\"];\n  return isLinearElementSimpleAndAlreadyBound(\n    linearElement,\n    otherBinding?.elementId,\n    bindableElement,\n  );\n};\n\nexport const isLinearElementSimpleAndAlreadyBound = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  alreadyBoundToId: ExcalidrawBindableElement[\"id\"] | undefined,\n  bindableElement: ExcalidrawBindableElement,\n): boolean => {\n  return (\n    alreadyBoundToId === bindableElement.id && linearElement.points.length < 3\n  );\n};\n\nexport const unbindLinearElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): void => {\n  elements.forEach((element) => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(element, null, null);\n    }\n  });\n};\n\nconst unbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): ExcalidrawBindableElement[\"id\"] | null => {\n  const field = startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\";\n  const binding = linearElement[field];\n  if (binding == null) {\n    return null;\n  }\n  mutateElement(linearElement, { [field]: null });\n  return binding.elementId;\n};\n\nexport const getHoveredElementForBinding = (\n  pointerCoords: {\n    x: number;\n    y: number;\n  },\n  scene: Scene,\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  const hoveredElement = getElementAtPosition(\n    scene.getNonDeletedElements(),\n    (element) =>\n      isBindableElement(element, false) &&\n      bindingBorderTest(element, pointerCoords),\n  );\n  return hoveredElement as NonDeleted<ExcalidrawBindableElement> | null;\n};\n\nconst calculateFocusAndGap = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): { focus: number; gap: number } => {\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    edgePointIndex,\n  );\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n  );\n  return {\n    focus: determineFocusDistance(hoveredElement, adjacentPoint, edgePoint),\n    gap: Math.max(1, distanceToBindableElement(hoveredElement, edgePoint)),\n  };\n};\n\n// Supports translating, rotating and scaling `changedElement` with bound\n// linear elements.\n// Because scaling involves moving the focus points as well, it is\n// done before the `changedElement` is updated, and the `newSize` is passed\n// in explicitly.\nexport const updateBoundElements = (\n  changedElement: NonDeletedExcalidrawElement,\n  options?: {\n    simultaneouslyUpdated?: readonly ExcalidrawElement[];\n    newSize?: { width: number; height: number };\n  },\n) => {\n  const boundLinearElements = (changedElement.boundElements ?? []).filter(\n    (el) => el.type === \"arrow\",\n  );\n  if (boundLinearElements.length === 0) {\n    return;\n  }\n  const { newSize, simultaneouslyUpdated } = options ?? {};\n  const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(\n    simultaneouslyUpdated,\n  );\n\n  getNonDeletedElements(\n    Scene.getScene(changedElement)!,\n    boundLinearElements.map((el) => el.id),\n  ).forEach((element) => {\n    if (!isLinearElement(element)) {\n      return;\n    }\n\n    const bindableElement = changedElement as ExcalidrawBindableElement;\n    // In case the boundElements are stale\n    if (!doesNeedUpdate(element, bindableElement)) {\n      return;\n    }\n    const startBinding = maybeCalculateNewGapWhenScaling(\n      bindableElement,\n      element.startBinding,\n      newSize,\n    );\n    const endBinding = maybeCalculateNewGapWhenScaling(\n      bindableElement,\n      element.endBinding,\n      newSize,\n    );\n    // `linearElement` is being moved/scaled already, just update the binding\n    if (simultaneouslyUpdatedElementIds.has(element.id)) {\n      mutateElement(element, { startBinding, endBinding });\n      return;\n    }\n    updateBoundPoint(\n      element,\n      \"start\",\n      startBinding,\n      changedElement as ExcalidrawBindableElement,\n    );\n    updateBoundPoint(\n      element,\n      \"end\",\n      endBinding,\n      changedElement as ExcalidrawBindableElement,\n    );\n    const boundText = getBoundTextElement(element);\n    if (boundText) {\n      handleBindTextResize(element, false);\n    }\n  });\n};\n\nconst doesNeedUpdate = (\n  boundElement: NonDeleted<ExcalidrawLinearElement>,\n  changedElement: ExcalidrawBindableElement,\n) => {\n  return (\n    boundElement.startBinding?.elementId === changedElement.id ||\n    boundElement.endBinding?.elementId === changedElement.id\n  );\n};\n\nconst getSimultaneouslyUpdatedElementIds = (\n  simultaneouslyUpdated: readonly ExcalidrawElement[] | undefined,\n): Set<ExcalidrawElement[\"id\"]> => {\n  return new Set((simultaneouslyUpdated || []).map((element) => element.id));\n};\n\nconst updateBoundPoint = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  binding: PointBinding | null | undefined,\n  changedElement: ExcalidrawBindableElement,\n): void => {\n  if (\n    binding == null ||\n    // We only need to update the other end if this is a 2 point line element\n    (binding.elementId !== changedElement.id && linearElement.points.length > 2)\n  ) {\n    return;\n  }\n  const bindingElement = Scene.getScene(linearElement)!.getElement(\n    binding.elementId,\n  ) as ExcalidrawBindableElement | null;\n  if (bindingElement == null) {\n    // We're not cleaning up after deleted elements atm., so handle this case\n    return;\n  }\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n  );\n  const focusPointAbsolute = determineFocusPoint(\n    bindingElement,\n    binding.focus,\n    adjacentPoint,\n  );\n  let newEdgePoint;\n  // The linear element was not originally pointing inside the bound shape,\n  // we can point directly at the focus point\n  if (binding.gap === 0) {\n    newEdgePoint = focusPointAbsolute;\n  } else {\n    const intersections = intersectElementWithLine(\n      bindingElement,\n      adjacentPoint,\n      focusPointAbsolute,\n      binding.gap,\n    );\n    if (intersections.length === 0) {\n      // This should never happen, since focusPoint should always be\n      // inside the element, but just in case, bail out\n      newEdgePoint = focusPointAbsolute;\n    } else {\n      // Guaranteed to intersect because focusPoint is always inside the shape\n      newEdgePoint = intersections[0];\n    }\n  }\n  LinearElementEditor.movePoints(\n    linearElement,\n    [\n      {\n        index: edgePointIndex,\n        point: LinearElementEditor.pointFromAbsoluteCoords(\n          linearElement,\n          newEdgePoint,\n        ),\n      },\n    ],\n    { [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: binding },\n  );\n};\n\nconst maybeCalculateNewGapWhenScaling = (\n  changedElement: ExcalidrawBindableElement,\n  currentBinding: PointBinding | null | undefined,\n  newSize: { width: number; height: number } | undefined,\n): PointBinding | null | undefined => {\n  if (currentBinding == null || newSize == null) {\n    return currentBinding;\n  }\n  const { gap, focus, elementId } = currentBinding;\n  const { width: newWidth, height: newHeight } = newSize;\n  const { width, height } = changedElement;\n  const newGap = Math.max(\n    1,\n    Math.min(\n      maxBindingGap(changedElement, newWidth, newHeight),\n      gap * (newWidth < newHeight ? newWidth / width : newHeight / height),\n    ),\n  );\n  return { elementId, gap: newGap, focus };\n};\n\nexport const getEligibleElementsForBinding = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): SuggestedBinding[] => {\n  const includedElementIds = new Set(elements.map(({ id }) => id));\n  return elements.flatMap((element) =>\n    isBindingElement(element, false)\n      ? (getElligibleElementsForBindingElement(\n          element as NonDeleted<ExcalidrawLinearElement>,\n        ).filter(\n          (element) => !includedElementIds.has(element.id),\n        ) as SuggestedBinding[])\n      : isBindableElement(element, false)\n      ? getElligibleElementsForBindableElementAndWhere(element).filter(\n          (binding) => !includedElementIds.has(binding[0].id),\n        )\n      : [],\n  );\n};\n\nconst getElligibleElementsForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n): NonDeleted<ExcalidrawBindableElement>[] => {\n  return [\n    getElligibleElementForBindingElement(linearElement, \"start\"),\n    getElligibleElementForBindingElement(linearElement, \"end\"),\n  ].filter(\n    (element): element is NonDeleted<ExcalidrawBindableElement> =>\n      element != null,\n  );\n};\n\nconst getElligibleElementForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  return getHoveredElementForBinding(\n    getLinearElementEdgeCoors(linearElement, startOrEnd),\n    Scene.getScene(linearElement)!,\n  );\n};\n\nconst getLinearElementEdgeCoors = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): { x: number; y: number } => {\n  const index = startOrEnd === \"start\" ? 0 : -1;\n  return tupleToCoors(\n    LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, index),\n  );\n};\n\nconst getElligibleElementsForBindableElementAndWhere = (\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): SuggestedPointBinding[] => {\n  return Scene.getScene(bindableElement)!\n    .getNonDeletedElements()\n    .map((element) => {\n      if (!isBindingElement(element, false)) {\n        return null;\n      }\n      const canBindStart = isLinearElementEligibleForNewBindingByBindable(\n        element,\n        \"start\",\n        bindableElement,\n      );\n      const canBindEnd = isLinearElementEligibleForNewBindingByBindable(\n        element,\n        \"end\",\n        bindableElement,\n      );\n      if (!canBindStart && !canBindEnd) {\n        return null;\n      }\n      return [\n        element,\n        canBindStart && canBindEnd ? \"both\" : canBindStart ? \"start\" : \"end\",\n        bindableElement,\n      ];\n    })\n    .filter((maybeElement) => maybeElement != null) as SuggestedPointBinding[];\n};\n\nconst isLinearElementEligibleForNewBindingByBindable = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): boolean => {\n  const existingBinding =\n    linearElement[startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"];\n  return (\n    existingBinding == null &&\n    !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n      linearElement,\n      bindableElement,\n      startOrEnd,\n    ) &&\n    bindingBorderTest(\n      bindableElement,\n      getLinearElementEdgeCoors(linearElement, startOrEnd),\n    )\n  );\n};\n\n// We need to:\n// 1: Update elements not selected to point to duplicated elements\n// 2: Update duplicated elements to point to other duplicated elements\nexport const fixBindingsAfterDuplication = (\n  sceneElements: readonly ExcalidrawElement[],\n  oldElements: readonly ExcalidrawElement[],\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n  // There are three copying mechanisms: Copy-paste, duplication and alt-drag.\n  // Only when alt-dragging the new \"duplicates\" act as the \"old\", while\n  // the \"old\" elements act as the \"new copy\" - essentially working reverse\n  // to the other two.\n  duplicatesServeAsOld?: \"duplicatesServeAsOld\" | undefined,\n): void => {\n  // First collect all the binding/bindable elements, so we only update\n  // each once, regardless of whether they were duplicated or not.\n  const allBoundElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  const allBindableElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  const shouldReverseRoles = duplicatesServeAsOld === \"duplicatesServeAsOld\";\n  oldElements.forEach((oldElement) => {\n    const { boundElements } = oldElement;\n    if (boundElements != null && boundElements.length > 0) {\n      boundElements.forEach((boundElement) => {\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(boundElement.id)) {\n          allBoundElementIds.add(boundElement.id);\n        }\n      });\n      allBindableElementIds.add(oldIdToDuplicatedId.get(oldElement.id)!);\n    }\n    if (isBindingElement(oldElement)) {\n      if (oldElement.startBinding != null) {\n        const { elementId } = oldElement.startBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.endBinding != null) {\n        const { elementId } = oldElement.endBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.startBinding != null || oldElement.endBinding != null) {\n        allBoundElementIds.add(oldIdToDuplicatedId.get(oldElement.id)!);\n      }\n    }\n  });\n\n  // Update the linear elements\n  (\n    sceneElements.filter(({ id }) =>\n      allBoundElementIds.has(id),\n    ) as ExcalidrawLinearElement[]\n  ).forEach((element) => {\n    const { startBinding, endBinding } = element;\n    mutateElement(element, {\n      startBinding: newBindingAfterDuplication(\n        startBinding,\n        oldIdToDuplicatedId,\n      ),\n      endBinding: newBindingAfterDuplication(endBinding, oldIdToDuplicatedId),\n    });\n  });\n\n  // Update the bindable shapes\n  sceneElements\n    .filter(({ id }) => allBindableElementIds.has(id))\n    .forEach((bindableElement) => {\n      const { boundElements } = bindableElement;\n      if (boundElements != null && boundElements.length > 0) {\n        mutateElement(bindableElement, {\n          boundElements: boundElements.map((boundElement) =>\n            oldIdToDuplicatedId.has(boundElement.id)\n              ? {\n                  id: oldIdToDuplicatedId.get(boundElement.id)!,\n                  type: boundElement.type,\n                }\n              : boundElement,\n          ),\n        });\n      }\n    });\n};\n\nconst newBindingAfterDuplication = (\n  binding: PointBinding | null,\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n): PointBinding | null => {\n  if (binding == null) {\n    return null;\n  }\n  const { elementId, focus, gap } = binding;\n  return {\n    focus,\n    gap,\n    elementId: oldIdToDuplicatedId.get(elementId) ?? elementId,\n  };\n};\n\nexport const fixBindingsAfterDeletion = (\n  sceneElements: readonly ExcalidrawElement[],\n  deletedElements: readonly ExcalidrawElement[],\n): void => {\n  const deletedElementIds = new Set(\n    deletedElements.map((element) => element.id),\n  );\n  // non-deleted which bindings need to be updated\n  const affectedElements: Set<ExcalidrawElement[\"id\"]> = new Set();\n  deletedElements.forEach((deletedElement) => {\n    if (isBindableElement(deletedElement)) {\n      deletedElement.boundElements?.forEach((element) => {\n        if (!deletedElementIds.has(element.id)) {\n          affectedElements.add(element.id);\n        }\n      });\n    } else if (isBindingElement(deletedElement)) {\n      if (deletedElement.startBinding) {\n        affectedElements.add(deletedElement.startBinding.elementId);\n      }\n      if (deletedElement.endBinding) {\n        affectedElements.add(deletedElement.endBinding.elementId);\n      }\n    }\n  });\n  sceneElements\n    .filter(({ id }) => affectedElements.has(id))\n    .forEach((element) => {\n      if (isBindableElement(element)) {\n        mutateElement(element, {\n          boundElements: newBoundElementsAfterDeletion(\n            element.boundElements,\n            deletedElementIds,\n          ),\n        });\n      } else if (isBindingElement(element)) {\n        mutateElement(element, {\n          startBinding: newBindingAfterDeletion(\n            element.startBinding,\n            deletedElementIds,\n          ),\n          endBinding: newBindingAfterDeletion(\n            element.endBinding,\n            deletedElementIds,\n          ),\n        });\n      }\n    });\n};\n\nconst newBindingAfterDeletion = (\n  binding: PointBinding | null,\n  deletedElementIds: Set<ExcalidrawElement[\"id\"]>,\n): PointBinding | null => {\n  if (binding == null || deletedElementIds.has(binding.elementId)) {\n    return null;\n  }\n  return binding;\n};\n\nconst newBoundElementsAfterDeletion = (\n  boundElements: ExcalidrawElement[\"boundElements\"],\n  deletedElementIds: Set<ExcalidrawElement[\"id\"]>,\n) => {\n  if (!boundElements) {\n    return null;\n  }\n  return boundElements.filter((ele) => !deletedElementIds.has(ele.id));\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}