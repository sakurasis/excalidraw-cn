{"ast":null,"code":"import { loadLibraryFromBlob } from \"./blob\";\nimport { restoreLibraryItems } from \"./restore\";\nimport { atom } from \"jotai\";\nimport { jotaiStore } from \"../jotai\";\nimport { getCommonBoundingBox } from \"../element/bounds\";\nimport { AbortError } from \"../errors\";\nimport { t } from \"../i18n\";\nimport { useEffect, useRef } from \"react\";\nimport { URL_HASH_KEYS, URL_QUERY_KEYS, APP_NAME, EVENT, DEFAULT_SIDEBAR, LIBRARY_SIDEBAR_TAB } from \"../constants\";\nimport { libraryItemSvgsCache } from \"../hooks/useLibraryItemSvg\";\nexport const libraryItemsAtom = atom({\n  status: \"loaded\",\n  isInitialized: true,\n  libraryItems: []\n});\nconst cloneLibraryItems = libraryItems => JSON.parse(JSON.stringify(libraryItems));\n\n/**\n * checks if library item does not exist already in current library\n */\nconst isUniqueItem = (existingLibraryItems, targetLibraryItem) => {\n  return !existingLibraryItems.find(libraryItem => {\n    if (libraryItem.elements.length !== targetLibraryItem.elements.length) {\n      return false;\n    }\n\n    // detect z-index difference by checking the excalidraw elements\n    // are in order\n    return libraryItem.elements.every((libItemExcalidrawItem, idx) => {\n      return libItemExcalidrawItem.id === targetLibraryItem.elements[idx].id && libItemExcalidrawItem.versionNonce === targetLibraryItem.elements[idx].versionNonce;\n    });\n  });\n};\n\n/** Merges otherItems into localItems. Unique items in otherItems array are\n    sorted first. */\nexport const mergeLibraryItems = (localItems, otherItems) => {\n  const newItems = [];\n  for (const item of otherItems) {\n    if (isUniqueItem(localItems, item)) {\n      newItems.push(item);\n    }\n  }\n  return [...newItems, ...localItems];\n};\nclass Library {\n  constructor(app) {\n    /** latest libraryItems */\n    this.lastLibraryItems = [];\n    /** indicates whether library is initialized with library items (has gone\n     * though at least one update) */\n    this.isInitialized = false;\n    this.app = void 0;\n    this.updateQueue = [];\n    this.getLastUpdateTask = () => {\n      return this.updateQueue[this.updateQueue.length - 1];\n    };\n    this.notifyListeners = () => {\n      if (this.updateQueue.length > 0) {\n        jotaiStore.set(libraryItemsAtom, {\n          status: \"loading\",\n          libraryItems: this.lastLibraryItems,\n          isInitialized: this.isInitialized\n        });\n      } else {\n        this.isInitialized = true;\n        jotaiStore.set(libraryItemsAtom, {\n          status: \"loaded\",\n          libraryItems: this.lastLibraryItems,\n          isInitialized: this.isInitialized\n        });\n        try {\n          var _this$app$props$onLib, _this$app$props;\n          (_this$app$props$onLib = (_this$app$props = this.app.props).onLibraryChange) === null || _this$app$props$onLib === void 0 ? void 0 : _this$app$props$onLib.call(_this$app$props, cloneLibraryItems(this.lastLibraryItems));\n        } catch (error) {\n          console.error(error);\n        }\n      }\n    };\n    /** call on excalidraw instance unmount */\n    this.destroy = () => {\n      this.isInitialized = false;\n      this.updateQueue = [];\n      this.lastLibraryItems = [];\n      jotaiStore.set(libraryItemSvgsCache, new Map());\n      // TODO uncomment after/if we make jotai store scoped to each excal instance\n      // jotaiStore.set(libraryItemsAtom, {\n      //   status: \"loading\",\n      //   isInitialized: false,\n      //   libraryItems: [],\n      // });\n    };\n    this.resetLibrary = () => {\n      return this.setLibrary([]);\n    };\n    /**\n     * @returns latest cloned libraryItems. Awaits all in-progress updates first.\n     */\n    this.getLatestLibrary = () => {\n      return new Promise(async resolve => {\n        try {\n          const libraryItems = await (this.getLastUpdateTask() || this.lastLibraryItems);\n          if (this.updateQueue.length > 0) {\n            resolve(this.getLatestLibrary());\n          } else {\n            resolve(cloneLibraryItems(libraryItems));\n          }\n        } catch (error) {\n          return resolve(this.lastLibraryItems);\n        }\n      });\n    };\n    // NOTE this is a high-level public API (exposed on ExcalidrawAPI) with\n    // a slight overhead (always restoring library items). For internal use\n    // where merging isn't needed, use `library.setLibrary()` directly.\n    this.updateLibrary = async _ref => {\n      let {\n        libraryItems,\n        prompt = false,\n        merge = false,\n        openLibraryMenu = false,\n        defaultStatus = \"unpublished\"\n      } = _ref;\n      if (openLibraryMenu) {\n        this.app.setState({\n          openSidebar: {\n            name: DEFAULT_SIDEBAR.name,\n            tab: LIBRARY_SIDEBAR_TAB\n          }\n        });\n      }\n      return this.setLibrary(() => {\n        return new Promise(async (resolve, reject) => {\n          try {\n            const source = await (typeof libraryItems === \"function\" && !(libraryItems instanceof Blob) ? libraryItems(this.lastLibraryItems) : libraryItems);\n            let nextItems;\n            if (source instanceof Blob) {\n              nextItems = await loadLibraryFromBlob(source, defaultStatus);\n            } else {\n              nextItems = restoreLibraryItems(source, defaultStatus);\n            }\n            if (!prompt || window.confirm(t(\"alerts.confirmAddLibrary\", {\n              numShapes: nextItems.length\n            }))) {\n              if (prompt) {\n                // focus container if we've prompted. We focus conditionally\n                // lest `props.autoFocus` is disabled (in which case we should\n                // focus only on user action such as prompt confirm)\n                this.app.focusContainer();\n              }\n              if (merge) {\n                resolve(mergeLibraryItems(this.lastLibraryItems, nextItems));\n              } else {\n                resolve(nextItems);\n              }\n            } else {\n              reject(new AbortError());\n            }\n          } catch (error) {\n            reject(error);\n          }\n        });\n      });\n    };\n    this.setLibrary = libraryItems => {\n      const task = new Promise(async (resolve, reject) => {\n        try {\n          await this.getLastUpdateTask();\n          if (typeof libraryItems === \"function\") {\n            libraryItems = libraryItems(this.lastLibraryItems);\n          }\n          this.lastLibraryItems = cloneLibraryItems(await libraryItems);\n          resolve(this.lastLibraryItems);\n        } catch (error) {\n          reject(error);\n        }\n      }).catch(error => {\n        if (error.name === \"AbortError\") {\n          console.warn(\"Library update aborted by user\");\n          return this.lastLibraryItems;\n        }\n        throw error;\n      }).finally(() => {\n        this.updateQueue = this.updateQueue.filter(_task => _task !== task);\n        this.notifyListeners();\n      });\n      this.updateQueue.push(task);\n      this.notifyListeners();\n      return task;\n    };\n    this.app = app;\n  }\n}\nexport default Library;\nexport const distributeLibraryItemsOnSquareGrid = libraryItems => {\n  const PADDING = 50;\n  const ITEMS_PER_ROW = Math.ceil(Math.sqrt(libraryItems.length));\n  const resElements = [];\n  const getMaxHeightPerRow = row => {\n    const maxHeight = libraryItems.slice(row * ITEMS_PER_ROW, row * ITEMS_PER_ROW + ITEMS_PER_ROW).reduce((acc, item) => {\n      const {\n        height\n      } = getCommonBoundingBox(item.elements);\n      return Math.max(acc, height);\n    }, 0);\n    return maxHeight;\n  };\n  const getMaxWidthPerCol = targetCol => {\n    let index = 0;\n    let currCol = 0;\n    let maxWidth = 0;\n    for (const item of libraryItems) {\n      if (index % ITEMS_PER_ROW === 0) {\n        currCol = 0;\n      }\n      if (currCol === targetCol) {\n        const {\n          width\n        } = getCommonBoundingBox(item.elements);\n        maxWidth = Math.max(maxWidth, width);\n      }\n      index++;\n      currCol++;\n    }\n    return maxWidth;\n  };\n  let colOffsetX = 0;\n  let rowOffsetY = 0;\n  let maxHeightCurrRow = 0;\n  let maxWidthCurrCol = 0;\n  let index = 0;\n  let col = 0;\n  let row = 0;\n  for (const item of libraryItems) {\n    if (index && index % ITEMS_PER_ROW === 0) {\n      rowOffsetY += maxHeightCurrRow + PADDING;\n      colOffsetX = 0;\n      col = 0;\n      row++;\n    }\n    if (col === 0) {\n      maxHeightCurrRow = getMaxHeightPerRow(row);\n    }\n    maxWidthCurrCol = getMaxWidthPerCol(col);\n    const {\n      minX,\n      minY,\n      width,\n      height\n    } = getCommonBoundingBox(item.elements);\n    const offsetCenterX = (maxWidthCurrCol - width) / 2;\n    const offsetCenterY = (maxHeightCurrRow - height) / 2;\n    resElements.push(\n    // eslint-disable-next-line no-loop-func\n    ...item.elements.map(element => ({\n      ...element,\n      x: element.x +\n      // offset for column\n      colOffsetX +\n      // offset to center in given square grid\n      offsetCenterX -\n      // subtract minX so that given item starts at 0 coord\n      minX,\n      y: element.y +\n      // offset for row\n      rowOffsetY +\n      // offset to center in given square grid\n      offsetCenterY -\n      // subtract minY so that given item starts at 0 coord\n      minY\n    })));\n    colOffsetX += maxWidthCurrCol + PADDING;\n    index++;\n    col++;\n  }\n  return resElements;\n};\nexport const parseLibraryTokensFromUrl = () => {\n  const libraryUrl =\n  // current\n  new URLSearchParams(window.location.hash.slice(1)).get(URL_HASH_KEYS.addLibrary) ||\n  // legacy, kept for compat reasons\n  new URLSearchParams(window.location.search).get(URL_QUERY_KEYS.addLibrary);\n  const idToken = libraryUrl ? new URLSearchParams(window.location.hash.slice(1)).get(\"token\") : null;\n  return libraryUrl ? {\n    libraryUrl,\n    idToken\n  } : null;\n};\nexport const useHandleLibrary = _ref2 => {\n  let {\n    excalidrawAPI,\n    getInitialLibraryItems\n  } = _ref2;\n  const getInitialLibraryRef = useRef(getInitialLibraryItems);\n  useEffect(() => {\n    if (!excalidrawAPI) {\n      return;\n    }\n    const importLibraryFromURL = async _ref3 => {\n      let {\n        libraryUrl,\n        idToken\n      } = _ref3;\n      const libraryPromise = new Promise(async (resolve, reject) => {\n        try {\n          const request = await fetch(decodeURIComponent(libraryUrl));\n          const blob = await request.blob();\n          resolve(blob);\n        } catch (error) {\n          reject(error);\n        }\n      });\n      const shouldPrompt = idToken !== excalidrawAPI.id;\n\n      // wait for the tab to be focused before continuing in case we'll prompt\n      // for confirmation\n      await (shouldPrompt && document.hidden ? new Promise(resolve => {\n        window.addEventListener(\"focus\", () => resolve(), {\n          once: true\n        });\n      }) : null);\n      try {\n        await excalidrawAPI.updateLibrary({\n          libraryItems: libraryPromise,\n          prompt: shouldPrompt,\n          merge: true,\n          defaultStatus: \"published\",\n          openLibraryMenu: true\n        });\n      } catch (error) {\n        throw error;\n      } finally {\n        if (window.location.hash.includes(URL_HASH_KEYS.addLibrary)) {\n          const hash = new URLSearchParams(window.location.hash.slice(1));\n          hash.delete(URL_HASH_KEYS.addLibrary);\n          window.history.replaceState({}, APP_NAME, `#${hash.toString()}`);\n        } else if (window.location.search.includes(URL_QUERY_KEYS.addLibrary)) {\n          const query = new URLSearchParams(window.location.search);\n          query.delete(URL_QUERY_KEYS.addLibrary);\n          window.history.replaceState({}, APP_NAME, `?${query.toString()}`);\n        }\n      }\n    };\n    const onHashChange = event => {\n      event.preventDefault();\n      const libraryUrlTokens = parseLibraryTokensFromUrl();\n      if (libraryUrlTokens) {\n        event.stopImmediatePropagation();\n        // If hash changed and it contains library url, import it and replace\n        // the url to its previous state (important in case of collaboration\n        // and similar).\n        // Using history API won't trigger another hashchange.\n        window.history.replaceState({}, \"\", event.oldURL);\n        importLibraryFromURL(libraryUrlTokens);\n      }\n    };\n\n    // -------------------------------------------------------------------------\n    // ------ init load --------------------------------------------------------\n    if (getInitialLibraryRef.current) {\n      excalidrawAPI.updateLibrary({\n        libraryItems: getInitialLibraryRef.current()\n      });\n    }\n    const libraryUrlTokens = parseLibraryTokensFromUrl();\n    if (libraryUrlTokens) {\n      importLibraryFromURL(libraryUrlTokens);\n    }\n    // --------------------------------------------------------- init load -----\n\n    window.addEventListener(EVENT.HASHCHANGE, onHashChange);\n    return () => {\n      window.removeEventListener(EVENT.HASHCHANGE, onHashChange);\n    };\n  }, [excalidrawAPI]);\n};","map":{"version":3,"names":["loadLibraryFromBlob","restoreLibraryItems","atom","jotaiStore","getCommonBoundingBox","AbortError","t","useEffect","useRef","URL_HASH_KEYS","URL_QUERY_KEYS","APP_NAME","EVENT","DEFAULT_SIDEBAR","LIBRARY_SIDEBAR_TAB","libraryItemSvgsCache","libraryItemsAtom","status","isInitialized","libraryItems","cloneLibraryItems","JSON","parse","stringify","isUniqueItem","existingLibraryItems","targetLibraryItem","find","libraryItem","elements","length","every","libItemExcalidrawItem","idx","id","versionNonce","mergeLibraryItems","localItems","otherItems","newItems","item","push","Library","constructor","app","lastLibraryItems","updateQueue","getLastUpdateTask","notifyListeners","set","_this$app$props$onLib","_this$app$props","props","onLibraryChange","call","error","console","destroy","Map","resetLibrary","setLibrary","getLatestLibrary","Promise","resolve","updateLibrary","_ref","prompt","merge","openLibraryMenu","defaultStatus","setState","openSidebar","name","tab","reject","source","Blob","nextItems","window","confirm","numShapes","focusContainer","task","catch","warn","finally","filter","_task","distributeLibraryItemsOnSquareGrid","PADDING","ITEMS_PER_ROW","Math","ceil","sqrt","resElements","getMaxHeightPerRow","row","maxHeight","slice","reduce","acc","height","max","getMaxWidthPerCol","targetCol","index","currCol","maxWidth","width","colOffsetX","rowOffsetY","maxHeightCurrRow","maxWidthCurrCol","col","minX","minY","offsetCenterX","offsetCenterY","map","element","x","y","parseLibraryTokensFromUrl","libraryUrl","URLSearchParams","location","hash","get","addLibrary","search","idToken","useHandleLibrary","_ref2","excalidrawAPI","getInitialLibraryItems","getInitialLibraryRef","importLibraryFromURL","_ref3","libraryPromise","request","fetch","decodeURIComponent","blob","shouldPrompt","document","hidden","addEventListener","once","includes","delete","history","replaceState","toString","query","onHashChange","event","preventDefault","libraryUrlTokens","stopImmediatePropagation","oldURL","current","HASHCHANGE","removeEventListener"],"sources":["D:/project/excalidraw-cn/src/data/library.ts"],"sourcesContent":["import { loadLibraryFromBlob } from \"./blob\";\nimport {\n  LibraryItems,\n  LibraryItem,\n  ExcalidrawImperativeAPI,\n  LibraryItemsSource,\n} from \"../types\";\nimport { restoreLibraryItems } from \"./restore\";\nimport type App from \"../components/App\";\nimport { atom } from \"jotai\";\nimport { jotaiStore } from \"../jotai\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { getCommonBoundingBox } from \"../element/bounds\";\nimport { AbortError } from \"../errors\";\nimport { t } from \"../i18n\";\nimport { useEffect, useRef } from \"react\";\nimport {\n  URL_HASH_KEYS,\n  URL_QUERY_KEYS,\n  APP_NAME,\n  EVENT,\n  DEFAULT_SIDEBAR,\n  LIBRARY_SIDEBAR_TAB,\n} from \"../constants\";\nimport { libraryItemSvgsCache } from \"../hooks/useLibraryItemSvg\";\n\nexport const libraryItemsAtom = atom<{\n  status: \"loading\" | \"loaded\";\n  isInitialized: boolean;\n  libraryItems: LibraryItems;\n}>({ status: \"loaded\", isInitialized: true, libraryItems: [] });\n\nconst cloneLibraryItems = (libraryItems: LibraryItems): LibraryItems =>\n  JSON.parse(JSON.stringify(libraryItems));\n\n/**\n * checks if library item does not exist already in current library\n */\nconst isUniqueItem = (\n  existingLibraryItems: LibraryItems,\n  targetLibraryItem: LibraryItem,\n) => {\n  return !existingLibraryItems.find((libraryItem) => {\n    if (libraryItem.elements.length !== targetLibraryItem.elements.length) {\n      return false;\n    }\n\n    // detect z-index difference by checking the excalidraw elements\n    // are in order\n    return libraryItem.elements.every((libItemExcalidrawItem, idx) => {\n      return (\n        libItemExcalidrawItem.id === targetLibraryItem.elements[idx].id &&\n        libItemExcalidrawItem.versionNonce ===\n          targetLibraryItem.elements[idx].versionNonce\n      );\n    });\n  });\n};\n\n/** Merges otherItems into localItems. Unique items in otherItems array are\n    sorted first. */\nexport const mergeLibraryItems = (\n  localItems: LibraryItems,\n  otherItems: LibraryItems,\n): LibraryItems => {\n  const newItems = [];\n  for (const item of otherItems) {\n    if (isUniqueItem(localItems, item)) {\n      newItems.push(item);\n    }\n  }\n\n  return [...newItems, ...localItems];\n};\n\nclass Library {\n  /** latest libraryItems */\n  private lastLibraryItems: LibraryItems = [];\n  /** indicates whether library is initialized with library items (has gone\n   * though at least one update) */\n  private isInitialized = false;\n\n  private app: App;\n\n  constructor(app: App) {\n    this.app = app;\n  }\n\n  private updateQueue: Promise<LibraryItems>[] = [];\n\n  private getLastUpdateTask = (): Promise<LibraryItems> | undefined => {\n    return this.updateQueue[this.updateQueue.length - 1];\n  };\n\n  private notifyListeners = () => {\n    if (this.updateQueue.length > 0) {\n      jotaiStore.set(libraryItemsAtom, {\n        status: \"loading\",\n        libraryItems: this.lastLibraryItems,\n        isInitialized: this.isInitialized,\n      });\n    } else {\n      this.isInitialized = true;\n      jotaiStore.set(libraryItemsAtom, {\n        status: \"loaded\",\n        libraryItems: this.lastLibraryItems,\n        isInitialized: this.isInitialized,\n      });\n      try {\n        this.app.props.onLibraryChange?.(\n          cloneLibraryItems(this.lastLibraryItems),\n        );\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  };\n\n  /** call on excalidraw instance unmount */\n  destroy = () => {\n    this.isInitialized = false;\n    this.updateQueue = [];\n    this.lastLibraryItems = [];\n    jotaiStore.set(libraryItemSvgsCache, new Map());\n    // TODO uncomment after/if we make jotai store scoped to each excal instance\n    // jotaiStore.set(libraryItemsAtom, {\n    //   status: \"loading\",\n    //   isInitialized: false,\n    //   libraryItems: [],\n    // });\n  };\n\n  resetLibrary = () => {\n    return this.setLibrary([]);\n  };\n\n  /**\n   * @returns latest cloned libraryItems. Awaits all in-progress updates first.\n   */\n  getLatestLibrary = (): Promise<LibraryItems> => {\n    return new Promise(async (resolve) => {\n      try {\n        const libraryItems = await (this.getLastUpdateTask() ||\n          this.lastLibraryItems);\n        if (this.updateQueue.length > 0) {\n          resolve(this.getLatestLibrary());\n        } else {\n          resolve(cloneLibraryItems(libraryItems));\n        }\n      } catch (error) {\n        return resolve(this.lastLibraryItems);\n      }\n    });\n  };\n\n  // NOTE this is a high-level public API (exposed on ExcalidrawAPI) with\n  // a slight overhead (always restoring library items). For internal use\n  // where merging isn't needed, use `library.setLibrary()` directly.\n  updateLibrary = async ({\n    libraryItems,\n    prompt = false,\n    merge = false,\n    openLibraryMenu = false,\n    defaultStatus = \"unpublished\",\n  }: {\n    libraryItems: LibraryItemsSource;\n    merge?: boolean;\n    prompt?: boolean;\n    openLibraryMenu?: boolean;\n    defaultStatus?: \"unpublished\" | \"published\";\n  }): Promise<LibraryItems> => {\n    if (openLibraryMenu) {\n      this.app.setState({\n        openSidebar: { name: DEFAULT_SIDEBAR.name, tab: LIBRARY_SIDEBAR_TAB },\n      });\n    }\n\n    return this.setLibrary(() => {\n      return new Promise<LibraryItems>(async (resolve, reject) => {\n        try {\n          const source = await (typeof libraryItems === \"function\" &&\n          !(libraryItems instanceof Blob)\n            ? libraryItems(this.lastLibraryItems)\n            : libraryItems);\n\n          let nextItems;\n\n          if (source instanceof Blob) {\n            nextItems = await loadLibraryFromBlob(source, defaultStatus);\n          } else {\n            nextItems = restoreLibraryItems(source, defaultStatus);\n          }\n          if (\n            !prompt ||\n            window.confirm(\n              t(\"alerts.confirmAddLibrary\", {\n                numShapes: nextItems.length,\n              }),\n            )\n          ) {\n            if (prompt) {\n              // focus container if we've prompted. We focus conditionally\n              // lest `props.autoFocus` is disabled (in which case we should\n              // focus only on user action such as prompt confirm)\n              this.app.focusContainer();\n            }\n\n            if (merge) {\n              resolve(mergeLibraryItems(this.lastLibraryItems, nextItems));\n            } else {\n              resolve(nextItems);\n            }\n          } else {\n            reject(new AbortError());\n          }\n        } catch (error: any) {\n          reject(error);\n        }\n      });\n    });\n  };\n\n  setLibrary = (\n    /**\n     * LibraryItems that will replace current items. Can be a function which\n     * will be invoked after all previous tasks are resolved\n     * (this is the prefered way to update the library to avoid race conditions,\n     * but you'll want to manually merge the library items in the callback\n     *  - which is what we're doing in Library.importLibrary()).\n     *\n     * If supplied promise is rejected with AbortError, we swallow it and\n     * do not update the library.\n     */\n    libraryItems:\n      | LibraryItems\n      | Promise<LibraryItems>\n      | ((\n          latestLibraryItems: LibraryItems,\n        ) => LibraryItems | Promise<LibraryItems>),\n  ): Promise<LibraryItems> => {\n    const task = new Promise<LibraryItems>(async (resolve, reject) => {\n      try {\n        await this.getLastUpdateTask();\n\n        if (typeof libraryItems === \"function\") {\n          libraryItems = libraryItems(this.lastLibraryItems);\n        }\n\n        this.lastLibraryItems = cloneLibraryItems(await libraryItems);\n\n        resolve(this.lastLibraryItems);\n      } catch (error: any) {\n        reject(error);\n      }\n    })\n      .catch((error) => {\n        if (error.name === \"AbortError\") {\n          console.warn(\"Library update aborted by user\");\n          return this.lastLibraryItems;\n        }\n        throw error;\n      })\n      .finally(() => {\n        this.updateQueue = this.updateQueue.filter((_task) => _task !== task);\n        this.notifyListeners();\n      });\n\n    this.updateQueue.push(task);\n    this.notifyListeners();\n\n    return task;\n  };\n}\n\nexport default Library;\n\nexport const distributeLibraryItemsOnSquareGrid = (\n  libraryItems: LibraryItems,\n) => {\n  const PADDING = 50;\n  const ITEMS_PER_ROW = Math.ceil(Math.sqrt(libraryItems.length));\n\n  const resElements: ExcalidrawElement[] = [];\n\n  const getMaxHeightPerRow = (row: number) => {\n    const maxHeight = libraryItems\n      .slice(row * ITEMS_PER_ROW, row * ITEMS_PER_ROW + ITEMS_PER_ROW)\n      .reduce((acc, item) => {\n        const { height } = getCommonBoundingBox(item.elements);\n        return Math.max(acc, height);\n      }, 0);\n    return maxHeight;\n  };\n\n  const getMaxWidthPerCol = (targetCol: number) => {\n    let index = 0;\n    let currCol = 0;\n    let maxWidth = 0;\n    for (const item of libraryItems) {\n      if (index % ITEMS_PER_ROW === 0) {\n        currCol = 0;\n      }\n      if (currCol === targetCol) {\n        const { width } = getCommonBoundingBox(item.elements);\n        maxWidth = Math.max(maxWidth, width);\n      }\n      index++;\n      currCol++;\n    }\n    return maxWidth;\n  };\n\n  let colOffsetX = 0;\n  let rowOffsetY = 0;\n\n  let maxHeightCurrRow = 0;\n  let maxWidthCurrCol = 0;\n\n  let index = 0;\n  let col = 0;\n  let row = 0;\n\n  for (const item of libraryItems) {\n    if (index && index % ITEMS_PER_ROW === 0) {\n      rowOffsetY += maxHeightCurrRow + PADDING;\n      colOffsetX = 0;\n      col = 0;\n      row++;\n    }\n\n    if (col === 0) {\n      maxHeightCurrRow = getMaxHeightPerRow(row);\n    }\n    maxWidthCurrCol = getMaxWidthPerCol(col);\n\n    const { minX, minY, width, height } = getCommonBoundingBox(item.elements);\n    const offsetCenterX = (maxWidthCurrCol - width) / 2;\n    const offsetCenterY = (maxHeightCurrRow - height) / 2;\n    resElements.push(\n      // eslint-disable-next-line no-loop-func\n      ...item.elements.map((element) => ({\n        ...element,\n        x:\n          element.x +\n          // offset for column\n          colOffsetX +\n          // offset to center in given square grid\n          offsetCenterX -\n          // subtract minX so that given item starts at 0 coord\n          minX,\n        y:\n          element.y +\n          // offset for row\n          rowOffsetY +\n          // offset to center in given square grid\n          offsetCenterY -\n          // subtract minY so that given item starts at 0 coord\n          minY,\n      })),\n    );\n    colOffsetX += maxWidthCurrCol + PADDING;\n    index++;\n    col++;\n  }\n\n  return resElements;\n};\n\nexport const parseLibraryTokensFromUrl = () => {\n  const libraryUrl =\n    // current\n    new URLSearchParams(window.location.hash.slice(1)).get(\n      URL_HASH_KEYS.addLibrary,\n    ) ||\n    // legacy, kept for compat reasons\n    new URLSearchParams(window.location.search).get(URL_QUERY_KEYS.addLibrary);\n  const idToken = libraryUrl\n    ? new URLSearchParams(window.location.hash.slice(1)).get(\"token\")\n    : null;\n\n  return libraryUrl ? { libraryUrl, idToken } : null;\n};\n\nexport const useHandleLibrary = ({\n  excalidrawAPI,\n  getInitialLibraryItems,\n}: {\n  excalidrawAPI: ExcalidrawImperativeAPI | null;\n  getInitialLibraryItems?: () => LibraryItemsSource;\n}) => {\n  const getInitialLibraryRef = useRef(getInitialLibraryItems);\n\n  useEffect(() => {\n    if (!excalidrawAPI) {\n      return;\n    }\n\n    const importLibraryFromURL = async ({\n      libraryUrl,\n      idToken,\n    }: {\n      libraryUrl: string;\n      idToken: string | null;\n    }) => {\n      const libraryPromise = new Promise<Blob>(async (resolve, reject) => {\n        try {\n          const request = await fetch(decodeURIComponent(libraryUrl));\n          const blob = await request.blob();\n          resolve(blob);\n        } catch (error: any) {\n          reject(error);\n        }\n      });\n\n      const shouldPrompt = idToken !== excalidrawAPI.id;\n\n      // wait for the tab to be focused before continuing in case we'll prompt\n      // for confirmation\n      await (shouldPrompt && document.hidden\n        ? new Promise<void>((resolve) => {\n            window.addEventListener(\"focus\", () => resolve(), {\n              once: true,\n            });\n          })\n        : null);\n\n      try {\n        await excalidrawAPI.updateLibrary({\n          libraryItems: libraryPromise,\n          prompt: shouldPrompt,\n          merge: true,\n          defaultStatus: \"published\",\n          openLibraryMenu: true,\n        });\n      } catch (error) {\n        throw error;\n      } finally {\n        if (window.location.hash.includes(URL_HASH_KEYS.addLibrary)) {\n          const hash = new URLSearchParams(window.location.hash.slice(1));\n          hash.delete(URL_HASH_KEYS.addLibrary);\n          window.history.replaceState({}, APP_NAME, `#${hash.toString()}`);\n        } else if (window.location.search.includes(URL_QUERY_KEYS.addLibrary)) {\n          const query = new URLSearchParams(window.location.search);\n          query.delete(URL_QUERY_KEYS.addLibrary);\n          window.history.replaceState({}, APP_NAME, `?${query.toString()}`);\n        }\n      }\n    };\n    const onHashChange = (event: HashChangeEvent) => {\n      event.preventDefault();\n      const libraryUrlTokens = parseLibraryTokensFromUrl();\n      if (libraryUrlTokens) {\n        event.stopImmediatePropagation();\n        // If hash changed and it contains library url, import it and replace\n        // the url to its previous state (important in case of collaboration\n        // and similar).\n        // Using history API won't trigger another hashchange.\n        window.history.replaceState({}, \"\", event.oldURL);\n\n        importLibraryFromURL(libraryUrlTokens);\n      }\n    };\n\n    // -------------------------------------------------------------------------\n    // ------ init load --------------------------------------------------------\n    if (getInitialLibraryRef.current) {\n      excalidrawAPI.updateLibrary({\n        libraryItems: getInitialLibraryRef.current(),\n      });\n    }\n\n    const libraryUrlTokens = parseLibraryTokensFromUrl();\n\n    if (libraryUrlTokens) {\n      importLibraryFromURL(libraryUrlTokens);\n    }\n    // --------------------------------------------------------- init load -----\n\n    window.addEventListener(EVENT.HASHCHANGE, onHashChange);\n    return () => {\n      window.removeEventListener(EVENT.HASHCHANGE, onHashChange);\n    };\n  }, [excalidrawAPI]);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}