{"ast":null,"code":"import _toArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toArray.js\";import _slicedToArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import{DEFAULT_ADAPTIVE_RADIUS,LINE_CONFIRM_THRESHOLD,DEFAULT_PROPORTIONAL_RADIUS,ROUNDNESS}from\"./constants\";import{getShapeForElement}from\"./renderer/renderElement\";import{getCurvePathOps}from\"./element/bounds\";export var rotate=function rotate(x1,y1,x2,y2,angle){return(// ùëé‚Ä≤ùë•=(ùëéùë•‚àíùëêùë•)cosùúÉ‚àí(ùëéùë¶‚àíùëêùë¶)sinùúÉ+ùëêùë•\n// ùëé‚Ä≤ùë¶=(ùëéùë•‚àíùëêùë•)sinùúÉ+(ùëéùë¶‚àíùëêùë¶)cosùúÉ+ùëêùë¶.\n// https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n[(x1-x2)*Math.cos(angle)-(y1-y2)*Math.sin(angle)+x2,(x1-x2)*Math.sin(angle)+(y1-y2)*Math.cos(angle)+y2]);};export var rotatePoint=function rotatePoint(point,center,angle){return rotate(point[0],point[1],center[0],center[1],angle);};export var adjustXYWithRotation=function adjustXYWithRotation(sides,x,y,angle,deltaX1,deltaY1,deltaX2,deltaY2){var cos=Math.cos(angle);var sin=Math.sin(angle);if(sides.e&&sides.w){x+=deltaX1+deltaX2;}else if(sides.e){x+=deltaX1*(1+cos);y+=deltaX1*sin;x+=deltaX2*(1-cos);y+=deltaX2*-sin;}else if(sides.w){x+=deltaX1*(1-cos);y+=deltaX1*-sin;x+=deltaX2*(1+cos);y+=deltaX2*sin;}if(sides.n&&sides.s){y+=deltaY1+deltaY2;}else if(sides.n){x+=deltaY1*sin;y+=deltaY1*(1-cos);x+=deltaY2*-sin;y+=deltaY2*(1+cos);}else if(sides.s){x+=deltaY1*-sin;y+=deltaY1*(1+cos);x+=deltaY2*sin;y+=deltaY2*(1-cos);}return[x,y];};export var getPointOnAPath=function getPointOnAPath(point,path){var _point=_slicedToArray(point,2),px=_point[0],py=_point[1];var _path=_toArray(path),start=_path[0],other=_path.slice(1);var _start=_slicedToArray(start,2),lastX=_start[0],lastY=_start[1];var kLine=0;var idx=0;// if any item in the array is true, it means that a point is\n// on some segment of a line based path\nvar retVal=other.some(function(_ref,i){var _ref2=_slicedToArray(_ref,2),x2=_ref2[0],y2=_ref2[1];// we always take a line when dealing with line segments\nvar x1=lastX;var y1=lastY;lastX=x2;lastY=y2;// if a point is not within the domain of the line segment\n// it is not on the line segment\nif(px<x1||px>x2){return false;}// check if all points lie on the same line\n// y1 = kx1 + b, y2 = kx2 + b\n// y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n// coefficient for the line (p0, p1)\nvar kL=(y2-y1)/(x2-x1);// coefficient for the line segment (p0, point)\nvar kP1=(py-y1)/(px-x1);// coefficient for the line segment (point, p1)\nvar kP2=(py-y2)/(px-x2);// because we are basing both lines from the same starting point\n// the only option for collinearity is having same coefficients\n// using it for floating point comparisons\nvar epsilon=0.3;// if coefficient is more than an arbitrary epsilon,\n// these lines are nor collinear\nif(Math.abs(kP1-kL)>epsilon&&Math.abs(kP2-kL)>epsilon){return false;}// store the coefficient because we are goint to need it\nkLine=kL;idx=i;return true;});// Return a coordinate that is always on the line segment\nif(retVal===true){return{x:point[0],y:kLine*point[0],segment:idx};}return null;};export var distance2d=function distance2d(x1,y1,x2,y2){var xd=x2-x1;var yd=y2-y1;return Math.hypot(xd,yd);};export var centerPoint=function centerPoint(a,b){return[(a[0]+b[0])/2,(a[1]+b[1])/2];};// Checks if the first and last point are close enough\n// to be considered a loop\nexport var isPathALoop=function isPathALoop(points){var zoomValue=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;if(points.length>=3){var _ref3=[points[0],points[points.length-1]],first=_ref3[0],last=_ref3[1];var distance=distance2d(first[0],first[1],last[0],last[1]);// Adjusting LINE_CONFIRM_THRESHOLD to current zoom so that when zoomed in\n// really close we make the threshold smaller, and vice versa.\nreturn distance<=LINE_CONFIRM_THRESHOLD/zoomValue;}return false;};// Draw a line from the point to the right till infiinty\n// Check how many lines of the polygon does this infinite line intersects with\n// If the number of intersections is odd, point is in the polygon\nexport var isPointInPolygon=function isPointInPolygon(points,x,y){var vertices=points.length;// There must be at least 3 vertices in polygon\nif(vertices<3){return false;}var extreme=[Number.MAX_SAFE_INTEGER,y];var p=[x,y];var count=0;for(var i=0;i<vertices;i++){var current=points[i];var next=points[(i+1)%vertices];if(doSegmentsIntersect(current,next,p,extreme)){if(orderedColinearOrientation(current,p,next)===0){return isPointWithinBounds(current,p,next);}count++;}}// true if count is off\nreturn count%2===1;};// Returns whether `q` lies inside the segment/rectangle defined by `p` and `r`.\n// This is an approximation to \"does `q` lie on a segment `pr`\" check.\nexport var isPointWithinBounds=function isPointWithinBounds(p,q,r){return q[0]<=Math.max(p[0],r[0])&&q[0]>=Math.min(p[0],r[0])&&q[1]<=Math.max(p[1],r[1])&&q[1]>=Math.min(p[1],r[1]);};// For the ordered points p, q, r, return\n// 0 if p, q, r are colinear\n// 1 if Clockwise\n// 2 if counterclickwise\nvar orderedColinearOrientation=function orderedColinearOrientation(p,q,r){var val=(q[1]-p[1])*(r[0]-q[0])-(q[0]-p[0])*(r[1]-q[1]);if(val===0){return 0;}return val>0?1:2;};// Check is p1q1 intersects with p2q2\nvar doSegmentsIntersect=function doSegmentsIntersect(p1,q1,p2,q2){var o1=orderedColinearOrientation(p1,q1,p2);var o2=orderedColinearOrientation(p1,q1,q2);var o3=orderedColinearOrientation(p2,q2,p1);var o4=orderedColinearOrientation(p2,q2,q1);if(o1!==o2&&o3!==o4){return true;}// p1, q1 and p2 are colinear and p2 lies on segment p1q1\nif(o1===0&&isPointWithinBounds(p1,p2,q1)){return true;}// p1, q1 and p2 are colinear and q2 lies on segment p1q1\nif(o2===0&&isPointWithinBounds(p1,q2,q1)){return true;}// p2, q2 and p1 are colinear and p1 lies on segment p2q2\nif(o3===0&&isPointWithinBounds(p2,p1,q2)){return true;}// p2, q2 and q1 are colinear and q1 lies on segment p2q2\nif(o4===0&&isPointWithinBounds(p2,q1,q2)){return true;}return false;};// TODO: Rounding this point causes some shake when free drawing\nexport var getGridPoint=function getGridPoint(x,y,gridSize){if(gridSize){return[Math.round(x/gridSize)*gridSize,Math.round(y/gridSize)*gridSize];}return[x,y];};export var getCornerRadius=function getCornerRadius(x,element){var _element$roundness,_element$roundness2,_element$roundness3;if(((_element$roundness=element.roundness)===null||_element$roundness===void 0?void 0:_element$roundness.type)===ROUNDNESS.PROPORTIONAL_RADIUS||((_element$roundness2=element.roundness)===null||_element$roundness2===void 0?void 0:_element$roundness2.type)===ROUNDNESS.LEGACY){return x*DEFAULT_PROPORTIONAL_RADIUS;}if(((_element$roundness3=element.roundness)===null||_element$roundness3===void 0?void 0:_element$roundness3.type)===ROUNDNESS.ADAPTIVE_RADIUS){var _element$roundness$va,_element$roundness4;var fixedRadiusSize=(_element$roundness$va=(_element$roundness4=element.roundness)===null||_element$roundness4===void 0?void 0:_element$roundness4.value)!==null&&_element$roundness$va!==void 0?_element$roundness$va:DEFAULT_ADAPTIVE_RADIUS;var CUTOFF_SIZE=fixedRadiusSize/DEFAULT_PROPORTIONAL_RADIUS;if(x<=CUTOFF_SIZE){return x*DEFAULT_PROPORTIONAL_RADIUS;}return fixedRadiusSize;}return 0;};export var getControlPointsForBezierCurve=function getControlPointsForBezierCurve(element,endPoint){var shape=getShapeForElement(element);if(!shape){return null;}var ops=getCurvePathOps(shape[0]);var currentP=[0,0];var index=0;var minDistance=Infinity;var controlPoints=null;while(index<ops.length){var _ops$index=ops[index],op=_ops$index.op,data=_ops$index.data;if(op===\"move\"){currentP=data;}if(op===\"bcurveTo\"){var p0=currentP;var p1=[data[0],data[1]];var p2=[data[2],data[3]];var p3=[data[4],data[5]];var distance=distance2d(p3[0],p3[1],endPoint[0],endPoint[1]);if(distance<minDistance){minDistance=distance;controlPoints=[p0,p1,p2,p3];}currentP=p3;}index++;}return controlPoints;};export var getBezierXY=function getBezierXY(p0,p1,p2,p3,t){var equation=function equation(t,idx){return Math.pow(1-t,3)*p3[idx]+3*t*Math.pow(1-t,2)*p2[idx]+3*Math.pow(t,2)*(1-t)*p1[idx]+p0[idx]*Math.pow(t,3);};var tx=equation(t,0);var ty=equation(t,1);return[tx,ty];};export var getPointsInBezierCurve=function getPointsInBezierCurve(element,endPoint){var controlPoints=getControlPointsForBezierCurve(element,endPoint);if(!controlPoints){return[];}var pointsOnCurve=[];var t=1;// Take 20 points on curve for better accuracy\nwhile(t>0){var point=getBezierXY(controlPoints[0],controlPoints[1],controlPoints[2],controlPoints[3],t);pointsOnCurve.push([point[0],point[1]]);t-=0.05;}if(pointsOnCurve.length){if(arePointsEqual(pointsOnCurve.at(-1),endPoint)){pointsOnCurve.push([endPoint[0],endPoint[1]]);}}return pointsOnCurve;};export var getBezierCurveArcLengths=function getBezierCurveArcLengths(element,endPoint){var arcLengths=[];arcLengths[0]=0;var points=getPointsInBezierCurve(element,endPoint);var index=0;var distance=0;while(index<points.length-1){var segmentDistance=distance2d(points[index][0],points[index][1],points[index+1][0],points[index+1][1]);distance+=segmentDistance;arcLengths.push(distance);index++;}return arcLengths;};export var getBezierCurveLength=function getBezierCurveLength(element,endPoint){var arcLengths=getBezierCurveArcLengths(element,endPoint);return arcLengths.at(-1);};// This maps interval to actual interval t on the curve so that when t = 0.5, its actually the point at 50% of the length\nexport var mapIntervalToBezierT=function mapIntervalToBezierT(element,endPoint,interval// The interval between 0 to 1 for which you want to find the point on the curve,\n){var arcLengths=getBezierCurveArcLengths(element,endPoint);var pointsCount=arcLengths.length-1;var curveLength=arcLengths.at(-1);var targetLength=interval*curveLength;var low=0;var high=pointsCount;var index=0;// Doing a binary search to find the largest length that is less than the target length\nwhile(low<high){index=Math.floor(low+(high-low)/2);if(arcLengths[index]<targetLength){low=index+1;}else{high=index;}}if(arcLengths[index]>targetLength){index--;}if(arcLengths[index]===targetLength){return index/pointsCount;}return 1-(index+(targetLength-arcLengths[index])/(arcLengths[index+1]-arcLengths[index]))/pointsCount;};export var arePointsEqual=function arePointsEqual(p1,p2){return p1[0]===p2[0]&&p1[1]===p2[1];};export var isRightAngle=function isRightAngle(angle){// if our angles were mathematically accurate, we could just check\n//\n//    angle % (Math.PI / 2) === 0\n//\n// but since we're in floating point land, we need to round.\n//\n// Below, after dividing by Math.PI, a multiple of 0.5 indicates a right\n// angle, which we can check with modulo after rounding.\nreturn Math.round(angle/Math.PI*10000)%5000===0;};","map":{"version":3,"names":["DEFAULT_ADAPTIVE_RADIUS","LINE_CONFIRM_THRESHOLD","DEFAULT_PROPORTIONAL_RADIUS","ROUNDNESS","getShapeForElement","getCurvePathOps","rotate","x1","y1","x2","y2","angle","Math","cos","sin","rotatePoint","point","center","adjustXYWithRotation","sides","x","y","deltaX1","deltaY1","deltaX2","deltaY2","e","w","n","s","getPointOnAPath","path","_point","_slicedToArray","px","py","_path","_toArray","start","other","slice","_start","lastX","lastY","kLine","idx","retVal","some","_ref","i","_ref2","kL","kP1","kP2","epsilon","abs","segment","distance2d","xd","yd","hypot","centerPoint","a","b","isPathALoop","points","zoomValue","arguments","length","undefined","_ref3","first","last","distance","isPointInPolygon","vertices","extreme","Number","MAX_SAFE_INTEGER","p","count","current","next","doSegmentsIntersect","orderedColinearOrientation","isPointWithinBounds","q","r","max","min","val","p1","q1","p2","q2","o1","o2","o3","o4","getGridPoint","gridSize","round","getCornerRadius","element","_element$roundness","_element$roundness2","_element$roundness3","roundness","type","PROPORTIONAL_RADIUS","LEGACY","ADAPTIVE_RADIUS","_element$roundness$va","_element$roundness4","fixedRadiusSize","value","CUTOFF_SIZE","getControlPointsForBezierCurve","endPoint","shape","ops","currentP","index","minDistance","Infinity","controlPoints","_ops$index","op","data","p0","p3","getBezierXY","t","equation","pow","tx","ty","getPointsInBezierCurve","pointsOnCurve","push","arePointsEqual","at","getBezierCurveArcLengths","arcLengths","segmentDistance","getBezierCurveLength","mapIntervalToBezierT","interval","pointsCount","curveLength","targetLength","low","high","floor","isRightAngle","PI"],"sources":["D:/project/excalidraw-cn/src/math.ts"],"sourcesContent":["import { NormalizedZoomValue, Point, Zoom } from \"./types\";\nimport {\n  DEFAULT_ADAPTIVE_RADIUS,\n  LINE_CONFIRM_THRESHOLD,\n  DEFAULT_PROPORTIONAL_RADIUS,\n  ROUNDNESS,\n} from \"./constants\";\nimport {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  NonDeleted,\n} from \"./element/types\";\nimport { getShapeForElement } from \"./renderer/renderElement\";\nimport { getCurvePathOps } from \"./element/bounds\";\nimport { Mutable } from \"./utility-types\";\n\nexport const rotate = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  angle: number,\n): [number, number] =>\n  // ùëé‚Ä≤ùë•=(ùëéùë•‚àíùëêùë•)cosùúÉ‚àí(ùëéùë¶‚àíùëêùë¶)sinùúÉ+ùëêùë•\n  // ùëé‚Ä≤ùë¶=(ùëéùë•‚àíùëêùë•)sinùúÉ+(ùëéùë¶‚àíùëêùë¶)cosùúÉ+ùëêùë¶.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2,\n  ];\n\nexport const rotatePoint = (\n  point: Point,\n  center: Point,\n  angle: number,\n): [number, number] => rotate(point[0], point[1], center[0], center[1], angle);\n\nexport const adjustXYWithRotation = (\n  sides: {\n    n?: boolean;\n    e?: boolean;\n    s?: boolean;\n    w?: boolean;\n  },\n  x: number,\n  y: number,\n  angle: number,\n  deltaX1: number,\n  deltaY1: number,\n  deltaX2: number,\n  deltaY2: number,\n): [number, number] => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  if (sides.e && sides.w) {\n    x += deltaX1 + deltaX2;\n  } else if (sides.e) {\n    x += deltaX1 * (1 + cos);\n    y += deltaX1 * sin;\n    x += deltaX2 * (1 - cos);\n    y += deltaX2 * -sin;\n  } else if (sides.w) {\n    x += deltaX1 * (1 - cos);\n    y += deltaX1 * -sin;\n    x += deltaX2 * (1 + cos);\n    y += deltaX2 * sin;\n  }\n\n  if (sides.n && sides.s) {\n    y += deltaY1 + deltaY2;\n  } else if (sides.n) {\n    x += deltaY1 * sin;\n    y += deltaY1 * (1 - cos);\n    x += deltaY2 * -sin;\n    y += deltaY2 * (1 + cos);\n  } else if (sides.s) {\n    x += deltaY1 * -sin;\n    y += deltaY1 * (1 + cos);\n    x += deltaY2 * sin;\n    y += deltaY2 * (1 - cos);\n  }\n  return [x, y];\n};\n\nexport const getPointOnAPath = (point: Point, path: Point[]) => {\n  const [px, py] = point;\n  const [start, ...other] = path;\n  let [lastX, lastY] = start;\n  let kLine: number = 0;\n  let idx: number = 0;\n\n  // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n  const retVal = other.some(([x2, y2], i) => {\n    // we always take a line when dealing with line segments\n    const x1 = lastX;\n    const y1 = lastY;\n\n    lastX = x2;\n    lastY = y2;\n\n    // if a point is not within the domain of the line segment\n    // it is not on the line segment\n    if (px < x1 || px > x2) {\n      return false;\n    }\n\n    // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n\n    // coefficient for the line (p0, p1)\n    const kL = (y2 - y1) / (x2 - x1);\n\n    // coefficient for the line segment (p0, point)\n    const kP1 = (py - y1) / (px - x1);\n\n    // coefficient for the line segment (point, p1)\n    const kP2 = (py - y2) / (px - x2);\n\n    // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n\n    // using it for floating point comparisons\n    const epsilon = 0.3;\n\n    // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    }\n\n    // store the coefficient because we are goint to need it\n    kLine = kL;\n    idx = i;\n\n    return true;\n  });\n\n  // Return a coordinate that is always on the line segment\n  if (retVal === true) {\n    return { x: point[0], y: kLine * point[0], segment: idx };\n  }\n\n  return null;\n};\n\nexport const distance2d = (x1: number, y1: number, x2: number, y2: number) => {\n  const xd = x2 - x1;\n  const yd = y2 - y1;\n  return Math.hypot(xd, yd);\n};\n\nexport const centerPoint = (a: Point, b: Point): Point => {\n  return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n};\n\n// Checks if the first and last point are close enough\n// to be considered a loop\nexport const isPathALoop = (\n  points: ExcalidrawLinearElement[\"points\"],\n  /** supply if you want the loop detection to account for current zoom */\n  zoomValue: Zoom[\"value\"] = 1 as NormalizedZoomValue,\n): boolean => {\n  if (points.length >= 3) {\n    const [first, last] = [points[0], points[points.length - 1]];\n    const distance = distance2d(first[0], first[1], last[0], last[1]);\n\n    // Adjusting LINE_CONFIRM_THRESHOLD to current zoom so that when zoomed in\n    // really close we make the threshold smaller, and vice versa.\n    return distance <= LINE_CONFIRM_THRESHOLD / zoomValue;\n  }\n  return false;\n};\n\n// Draw a line from the point to the right till infiinty\n// Check how many lines of the polygon does this infinite line intersects with\n// If the number of intersections is odd, point is in the polygon\nexport const isPointInPolygon = (\n  points: Point[],\n  x: number,\n  y: number,\n): boolean => {\n  const vertices = points.length;\n\n  // There must be at least 3 vertices in polygon\n  if (vertices < 3) {\n    return false;\n  }\n  const extreme: Point = [Number.MAX_SAFE_INTEGER, y];\n  const p: Point = [x, y];\n  let count = 0;\n  for (let i = 0; i < vertices; i++) {\n    const current = points[i];\n    const next = points[(i + 1) % vertices];\n    if (doSegmentsIntersect(current, next, p, extreme)) {\n      if (orderedColinearOrientation(current, p, next) === 0) {\n        return isPointWithinBounds(current, p, next);\n      }\n      count++;\n    }\n  }\n  // true if count is off\n  return count % 2 === 1;\n};\n\n// Returns whether `q` lies inside the segment/rectangle defined by `p` and `r`.\n// This is an approximation to \"does `q` lie on a segment `pr`\" check.\nexport const isPointWithinBounds = (p: Point, q: Point, r: Point) => {\n  return (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  );\n};\n\n// For the ordered points p, q, r, return\n// 0 if p, q, r are colinear\n// 1 if Clockwise\n// 2 if counterclickwise\nconst orderedColinearOrientation = (p: Point, q: Point, r: Point) => {\n  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n  if (val === 0) {\n    return 0;\n  }\n  return val > 0 ? 1 : 2;\n};\n\n// Check is p1q1 intersects with p2q2\nconst doSegmentsIntersect = (p1: Point, q1: Point, p2: Point, q2: Point) => {\n  const o1 = orderedColinearOrientation(p1, q1, p2);\n  const o2 = orderedColinearOrientation(p1, q1, q2);\n  const o3 = orderedColinearOrientation(p2, q2, p1);\n  const o4 = orderedColinearOrientation(p2, q2, q1);\n\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n  if (o1 === 0 && isPointWithinBounds(p1, p2, q1)) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n  if (o2 === 0 && isPointWithinBounds(p1, q2, q1)) {\n    return true;\n  }\n\n  // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n  if (o3 === 0 && isPointWithinBounds(p2, p1, q2)) {\n    return true;\n  }\n\n  // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n  if (o4 === 0 && isPointWithinBounds(p2, q1, q2)) {\n    return true;\n  }\n\n  return false;\n};\n\n// TODO: Rounding this point causes some shake when free drawing\nexport const getGridPoint = (\n  x: number,\n  y: number,\n  gridSize: number | null,\n): [number, number] => {\n  if (gridSize) {\n    return [\n      Math.round(x / gridSize) * gridSize,\n      Math.round(y / gridSize) * gridSize,\n    ];\n  }\n  return [x, y];\n};\n\nexport const getCornerRadius = (x: number, element: ExcalidrawElement) => {\n  if (\n    element.roundness?.type === ROUNDNESS.PROPORTIONAL_RADIUS ||\n    element.roundness?.type === ROUNDNESS.LEGACY\n  ) {\n    return x * DEFAULT_PROPORTIONAL_RADIUS;\n  }\n\n  if (element.roundness?.type === ROUNDNESS.ADAPTIVE_RADIUS) {\n    const fixedRadiusSize = element.roundness?.value ?? DEFAULT_ADAPTIVE_RADIUS;\n\n    const CUTOFF_SIZE = fixedRadiusSize / DEFAULT_PROPORTIONAL_RADIUS;\n\n    if (x <= CUTOFF_SIZE) {\n      return x * DEFAULT_PROPORTIONAL_RADIUS;\n    }\n\n    return fixedRadiusSize;\n  }\n\n  return 0;\n};\n\nexport const getControlPointsForBezierCurve = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  endPoint: Point,\n) => {\n  const shape = getShapeForElement(element as ExcalidrawLinearElement);\n  if (!shape) {\n    return null;\n  }\n\n  const ops = getCurvePathOps(shape[0]);\n  let currentP: Mutable<Point> = [0, 0];\n  let index = 0;\n  let minDistance = Infinity;\n  let controlPoints: Mutable<Point>[] | null = null;\n\n  while (index < ops.length) {\n    const { op, data } = ops[index];\n    if (op === \"move\") {\n      currentP = data as unknown as Mutable<Point>;\n    }\n    if (op === \"bcurveTo\") {\n      const p0 = currentP;\n      const p1 = [data[0], data[1]] as Mutable<Point>;\n      const p2 = [data[2], data[3]] as Mutable<Point>;\n      const p3 = [data[4], data[5]] as Mutable<Point>;\n      const distance = distance2d(p3[0], p3[1], endPoint[0], endPoint[1]);\n      if (distance < minDistance) {\n        minDistance = distance;\n        controlPoints = [p0, p1, p2, p3];\n      }\n      currentP = p3;\n    }\n    index++;\n  }\n\n  return controlPoints;\n};\n\nexport const getBezierXY = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  p3: Point,\n  t: number,\n) => {\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n  const tx = equation(t, 0);\n  const ty = equation(t, 1);\n  return [tx, ty];\n};\n\nexport const getPointsInBezierCurve = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  endPoint: Point,\n) => {\n  const controlPoints: Mutable<Point>[] = getControlPointsForBezierCurve(\n    element,\n    endPoint,\n  )!;\n  if (!controlPoints) {\n    return [];\n  }\n  const pointsOnCurve: Mutable<Point>[] = [];\n  let t = 1;\n  // Take 20 points on curve for better accuracy\n  while (t > 0) {\n    const point = getBezierXY(\n      controlPoints[0],\n      controlPoints[1],\n      controlPoints[2],\n      controlPoints[3],\n      t,\n    );\n    pointsOnCurve.push([point[0], point[1]]);\n    t -= 0.05;\n  }\n  if (pointsOnCurve.length) {\n    if (arePointsEqual(pointsOnCurve.at(-1)!, endPoint)) {\n      pointsOnCurve.push([endPoint[0], endPoint[1]]);\n    }\n  }\n  return pointsOnCurve;\n};\n\nexport const getBezierCurveArcLengths = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  endPoint: Point,\n) => {\n  const arcLengths: number[] = [];\n  arcLengths[0] = 0;\n  const points = getPointsInBezierCurve(element, endPoint);\n  let index = 0;\n  let distance = 0;\n  while (index < points.length - 1) {\n    const segmentDistance = distance2d(\n      points[index][0],\n      points[index][1],\n      points[index + 1][0],\n      points[index + 1][1],\n    );\n    distance += segmentDistance;\n    arcLengths.push(distance);\n    index++;\n  }\n\n  return arcLengths;\n};\n\nexport const getBezierCurveLength = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  endPoint: Point,\n) => {\n  const arcLengths = getBezierCurveArcLengths(element, endPoint);\n  return arcLengths.at(-1) as number;\n};\n\n// This maps interval to actual interval t on the curve so that when t = 0.5, its actually the point at 50% of the length\nexport const mapIntervalToBezierT = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  endPoint: Point,\n  interval: number, // The interval between 0 to 1 for which you want to find the point on the curve,\n) => {\n  const arcLengths = getBezierCurveArcLengths(element, endPoint);\n  const pointsCount = arcLengths.length - 1;\n  const curveLength = arcLengths.at(-1) as number;\n  const targetLength = interval * curveLength;\n  let low = 0;\n  let high = pointsCount;\n  let index = 0;\n  // Doing a binary search to find the largest length that is less than the target length\n  while (low < high) {\n    index = Math.floor(low + (high - low) / 2);\n    if (arcLengths[index] < targetLength) {\n      low = index + 1;\n    } else {\n      high = index;\n    }\n  }\n  if (arcLengths[index] > targetLength) {\n    index--;\n  }\n  if (arcLengths[index] === targetLength) {\n    return index / pointsCount;\n  }\n\n  return (\n    1 -\n    (index +\n      (targetLength - arcLengths[index]) /\n        (arcLengths[index + 1] - arcLengths[index])) /\n      pointsCount\n  );\n};\n\nexport const arePointsEqual = (p1: Point, p2: Point) => {\n  return p1[0] === p2[0] && p1[1] === p2[1];\n};\n\nexport const isRightAngle = (angle: number) => {\n  // if our angles were mathematically accurate, we could just check\n  //\n  //    angle % (Math.PI / 2) === 0\n  //\n  // but since we're in floating point land, we need to round.\n  //\n  // Below, after dividing by Math.PI, a multiple of 0.5 indicates a right\n  // angle, which we can check with modulo after rounding.\n  return Math.round((angle / Math.PI) * 10000) % 5000 === 0;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}