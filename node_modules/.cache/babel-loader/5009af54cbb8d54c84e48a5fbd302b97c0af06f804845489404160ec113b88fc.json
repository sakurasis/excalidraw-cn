{"ast":null,"code":"import { isSyncableElement } from \"../data\";\nimport { WS_EVENTS, FILE_UPLOAD_TIMEOUT, WS_SCENE_EVENT_TYPES } from \"../app_constants\";\nimport { trackEvent } from \"../../analytics\";\nimport throttle from \"lodash.throttle\";\nimport { newElementWith } from \"../../element/mutateElement\";\nimport { encryptData } from \"../../data/encryption\";\nimport { PRECEDING_ELEMENT_KEY } from \"../../constants\";\nclass Portal {\n  constructor(collab) {\n    this.collab = void 0;\n    this.socket = null;\n    this.socketInitialized = false;\n    // we don't want the socket to emit any updates until it is fully initialized\n    this.roomId = null;\n    this.roomKey = null;\n    this.broadcastedElementVersions = new Map();\n    this.queueFileUpload = throttle(async () => {\n      try {\n        await this.collab.fileManager.saveFiles({\n          elements: this.collab.excalidrawAPI.getSceneElementsIncludingDeleted(),\n          files: this.collab.excalidrawAPI.getFiles()\n        });\n      } catch (error) {\n        if (error.name !== \"AbortError\") {\n          this.collab.excalidrawAPI.updateScene({\n            appState: {\n              errorMessage: error.message\n            }\n          });\n        }\n      }\n      this.collab.excalidrawAPI.updateScene({\n        elements: this.collab.excalidrawAPI.getSceneElementsIncludingDeleted().map(element => {\n          if (this.collab.fileManager.shouldUpdateImageElementStatus(element)) {\n            // this will signal collaborators to pull image data from server\n            // (using mutation instead of newElementWith otherwise it'd break\n            // in-progress dragging)\n            return newElementWith(element, {\n              status: \"saved\"\n            });\n          }\n          return element;\n        })\n      });\n    }, FILE_UPLOAD_TIMEOUT);\n    this.broadcastScene = async (updateType, allElements, syncAll) => {\n      if (updateType === WS_SCENE_EVENT_TYPES.INIT && !syncAll) {\n        throw new Error(\"syncAll must be true when sending SCENE.INIT\");\n      }\n\n      // sync out only the elements we think we need to to save bandwidth.\n      // periodically we'll resync the whole thing to make sure no one diverges\n      // due to a dropped message (server goes down etc).\n      const syncableElements = allElements.reduce((acc, element, idx, elements) => {\n        if ((syncAll || !this.broadcastedElementVersions.has(element.id) || element.version > this.broadcastedElementVersions.get(element.id)) && isSyncableElement(element)) {\n          var _elements;\n          acc.push({\n            ...element,\n            // z-index info for the reconciler\n            [PRECEDING_ELEMENT_KEY]: idx === 0 ? \"^\" : (_elements = elements[idx - 1]) === null || _elements === void 0 ? void 0 : _elements.id\n          });\n        }\n        return acc;\n      }, []);\n      const data = {\n        type: updateType,\n        payload: {\n          elements: syncableElements\n        }\n      };\n      for (const syncableElement of syncableElements) {\n        this.broadcastedElementVersions.set(syncableElement.id, syncableElement.version);\n      }\n      this.queueFileUpload();\n      await this._broadcastSocketData(data);\n    };\n    this.broadcastIdleChange = userState => {\n      var _this$socket;\n      if ((_this$socket = this.socket) !== null && _this$socket !== void 0 && _this$socket.id) {\n        const data = {\n          type: \"IDLE_STATUS\",\n          payload: {\n            socketId: this.socket.id,\n            userState,\n            username: this.collab.state.username\n          }\n        };\n        return this._broadcastSocketData(data, true // volatile\n        );\n      }\n    };\n    this.broadcastMouseLocation = payload => {\n      var _this$socket2;\n      if ((_this$socket2 = this.socket) !== null && _this$socket2 !== void 0 && _this$socket2.id) {\n        const data = {\n          type: \"MOUSE_LOCATION\",\n          payload: {\n            socketId: this.socket.id,\n            pointer: payload.pointer,\n            button: payload.button || \"up\",\n            selectedElementIds: this.collab.excalidrawAPI.getAppState().selectedElementIds,\n            username: this.collab.state.username\n          }\n        };\n        return this._broadcastSocketData(data, true // volatile\n        );\n      }\n    };\n    this.collab = collab;\n  }\n  open(socket, id, key) {\n    this.socket = socket;\n    this.roomId = id;\n    this.roomKey = key;\n\n    // Initialize socket listeners\n    this.socket.on(\"init-room\", () => {\n      if (this.socket) {\n        this.socket.emit(\"join-room\", this.roomId);\n        trackEvent(\"share\", \"room joined\");\n      }\n    });\n    this.socket.on(\"new-user\", async _socketId => {\n      this.broadcastScene(WS_SCENE_EVENT_TYPES.INIT, this.collab.getSceneElementsIncludingDeleted(), /* syncAll */true);\n    });\n    this.socket.on(\"room-user-change\", clients => {\n      this.collab.setCollaborators(clients);\n    });\n    return socket;\n  }\n  close() {\n    if (!this.socket) {\n      return;\n    }\n    this.queueFileUpload.flush();\n    this.socket.close();\n    this.socket = null;\n    this.roomId = null;\n    this.roomKey = null;\n    this.socketInitialized = false;\n    this.broadcastedElementVersions = new Map();\n  }\n  isOpen() {\n    return !!(this.socketInitialized && this.socket && this.roomId && this.roomKey);\n  }\n  async _broadcastSocketData(data) {\n    let volatile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this.isOpen()) {\n      var _this$socket3;\n      const json = JSON.stringify(data);\n      const encoded = new TextEncoder().encode(json);\n      const {\n        encryptedBuffer,\n        iv\n      } = await encryptData(this.roomKey, encoded);\n      (_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.emit(volatile ? WS_EVENTS.SERVER_VOLATILE : WS_EVENTS.SERVER, this.roomId, encryptedBuffer, iv);\n    }\n  }\n}\nexport default Portal;","map":{"version":3,"names":["isSyncableElement","WS_EVENTS","FILE_UPLOAD_TIMEOUT","WS_SCENE_EVENT_TYPES","trackEvent","throttle","newElementWith","encryptData","PRECEDING_ELEMENT_KEY","Portal","constructor","collab","socket","socketInitialized","roomId","roomKey","broadcastedElementVersions","Map","queueFileUpload","fileManager","saveFiles","elements","excalidrawAPI","getSceneElementsIncludingDeleted","files","getFiles","error","name","updateScene","appState","errorMessage","message","map","element","shouldUpdateImageElementStatus","status","broadcastScene","updateType","allElements","syncAll","INIT","Error","syncableElements","reduce","acc","idx","has","id","version","get","_elements","push","data","type","payload","syncableElement","set","_broadcastSocketData","broadcastIdleChange","userState","_this$socket","socketId","username","state","broadcastMouseLocation","_this$socket2","pointer","button","selectedElementIds","getAppState","open","key","on","emit","_socketId","clients","setCollaborators","close","flush","isOpen","volatile","arguments","length","undefined","_this$socket3","json","JSON","stringify","encoded","TextEncoder","encode","encryptedBuffer","iv","SERVER_VOLATILE","SERVER"],"sources":["D:/project/excalidraw-cn/src/excalidraw-app/collab/Portal.tsx"],"sourcesContent":["import {\n  isSyncableElement,\n  SocketUpdateData,\n  SocketUpdateDataSource,\n} from \"../data\";\n\nimport { TCollabClass } from \"./Collab\";\n\nimport { ExcalidrawElement } from \"../../element/types\";\nimport {\n  WS_EVENTS,\n  FILE_UPLOAD_TIMEOUT,\n  WS_SCENE_EVENT_TYPES,\n} from \"../app_constants\";\nimport { UserIdleState } from \"../../types\";\nimport { trackEvent } from \"../../analytics\";\nimport throttle from \"lodash.throttle\";\nimport { newElementWith } from \"../../element/mutateElement\";\nimport { BroadcastedExcalidrawElement } from \"./reconciliation\";\nimport { encryptData } from \"../../data/encryption\";\nimport { PRECEDING_ELEMENT_KEY } from \"../../constants\";\n\nclass Portal {\n  collab: TCollabClass;\n  socket: SocketIOClient.Socket | null = null;\n  socketInitialized: boolean = false; // we don't want the socket to emit any updates until it is fully initialized\n  roomId: string | null = null;\n  roomKey: string | null = null;\n  broadcastedElementVersions: Map<string, number> = new Map();\n\n  constructor(collab: TCollabClass) {\n    this.collab = collab;\n  }\n\n  open(socket: SocketIOClient.Socket, id: string, key: string) {\n    this.socket = socket;\n    this.roomId = id;\n    this.roomKey = key;\n\n    // Initialize socket listeners\n    this.socket.on(\"init-room\", () => {\n      if (this.socket) {\n        this.socket.emit(\"join-room\", this.roomId);\n        trackEvent(\"share\", \"room joined\");\n      }\n    });\n    this.socket.on(\"new-user\", async (_socketId: string) => {\n      this.broadcastScene(\n        WS_SCENE_EVENT_TYPES.INIT,\n        this.collab.getSceneElementsIncludingDeleted(),\n        /* syncAll */ true,\n      );\n    });\n    this.socket.on(\"room-user-change\", (clients: string[]) => {\n      this.collab.setCollaborators(clients);\n    });\n\n    return socket;\n  }\n\n  close() {\n    if (!this.socket) {\n      return;\n    }\n    this.queueFileUpload.flush();\n    this.socket.close();\n    this.socket = null;\n    this.roomId = null;\n    this.roomKey = null;\n    this.socketInitialized = false;\n    this.broadcastedElementVersions = new Map();\n  }\n\n  isOpen() {\n    return !!(\n      this.socketInitialized &&\n      this.socket &&\n      this.roomId &&\n      this.roomKey\n    );\n  }\n\n  async _broadcastSocketData(\n    data: SocketUpdateData,\n    volatile: boolean = false,\n  ) {\n    if (this.isOpen()) {\n      const json = JSON.stringify(data);\n      const encoded = new TextEncoder().encode(json);\n      const { encryptedBuffer, iv } = await encryptData(this.roomKey!, encoded);\n\n      this.socket?.emit(\n        volatile ? WS_EVENTS.SERVER_VOLATILE : WS_EVENTS.SERVER,\n        this.roomId,\n        encryptedBuffer,\n        iv,\n      );\n    }\n  }\n\n  queueFileUpload = throttle(async () => {\n    try {\n      await this.collab.fileManager.saveFiles({\n        elements: this.collab.excalidrawAPI.getSceneElementsIncludingDeleted(),\n        files: this.collab.excalidrawAPI.getFiles(),\n      });\n    } catch (error: any) {\n      if (error.name !== \"AbortError\") {\n        this.collab.excalidrawAPI.updateScene({\n          appState: {\n            errorMessage: error.message,\n          },\n        });\n      }\n    }\n\n    this.collab.excalidrawAPI.updateScene({\n      elements: this.collab.excalidrawAPI\n        .getSceneElementsIncludingDeleted()\n        .map((element) => {\n          if (this.collab.fileManager.shouldUpdateImageElementStatus(element)) {\n            // this will signal collaborators to pull image data from server\n            // (using mutation instead of newElementWith otherwise it'd break\n            // in-progress dragging)\n            return newElementWith(element, { status: \"saved\" });\n          }\n          return element;\n        }),\n    });\n  }, FILE_UPLOAD_TIMEOUT);\n\n  broadcastScene = async (\n    updateType: WS_SCENE_EVENT_TYPES.INIT | WS_SCENE_EVENT_TYPES.UPDATE,\n    allElements: readonly ExcalidrawElement[],\n    syncAll: boolean,\n  ) => {\n    if (updateType === WS_SCENE_EVENT_TYPES.INIT && !syncAll) {\n      throw new Error(\"syncAll must be true when sending SCENE.INIT\");\n    }\n\n    // sync out only the elements we think we need to to save bandwidth.\n    // periodically we'll resync the whole thing to make sure no one diverges\n    // due to a dropped message (server goes down etc).\n    const syncableElements = allElements.reduce(\n      (acc, element: BroadcastedExcalidrawElement, idx, elements) => {\n        if (\n          (syncAll ||\n            !this.broadcastedElementVersions.has(element.id) ||\n            element.version >\n              this.broadcastedElementVersions.get(element.id)!) &&\n          isSyncableElement(element)\n        ) {\n          acc.push({\n            ...element,\n            // z-index info for the reconciler\n            [PRECEDING_ELEMENT_KEY]: idx === 0 ? \"^\" : elements[idx - 1]?.id,\n          });\n        }\n        return acc;\n      },\n      [] as BroadcastedExcalidrawElement[],\n    );\n\n    const data: SocketUpdateDataSource[typeof updateType] = {\n      type: updateType,\n      payload: {\n        elements: syncableElements,\n      },\n    };\n\n    for (const syncableElement of syncableElements) {\n      this.broadcastedElementVersions.set(\n        syncableElement.id,\n        syncableElement.version,\n      );\n    }\n\n    this.queueFileUpload();\n\n    await this._broadcastSocketData(data as SocketUpdateData);\n  };\n\n  broadcastIdleChange = (userState: UserIdleState) => {\n    if (this.socket?.id) {\n      const data: SocketUpdateDataSource[\"IDLE_STATUS\"] = {\n        type: \"IDLE_STATUS\",\n        payload: {\n          socketId: this.socket.id,\n          userState,\n          username: this.collab.state.username,\n        },\n      };\n      return this._broadcastSocketData(\n        data as SocketUpdateData,\n        true, // volatile\n      );\n    }\n  };\n\n  broadcastMouseLocation = (payload: {\n    pointer: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"pointer\"];\n    button: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"button\"];\n  }) => {\n    if (this.socket?.id) {\n      const data: SocketUpdateDataSource[\"MOUSE_LOCATION\"] = {\n        type: \"MOUSE_LOCATION\",\n        payload: {\n          socketId: this.socket.id,\n          pointer: payload.pointer,\n          button: payload.button || \"up\",\n          selectedElementIds:\n            this.collab.excalidrawAPI.getAppState().selectedElementIds,\n          username: this.collab.state.username,\n        },\n      };\n      return this._broadcastSocketData(\n        data as SocketUpdateData,\n        true, // volatile\n      );\n    }\n  };\n}\n\nexport default Portal;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}