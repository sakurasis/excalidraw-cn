{"ast":null,"code":"/**\n * This file deals with saving data state (appState, elements, images, ...)\n * locally to the browser.\n *\n * Notes:\n *\n * - DataState refers to full state of the app: appState, elements, images,\n *   though some state is saved separately (collab username, library) for one\n *   reason or another. We also save different data to different sotrage\n *   (localStorage, indexedDB).\n */\n\nimport { createStore, entries, del, getMany, set, setMany } from \"idb-keyval\";\nimport { clearAppStateForLocalStorage } from \"../../appState\";\nimport { clearElementsForLocalStorage } from \"../../element\";\nimport { debounce } from \"../../utils\";\nimport { SAVE_TO_LOCAL_STORAGE_TIMEOUT, STORAGE_KEYS } from \"../app_constants\";\nimport { FileManager } from \"./FileManager\";\nimport { Locker } from \"./Locker\";\nimport { updateBrowserStateVersion } from \"./tabSync\";\nconst filesStore = createStore(\"files-db\", \"files-store\");\nclass LocalFileManager extends FileManager {\n  constructor() {\n    super(...arguments);\n    this.clearObsoleteFiles = async opts => {\n      await entries(filesStore).then(entries => {\n        for (const [id, imageData] of entries) {\n          // if image is unused (not on canvas) & is older than 1 day, delete it\n          // from storage. We check `lastRetrieved` we care about the last time\n          // the image was used (loaded on canvas), not when it was initially\n          // created.\n          if ((!imageData.lastRetrieved || Date.now() - imageData.lastRetrieved > 24 * 3600 * 1000) && !opts.currentFileIds.includes(id)) {\n            del(id, filesStore);\n          }\n        }\n      });\n    };\n  }\n}\nconst saveDataStateToLocalStorage = (elements, appState) => {\n  try {\n    localStorage.setItem(STORAGE_KEYS.LOCAL_STORAGE_ELEMENTS, JSON.stringify(clearElementsForLocalStorage(elements)));\n    localStorage.setItem(STORAGE_KEYS.LOCAL_STORAGE_APP_STATE, JSON.stringify(clearAppStateForLocalStorage(appState)));\n    updateBrowserStateVersion(STORAGE_KEYS.VERSION_DATA_STATE);\n  } catch (error) {\n    // Unable to access window.localStorage\n    console.error(error);\n  }\n};\nexport class LocalData {}\nLocalData._save = debounce(async (elements, appState, files, onFilesSaved) => {\n  saveDataStateToLocalStorage(elements, appState);\n  await LocalData.fileStorage.saveFiles({\n    elements,\n    files\n  });\n  onFilesSaved();\n}, SAVE_TO_LOCAL_STORAGE_TIMEOUT);\n/** Saves DataState, including files. Bails if saving is paused */\nLocalData.save = (elements, appState, files, onFilesSaved) => {\n  // we need to make the `isSavePaused` check synchronously (undebounced)\n  if (!LocalData.isSavePaused()) {\n    LocalData._save(elements, appState, files, onFilesSaved);\n  }\n};\nLocalData.flushSave = () => {\n  LocalData._save.flush();\n};\nLocalData.locker = new Locker();\nLocalData.pauseSave = lockType => {\n  LocalData.locker.lock(lockType);\n};\nLocalData.resumeSave = lockType => {\n  LocalData.locker.unlock(lockType);\n};\nLocalData.isSavePaused = () => {\n  return document.hidden || LocalData.locker.isLocked();\n};\n// ---------------------------------------------------------------------------\nLocalData.fileStorage = new LocalFileManager({\n  getFiles(ids) {\n    return getMany(ids, filesStore).then(async filesData => {\n      const loadedFiles = [];\n      const erroredFiles = new Map();\n      const filesToSave = [];\n      filesData.forEach((data, index) => {\n        const id = ids[index];\n        if (data) {\n          const _data = {\n            ...data,\n            lastRetrieved: Date.now()\n          };\n          filesToSave.push([id, _data]);\n          loadedFiles.push(_data);\n        } else {\n          erroredFiles.set(id, true);\n        }\n      });\n      try {\n        // save loaded files back to storage with updated `lastRetrieved`\n        setMany(filesToSave, filesStore);\n      } catch (error) {\n        console.warn(error);\n      }\n      return {\n        loadedFiles,\n        erroredFiles\n      };\n    });\n  },\n  async saveFiles(_ref) {\n    let {\n      addedFiles\n    } = _ref;\n    const savedFiles = new Map();\n    const erroredFiles = new Map();\n\n    // before we use `storage` event synchronization, let's update the flag\n    // optimistically. Hopefully nothing fails, and an IDB read executed\n    // before an IDB write finishes will read the latest value.\n    updateBrowserStateVersion(STORAGE_KEYS.VERSION_FILES);\n    await Promise.all([...addedFiles].map(async _ref2 => {\n      let [id, fileData] = _ref2;\n      try {\n        await set(id, fileData, filesStore);\n        savedFiles.set(id, true);\n      } catch (error) {\n        console.error(error);\n        erroredFiles.set(id, true);\n      }\n    }));\n    return {\n      savedFiles,\n      erroredFiles\n    };\n  }\n});","map":{"version":3,"names":["createStore","entries","del","getMany","set","setMany","clearAppStateForLocalStorage","clearElementsForLocalStorage","debounce","SAVE_TO_LOCAL_STORAGE_TIMEOUT","STORAGE_KEYS","FileManager","Locker","updateBrowserStateVersion","filesStore","LocalFileManager","constructor","arguments","clearObsoleteFiles","opts","then","id","imageData","lastRetrieved","Date","now","currentFileIds","includes","saveDataStateToLocalStorage","elements","appState","localStorage","setItem","LOCAL_STORAGE_ELEMENTS","JSON","stringify","LOCAL_STORAGE_APP_STATE","VERSION_DATA_STATE","error","console","LocalData","_save","files","onFilesSaved","fileStorage","saveFiles","save","isSavePaused","flushSave","flush","locker","pauseSave","lockType","lock","resumeSave","unlock","document","hidden","isLocked","getFiles","ids","filesData","loadedFiles","erroredFiles","Map","filesToSave","forEach","data","index","_data","push","warn","_ref","addedFiles","savedFiles","VERSION_FILES","Promise","all","map","_ref2","fileData"],"sources":["D:/project/excalidraw-cn/src/excalidraw-app/data/LocalData.ts"],"sourcesContent":["/**\n * This file deals with saving data state (appState, elements, images, ...)\n * locally to the browser.\n *\n * Notes:\n *\n * - DataState refers to full state of the app: appState, elements, images,\n *   though some state is saved separately (collab username, library) for one\n *   reason or another. We also save different data to different sotrage\n *   (localStorage, indexedDB).\n */\n\nimport { createStore, entries, del, getMany, set, setMany } from \"idb-keyval\";\nimport { clearAppStateForLocalStorage } from \"../../appState\";\nimport { clearElementsForLocalStorage } from \"../../element\";\nimport { ExcalidrawElement, FileId } from \"../../element/types\";\nimport { AppState, BinaryFileData, BinaryFiles } from \"../../types\";\nimport { debounce } from \"../../utils\";\nimport { SAVE_TO_LOCAL_STORAGE_TIMEOUT, STORAGE_KEYS } from \"../app_constants\";\nimport { FileManager } from \"./FileManager\";\nimport { Locker } from \"./Locker\";\nimport { updateBrowserStateVersion } from \"./tabSync\";\n\nconst filesStore = createStore(\"files-db\", \"files-store\");\n\nclass LocalFileManager extends FileManager {\n  clearObsoleteFiles = async (opts: { currentFileIds: FileId[] }) => {\n    await entries(filesStore).then((entries) => {\n      for (const [id, imageData] of entries as [FileId, BinaryFileData][]) {\n        // if image is unused (not on canvas) & is older than 1 day, delete it\n        // from storage. We check `lastRetrieved` we care about the last time\n        // the image was used (loaded on canvas), not when it was initially\n        // created.\n        if (\n          (!imageData.lastRetrieved ||\n            Date.now() - imageData.lastRetrieved > 24 * 3600 * 1000) &&\n          !opts.currentFileIds.includes(id as FileId)\n        ) {\n          del(id, filesStore);\n        }\n      }\n    });\n  };\n}\n\nconst saveDataStateToLocalStorage = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  try {\n    localStorage.setItem(\n      STORAGE_KEYS.LOCAL_STORAGE_ELEMENTS,\n      JSON.stringify(clearElementsForLocalStorage(elements)),\n    );\n    localStorage.setItem(\n      STORAGE_KEYS.LOCAL_STORAGE_APP_STATE,\n      JSON.stringify(clearAppStateForLocalStorage(appState)),\n    );\n    updateBrowserStateVersion(STORAGE_KEYS.VERSION_DATA_STATE);\n  } catch (error: any) {\n    // Unable to access window.localStorage\n    console.error(error);\n  }\n};\n\ntype SavingLockTypes = \"collaboration\";\n\nexport class LocalData {\n  private static _save = debounce(\n    async (\n      elements: readonly ExcalidrawElement[],\n      appState: AppState,\n      files: BinaryFiles,\n      onFilesSaved: () => void,\n    ) => {\n      saveDataStateToLocalStorage(elements, appState);\n\n      await this.fileStorage.saveFiles({\n        elements,\n        files,\n      });\n      onFilesSaved();\n    },\n    SAVE_TO_LOCAL_STORAGE_TIMEOUT,\n  );\n\n  /** Saves DataState, including files. Bails if saving is paused */\n  static save = (\n    elements: readonly ExcalidrawElement[],\n    appState: AppState,\n    files: BinaryFiles,\n    onFilesSaved: () => void,\n  ) => {\n    // we need to make the `isSavePaused` check synchronously (undebounced)\n    if (!this.isSavePaused()) {\n      this._save(elements, appState, files, onFilesSaved);\n    }\n  };\n\n  static flushSave = () => {\n    this._save.flush();\n  };\n\n  private static locker = new Locker<SavingLockTypes>();\n\n  static pauseSave = (lockType: SavingLockTypes) => {\n    this.locker.lock(lockType);\n  };\n\n  static resumeSave = (lockType: SavingLockTypes) => {\n    this.locker.unlock(lockType);\n  };\n\n  static isSavePaused = () => {\n    return document.hidden || this.locker.isLocked();\n  };\n\n  // ---------------------------------------------------------------------------\n\n  static fileStorage = new LocalFileManager({\n    getFiles(ids) {\n      return getMany(ids, filesStore).then(\n        async (filesData: (BinaryFileData | undefined)[]) => {\n          const loadedFiles: BinaryFileData[] = [];\n          const erroredFiles = new Map<FileId, true>();\n\n          const filesToSave: [FileId, BinaryFileData][] = [];\n\n          filesData.forEach((data, index) => {\n            const id = ids[index];\n            if (data) {\n              const _data: BinaryFileData = {\n                ...data,\n                lastRetrieved: Date.now(),\n              };\n              filesToSave.push([id, _data]);\n              loadedFiles.push(_data);\n            } else {\n              erroredFiles.set(id, true);\n            }\n          });\n\n          try {\n            // save loaded files back to storage with updated `lastRetrieved`\n            setMany(filesToSave, filesStore);\n          } catch (error) {\n            console.warn(error);\n          }\n\n          return { loadedFiles, erroredFiles };\n        },\n      );\n    },\n    async saveFiles({ addedFiles }) {\n      const savedFiles = new Map<FileId, true>();\n      const erroredFiles = new Map<FileId, true>();\n\n      // before we use `storage` event synchronization, let's update the flag\n      // optimistically. Hopefully nothing fails, and an IDB read executed\n      // before an IDB write finishes will read the latest value.\n      updateBrowserStateVersion(STORAGE_KEYS.VERSION_FILES);\n\n      await Promise.all(\n        [...addedFiles].map(async ([id, fileData]) => {\n          try {\n            await set(id, fileData, filesStore);\n            savedFiles.set(id, true);\n          } catch (error: any) {\n            console.error(error);\n            erroredFiles.set(id, true);\n          }\n        }),\n      );\n\n      return { savedFiles, erroredFiles };\n    },\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}