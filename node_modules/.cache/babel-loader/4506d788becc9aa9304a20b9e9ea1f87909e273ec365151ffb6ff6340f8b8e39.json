{"ast":null,"code":"var _jsxFileName = \"D:\\\\project\\\\excalidraw-cn\\\\src\\\\actions\\\\actionFinalize.tsx\";\nimport { KEYS } from \"../keys\";\nimport { isInvisiblySmallElement } from \"../element\";\nimport { updateActiveTool, resetCursor } from \"../utils\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { done } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { isPathALoop } from \"../math\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport Scene from \"../scene/Scene\";\nimport { maybeBindLinearElement, bindOrUnbindLinearElement } from \"../element/binding\";\nimport { isBindingElement, isLinearElement } from \"../element/typeChecks\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const actionFinalize = register({\n  name: \"finalize\",\n  trackEvent: false,\n  perform: (elements, appState, _, _ref) => {\n    var _appState$editingElem;\n    let {\n      canvas,\n      focusContainer,\n      scene\n    } = _ref;\n    if (appState.editingLinearElement) {\n      const {\n        elementId,\n        startBindingElement,\n        endBindingElement\n      } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n      if (element) {\n        if (isBindingElement(element)) {\n          bindOrUnbindLinearElement(element, startBindingElement, endBindingElement);\n        }\n        return {\n          elements: element.points.length < 2 || isInvisiblySmallElement(element) ? elements.filter(el => el.id !== element.id) : undefined,\n          appState: {\n            ...appState,\n            cursorButton: \"up\",\n            editingLinearElement: null\n          },\n          commitToHistory: true\n        };\n      }\n    }\n    let newElements = elements;\n    const pendingImageElement = appState.pendingImageElementId && scene.getElement(appState.pendingImageElementId);\n    if (pendingImageElement) {\n      mutateElement(pendingImageElement, {\n        isDeleted: true\n      }, false);\n    }\n    if (window.document.activeElement instanceof HTMLElement) {\n      focusContainer();\n    }\n    const multiPointElement = appState.multiElement ? appState.multiElement : ((_appState$editingElem = appState.editingElement) === null || _appState$editingElem === void 0 ? void 0 : _appState$editingElem.type) === \"freedraw\" ? appState.editingElement : null;\n    if (multiPointElement) {\n      // pen and mouse have hover\n      if (multiPointElement.type !== \"freedraw\" && appState.lastPointerDownWith !== \"touch\") {\n        const {\n          points,\n          lastCommittedPoint\n        } = multiPointElement;\n        if (!lastCommittedPoint || points[points.length - 1] !== lastCommittedPoint) {\n          mutateElement(multiPointElement, {\n            points: multiPointElement.points.slice(0, -1)\n          });\n        }\n      }\n      if (isInvisiblySmallElement(multiPointElement)) {\n        newElements = newElements.slice(0, -1);\n      }\n\n      // If the multi point line closes the loop,\n      // set the last point to first point.\n      // This ensures that loop remains closed at different scales.\n      const isLoop = isPathALoop(multiPointElement.points, appState.zoom.value);\n      if (multiPointElement.type === \"line\" || multiPointElement.type === \"freedraw\") {\n        if (isLoop) {\n          const linePoints = multiPointElement.points;\n          const firstPoint = linePoints[0];\n          mutateElement(multiPointElement, {\n            points: linePoints.map((point, index) => index === linePoints.length - 1 ? [firstPoint[0], firstPoint[1]] : point)\n          });\n        }\n      }\n      if (isBindingElement(multiPointElement) && !isLoop && multiPointElement.points.length > 1) {\n        const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(multiPointElement, -1);\n        maybeBindLinearElement(multiPointElement, appState, Scene.getScene(multiPointElement), {\n          x,\n          y\n        });\n      }\n    }\n    if (!appState.activeTool.locked && appState.activeTool.type !== \"freedraw\" || !multiPointElement) {\n      resetCursor(canvas);\n    }\n    let activeTool;\n    if (appState.activeTool.type === \"eraser\") {\n      activeTool = updateActiveTool(appState, {\n        ...(appState.activeTool.lastActiveTool || {\n          type: \"selection\"\n        }),\n        lastActiveToolBeforeEraser: null\n      });\n    } else {\n      activeTool = updateActiveTool(appState, {\n        type: \"selection\"\n      });\n    }\n    return {\n      elements: newElements,\n      appState: {\n        ...appState,\n        cursorButton: \"up\",\n        activeTool: (appState.activeTool.locked || appState.activeTool.type === \"freedraw\") && multiPointElement ? appState.activeTool : activeTool,\n        draggingElement: null,\n        multiElement: null,\n        editingElement: null,\n        startBoundElement: null,\n        suggestedBindings: [],\n        selectedElementIds: multiPointElement && !appState.activeTool.locked && appState.activeTool.type !== \"freedraw\" ? {\n          ...appState.selectedElementIds,\n          [multiPointElement.id]: true\n        } : appState.selectedElementIds,\n        // To select the linear element when user has finished mutipoint editing\n        selectedLinearElement: multiPointElement && isLinearElement(multiPointElement) ? new LinearElementEditor(multiPointElement, scene) : appState.selectedLinearElement,\n        pendingImageElementId: null\n      },\n      commitToHistory: appState.activeTool.type === \"freedraw\"\n    };\n  },\n  keyTest: (event, appState) => event.key === KEYS.ESCAPE && (appState.editingLinearElement !== null || !appState.draggingElement && appState.multiElement === null) || (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) && appState.multiElement !== null,\n  PanelComponent: _ref2 => {\n    let {\n      appState,\n      updateData,\n      data\n    } = _ref2;\n    return /*#__PURE__*/_jsxDEV(ToolButton, {\n      type: \"button\",\n      icon: done,\n      title: t(\"buttons.done\"),\n      \"aria-label\": t(\"buttons.done\"),\n      onClick: updateData,\n      visible: appState.multiElement != null,\n      size: (data === null || data === void 0 ? void 0 : data.size) || \"medium\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 194,\n      columnNumber: 5\n    }, this);\n  }\n});","map":{"version":3,"names":["KEYS","isInvisiblySmallElement","updateActiveTool","resetCursor","ToolButton","done","t","register","mutateElement","isPathALoop","LinearElementEditor","Scene","maybeBindLinearElement","bindOrUnbindLinearElement","isBindingElement","isLinearElement","jsxDEV","_jsxDEV","actionFinalize","name","trackEvent","perform","elements","appState","_","_ref","_appState$editingElem","canvas","focusContainer","scene","editingLinearElement","elementId","startBindingElement","endBindingElement","element","getElement","points","length","filter","el","id","undefined","cursorButton","commitToHistory","newElements","pendingImageElement","pendingImageElementId","isDeleted","window","document","activeElement","HTMLElement","multiPointElement","multiElement","editingElement","type","lastPointerDownWith","lastCommittedPoint","slice","isLoop","zoom","value","linePoints","firstPoint","map","point","index","x","y","getPointAtIndexGlobalCoordinates","getScene","activeTool","locked","lastActiveTool","lastActiveToolBeforeEraser","draggingElement","startBoundElement","suggestedBindings","selectedElementIds","selectedLinearElement","keyTest","event","key","ESCAPE","ENTER","PanelComponent","_ref2","updateData","data","icon","title","onClick","visible","size","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["D:/project/excalidraw-cn/src/actions/actionFinalize.tsx"],"sourcesContent":["import { KEYS } from \"../keys\";\nimport { isInvisiblySmallElement } from \"../element\";\nimport { updateActiveTool, resetCursor } from \"../utils\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { done } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { isPathALoop } from \"../math\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport Scene from \"../scene/Scene\";\nimport {\n  maybeBindLinearElement,\n  bindOrUnbindLinearElement,\n} from \"../element/binding\";\nimport { isBindingElement, isLinearElement } from \"../element/typeChecks\";\nimport { AppState } from \"../types\";\n\nexport const actionFinalize = register({\n  name: \"finalize\",\n  trackEvent: false,\n  perform: (elements, appState, _, { canvas, focusContainer, scene }) => {\n    if (appState.editingLinearElement) {\n      const { elementId, startBindingElement, endBindingElement } =\n        appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n\n      if (element) {\n        if (isBindingElement(element)) {\n          bindOrUnbindLinearElement(\n            element,\n            startBindingElement,\n            endBindingElement,\n          );\n        }\n        return {\n          elements:\n            element.points.length < 2 || isInvisiblySmallElement(element)\n              ? elements.filter((el) => el.id !== element.id)\n              : undefined,\n          appState: {\n            ...appState,\n            cursorButton: \"up\",\n            editingLinearElement: null,\n          },\n          commitToHistory: true,\n        };\n      }\n    }\n\n    let newElements = elements;\n\n    const pendingImageElement =\n      appState.pendingImageElementId &&\n      scene.getElement(appState.pendingImageElementId);\n\n    if (pendingImageElement) {\n      mutateElement(pendingImageElement, { isDeleted: true }, false);\n    }\n\n    if (window.document.activeElement instanceof HTMLElement) {\n      focusContainer();\n    }\n\n    const multiPointElement = appState.multiElement\n      ? appState.multiElement\n      : appState.editingElement?.type === \"freedraw\"\n      ? appState.editingElement\n      : null;\n\n    if (multiPointElement) {\n      // pen and mouse have hover\n      if (\n        multiPointElement.type !== \"freedraw\" &&\n        appState.lastPointerDownWith !== \"touch\"\n      ) {\n        const { points, lastCommittedPoint } = multiPointElement;\n        if (\n          !lastCommittedPoint ||\n          points[points.length - 1] !== lastCommittedPoint\n        ) {\n          mutateElement(multiPointElement, {\n            points: multiPointElement.points.slice(0, -1),\n          });\n        }\n      }\n      if (isInvisiblySmallElement(multiPointElement)) {\n        newElements = newElements.slice(0, -1);\n      }\n\n      // If the multi point line closes the loop,\n      // set the last point to first point.\n      // This ensures that loop remains closed at different scales.\n      const isLoop = isPathALoop(multiPointElement.points, appState.zoom.value);\n      if (\n        multiPointElement.type === \"line\" ||\n        multiPointElement.type === \"freedraw\"\n      ) {\n        if (isLoop) {\n          const linePoints = multiPointElement.points;\n          const firstPoint = linePoints[0];\n          mutateElement(multiPointElement, {\n            points: linePoints.map((point, index) =>\n              index === linePoints.length - 1\n                ? ([firstPoint[0], firstPoint[1]] as const)\n                : point,\n            ),\n          });\n        }\n      }\n\n      if (\n        isBindingElement(multiPointElement) &&\n        !isLoop &&\n        multiPointElement.points.length > 1\n      ) {\n        const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n          multiPointElement,\n          -1,\n        );\n        maybeBindLinearElement(\n          multiPointElement,\n          appState,\n          Scene.getScene(multiPointElement)!,\n          { x, y },\n        );\n      }\n    }\n\n    if (\n      (!appState.activeTool.locked &&\n        appState.activeTool.type !== \"freedraw\") ||\n      !multiPointElement\n    ) {\n      resetCursor(canvas);\n    }\n\n    let activeTool: AppState[\"activeTool\"];\n    if (appState.activeTool.type === \"eraser\") {\n      activeTool = updateActiveTool(appState, {\n        ...(appState.activeTool.lastActiveTool || {\n          type: \"selection\",\n        }),\n        lastActiveToolBeforeEraser: null,\n      });\n    } else {\n      activeTool = updateActiveTool(appState, {\n        type: \"selection\",\n      });\n    }\n\n    return {\n      elements: newElements,\n      appState: {\n        ...appState,\n        cursorButton: \"up\",\n        activeTool:\n          (appState.activeTool.locked ||\n            appState.activeTool.type === \"freedraw\") &&\n          multiPointElement\n            ? appState.activeTool\n            : activeTool,\n        draggingElement: null,\n        multiElement: null,\n        editingElement: null,\n        startBoundElement: null,\n        suggestedBindings: [],\n        selectedElementIds:\n          multiPointElement &&\n          !appState.activeTool.locked &&\n          appState.activeTool.type !== \"freedraw\"\n            ? {\n                ...appState.selectedElementIds,\n                [multiPointElement.id]: true,\n              }\n            : appState.selectedElementIds,\n        // To select the linear element when user has finished mutipoint editing\n        selectedLinearElement:\n          multiPointElement && isLinearElement(multiPointElement)\n            ? new LinearElementEditor(multiPointElement, scene)\n            : appState.selectedLinearElement,\n        pendingImageElementId: null,\n      },\n      commitToHistory: appState.activeTool.type === \"freedraw\",\n    };\n  },\n  keyTest: (event, appState) =>\n    (event.key === KEYS.ESCAPE &&\n      (appState.editingLinearElement !== null ||\n        (!appState.draggingElement && appState.multiElement === null))) ||\n    ((event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) &&\n      appState.multiElement !== null),\n  PanelComponent: ({ appState, updateData, data }) => (\n    <ToolButton\n      type=\"button\"\n      icon={done}\n      title={t(\"buttons.done\")}\n      aria-label={t(\"buttons.done\")}\n      onClick={updateData}\n      visible={appState.multiElement != null}\n      size={data?.size || \"medium\"}\n    />\n  ),\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}