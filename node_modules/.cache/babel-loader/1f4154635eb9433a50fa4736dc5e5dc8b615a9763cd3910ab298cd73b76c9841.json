{"ast":null,"code":"import * as GA from \"../ga\";\nimport * as GAPoint from \"../gapoints\";\nimport * as GADirection from \"../gadirections\";\nimport * as GALine from \"../galines\";\nimport * as GATransform from \"../gatransforms\";\nimport { distance2d, rotatePoint, isPathALoop, isPointInPolygon, rotate } from \"../math\";\nimport { pointsOnBezierCurves } from \"points-on-curve\";\nimport { getElementAbsoluteCoords, getCurvePathOps, getRectangleBoxAbsoluteCoords } from \"./bounds\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\nimport { hasBoundTextElement, isImageElement } from \"./typeChecks\";\nimport { isTextElement } from \".\";\nimport { isTransparent } from \"../utils\";\nimport { shouldShowBoundingBox } from \"./transformHandles\";\nimport { getBoundTextElement } from \"./textElement\";\nconst isElementDraggableFromInside = element => {\n  if (element.type === \"arrow\") {\n    return false;\n  }\n  if (element.type === \"freedraw\") {\n    return true;\n  }\n  const isDraggableFromInside = !isTransparent(element.backgroundColor) || hasBoundTextElement(element);\n  if (element.type === \"line\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n  return isDraggableFromInside || isImageElement(element);\n};\nexport const hitTest = (element, appState, frameNameBoundsCache, x, y) => {\n  // How many pixels off the shape boundary we still consider a hit\n  const threshold = 10 / appState.zoom.value;\n  const point = [x, y];\n  if (isElementSelected(appState, element) && shouldShowBoundingBox([element], appState)) {\n    return isPointHittingElementBoundingBox(element, point, threshold, frameNameBoundsCache);\n  }\n  const boundTextElement = getBoundTextElement(element);\n  if (boundTextElement) {\n    const isHittingBoundTextElement = hitTest(boundTextElement, appState, frameNameBoundsCache, x, y);\n    if (isHittingBoundTextElement) {\n      return true;\n    }\n  }\n  return isHittingElementNotConsideringBoundingBox(element, appState, frameNameBoundsCache, point);\n};\nexport const isHittingElementBoundingBoxWithoutHittingElement = (element, appState, frameNameBoundsCache, x, y) => {\n  const threshold = 10 / appState.zoom.value;\n\n  // So that bound text element hit is considered within bounding box of container even if its outside actual bounding box of element\n  // eg for linear elements text can be outside the element bounding box\n  const boundTextElement = getBoundTextElement(element);\n  if (boundTextElement && hitTest(boundTextElement, appState, frameNameBoundsCache, x, y)) {\n    return false;\n  }\n  return !isHittingElementNotConsideringBoundingBox(element, appState, frameNameBoundsCache, [x, y]) && isPointHittingElementBoundingBox(element, [x, y], threshold, frameNameBoundsCache);\n};\nexport const isHittingElementNotConsideringBoundingBox = (element, appState, frameNameBoundsCache, point) => {\n  const threshold = 10 / appState.zoom.value;\n  const check = isTextElement(element) ? isStrictlyInside : isElementDraggableFromInside(element) ? isInsideCheck : isNearCheck;\n  return hitTestPointAgainstElement({\n    element,\n    point,\n    threshold,\n    check,\n    frameNameBoundsCache\n  });\n};\nconst isElementSelected = (appState, element) => appState.selectedElementIds[element.id];\nexport const isPointHittingElementBoundingBox = (element, _ref, threshold, frameNameBoundsCache) => {\n  let [x, y] = _ref;\n  // frames needs be checked differently so as to be able to drag it\n  // by its frame, whether it has been selected or not\n  // this logic here is not ideal\n  // TODO: refactor it later...\n  if (element.type === \"frame\") {\n    return hitTestPointAgainstElement({\n      element,\n      point: [x, y],\n      threshold,\n      check: isInsideCheck,\n      frameNameBoundsCache\n    });\n  }\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const elementCenterX = (x1 + x2) / 2;\n  const elementCenterY = (y1 + y2) / 2;\n  // reverse rotate to take element's angle into account.\n  const [rotatedX, rotatedY] = rotate(x, y, elementCenterX, elementCenterY, -element.angle);\n  return rotatedX > x1 - threshold && rotatedX < x2 + threshold && rotatedY > y1 - threshold && rotatedY < y2 + threshold;\n};\nexport const bindingBorderTest = (element, _ref2) => {\n  let {\n    x,\n    y\n  } = _ref2;\n  const threshold = maxBindingGap(element, element.width, element.height);\n  const check = isOutsideCheck;\n  const point = [x, y];\n  return hitTestPointAgainstElement({\n    element,\n    point,\n    threshold,\n    check,\n    frameNameBoundsCache: null\n  });\n};\nexport const maxBindingGap = (element, elementWidth, elementHeight) => {\n  // Aligns diamonds with rectangles\n  const shapeRatio = element.type === \"diamond\" ? 1 / Math.sqrt(2) : 1;\n  const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight);\n  // We make the bindable boundary bigger for bigger elements\n  return Math.max(16, Math.min(0.25 * smallerDimension, 32));\n};\nconst hitTestPointAgainstElement = args => {\n  switch (args.element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"diamond\":\n    case \"ellipse\":\n      const distance = distanceToBindableElement(args.element, args.point);\n      return args.check(distance, args.threshold);\n    case \"freedraw\":\n      {\n        if (!args.check(distanceToRectangle(args.element, args.point), args.threshold)) {\n          return false;\n        }\n        return hitTestFreeDrawElement(args.element, args.point, args.threshold);\n      }\n    case \"arrow\":\n    case \"line\":\n      return hitTestLinear(args);\n    case \"selection\":\n      console.warn(\"This should not happen, we need to investigate why it does.\");\n      return false;\n    case \"frame\":\n      {\n        var _args$frameNameBounds;\n        // check distance to frame element first\n        if (args.check(distanceToBindableElement(args.element, args.point), args.threshold)) {\n          return true;\n        }\n        const frameNameBounds = (_args$frameNameBounds = args.frameNameBoundsCache) === null || _args$frameNameBounds === void 0 ? void 0 : _args$frameNameBounds.get(args.element);\n        if (frameNameBounds) {\n          return args.check(distanceToRectangleBox(frameNameBounds, args.point), args.threshold);\n        }\n        return false;\n      }\n  }\n};\nexport const distanceToBindableElement = (element, point) => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"frame\":\n      return distanceToRectangle(element, point);\n    case \"diamond\":\n      return distanceToDiamond(element, point);\n    case \"ellipse\":\n      return distanceToEllipse(element, point);\n  }\n};\nconst isStrictlyInside = (distance, threshold) => {\n  return distance < 0;\n};\nconst isInsideCheck = (distance, threshold) => {\n  return distance < threshold;\n};\nconst isNearCheck = (distance, threshold) => {\n  return Math.abs(distance) < threshold;\n};\nconst isOutsideCheck = (distance, threshold) => {\n  return 0 <= distance && distance < threshold;\n};\nconst distanceToRectangle = (element, point) => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  return Math.max(GAPoint.distanceToLine(pointRel, GALine.equation(0, 1, -hheight)), GAPoint.distanceToLine(pointRel, GALine.equation(1, 0, -hwidth)));\n};\nconst distanceToRectangleBox = (box, point) => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToDivElement(point, box);\n  return Math.max(GAPoint.distanceToLine(pointRel, GALine.equation(0, 1, -hheight)), GAPoint.distanceToLine(pointRel, GALine.equation(1, 0, -hwidth)));\n};\nconst distanceToDiamond = (element, point) => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const side = GALine.equation(hheight, hwidth, -hheight * hwidth);\n  return GAPoint.distanceToLine(pointRel, side);\n};\nconst distanceToEllipse = (element, point) => {\n  const [pointRel, tangent] = ellipseParamsForTest(element, point);\n  return -GALine.sign(tangent) * GAPoint.distanceToLine(pointRel, tangent);\n};\nconst ellipseParamsForTest = (element, point) => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const [px, py] = GAPoint.toTuple(pointRel);\n\n  // We're working in positive quadrant, so start with `t = 45deg`, `tx=cos(t)`\n  let tx = 0.707;\n  let ty = 0.707;\n  const a = hwidth;\n  const b = hheight;\n\n  // This is a numerical method to find the params tx, ty at which\n  // the ellipse has the closest point to the given point\n  [0, 1, 2, 3].forEach(_ => {\n    const xx = a * tx;\n    const yy = b * ty;\n    const ex = (a * a - b * b) * tx ** 3 / a;\n    const ey = (b * b - a * a) * ty ** 3 / b;\n    const rx = xx - ex;\n    const ry = yy - ey;\n    const qx = px - ex;\n    const qy = py - ey;\n    const r = Math.hypot(ry, rx);\n    const q = Math.hypot(qy, qx);\n    tx = Math.min(1, Math.max(0, (qx * r / q + ex) / a));\n    ty = Math.min(1, Math.max(0, (qy * r / q + ey) / b));\n    const t = Math.hypot(ty, tx);\n    tx /= t;\n    ty /= t;\n  });\n  const closestPoint = GA.point(a * tx, b * ty);\n  const tangent = GALine.orthogonalThrough(pointRel, closestPoint);\n  return [pointRel, tangent];\n};\nconst hitTestFreeDrawElement = (element, point, threshold) => {\n  // Check point-distance-to-line-segment for every segment in the\n  // element's points (its input points, not its outline points).\n  // This is... okay? It's plenty fast, but the GA library may\n  // have a faster option.\n\n  let x;\n  let y;\n  if (element.angle === 0) {\n    x = point[0] - element.x;\n    y = point[1] - element.y;\n  } else {\n    // Counter-rotate the point around center before testing\n    const [minX, minY, maxX, maxY] = getElementAbsoluteCoords(element);\n    const rotatedPoint = rotatePoint(point, [minX + (maxX - minX) / 2, minY + (maxY - minY) / 2], -element.angle);\n    x = rotatedPoint[0] - element.x;\n    y = rotatedPoint[1] - element.y;\n  }\n  let [A, B] = element.points;\n  let P;\n\n  // For freedraw dots\n  if (distance2d(A[0], A[1], x, y) < threshold || distance2d(B[0], B[1], x, y) < threshold) {\n    return true;\n  }\n\n  // For freedraw lines\n  for (let i = 0; i < element.points.length; i++) {\n    const delta = [B[0] - A[0], B[1] - A[1]];\n    const length = Math.hypot(delta[1], delta[0]);\n    const U = [delta[0] / length, delta[1] / length];\n    const C = [x - A[0], y - A[1]];\n    const d = (C[0] * U[0] + C[1] * U[1]) / Math.hypot(U[1], U[0]);\n    P = [A[0] + U[0] * d, A[1] + U[1] * d];\n    const da = distance2d(P[0], P[1], A[0], A[1]);\n    const db = distance2d(P[0], P[1], B[0], B[1]);\n    P = db < da && da > length ? B : da < db && db > length ? A : P;\n    if (Math.hypot(y - P[1], x - P[0]) < threshold) {\n      return true;\n    }\n    A = B;\n    B = element.points[i + 1];\n  }\n  const shape = getShapeForElement(element);\n\n  // for filled freedraw shapes, support\n  // selecting from inside\n  if (shape && shape.sets.length) {\n    return hitTestRoughShape(shape, x, y, threshold);\n  }\n  return false;\n};\nconst hitTestLinear = args => {\n  const {\n    element,\n    threshold\n  } = args;\n  if (!getShapeForElement(element)) {\n    return false;\n  }\n  const [point, pointAbs, hwidth, hheight] = pointRelativeToElement(args.element, args.point);\n  const side1 = GALine.equation(0, 1, -hheight);\n  const side2 = GALine.equation(1, 0, -hwidth);\n  if (!isInsideCheck(GAPoint.distanceToLine(pointAbs, side1), threshold) || !isInsideCheck(GAPoint.distanceToLine(pointAbs, side2), threshold)) {\n    return false;\n  }\n  const [relX, relY] = GAPoint.toTuple(point);\n  const shape = getShapeForElement(element);\n  if (!shape) {\n    return false;\n  }\n  if (args.check === isInsideCheck) {\n    const hit = shape.some(subshape => hitTestCurveInside(subshape, relX, relY, element.roundness ? \"round\" : \"sharp\"));\n    if (hit) {\n      return true;\n    }\n  }\n\n  // hit test all \"subshapes\" of the linear element\n  return shape.some(subshape => hitTestRoughShape(subshape, relX, relY, threshold));\n};\n\n// Returns:\n//   1. the point relative to the elements (x, y) position\n//   2. the point relative to the element's center with positive (x, y)\n//   3. half element width\n//   4. half element height\n//\n// Note that for linear elements the (x, y) position is not at the\n// top right corner of their boundary.\n//\n// Rectangles, diamonds and ellipses are symmetrical over axes,\n// and other elements have a rectangular boundary,\n// so we only need to perform hit tests for the positive quadrant.\nconst pointRelativeToElement = (element, pointTuple) => {\n  const point = GAPoint.from(pointTuple);\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const center = coordsCenter(x1, y1, x2, y2);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const pointRotated = GATransform.apply(rotate, point);\n  const pointRelToCenter = GA.sub(pointRotated, GADirection.from(center));\n  const pointRelToCenterAbs = GAPoint.abs(pointRelToCenter);\n  const elementPos = GA.offset(element.x, element.y);\n  const pointRelToPos = GA.sub(pointRotated, elementPos);\n  const halfWidth = (x2 - x1) / 2;\n  const halfHeight = (y2 - y1) / 2;\n  return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];\n};\nconst pointRelativeToDivElement = (pointTuple, rectangle) => {\n  const point = GAPoint.from(pointTuple);\n  const [x1, y1, x2, y2] = getRectangleBoxAbsoluteCoords(rectangle);\n  const center = coordsCenter(x1, y1, x2, y2);\n  const rotate = GATransform.rotation(center, rectangle.angle);\n  const pointRotated = GATransform.apply(rotate, point);\n  const pointRelToCenter = GA.sub(pointRotated, GADirection.from(center));\n  const pointRelToCenterAbs = GAPoint.abs(pointRelToCenter);\n  const elementPos = GA.offset(rectangle.x, rectangle.y);\n  const pointRelToPos = GA.sub(pointRotated, elementPos);\n  const halfWidth = (x2 - x1) / 2;\n  const halfHeight = (y2 - y1) / 2;\n  return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];\n};\n\n// Returns point in absolute coordinates\nexport const pointInAbsoluteCoords = (element, point) => {\n  const [x, y] = point;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2;\n  const cy = (y2 - y1) / 2;\n  const [rotatedX, rotatedY] = rotate(x, y, cx, cy, element.angle);\n  return [element.x + rotatedX, element.y + rotatedY];\n};\nconst relativizationToElementCenter = element => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const center = coordsCenter(x1, y1, x2, y2);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const translate = GA.reverse(GATransform.translation(GADirection.from(center)));\n  return GATransform.compose(rotate, translate);\n};\nconst coordsCenter = (x1, y1, x2, y2) => {\n  return GA.point((x1 + x2) / 2, (y1 + y2) / 2);\n};\n\n// The focus distance is the oriented ratio between the size of\n// the `element` and the \"focus image\" of the element on which\n// all focus points lie, so it's a number between -1 and 1.\n// The line going through `a` and `b` is a tangent to the \"focus image\"\n// of the element.\nexport const determineFocusDistance = (element, a, b) => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const q = element.height / element.width;\n  const hwidth = element.width / 2;\n  const hheight = element.height / 2;\n  const n = line[2];\n  const m = line[3];\n  const c = line[1];\n  const mabs = Math.abs(m);\n  const nabs = Math.abs(n);\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"frame\":\n      return c / (hwidth * (nabs + q * mabs));\n    case \"diamond\":\n      return mabs < nabs ? c / (nabs * hwidth) : c / (mabs * hheight);\n    case \"ellipse\":\n      return c / (hwidth * Math.sqrt(n ** 2 + q ** 2 * m ** 2));\n  }\n};\nexport const determineFocusPoint = (element, focus, adjecentPoint) => {\n  if (focus === 0) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const center = coordsCenter(x1, y1, x2, y2);\n    return GAPoint.toTuple(center);\n  }\n  const relateToCenter = relativizationToElementCenter(element);\n  const adjecentPointRel = GATransform.apply(relateToCenter, GAPoint.from(adjecentPoint));\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  let point;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"diamond\":\n    case \"frame\":\n      point = findFocusPointForRectangulars(element, focus, adjecentPointRel);\n      break;\n    case \"ellipse\":\n      point = findFocusPointForEllipse(element, focus, adjecentPointRel);\n      break;\n  }\n  return GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point));\n};\n\n// Returns 2 or 0 intersection points between line going through `a` and `b`\n// and the `element`, in ascending order of distance from `a`.\nexport const intersectElementWithLine = function (element, a, b) {\n  let gap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  const intersections = getSortedElementLineIntersections(element, line, aRel, gap);\n  return intersections.map(point => GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point)));\n};\nconst getSortedElementLineIntersections = function (element, line, nearPoint) {\n  let gap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let intersections;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"diamond\":\n    case \"frame\":\n      const corners = getCorners(element);\n      intersections = corners.flatMap((point, i) => {\n        const edge = [point, corners[(i + 1) % 4]];\n        return intersectSegment(line, offsetSegment(edge, gap));\n      }).concat(corners.flatMap(point => getCircleIntersections(point, gap, line)));\n      break;\n    case \"ellipse\":\n      intersections = getEllipseIntersections(element, gap, line);\n      break;\n  }\n  if (intersections.length < 2) {\n    // Ignore the \"edge\" case of only intersecting with a single corner\n    return [];\n  }\n  const sortedIntersections = intersections.sort((i1, i2) => GAPoint.distance(i1, nearPoint) - GAPoint.distance(i2, nearPoint));\n  return [sortedIntersections[0], sortedIntersections[sortedIntersections.length - 1]];\n};\nconst getCorners = function (element) {\n  let scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  const hx = scale * element.width / 2;\n  const hy = scale * element.height / 2;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"frame\":\n      return [GA.point(hx, hy), GA.point(hx, -hy), GA.point(-hx, -hy), GA.point(-hx, hy)];\n    case \"diamond\":\n      return [GA.point(0, hy), GA.point(hx, 0), GA.point(0, -hy), GA.point(-hx, 0)];\n  }\n};\n\n// Returns intersection of `line` with `segment`, with `segment` moved by\n// `gap` in its polar direction.\n// If intersection coincides with second segment point returns empty array.\nconst intersectSegment = (line, segment) => {\n  const [a, b] = segment;\n  const aDist = GAPoint.distanceToLine(a, line);\n  const bDist = GAPoint.distanceToLine(b, line);\n  if (aDist * bDist >= 0) {\n    // The intersection is outside segment `(a, b)`\n    return [];\n  }\n  return [GAPoint.intersect(line, GALine.through(a, b))];\n};\nconst offsetSegment = (segment, distance) => {\n  const [a, b] = segment;\n  const offset = GATransform.translationOrthogonal(GADirection.fromTo(a, b), distance);\n  return [GATransform.apply(offset, a), GATransform.apply(offset, b)];\n};\nconst getEllipseIntersections = (element, gap, line) => {\n  const a = element.width / 2 + gap;\n  const b = element.height / 2 + gap;\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const squares = a * a * m * m + b * b * n * n;\n  const discr = squares - c * c;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = -a * a * m * c;\n  const yn = -b * b * n * c;\n  return [GA.point((xn + a * b * n * discrRoot) / squares, (yn - a * b * m * discrRoot) / squares), GA.point((xn - a * b * n * discrRoot) / squares, (yn + a * b * m * discrRoot) / squares)];\n};\nexport const getCircleIntersections = (center, radius, line) => {\n  if (radius === 0) {\n    return GAPoint.distanceToLine(line, center) === 0 ? [center] : [];\n  }\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const [a, b] = GAPoint.toTuple(center);\n  const r = radius;\n  const squares = m * m + n * n;\n  const discr = r * r * squares - (m * a + n * b + c) ** 2;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = a * n * n - b * m * n - m * c;\n  const yn = b * m * m - a * m * n - n * c;\n  return [GA.point((xn + n * discrRoot) / squares, (yn - m * discrRoot) / squares), GA.point((xn - n * discrRoot) / squares, (yn + m * discrRoot) / squares)];\n};\n\n// The focus point is the tangent point of the \"focus image\" of the\n// `element`, where the tangent goes through `point`.\nexport const findFocusPointForEllipse = (ellipse, relativeDistance, point) => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const a = ellipse.width * relativeDistanceAbs / 2;\n  const b = ellipse.height * relativeDistanceAbs / 2;\n  const orientation = Math.sign(relativeDistance);\n  const [px, pyo] = GAPoint.toTuple(point);\n\n  // The calculation below can't handle py = 0\n  const py = pyo === 0 ? 0.0001 : pyo;\n  const squares = px ** 2 * b ** 2 + py ** 2 * a ** 2;\n  // Tangent mx + ny + 1 = 0\n  const m = (-px * b ** 2 + orientation * py * Math.sqrt(Math.max(0, squares - a ** 2 * b ** 2))) / squares;\n  let n = (-m * px - 1) / py;\n  if (n === 0) {\n    // if zero {-0, 0}, fall back to a same-sign value in the similar range\n    n = (Object.is(n, -0) ? -1 : 1) * 0.01;\n  }\n  const x = -(a ** 2 * m) / (n ** 2 * b ** 2 + m ** 2 * a ** 2);\n  return GA.point(x, (-m * x - 1) / n);\n};\nexport const findFocusPointForRectangulars = (element, relativeDistance, point) => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const orientation = Math.sign(relativeDistance);\n  const corners = getCorners(element, relativeDistanceAbs);\n  let maxDistance = 0;\n  let tangentPoint = null;\n  corners.forEach(corner => {\n    const distance = orientation * GALine.through(point, corner)[1];\n    if (distance > maxDistance) {\n      maxDistance = distance;\n      tangentPoint = corner;\n    }\n  });\n  return tangentPoint;\n};\nconst pointInBezierEquation = (p0, p1, p2, p3, _ref3, lineThreshold) => {\n  let [mx, my] = _ref3;\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t, idx) => Math.pow(1 - t, 3) * p3[idx] + 3 * t * Math.pow(1 - t, 2) * p2[idx] + 3 * Math.pow(t, 2) * (1 - t) * p1[idx] + p0[idx] * Math.pow(t, 3);\n\n  // go through t in increments of 0.01\n  let t = 0;\n  while (t <= 1.0) {\n    const tx = equation(t, 0);\n    const ty = equation(t, 1);\n    const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));\n    if (diff < lineThreshold) {\n      return true;\n    }\n    t += 0.01;\n  }\n  return false;\n};\nconst hitTestCurveInside = (drawable, x, y, roundness) => {\n  const ops = getCurvePathOps(drawable);\n  const points = [];\n  let odd = false; // select one line out of double lines\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      odd = !odd;\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n      }\n    } else if (operation.op === \"bcurveTo\") {\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n        points.push([operation.data[2], operation.data[3]]);\n        points.push([operation.data[4], operation.data[5]]);\n      }\n    } else if (operation.op === \"lineTo\") {\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n      }\n    }\n  }\n  if (points.length >= 4) {\n    if (roundness === \"sharp\") {\n      return isPointInPolygon(points, x, y);\n    }\n    const polygonPoints = pointsOnBezierCurves(points, 10, 5);\n    return isPointInPolygon(polygonPoints, x, y);\n  }\n  return false;\n};\nconst hitTestRoughShape = (drawable, x, y, lineThreshold) => {\n  // read operations from first opSet\n  const ops = getCurvePathOps(drawable);\n\n  // set start position as (0,0) just in case\n  // move operation does not exist (unlikely but it is worth safekeeping it)\n  let currentP = [0, 0];\n  return ops.some((_ref4, idx) => {\n    let {\n      op,\n      data\n    } = _ref4;\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = data;\n      // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]];\n      const p2 = [data[2], data[3]];\n      const p3 = [data[4], data[5]];\n      const p0 = currentP;\n      currentP = p3;\n\n      // check if points are on the curve\n      // cubic bezier curves require four parameters\n      // the first parameter is the last stored position (p0)\n      const retVal = pointInBezierEquation(p0, p1, p2, p3, [x, y], lineThreshold);\n\n      // set end point of bezier curve as the new starting point for\n      // upcoming operations as each operation is based on the last drawn\n      // position of the previous operation\n      return retVal;\n    } else if (op === \"lineTo\") {\n      return hitTestCurveInside(drawable, x, y, \"sharp\");\n    } else if (op === \"qcurveTo\") {\n      // TODO: Implement this\n      console.warn(\"qcurveTo is not implemented yet\");\n    }\n    return false;\n  });\n};","map":{"version":3,"names":["GA","GAPoint","GADirection","GALine","GATransform","distance2d","rotatePoint","isPathALoop","isPointInPolygon","rotate","pointsOnBezierCurves","getElementAbsoluteCoords","getCurvePathOps","getRectangleBoxAbsoluteCoords","getShapeForElement","hasBoundTextElement","isImageElement","isTextElement","isTransparent","shouldShowBoundingBox","getBoundTextElement","isElementDraggableFromInside","element","type","isDraggableFromInside","backgroundColor","points","hitTest","appState","frameNameBoundsCache","x","y","threshold","zoom","value","point","isElementSelected","isPointHittingElementBoundingBox","boundTextElement","isHittingBoundTextElement","isHittingElementNotConsideringBoundingBox","isHittingElementBoundingBoxWithoutHittingElement","check","isStrictlyInside","isInsideCheck","isNearCheck","hitTestPointAgainstElement","selectedElementIds","id","_ref","x1","y1","x2","y2","elementCenterX","elementCenterY","rotatedX","rotatedY","angle","bindingBorderTest","_ref2","maxBindingGap","width","height","isOutsideCheck","elementWidth","elementHeight","shapeRatio","Math","sqrt","smallerDimension","min","max","args","distance","distanceToBindableElement","distanceToRectangle","hitTestFreeDrawElement","hitTestLinear","console","warn","_args$frameNameBounds","frameNameBounds","get","distanceToRectangleBox","distanceToDiamond","distanceToEllipse","abs","pointRel","hwidth","hheight","pointRelativeToElement","distanceToLine","equation","box","pointRelativeToDivElement","side","tangent","ellipseParamsForTest","sign","px","py","toTuple","tx","ty","a","b","forEach","_","xx","yy","ex","ey","rx","ry","qx","qy","r","hypot","q","t","closestPoint","orthogonalThrough","minX","minY","maxX","maxY","rotatedPoint","A","B","P","i","length","delta","U","C","d","da","db","shape","sets","hitTestRoughShape","pointAbs","side1","side2","relX","relY","hit","some","subshape","hitTestCurveInside","roundness","pointTuple","from","center","coordsCenter","rotation","pointRotated","apply","pointRelToCenter","sub","pointRelToCenterAbs","elementPos","offset","pointRelToPos","halfWidth","halfHeight","rectangle","pointInAbsoluteCoords","cx","cy","relativizationToElementCenter","translate","reverse","translation","compose","determineFocusDistance","relateToCenter","aRel","bRel","line","through","n","m","c","mabs","nabs","determineFocusPoint","focus","adjecentPoint","adjecentPointRel","reverseRelateToCenter","findFocusPointForRectangulars","findFocusPointForEllipse","intersectElementWithLine","gap","arguments","undefined","intersections","getSortedElementLineIntersections","map","nearPoint","corners","getCorners","flatMap","edge","intersectSegment","offsetSegment","concat","getCircleIntersections","getEllipseIntersections","sortedIntersections","sort","i1","i2","scale","hx","hy","segment","aDist","bDist","intersect","translationOrthogonal","fromTo","squares","discr","discrRoot","xn","yn","radius","ellipse","relativeDistance","relativeDistanceAbs","orientation","pyo","Object","is","maxDistance","tangentPoint","corner","pointInBezierEquation","p0","p1","p2","p3","_ref3","lineThreshold","mx","my","idx","pow","diff","drawable","ops","odd","operation","op","push","data","polygonPoints","currentP","_ref4","retVal"],"sources":["D:/project/excalidraw-cn/src/element/collision.ts"],"sourcesContent":["import * as GA from \"../ga\";\nimport * as GAPoint from \"../gapoints\";\nimport * as GADirection from \"../gadirections\";\nimport * as GALine from \"../galines\";\nimport * as GATransform from \"../gatransforms\";\n\nimport {\n  distance2d,\n  rotatePoint,\n  isPathALoop,\n  isPointInPolygon,\n  rotate,\n} from \"../math\";\nimport { pointsOnBezierCurves } from \"points-on-curve\";\n\nimport {\n  NonDeletedExcalidrawElement,\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawRectangleElement,\n  ExcalidrawDiamondElement,\n  ExcalidrawTextElement,\n  ExcalidrawEllipseElement,\n  NonDeleted,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawImageElement,\n  ExcalidrawLinearElement,\n  StrokeRoundness,\n  ExcalidrawFrameElement,\n} from \"./types\";\n\nimport {\n  getElementAbsoluteCoords,\n  getCurvePathOps,\n  getRectangleBoxAbsoluteCoords,\n  RectangleBox,\n} from \"./bounds\";\nimport { FrameNameBoundsCache, Point } from \"../types\";\nimport { Drawable } from \"roughjs/bin/core\";\nimport { AppState } from \"../types\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\nimport { hasBoundTextElement, isImageElement } from \"./typeChecks\";\nimport { isTextElement } from \".\";\nimport { isTransparent } from \"../utils\";\nimport { shouldShowBoundingBox } from \"./transformHandles\";\nimport { getBoundTextElement } from \"./textElement\";\nimport { Mutable } from \"../utility-types\";\n\nconst isElementDraggableFromInside = (\n  element: NonDeletedExcalidrawElement,\n): boolean => {\n  if (element.type === \"arrow\") {\n    return false;\n  }\n\n  if (element.type === \"freedraw\") {\n    return true;\n  }\n  const isDraggableFromInside =\n    !isTransparent(element.backgroundColor) || hasBoundTextElement(element);\n  if (element.type === \"line\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n  return isDraggableFromInside || isImageElement(element);\n};\n\nexport const hitTest = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  frameNameBoundsCache: FrameNameBoundsCache,\n  x: number,\n  y: number,\n): boolean => {\n  // How many pixels off the shape boundary we still consider a hit\n  const threshold = 10 / appState.zoom.value;\n  const point: Point = [x, y];\n\n  if (\n    isElementSelected(appState, element) &&\n    shouldShowBoundingBox([element], appState)\n  ) {\n    return isPointHittingElementBoundingBox(\n      element,\n      point,\n      threshold,\n      frameNameBoundsCache,\n    );\n  }\n\n  const boundTextElement = getBoundTextElement(element);\n  if (boundTextElement) {\n    const isHittingBoundTextElement = hitTest(\n      boundTextElement,\n      appState,\n      frameNameBoundsCache,\n      x,\n      y,\n    );\n    if (isHittingBoundTextElement) {\n      return true;\n    }\n  }\n  return isHittingElementNotConsideringBoundingBox(\n    element,\n    appState,\n    frameNameBoundsCache,\n    point,\n  );\n};\n\nexport const isHittingElementBoundingBoxWithoutHittingElement = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  frameNameBoundsCache: FrameNameBoundsCache,\n  x: number,\n  y: number,\n): boolean => {\n  const threshold = 10 / appState.zoom.value;\n\n  // So that bound text element hit is considered within bounding box of container even if its outside actual bounding box of element\n  // eg for linear elements text can be outside the element bounding box\n  const boundTextElement = getBoundTextElement(element);\n  if (\n    boundTextElement &&\n    hitTest(boundTextElement, appState, frameNameBoundsCache, x, y)\n  ) {\n    return false;\n  }\n\n  return (\n    !isHittingElementNotConsideringBoundingBox(\n      element,\n      appState,\n      frameNameBoundsCache,\n      [x, y],\n    ) &&\n    isPointHittingElementBoundingBox(\n      element,\n      [x, y],\n      threshold,\n      frameNameBoundsCache,\n    )\n  );\n};\n\nexport const isHittingElementNotConsideringBoundingBox = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  frameNameBoundsCache: FrameNameBoundsCache | null,\n  point: Point,\n): boolean => {\n  const threshold = 10 / appState.zoom.value;\n  const check = isTextElement(element)\n    ? isStrictlyInside\n    : isElementDraggableFromInside(element)\n    ? isInsideCheck\n    : isNearCheck;\n  return hitTestPointAgainstElement({\n    element,\n    point,\n    threshold,\n    check,\n    frameNameBoundsCache,\n  });\n};\n\nconst isElementSelected = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n) => appState.selectedElementIds[element.id];\n\nexport const isPointHittingElementBoundingBox = (\n  element: NonDeleted<ExcalidrawElement>,\n  [x, y]: Point,\n  threshold: number,\n  frameNameBoundsCache: FrameNameBoundsCache | null,\n) => {\n  // frames needs be checked differently so as to be able to drag it\n  // by its frame, whether it has been selected or not\n  // this logic here is not ideal\n  // TODO: refactor it later...\n  if (element.type === \"frame\") {\n    return hitTestPointAgainstElement({\n      element,\n      point: [x, y],\n      threshold,\n      check: isInsideCheck,\n      frameNameBoundsCache,\n    });\n  }\n\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const elementCenterX = (x1 + x2) / 2;\n  const elementCenterY = (y1 + y2) / 2;\n  // reverse rotate to take element's angle into account.\n  const [rotatedX, rotatedY] = rotate(\n    x,\n    y,\n    elementCenterX,\n    elementCenterY,\n    -element.angle,\n  );\n\n  return (\n    rotatedX > x1 - threshold &&\n    rotatedX < x2 + threshold &&\n    rotatedY > y1 - threshold &&\n    rotatedY < y2 + threshold\n  );\n};\n\nexport const bindingBorderTest = (\n  element: NonDeleted<ExcalidrawBindableElement>,\n  { x, y }: { x: number; y: number },\n): boolean => {\n  const threshold = maxBindingGap(element, element.width, element.height);\n  const check = isOutsideCheck;\n  const point: Point = [x, y];\n  return hitTestPointAgainstElement({\n    element,\n    point,\n    threshold,\n    check,\n    frameNameBoundsCache: null,\n  });\n};\n\nexport const maxBindingGap = (\n  element: ExcalidrawElement,\n  elementWidth: number,\n  elementHeight: number,\n): number => {\n  // Aligns diamonds with rectangles\n  const shapeRatio = element.type === \"diamond\" ? 1 / Math.sqrt(2) : 1;\n  const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight);\n  // We make the bindable boundary bigger for bigger elements\n  return Math.max(16, Math.min(0.25 * smallerDimension, 32));\n};\n\ntype HitTestArgs = {\n  element: NonDeletedExcalidrawElement;\n  point: Point;\n  threshold: number;\n  check: (distance: number, threshold: number) => boolean;\n  frameNameBoundsCache: FrameNameBoundsCache | null;\n};\n\nconst hitTestPointAgainstElement = (args: HitTestArgs): boolean => {\n  switch (args.element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"diamond\":\n    case \"ellipse\":\n      const distance = distanceToBindableElement(args.element, args.point);\n      return args.check(distance, args.threshold);\n    case \"freedraw\": {\n      if (\n        !args.check(\n          distanceToRectangle(args.element, args.point),\n          args.threshold,\n        )\n      ) {\n        return false;\n      }\n\n      return hitTestFreeDrawElement(args.element, args.point, args.threshold);\n    }\n    case \"arrow\":\n    case \"line\":\n      return hitTestLinear(args);\n    case \"selection\":\n      console.warn(\n        \"This should not happen, we need to investigate why it does.\",\n      );\n      return false;\n    case \"frame\": {\n      // check distance to frame element first\n      if (\n        args.check(\n          distanceToBindableElement(args.element, args.point),\n          args.threshold,\n        )\n      ) {\n        return true;\n      }\n\n      const frameNameBounds = args.frameNameBoundsCache?.get(args.element);\n\n      if (frameNameBounds) {\n        return args.check(\n          distanceToRectangleBox(frameNameBounds, args.point),\n          args.threshold,\n        );\n      }\n      return false;\n    }\n  }\n};\n\nexport const distanceToBindableElement = (\n  element: ExcalidrawBindableElement,\n  point: Point,\n): number => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"frame\":\n      return distanceToRectangle(element, point);\n    case \"diamond\":\n      return distanceToDiamond(element, point);\n    case \"ellipse\":\n      return distanceToEllipse(element, point);\n  }\n};\n\nconst isStrictlyInside = (distance: number, threshold: number): boolean => {\n  return distance < 0;\n};\n\nconst isInsideCheck = (distance: number, threshold: number): boolean => {\n  return distance < threshold;\n};\n\nconst isNearCheck = (distance: number, threshold: number): boolean => {\n  return Math.abs(distance) < threshold;\n};\n\nconst isOutsideCheck = (distance: number, threshold: number): boolean => {\n  return 0 <= distance && distance < threshold;\n};\n\nconst distanceToRectangle = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawTextElement\n    | ExcalidrawFreeDrawElement\n    | ExcalidrawImageElement\n    | ExcalidrawFrameElement,\n  point: Point,\n): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  return Math.max(\n    GAPoint.distanceToLine(pointRel, GALine.equation(0, 1, -hheight)),\n    GAPoint.distanceToLine(pointRel, GALine.equation(1, 0, -hwidth)),\n  );\n};\n\nconst distanceToRectangleBox = (box: RectangleBox, point: Point): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToDivElement(point, box);\n  return Math.max(\n    GAPoint.distanceToLine(pointRel, GALine.equation(0, 1, -hheight)),\n    GAPoint.distanceToLine(pointRel, GALine.equation(1, 0, -hwidth)),\n  );\n};\n\nconst distanceToDiamond = (\n  element: ExcalidrawDiamondElement,\n  point: Point,\n): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const side = GALine.equation(hheight, hwidth, -hheight * hwidth);\n  return GAPoint.distanceToLine(pointRel, side);\n};\n\nconst distanceToEllipse = (\n  element: ExcalidrawEllipseElement,\n  point: Point,\n): number => {\n  const [pointRel, tangent] = ellipseParamsForTest(element, point);\n  return -GALine.sign(tangent) * GAPoint.distanceToLine(pointRel, tangent);\n};\n\nconst ellipseParamsForTest = (\n  element: ExcalidrawEllipseElement,\n  point: Point,\n): [GA.Point, GA.Line] => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const [px, py] = GAPoint.toTuple(pointRel);\n\n  // We're working in positive quadrant, so start with `t = 45deg`, `tx=cos(t)`\n  let tx = 0.707;\n  let ty = 0.707;\n\n  const a = hwidth;\n  const b = hheight;\n\n  // This is a numerical method to find the params tx, ty at which\n  // the ellipse has the closest point to the given point\n  [0, 1, 2, 3].forEach((_) => {\n    const xx = a * tx;\n    const yy = b * ty;\n\n    const ex = ((a * a - b * b) * tx ** 3) / a;\n    const ey = ((b * b - a * a) * ty ** 3) / b;\n\n    const rx = xx - ex;\n    const ry = yy - ey;\n\n    const qx = px - ex;\n    const qy = py - ey;\n\n    const r = Math.hypot(ry, rx);\n    const q = Math.hypot(qy, qx);\n\n    tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n    ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n    const t = Math.hypot(ty, tx);\n    tx /= t;\n    ty /= t;\n  });\n\n  const closestPoint = GA.point(a * tx, b * ty);\n\n  const tangent = GALine.orthogonalThrough(pointRel, closestPoint);\n  return [pointRel, tangent];\n};\n\nconst hitTestFreeDrawElement = (\n  element: ExcalidrawFreeDrawElement,\n  point: Point,\n  threshold: number,\n): boolean => {\n  // Check point-distance-to-line-segment for every segment in the\n  // element's points (its input points, not its outline points).\n  // This is... okay? It's plenty fast, but the GA library may\n  // have a faster option.\n\n  let x: number;\n  let y: number;\n\n  if (element.angle === 0) {\n    x = point[0] - element.x;\n    y = point[1] - element.y;\n  } else {\n    // Counter-rotate the point around center before testing\n    const [minX, minY, maxX, maxY] = getElementAbsoluteCoords(element);\n    const rotatedPoint = rotatePoint(\n      point,\n      [minX + (maxX - minX) / 2, minY + (maxY - minY) / 2],\n      -element.angle,\n    );\n    x = rotatedPoint[0] - element.x;\n    y = rotatedPoint[1] - element.y;\n  }\n\n  let [A, B] = element.points;\n  let P: readonly [number, number];\n\n  // For freedraw dots\n  if (\n    distance2d(A[0], A[1], x, y) < threshold ||\n    distance2d(B[0], B[1], x, y) < threshold\n  ) {\n    return true;\n  }\n\n  // For freedraw lines\n  for (let i = 0; i < element.points.length; i++) {\n    const delta = [B[0] - A[0], B[1] - A[1]];\n    const length = Math.hypot(delta[1], delta[0]);\n\n    const U = [delta[0] / length, delta[1] / length];\n    const C = [x - A[0], y - A[1]];\n    const d = (C[0] * U[0] + C[1] * U[1]) / Math.hypot(U[1], U[0]);\n    P = [A[0] + U[0] * d, A[1] + U[1] * d];\n\n    const da = distance2d(P[0], P[1], A[0], A[1]);\n    const db = distance2d(P[0], P[1], B[0], B[1]);\n\n    P = db < da && da > length ? B : da < db && db > length ? A : P;\n\n    if (Math.hypot(y - P[1], x - P[0]) < threshold) {\n      return true;\n    }\n\n    A = B;\n    B = element.points[i + 1];\n  }\n\n  const shape = getShapeForElement(element);\n\n  // for filled freedraw shapes, support\n  // selecting from inside\n  if (shape && shape.sets.length) {\n    return hitTestRoughShape(shape, x, y, threshold);\n  }\n\n  return false;\n};\n\nconst hitTestLinear = (args: HitTestArgs): boolean => {\n  const { element, threshold } = args;\n  if (!getShapeForElement(element)) {\n    return false;\n  }\n\n  const [point, pointAbs, hwidth, hheight] = pointRelativeToElement(\n    args.element,\n    args.point,\n  );\n  const side1 = GALine.equation(0, 1, -hheight);\n  const side2 = GALine.equation(1, 0, -hwidth);\n  if (\n    !isInsideCheck(GAPoint.distanceToLine(pointAbs, side1), threshold) ||\n    !isInsideCheck(GAPoint.distanceToLine(pointAbs, side2), threshold)\n  ) {\n    return false;\n  }\n  const [relX, relY] = GAPoint.toTuple(point);\n\n  const shape = getShapeForElement(element as ExcalidrawLinearElement);\n\n  if (!shape) {\n    return false;\n  }\n\n  if (args.check === isInsideCheck) {\n    const hit = shape.some((subshape) =>\n      hitTestCurveInside(\n        subshape,\n        relX,\n        relY,\n        element.roundness ? \"round\" : \"sharp\",\n      ),\n    );\n    if (hit) {\n      return true;\n    }\n  }\n\n  // hit test all \"subshapes\" of the linear element\n  return shape.some((subshape) =>\n    hitTestRoughShape(subshape, relX, relY, threshold),\n  );\n};\n\n// Returns:\n//   1. the point relative to the elements (x, y) position\n//   2. the point relative to the element's center with positive (x, y)\n//   3. half element width\n//   4. half element height\n//\n// Note that for linear elements the (x, y) position is not at the\n// top right corner of their boundary.\n//\n// Rectangles, diamonds and ellipses are symmetrical over axes,\n// and other elements have a rectangular boundary,\n// so we only need to perform hit tests for the positive quadrant.\nconst pointRelativeToElement = (\n  element: ExcalidrawElement,\n  pointTuple: Point,\n): [GA.Point, GA.Point, number, number] => {\n  const point = GAPoint.from(pointTuple);\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const center = coordsCenter(x1, y1, x2, y2);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const pointRotated = GATransform.apply(rotate, point);\n  const pointRelToCenter = GA.sub(pointRotated, GADirection.from(center));\n  const pointRelToCenterAbs = GAPoint.abs(pointRelToCenter);\n  const elementPos = GA.offset(element.x, element.y);\n  const pointRelToPos = GA.sub(pointRotated, elementPos);\n  const halfWidth = (x2 - x1) / 2;\n  const halfHeight = (y2 - y1) / 2;\n  return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];\n};\n\nconst pointRelativeToDivElement = (\n  pointTuple: Point,\n  rectangle: RectangleBox,\n): [GA.Point, GA.Point, number, number] => {\n  const point = GAPoint.from(pointTuple);\n  const [x1, y1, x2, y2] = getRectangleBoxAbsoluteCoords(rectangle);\n  const center = coordsCenter(x1, y1, x2, y2);\n  const rotate = GATransform.rotation(center, rectangle.angle);\n  const pointRotated = GATransform.apply(rotate, point);\n  const pointRelToCenter = GA.sub(pointRotated, GADirection.from(center));\n  const pointRelToCenterAbs = GAPoint.abs(pointRelToCenter);\n  const elementPos = GA.offset(rectangle.x, rectangle.y);\n  const pointRelToPos = GA.sub(pointRotated, elementPos);\n  const halfWidth = (x2 - x1) / 2;\n  const halfHeight = (y2 - y1) / 2;\n  return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];\n};\n\n// Returns point in absolute coordinates\nexport const pointInAbsoluteCoords = (\n  element: ExcalidrawElement,\n  // Point relative to the element position\n  point: Point,\n): Point => {\n  const [x, y] = point;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2;\n  const cy = (y2 - y1) / 2;\n  const [rotatedX, rotatedY] = rotate(x, y, cx, cy, element.angle);\n  return [element.x + rotatedX, element.y + rotatedY];\n};\n\nconst relativizationToElementCenter = (\n  element: ExcalidrawElement,\n): GA.Transform => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const center = coordsCenter(x1, y1, x2, y2);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const translate = GA.reverse(\n    GATransform.translation(GADirection.from(center)),\n  );\n  return GATransform.compose(rotate, translate);\n};\n\nconst coordsCenter = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n): GA.Point => {\n  return GA.point((x1 + x2) / 2, (y1 + y2) / 2);\n};\n\n// The focus distance is the oriented ratio between the size of\n// the `element` and the \"focus image\" of the element on which\n// all focus points lie, so it's a number between -1 and 1.\n// The line going through `a` and `b` is a tangent to the \"focus image\"\n// of the element.\nexport const determineFocusDistance = (\n  element: ExcalidrawBindableElement,\n  // Point on the line, in absolute coordinates\n  a: Point,\n  // Another point on the line, in absolute coordinates (closer to element)\n  b: Point,\n): number => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const q = element.height / element.width;\n  const hwidth = element.width / 2;\n  const hheight = element.height / 2;\n  const n = line[2];\n  const m = line[3];\n  const c = line[1];\n  const mabs = Math.abs(m);\n  const nabs = Math.abs(n);\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"frame\":\n      return c / (hwidth * (nabs + q * mabs));\n    case \"diamond\":\n      return mabs < nabs ? c / (nabs * hwidth) : c / (mabs * hheight);\n    case \"ellipse\":\n      return c / (hwidth * Math.sqrt(n ** 2 + q ** 2 * m ** 2));\n  }\n};\n\nexport const determineFocusPoint = (\n  element: ExcalidrawBindableElement,\n  // The oriented, relative distance from the center of `element` of the\n  // returned focusPoint\n  focus: number,\n  adjecentPoint: Point,\n): Point => {\n  if (focus === 0) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const center = coordsCenter(x1, y1, x2, y2);\n    return GAPoint.toTuple(center);\n  }\n  const relateToCenter = relativizationToElementCenter(element);\n  const adjecentPointRel = GATransform.apply(\n    relateToCenter,\n    GAPoint.from(adjecentPoint),\n  );\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  let point;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"diamond\":\n    case \"frame\":\n      point = findFocusPointForRectangulars(element, focus, adjecentPointRel);\n      break;\n    case \"ellipse\":\n      point = findFocusPointForEllipse(element, focus, adjecentPointRel);\n      break;\n  }\n  return GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point));\n};\n\n// Returns 2 or 0 intersection points between line going through `a` and `b`\n// and the `element`, in ascending order of distance from `a`.\nexport const intersectElementWithLine = (\n  element: ExcalidrawBindableElement,\n  // Point on the line, in absolute coordinates\n  a: Point,\n  // Another point on the line, in absolute coordinates\n  b: Point,\n  // If given, the element is inflated by this value\n  gap: number = 0,\n): Point[] => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  const intersections = getSortedElementLineIntersections(\n    element,\n    line,\n    aRel,\n    gap,\n  );\n  return intersections.map((point) =>\n    GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point)),\n  );\n};\n\nconst getSortedElementLineIntersections = (\n  element: ExcalidrawBindableElement,\n  // Relative to element center\n  line: GA.Line,\n  // Relative to element center\n  nearPoint: GA.Point,\n  gap: number = 0,\n): GA.Point[] => {\n  let intersections: GA.Point[];\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"diamond\":\n    case \"frame\":\n      const corners = getCorners(element);\n      intersections = corners\n        .flatMap((point, i) => {\n          const edge: [GA.Point, GA.Point] = [point, corners[(i + 1) % 4]];\n          return intersectSegment(line, offsetSegment(edge, gap));\n        })\n        .concat(\n          corners.flatMap((point) => getCircleIntersections(point, gap, line)),\n        );\n      break;\n    case \"ellipse\":\n      intersections = getEllipseIntersections(element, gap, line);\n      break;\n  }\n  if (intersections.length < 2) {\n    // Ignore the \"edge\" case of only intersecting with a single corner\n    return [];\n  }\n  const sortedIntersections = intersections.sort(\n    (i1, i2) =>\n      GAPoint.distance(i1, nearPoint) - GAPoint.distance(i2, nearPoint),\n  );\n  return [\n    sortedIntersections[0],\n    sortedIntersections[sortedIntersections.length - 1],\n  ];\n};\n\nconst getCorners = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawImageElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawTextElement\n    | ExcalidrawFrameElement,\n  scale: number = 1,\n): GA.Point[] => {\n  const hx = (scale * element.width) / 2;\n  const hy = (scale * element.height) / 2;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"frame\":\n      return [\n        GA.point(hx, hy),\n        GA.point(hx, -hy),\n        GA.point(-hx, -hy),\n        GA.point(-hx, hy),\n      ];\n    case \"diamond\":\n      return [\n        GA.point(0, hy),\n        GA.point(hx, 0),\n        GA.point(0, -hy),\n        GA.point(-hx, 0),\n      ];\n  }\n};\n\n// Returns intersection of `line` with `segment`, with `segment` moved by\n// `gap` in its polar direction.\n// If intersection coincides with second segment point returns empty array.\nconst intersectSegment = (\n  line: GA.Line,\n  segment: [GA.Point, GA.Point],\n): GA.Point[] => {\n  const [a, b] = segment;\n  const aDist = GAPoint.distanceToLine(a, line);\n  const bDist = GAPoint.distanceToLine(b, line);\n  if (aDist * bDist >= 0) {\n    // The intersection is outside segment `(a, b)`\n    return [];\n  }\n  return [GAPoint.intersect(line, GALine.through(a, b))];\n};\n\nconst offsetSegment = (\n  segment: [GA.Point, GA.Point],\n  distance: number,\n): [GA.Point, GA.Point] => {\n  const [a, b] = segment;\n  const offset = GATransform.translationOrthogonal(\n    GADirection.fromTo(a, b),\n    distance,\n  );\n  return [GATransform.apply(offset, a), GATransform.apply(offset, b)];\n};\n\nconst getEllipseIntersections = (\n  element: ExcalidrawEllipseElement,\n  gap: number,\n  line: GA.Line,\n): GA.Point[] => {\n  const a = element.width / 2 + gap;\n  const b = element.height / 2 + gap;\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const squares = a * a * m * m + b * b * n * n;\n  const discr = squares - c * c;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = -a * a * m * c;\n  const yn = -b * b * n * c;\n  return [\n    GA.point(\n      (xn + a * b * n * discrRoot) / squares,\n      (yn - a * b * m * discrRoot) / squares,\n    ),\n    GA.point(\n      (xn - a * b * n * discrRoot) / squares,\n      (yn + a * b * m * discrRoot) / squares,\n    ),\n  ];\n};\n\nexport const getCircleIntersections = (\n  center: GA.Point,\n  radius: number,\n  line: GA.Line,\n): GA.Point[] => {\n  if (radius === 0) {\n    return GAPoint.distanceToLine(line, center) === 0 ? [center] : [];\n  }\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const [a, b] = GAPoint.toTuple(center);\n  const r = radius;\n  const squares = m * m + n * n;\n  const discr = r * r * squares - (m * a + n * b + c) ** 2;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = a * n * n - b * m * n - m * c;\n  const yn = b * m * m - a * m * n - n * c;\n\n  return [\n    GA.point((xn + n * discrRoot) / squares, (yn - m * discrRoot) / squares),\n    GA.point((xn - n * discrRoot) / squares, (yn + m * discrRoot) / squares),\n  ];\n};\n\n// The focus point is the tangent point of the \"focus image\" of the\n// `element`, where the tangent goes through `point`.\nexport const findFocusPointForEllipse = (\n  ellipse: ExcalidrawEllipseElement,\n  // Between -1 and 1 (not 0) the relative size of the \"focus image\" of\n  // the element on which the focus point lies\n  relativeDistance: number,\n  // The point for which we're trying to find the focus point, relative\n  // to the ellipse center.\n  point: GA.Point,\n): GA.Point => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const a = (ellipse.width * relativeDistanceAbs) / 2;\n  const b = (ellipse.height * relativeDistanceAbs) / 2;\n\n  const orientation = Math.sign(relativeDistance);\n  const [px, pyo] = GAPoint.toTuple(point);\n\n  // The calculation below can't handle py = 0\n  const py = pyo === 0 ? 0.0001 : pyo;\n\n  const squares = px ** 2 * b ** 2 + py ** 2 * a ** 2;\n  // Tangent mx + ny + 1 = 0\n  const m =\n    (-px * b ** 2 +\n      orientation * py * Math.sqrt(Math.max(0, squares - a ** 2 * b ** 2))) /\n    squares;\n\n  let n = (-m * px - 1) / py;\n\n  if (n === 0) {\n    // if zero {-0, 0}, fall back to a same-sign value in the similar range\n    n = (Object.is(n, -0) ? -1 : 1) * 0.01;\n  }\n\n  const x = -(a ** 2 * m) / (n ** 2 * b ** 2 + m ** 2 * a ** 2);\n  return GA.point(x, (-m * x - 1) / n);\n};\n\nexport const findFocusPointForRectangulars = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawImageElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawTextElement\n    | ExcalidrawFrameElement,\n  // Between -1 and 1 for how far away should the focus point be relative\n  // to the size of the element. Sign determines orientation.\n  relativeDistance: number,\n  // The point for which we're trying to find the focus point, relative\n  // to the element center.\n  point: GA.Point,\n): GA.Point => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const orientation = Math.sign(relativeDistance);\n  const corners = getCorners(element, relativeDistanceAbs);\n\n  let maxDistance = 0;\n  let tangentPoint: null | GA.Point = null;\n  corners.forEach((corner) => {\n    const distance = orientation * GALine.through(point, corner)[1];\n    if (distance > maxDistance) {\n      maxDistance = distance;\n      tangentPoint = corner;\n    }\n  });\n  return tangentPoint!;\n};\n\nconst pointInBezierEquation = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  p3: Point,\n  [mx, my]: Point,\n  lineThreshold: number,\n) => {\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // go through t in increments of 0.01\n  let t = 0;\n  while (t <= 1.0) {\n    const tx = equation(t, 0);\n    const ty = equation(t, 1);\n\n    const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));\n\n    if (diff < lineThreshold) {\n      return true;\n    }\n\n    t += 0.01;\n  }\n\n  return false;\n};\n\nconst hitTestCurveInside = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  roundness: StrokeRoundness,\n) => {\n  const ops = getCurvePathOps(drawable);\n  const points: Mutable<Point>[] = [];\n  let odd = false; // select one line out of double lines\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      odd = !odd;\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n      }\n    } else if (operation.op === \"bcurveTo\") {\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n        points.push([operation.data[2], operation.data[3]]);\n        points.push([operation.data[4], operation.data[5]]);\n      }\n    } else if (operation.op === \"lineTo\") {\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n      }\n    }\n  }\n  if (points.length >= 4) {\n    if (roundness === \"sharp\") {\n      return isPointInPolygon(points, x, y);\n    }\n    const polygonPoints = pointsOnBezierCurves(points, 10, 5);\n    return isPointInPolygon(polygonPoints, x, y);\n  }\n  return false;\n};\n\nconst hitTestRoughShape = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  lineThreshold: number,\n) => {\n  // read operations from first opSet\n  const ops = getCurvePathOps(drawable);\n\n  // set start position as (0,0) just in case\n  // move operation does not exist (unlikely but it is worth safekeeping it)\n  let currentP: Point = [0, 0];\n\n  return ops.some(({ op, data }, idx) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = data as unknown as Point;\n      // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]] as Point;\n      const p2 = [data[2], data[3]] as Point;\n      const p3 = [data[4], data[5]] as Point;\n\n      const p0 = currentP;\n      currentP = p3;\n\n      // check if points are on the curve\n      // cubic bezier curves require four parameters\n      // the first parameter is the last stored position (p0)\n      const retVal = pointInBezierEquation(\n        p0,\n        p1,\n        p2,\n        p3,\n        [x, y],\n        lineThreshold,\n      );\n\n      // set end point of bezier curve as the new starting point for\n      // upcoming operations as each operation is based on the last drawn\n      // position of the previous operation\n      return retVal;\n    } else if (op === \"lineTo\") {\n      return hitTestCurveInside(drawable, x, y, \"sharp\");\n    } else if (op === \"qcurveTo\") {\n      // TODO: Implement this\n      console.warn(\"qcurveTo is not implemented yet\");\n    }\n\n    return false;\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}