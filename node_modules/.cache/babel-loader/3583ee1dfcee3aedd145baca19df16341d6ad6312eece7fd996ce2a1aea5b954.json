{"ast":null,"code":"import { arrayToMapWithIndex } from \"../utils\";\nconst normalizeGroupElementOrder = elements => {\n  const origElements = elements.slice();\n  const sortedElements = new Set();\n  const orderInnerGroups = elements => {\n    var _elements$, _elements$$groupIds;\n    const firstGroupSig = (_elements$ = elements[0]) === null || _elements$ === void 0 ? void 0 : (_elements$$groupIds = _elements$.groupIds) === null || _elements$$groupIds === void 0 ? void 0 : _elements$$groupIds.join(\"\");\n    const aGroup = [elements[0]];\n    const bGroup = [];\n    for (const element of elements.slice(1)) {\n      var _element$groupIds;\n      if (((_element$groupIds = element.groupIds) === null || _element$groupIds === void 0 ? void 0 : _element$groupIds.join(\"\")) === firstGroupSig) {\n        aGroup.push(element);\n      } else {\n        bGroup.push(element);\n      }\n    }\n    return bGroup.length ? [...aGroup, ...orderInnerGroups(bGroup)] : aGroup;\n  };\n  const groupHandledElements = new Map();\n  origElements.forEach((element, idx) => {\n    var _element$groupIds2;\n    if (groupHandledElements.has(element.id)) {\n      return;\n    }\n    if ((_element$groupIds2 = element.groupIds) !== null && _element$groupIds2 !== void 0 && _element$groupIds2.length) {\n      const topGroup = element.groupIds[element.groupIds.length - 1];\n      const groupElements = origElements.slice(idx).filter(element => {\n        var _element$groupIds3;\n        const ret = element === null || element === void 0 ? void 0 : (_element$groupIds3 = element.groupIds) === null || _element$groupIds3 === void 0 ? void 0 : _element$groupIds3.some(id => id === topGroup);\n        if (ret) {\n          groupHandledElements.set(element.id, true);\n        }\n        return ret;\n      });\n      for (const elem of orderInnerGroups(groupElements)) {\n        sortedElements.add(elem);\n      }\n    } else {\n      sortedElements.add(element);\n    }\n  });\n\n  // if there's a bug which resulted in losing some of the elements, return\n  // original instead as that's better than losing data\n  if (sortedElements.size !== elements.length) {\n    console.error(\"normalizeGroupElementOrder: lost some elements... bailing!\");\n    return elements;\n  }\n  return [...sortedElements];\n};\n\n/**\n * In theory, when we have text elements bound to a container, they\n * should be right after the container element in the elements array.\n * However, this is not guaranteed due to old and potential future bugs.\n *\n * This function sorts containers and their bound texts together. It prefers\n * original z-index of container (i.e. it moves bound text elements after\n * containers).\n */\nconst normalizeBoundElementsOrder = elements => {\n  const elementsMap = arrayToMapWithIndex(elements);\n  const origElements = elements.slice();\n  const sortedElements = new Set();\n  origElements.forEach((element, idx) => {\n    var _element$boundElement;\n    if (!element) {\n      return;\n    }\n    if ((_element$boundElement = element.boundElements) !== null && _element$boundElement !== void 0 && _element$boundElement.length) {\n      sortedElements.add(element);\n      origElements[idx] = null;\n      element.boundElements.forEach(boundElement => {\n        const child = elementsMap.get(boundElement.id);\n        if (child && boundElement.type === \"text\") {\n          sortedElements.add(child[0]);\n          origElements[child[1]] = null;\n        }\n      });\n    } else if (element.type === \"text\" && element.containerId) {\n      var _parent$0$boundElemen;\n      const parent = elementsMap.get(element.containerId);\n      if (!(parent !== null && parent !== void 0 && (_parent$0$boundElemen = parent[0].boundElements) !== null && _parent$0$boundElemen !== void 0 && _parent$0$boundElemen.find(x => x.id === element.id))) {\n        sortedElements.add(element);\n        origElements[idx] = null;\n\n        // if element has a container and container lists it, skip this element\n        // as it'll be taken care of by the container\n      }\n    } else {\n      sortedElements.add(element);\n      origElements[idx] = null;\n    }\n  });\n\n  // if there's a bug which resulted in losing some of the elements, return\n  // original instead as that's better than losing data\n  if (sortedElements.size !== elements.length) {\n    console.error(\"normalizeBoundElementsOrder: lost some elements... bailing!\");\n    return elements;\n  }\n  return [...sortedElements];\n};\nexport const normalizeElementOrder = elements => {\n  // console.time();\n  const ret = normalizeBoundElementsOrder(normalizeGroupElementOrder(elements));\n  // console.timeEnd();\n  return ret;\n};","map":{"version":3,"names":["arrayToMapWithIndex","normalizeGroupElementOrder","elements","origElements","slice","sortedElements","Set","orderInnerGroups","_elements$","_elements$$groupIds","firstGroupSig","groupIds","join","aGroup","bGroup","element","_element$groupIds","push","length","groupHandledElements","Map","forEach","idx","_element$groupIds2","has","id","topGroup","groupElements","filter","_element$groupIds3","ret","some","set","elem","add","size","console","error","normalizeBoundElementsOrder","elementsMap","_element$boundElement","boundElements","boundElement","child","get","type","containerId","_parent$0$boundElemen","parent","find","x","normalizeElementOrder"],"sources":["D:/project/excalidraw-cn/src/element/sortElements.ts"],"sourcesContent":["import { arrayToMapWithIndex } from \"../utils\";\nimport { ExcalidrawElement } from \"./types\";\n\nconst normalizeGroupElementOrder = (elements: readonly ExcalidrawElement[]) => {\n  const origElements: ExcalidrawElement[] = elements.slice();\n  const sortedElements = new Set<ExcalidrawElement>();\n\n  const orderInnerGroups = (\n    elements: readonly ExcalidrawElement[],\n  ): ExcalidrawElement[] => {\n    const firstGroupSig = elements[0]?.groupIds?.join(\"\");\n    const aGroup: ExcalidrawElement[] = [elements[0]];\n    const bGroup: ExcalidrawElement[] = [];\n    for (const element of elements.slice(1)) {\n      if (element.groupIds?.join(\"\") === firstGroupSig) {\n        aGroup.push(element);\n      } else {\n        bGroup.push(element);\n      }\n    }\n    return bGroup.length ? [...aGroup, ...orderInnerGroups(bGroup)] : aGroup;\n  };\n\n  const groupHandledElements = new Map<string, true>();\n\n  origElements.forEach((element, idx) => {\n    if (groupHandledElements.has(element.id)) {\n      return;\n    }\n    if (element.groupIds?.length) {\n      const topGroup = element.groupIds[element.groupIds.length - 1];\n      const groupElements = origElements.slice(idx).filter((element) => {\n        const ret = element?.groupIds?.some((id) => id === topGroup);\n        if (ret) {\n          groupHandledElements.set(element!.id, true);\n        }\n        return ret;\n      });\n\n      for (const elem of orderInnerGroups(groupElements)) {\n        sortedElements.add(elem);\n      }\n    } else {\n      sortedElements.add(element);\n    }\n  });\n\n  // if there's a bug which resulted in losing some of the elements, return\n  // original instead as that's better than losing data\n  if (sortedElements.size !== elements.length) {\n    console.error(\"normalizeGroupElementOrder: lost some elements... bailing!\");\n    return elements;\n  }\n\n  return [...sortedElements];\n};\n\n/**\n * In theory, when we have text elements bound to a container, they\n * should be right after the container element in the elements array.\n * However, this is not guaranteed due to old and potential future bugs.\n *\n * This function sorts containers and their bound texts together. It prefers\n * original z-index of container (i.e. it moves bound text elements after\n * containers).\n */\nconst normalizeBoundElementsOrder = (\n  elements: readonly ExcalidrawElement[],\n) => {\n  const elementsMap = arrayToMapWithIndex(elements);\n\n  const origElements: (ExcalidrawElement | null)[] = elements.slice();\n  const sortedElements = new Set<ExcalidrawElement>();\n\n  origElements.forEach((element, idx) => {\n    if (!element) {\n      return;\n    }\n    if (element.boundElements?.length) {\n      sortedElements.add(element);\n      origElements[idx] = null;\n      element.boundElements.forEach((boundElement) => {\n        const child = elementsMap.get(boundElement.id);\n        if (child && boundElement.type === \"text\") {\n          sortedElements.add(child[0]);\n          origElements[child[1]] = null;\n        }\n      });\n    } else if (element.type === \"text\" && element.containerId) {\n      const parent = elementsMap.get(element.containerId);\n      if (!parent?.[0].boundElements?.find((x) => x.id === element.id)) {\n        sortedElements.add(element);\n        origElements[idx] = null;\n\n        // if element has a container and container lists it, skip this element\n        // as it'll be taken care of by the container\n      }\n    } else {\n      sortedElements.add(element);\n      origElements[idx] = null;\n    }\n  });\n\n  // if there's a bug which resulted in losing some of the elements, return\n  // original instead as that's better than losing data\n  if (sortedElements.size !== elements.length) {\n    console.error(\n      \"normalizeBoundElementsOrder: lost some elements... bailing!\",\n    );\n    return elements;\n  }\n\n  return [...sortedElements];\n};\n\nexport const normalizeElementOrder = (\n  elements: readonly ExcalidrawElement[],\n) => {\n  // console.time();\n  const ret = normalizeBoundElementsOrder(normalizeGroupElementOrder(elements));\n  // console.timeEnd();\n  return ret;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}