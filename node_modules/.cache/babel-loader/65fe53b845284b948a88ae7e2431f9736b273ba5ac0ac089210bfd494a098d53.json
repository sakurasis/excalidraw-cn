{"ast":null,"code":"import { SVG_EXPORT_TAG } from \"./scene/export\";\nimport { tryParseSpreadsheet, VALID_SPREADSHEET } from \"./charts\";\nimport { EXPORT_DATA_TYPES, MIME_TYPES } from \"./constants\";\nimport { isInitializedImageElement } from \"./element/typeChecks\";\nimport { deepCopyElement } from \"./element/newElement\";\nimport { mutateElement } from \"./element/mutateElement\";\nimport { getContainingFrame } from \"./frame\";\nimport { isPromiseLike, isTestEnv } from \"./utils\";\nlet CLIPBOARD = \"\";\nlet PREFER_APP_CLIPBOARD = false;\nexport const probablySupportsClipboardReadText = \"clipboard\" in navigator && \"readText\" in navigator.clipboard;\nexport const probablySupportsClipboardWriteText = \"clipboard\" in navigator && \"writeText\" in navigator.clipboard;\nexport const probablySupportsClipboardBlob = \"clipboard\" in navigator && \"write\" in navigator.clipboard && \"ClipboardItem\" in window && \"toBlob\" in HTMLCanvasElement.prototype;\nconst clipboardContainsElements = contents => {\n  if ([EXPORT_DATA_TYPES.excalidraw, EXPORT_DATA_TYPES.excalidrawClipboard].includes(contents === null || contents === void 0 ? void 0 : contents.type) && Array.isArray(contents.elements)) {\n    return true;\n  }\n  return false;\n};\nexport const copyToClipboard = async (elements, files) => {\n  const framesToCopy = new Set(elements.filter(element => element.type === \"frame\"));\n  let foundFile = false;\n  const _files = elements.reduce((acc, element) => {\n    if (isInitializedImageElement(element)) {\n      foundFile = true;\n      if (files && files[element.fileId]) {\n        acc[element.fileId] = files[element.fileId];\n      }\n    }\n    return acc;\n  }, {});\n  if (foundFile && !files) {\n    console.warn(\"copyToClipboard: attempting to file element(s) without providing associated `files` object.\");\n  }\n\n  // select binded text elements when copying\n  const contents = {\n    type: EXPORT_DATA_TYPES.excalidrawClipboard,\n    elements: elements.map(element => {\n      if (getContainingFrame(element) && !framesToCopy.has(getContainingFrame(element))) {\n        const copiedElement = deepCopyElement(element);\n        mutateElement(copiedElement, {\n          frameId: null\n        });\n        return copiedElement;\n      }\n      return element;\n    }),\n    files: files ? _files : undefined\n  };\n  const json = JSON.stringify(contents);\n  if (isTestEnv()) {\n    return json;\n  }\n  CLIPBOARD = json;\n  try {\n    PREFER_APP_CLIPBOARD = false;\n    await copyTextToSystemClipboard(json);\n  } catch (error) {\n    PREFER_APP_CLIPBOARD = true;\n    console.error(error);\n  }\n};\nconst getAppClipboard = () => {\n  if (!CLIPBOARD) {\n    return {};\n  }\n  try {\n    return JSON.parse(CLIPBOARD);\n  } catch (error) {\n    console.error(error);\n    return {};\n  }\n};\nconst parsePotentialSpreadsheet = text => {\n  const result = tryParseSpreadsheet(text);\n  if (result.type === VALID_SPREADSHEET) {\n    return {\n      spreadsheet: result.spreadsheet\n    };\n  }\n  return null;\n};\n\n/**\n * Retrieves content from system clipboard (either from ClipboardEvent or\n *  via async clipboard API if supported)\n */\nexport const getSystemClipboard = async event => {\n  try {\n    var _event$clipboardData;\n    const text = event ? (_event$clipboardData = event.clipboardData) === null || _event$clipboardData === void 0 ? void 0 : _event$clipboardData.getData(\"text/plain\") : probablySupportsClipboardReadText && (await navigator.clipboard.readText());\n    return (text || \"\").trim();\n  } catch {\n    return \"\";\n  }\n};\n\n/**\n * Attempts to parse clipboard. Prefers system clipboard.\n */\nexport const parseClipboard = async function (event) {\n  let isPlainPaste = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const systemClipboard = await getSystemClipboard(event);\n\n  // if system clipboard empty, couldn't be resolved, or contains previously\n  // copied excalidraw scene as SVG, fall back to previously copied excalidraw\n  // elements\n  if (!systemClipboard || !isPlainPaste && systemClipboard.includes(SVG_EXPORT_TAG)) {\n    return getAppClipboard();\n  }\n\n  // if system clipboard contains spreadsheet, use it even though it's\n  // technically possible it's staler than in-app clipboard\n  const spreadsheetResult = !isPlainPaste && parsePotentialSpreadsheet(systemClipboard);\n  if (spreadsheetResult) {\n    return spreadsheetResult;\n  }\n  const appClipboardData = getAppClipboard();\n  try {\n    const systemClipboardData = JSON.parse(systemClipboard);\n    if (clipboardContainsElements(systemClipboardData)) {\n      return {\n        elements: systemClipboardData.elements,\n        files: systemClipboardData.files,\n        text: isPlainPaste ? JSON.stringify(systemClipboardData.elements, null, 2) : undefined\n      };\n    }\n  } catch (e) {}\n  // system clipboard doesn't contain excalidraw elements → return plaintext\n  // unless we set a flag to prefer in-app clipboard because browser didn't\n  // support storing to system clipboard on copy\n  return PREFER_APP_CLIPBOARD && appClipboardData.elements ? {\n    ...appClipboardData,\n    text: isPlainPaste ? JSON.stringify(appClipboardData.elements, null, 2) : undefined\n  } : {\n    text: systemClipboard\n  };\n};\nexport const copyBlobToClipboardAsPng = async blob => {\n  try {\n    // in Safari so far we need to construct the ClipboardItem synchronously\n    // (i.e. in the same tick) otherwise browser will complain for lack of\n    // user intent. Using a Promise ClipboardItem constructor solves this.\n    // https://bugs.webkit.org/show_bug.cgi?id=222262\n    //\n    // Note that Firefox (and potentially others) seems to support Promise\n    // ClipboardItem constructor, but throws on an unrelated MIME type error.\n    // So we need to await this and fallback to awaiting the blob if applicable.\n    await navigator.clipboard.write([new window.ClipboardItem({\n      [MIME_TYPES.png]: blob\n    })]);\n  } catch (error) {\n    // if we're using a Promise ClipboardItem, let's try constructing\n    // with resolution value instead\n    if (isPromiseLike(blob)) {\n      await navigator.clipboard.write([new window.ClipboardItem({\n        [MIME_TYPES.png]: await blob\n      })]);\n    } else {\n      throw error;\n    }\n  }\n};\nexport const copyTextToSystemClipboard = async text => {\n  let copied = false;\n  if (probablySupportsClipboardWriteText) {\n    try {\n      // NOTE: doesn't work on FF on non-HTTPS domains, or when document\n      // not focused\n      await navigator.clipboard.writeText(text || \"\");\n      copied = true;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  // Note that execCommand doesn't allow copying empty strings, so if we're\n  // clearing clipboard using this API, we must copy at least an empty char\n  if (!copied && !copyTextViaExecCommand(text || \" \")) {\n    throw new Error(\"couldn't copy\");\n  }\n};\n\n// adapted from https://github.com/zenorocha/clipboard.js/blob/ce79f170aa655c408b6aab33c9472e8e4fa52e19/src/clipboard-action.js#L48\nconst copyTextViaExecCommand = text => {\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n  const textarea = document.createElement(\"textarea\");\n  textarea.style.border = \"0\";\n  textarea.style.padding = \"0\";\n  textarea.style.margin = \"0\";\n  textarea.style.position = \"absolute\";\n  textarea.style[isRTL ? \"right\" : \"left\"] = \"-9999px\";\n  const yPosition = window.pageYOffset || document.documentElement.scrollTop;\n  textarea.style.top = `${yPosition}px`;\n  // Prevent zooming on iOS\n  textarea.style.fontSize = \"12pt\";\n  textarea.setAttribute(\"readonly\", \"\");\n  textarea.value = text;\n  document.body.appendChild(textarea);\n  let success = false;\n  try {\n    textarea.select();\n    textarea.setSelectionRange(0, textarea.value.length);\n    success = document.execCommand(\"copy\");\n  } catch (error) {\n    console.error(error);\n  }\n  textarea.remove();\n  return success;\n};","map":{"version":3,"names":["SVG_EXPORT_TAG","tryParseSpreadsheet","VALID_SPREADSHEET","EXPORT_DATA_TYPES","MIME_TYPES","isInitializedImageElement","deepCopyElement","mutateElement","getContainingFrame","isPromiseLike","isTestEnv","CLIPBOARD","PREFER_APP_CLIPBOARD","probablySupportsClipboardReadText","navigator","clipboard","probablySupportsClipboardWriteText","probablySupportsClipboardBlob","window","HTMLCanvasElement","prototype","clipboardContainsElements","contents","excalidraw","excalidrawClipboard","includes","type","Array","isArray","elements","copyToClipboard","files","framesToCopy","Set","filter","element","foundFile","_files","reduce","acc","fileId","console","warn","map","has","copiedElement","frameId","undefined","json","JSON","stringify","copyTextToSystemClipboard","error","getAppClipboard","parse","parsePotentialSpreadsheet","text","result","spreadsheet","getSystemClipboard","event","_event$clipboardData","clipboardData","getData","readText","trim","parseClipboard","isPlainPaste","arguments","length","systemClipboard","spreadsheetResult","appClipboardData","systemClipboardData","e","copyBlobToClipboardAsPng","blob","write","ClipboardItem","png","copied","writeText","copyTextViaExecCommand","Error","isRTL","document","documentElement","getAttribute","textarea","createElement","style","border","padding","margin","position","yPosition","pageYOffset","scrollTop","top","fontSize","setAttribute","value","body","appendChild","success","select","setSelectionRange","execCommand","remove"],"sources":["D:/project/excalidraw-cn/src/clipboard.ts"],"sourcesContent":["import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"./element/types\";\nimport { BinaryFiles } from \"./types\";\nimport { SVG_EXPORT_TAG } from \"./scene/export\";\nimport { tryParseSpreadsheet, Spreadsheet, VALID_SPREADSHEET } from \"./charts\";\nimport { EXPORT_DATA_TYPES, MIME_TYPES } from \"./constants\";\nimport { isInitializedImageElement } from \"./element/typeChecks\";\nimport { deepCopyElement } from \"./element/newElement\";\nimport { mutateElement } from \"./element/mutateElement\";\nimport { getContainingFrame } from \"./frame\";\nimport { isPromiseLike, isTestEnv } from \"./utils\";\n\ntype ElementsClipboard = {\n  type: typeof EXPORT_DATA_TYPES.excalidrawClipboard;\n  elements: readonly NonDeletedExcalidrawElement[];\n  files: BinaryFiles | undefined;\n};\n\nexport interface ClipboardData {\n  spreadsheet?: Spreadsheet;\n  elements?: readonly ExcalidrawElement[];\n  files?: BinaryFiles;\n  text?: string;\n  errorMessage?: string;\n}\n\nlet CLIPBOARD = \"\";\nlet PREFER_APP_CLIPBOARD = false;\n\nexport const probablySupportsClipboardReadText =\n  \"clipboard\" in navigator && \"readText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardWriteText =\n  \"clipboard\" in navigator && \"writeText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardBlob =\n  \"clipboard\" in navigator &&\n  \"write\" in navigator.clipboard &&\n  \"ClipboardItem\" in window &&\n  \"toBlob\" in HTMLCanvasElement.prototype;\n\nconst clipboardContainsElements = (\n  contents: any,\n): contents is { elements: ExcalidrawElement[]; files?: BinaryFiles } => {\n  if (\n    [\n      EXPORT_DATA_TYPES.excalidraw,\n      EXPORT_DATA_TYPES.excalidrawClipboard,\n    ].includes(contents?.type) &&\n    Array.isArray(contents.elements)\n  ) {\n    return true;\n  }\n  return false;\n};\n\nexport const copyToClipboard = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  files: BinaryFiles | null,\n) => {\n  const framesToCopy = new Set(\n    elements.filter((element) => element.type === \"frame\"),\n  );\n  let foundFile = false;\n\n  const _files = elements.reduce((acc, element) => {\n    if (isInitializedImageElement(element)) {\n      foundFile = true;\n      if (files && files[element.fileId]) {\n        acc[element.fileId] = files[element.fileId];\n      }\n    }\n    return acc;\n  }, {} as BinaryFiles);\n\n  if (foundFile && !files) {\n    console.warn(\n      \"copyToClipboard: attempting to file element(s) without providing associated `files` object.\",\n    );\n  }\n\n  // select binded text elements when copying\n  const contents: ElementsClipboard = {\n    type: EXPORT_DATA_TYPES.excalidrawClipboard,\n    elements: elements.map((element) => {\n      if (\n        getContainingFrame(element) &&\n        !framesToCopy.has(getContainingFrame(element)!)\n      ) {\n        const copiedElement = deepCopyElement(element);\n        mutateElement(copiedElement, {\n          frameId: null,\n        });\n        return copiedElement;\n      }\n\n      return element;\n    }),\n    files: files ? _files : undefined,\n  };\n  const json = JSON.stringify(contents);\n\n  if (isTestEnv()) {\n    return json;\n  }\n\n  CLIPBOARD = json;\n\n  try {\n    PREFER_APP_CLIPBOARD = false;\n    await copyTextToSystemClipboard(json);\n  } catch (error: any) {\n    PREFER_APP_CLIPBOARD = true;\n    console.error(error);\n  }\n};\n\nconst getAppClipboard = (): Partial<ElementsClipboard> => {\n  if (!CLIPBOARD) {\n    return {};\n  }\n\n  try {\n    return JSON.parse(CLIPBOARD);\n  } catch (error: any) {\n    console.error(error);\n    return {};\n  }\n};\n\nconst parsePotentialSpreadsheet = (\n  text: string,\n): { spreadsheet: Spreadsheet } | { errorMessage: string } | null => {\n  const result = tryParseSpreadsheet(text);\n  if (result.type === VALID_SPREADSHEET) {\n    return { spreadsheet: result.spreadsheet };\n  }\n  return null;\n};\n\n/**\n * Retrieves content from system clipboard (either from ClipboardEvent or\n *  via async clipboard API if supported)\n */\nexport const getSystemClipboard = async (\n  event: ClipboardEvent | null,\n): Promise<string> => {\n  try {\n    const text = event\n      ? event.clipboardData?.getData(\"text/plain\")\n      : probablySupportsClipboardReadText &&\n        (await navigator.clipboard.readText());\n\n    return (text || \"\").trim();\n  } catch {\n    return \"\";\n  }\n};\n\n/**\n * Attempts to parse clipboard. Prefers system clipboard.\n */\nexport const parseClipboard = async (\n  event: ClipboardEvent | null,\n  isPlainPaste = false,\n): Promise<ClipboardData> => {\n  const systemClipboard = await getSystemClipboard(event);\n\n  // if system clipboard empty, couldn't be resolved, or contains previously\n  // copied excalidraw scene as SVG, fall back to previously copied excalidraw\n  // elements\n  if (\n    !systemClipboard ||\n    (!isPlainPaste && systemClipboard.includes(SVG_EXPORT_TAG))\n  ) {\n    return getAppClipboard();\n  }\n\n  // if system clipboard contains spreadsheet, use it even though it's\n  // technically possible it's staler than in-app clipboard\n  const spreadsheetResult =\n    !isPlainPaste && parsePotentialSpreadsheet(systemClipboard);\n\n  if (spreadsheetResult) {\n    return spreadsheetResult;\n  }\n\n  const appClipboardData = getAppClipboard();\n\n  try {\n    const systemClipboardData = JSON.parse(systemClipboard);\n    if (clipboardContainsElements(systemClipboardData)) {\n      return {\n        elements: systemClipboardData.elements,\n        files: systemClipboardData.files,\n        text: isPlainPaste\n          ? JSON.stringify(systemClipboardData.elements, null, 2)\n          : undefined,\n      };\n    }\n  } catch (e) {}\n  // system clipboard doesn't contain excalidraw elements → return plaintext\n  // unless we set a flag to prefer in-app clipboard because browser didn't\n  // support storing to system clipboard on copy\n  return PREFER_APP_CLIPBOARD && appClipboardData.elements\n    ? {\n        ...appClipboardData,\n        text: isPlainPaste\n          ? JSON.stringify(appClipboardData.elements, null, 2)\n          : undefined,\n      }\n    : { text: systemClipboard };\n};\n\nexport const copyBlobToClipboardAsPng = async (blob: Blob | Promise<Blob>) => {\n  try {\n    // in Safari so far we need to construct the ClipboardItem synchronously\n    // (i.e. in the same tick) otherwise browser will complain for lack of\n    // user intent. Using a Promise ClipboardItem constructor solves this.\n    // https://bugs.webkit.org/show_bug.cgi?id=222262\n    //\n    // Note that Firefox (and potentially others) seems to support Promise\n    // ClipboardItem constructor, but throws on an unrelated MIME type error.\n    // So we need to await this and fallback to awaiting the blob if applicable.\n    await navigator.clipboard.write([\n      new window.ClipboardItem({\n        [MIME_TYPES.png]: blob,\n      }),\n    ]);\n  } catch (error: any) {\n    // if we're using a Promise ClipboardItem, let's try constructing\n    // with resolution value instead\n    if (isPromiseLike(blob)) {\n      await navigator.clipboard.write([\n        new window.ClipboardItem({\n          [MIME_TYPES.png]: await blob,\n        }),\n      ]);\n    } else {\n      throw error;\n    }\n  }\n};\n\nexport const copyTextToSystemClipboard = async (text: string | null) => {\n  let copied = false;\n  if (probablySupportsClipboardWriteText) {\n    try {\n      // NOTE: doesn't work on FF on non-HTTPS domains, or when document\n      // not focused\n      await navigator.clipboard.writeText(text || \"\");\n      copied = true;\n    } catch (error: any) {\n      console.error(error);\n    }\n  }\n\n  // Note that execCommand doesn't allow copying empty strings, so if we're\n  // clearing clipboard using this API, we must copy at least an empty char\n  if (!copied && !copyTextViaExecCommand(text || \" \")) {\n    throw new Error(\"couldn't copy\");\n  }\n};\n\n// adapted from https://github.com/zenorocha/clipboard.js/blob/ce79f170aa655c408b6aab33c9472e8e4fa52e19/src/clipboard-action.js#L48\nconst copyTextViaExecCommand = (text: string) => {\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n\n  const textarea = document.createElement(\"textarea\");\n\n  textarea.style.border = \"0\";\n  textarea.style.padding = \"0\";\n  textarea.style.margin = \"0\";\n  textarea.style.position = \"absolute\";\n  textarea.style[isRTL ? \"right\" : \"left\"] = \"-9999px\";\n  const yPosition = window.pageYOffset || document.documentElement.scrollTop;\n  textarea.style.top = `${yPosition}px`;\n  // Prevent zooming on iOS\n  textarea.style.fontSize = \"12pt\";\n\n  textarea.setAttribute(\"readonly\", \"\");\n  textarea.value = text;\n\n  document.body.appendChild(textarea);\n\n  let success = false;\n\n  try {\n    textarea.select();\n    textarea.setSelectionRange(0, textarea.value.length);\n\n    success = document.execCommand(\"copy\");\n  } catch (error: any) {\n    console.error(error);\n  }\n\n  textarea.remove();\n\n  return success;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}