{"ast":null,"code":"import _defineProperty from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";import _slicedToArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import _toConsumableArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _objectSpread from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";var _DEFAULT_LINE_HEIGHT;import{getFontString,arrayToMap,isTestEnv}from\"../utils\";import{mutateElement}from\"./mutateElement\";import{BOUND_TEXT_PADDING,DEFAULT_FONT_FAMILY,DEFAULT_FONT_SIZE,FONT_FAMILY,isSafari,TEXT_ALIGN,VERTICAL_ALIGN}from\"../constants\";import Scene from\"../scene/Scene\";import{isTextElement}from\".\";import{isBoundToContainer,isArrowElement}from\"./typeChecks\";import{LinearElementEditor}from\"./linearElementEditor\";import{isTextBindableContainer}from\"./typeChecks\";import{getElementAbsoluteCoords}from\"../element\";import{getSelectedElements}from\"../scene\";import{isHittingElementNotConsideringBoundingBox}from\"./collision\";import{resetOriginalContainerCache,updateOriginalContainerCache}from\"./textWysiwyg\";export var normalizeText=function normalizeText(text){return text// replace tabs with spaces so they render and measure correctly\n.replace(/\\t/g,\"        \")// normalize newlines\n.replace(/\\r?\\n|\\r/g,\"\\n\");};export var splitIntoLines=function splitIntoLines(text){return normalizeText(text).split(\"\\n\");};export var redrawTextBoundingBox=function redrawTextBoundingBox(textElement,container){var maxWidth=undefined;var boundTextUpdates={x:textElement.x,y:textElement.y,text:textElement.text,width:textElement.width,height:textElement.height,baseline:textElement.baseline};boundTextUpdates.text=textElement.text;if(container){maxWidth=getBoundTextMaxWidth(container);boundTextUpdates.text=wrapText(textElement.originalText,getFontString(textElement),maxWidth);}var metrics=measureText(boundTextUpdates.text,getFontString(textElement),textElement.lineHeight);boundTextUpdates.width=metrics.width;boundTextUpdates.height=metrics.height;boundTextUpdates.baseline=metrics.baseline;if(container){var containerDims=getContainerDims(container);var maxContainerHeight=getBoundTextMaxHeight(container,textElement);var nextHeight=containerDims.height;if(metrics.height>maxContainerHeight){nextHeight=computeContainerDimensionForBoundText(metrics.height,container.type);mutateElement(container,{height:nextHeight});updateOriginalContainerCache(container.id,nextHeight);}var updatedTextElement=_objectSpread(_objectSpread({},textElement),boundTextUpdates);var _computeBoundTextPosi=computeBoundTextPosition(container,updatedTextElement),x=_computeBoundTextPosi.x,y=_computeBoundTextPosi.y;boundTextUpdates.x=x;boundTextUpdates.y=y;}mutateElement(textElement,boundTextUpdates);};export var bindTextToShapeAfterDuplication=function bindTextToShapeAfterDuplication(sceneElements,oldElements,oldIdToDuplicatedId){var sceneElementMap=arrayToMap(sceneElements);oldElements.forEach(function(element){var newElementId=oldIdToDuplicatedId.get(element.id);var boundTextElementId=getBoundTextElementId(element);if(boundTextElementId){var newTextElementId=oldIdToDuplicatedId.get(boundTextElementId);if(newTextElementId){var newContainer=sceneElementMap.get(newElementId);if(newContainer){mutateElement(newContainer,{boundElements:(element.boundElements||[]).filter(function(boundElement){return boundElement.id!==newTextElementId&&boundElement.id!==boundTextElementId;}).concat({type:\"text\",id:newTextElementId})});}var newTextElement=sceneElementMap.get(newTextElementId);if(newTextElement&&isTextElement(newTextElement)){mutateElement(newTextElement,{containerId:newContainer?newElementId:null});}}}});};export var handleBindTextResize=function handleBindTextResize(container,transformHandleType){var boundTextElementId=getBoundTextElementId(container);if(!boundTextElementId){return;}resetOriginalContainerCache(container.id);var textElement=Scene.getScene(container).getElement(boundTextElementId);if(textElement&&textElement.text){if(!container){return;}textElement=Scene.getScene(container).getElement(boundTextElementId);var text=textElement.text;var nextHeight=textElement.height;var nextWidth=textElement.width;var containerDims=getContainerDims(container);var maxWidth=getBoundTextMaxWidth(container);var maxHeight=getBoundTextMaxHeight(container,textElement);var containerHeight=containerDims.height;var nextBaseLine=textElement.baseline;if(transformHandleType!==\"n\"&&transformHandleType!==\"s\"){if(text){text=wrapText(textElement.originalText,getFontString(textElement),maxWidth);}var metrics=measureText(text,getFontString(textElement),textElement.lineHeight);nextHeight=metrics.height;nextWidth=metrics.width;nextBaseLine=metrics.baseline;}// increase height in case text element height exceeds\nif(nextHeight>maxHeight){containerHeight=computeContainerDimensionForBoundText(nextHeight,container.type);var diff=containerHeight-containerDims.height;// fix the y coord when resizing from ne/nw/n\nvar updatedY=!isArrowElement(container)&&(transformHandleType===\"ne\"||transformHandleType===\"nw\"||transformHandleType===\"n\")?container.y-diff:container.y;mutateElement(container,{height:containerHeight,y:updatedY});}mutateElement(textElement,{text:text,width:nextWidth,height:nextHeight,baseline:nextBaseLine});if(!isArrowElement(container)){mutateElement(textElement,computeBoundTextPosition(container,textElement));}}};export var computeBoundTextPosition=function computeBoundTextPosition(container,boundTextElement){if(isArrowElement(container)){return LinearElementEditor.getBoundTextElementPosition(container,boundTextElement);}var containerCoords=getContainerCoords(container);var maxContainerHeight=getBoundTextMaxHeight(container,boundTextElement);var maxContainerWidth=getBoundTextMaxWidth(container);var x;var y;if(boundTextElement.verticalAlign===VERTICAL_ALIGN.TOP){y=containerCoords.y;}else if(boundTextElement.verticalAlign===VERTICAL_ALIGN.BOTTOM){y=containerCoords.y+(maxContainerHeight-boundTextElement.height);}else{y=containerCoords.y+(maxContainerHeight/2-boundTextElement.height/2);}if(boundTextElement.textAlign===TEXT_ALIGN.LEFT){x=containerCoords.x;}else if(boundTextElement.textAlign===TEXT_ALIGN.RIGHT){x=containerCoords.x+(maxContainerWidth-boundTextElement.width);}else{x=containerCoords.x+(maxContainerWidth/2-boundTextElement.width/2);}return{x:x,y:y};};// https://github.com/grassator/canvas-text-editor/blob/master/lib/FontMetrics.js\nexport var measureText=function measureText(text,font,lineHeight){text=text.split(\"\\n\")// replace empty lines with single space because leading/trailing empty\n// lines would be stripped from computation\n.map(function(x){return x||\" \";}).join(\"\\n\");var fontSize=parseFloat(font);var height=getTextHeight(text,fontSize,lineHeight);var width=getTextWidth(text,font);var baseline=measureBaseline(text,font,lineHeight);return{width:width,height:height,baseline:baseline};};export var measureBaseline=function measureBaseline(text,font,lineHeight,wrapInContainer){var container=document.createElement(\"div\");container.style.position=\"absolute\";container.style.whiteSpace=\"pre\";container.style.font=font;container.style.minHeight=\"1em\";if(wrapInContainer){container.style.overflow=\"hidden\";container.style.wordBreak=\"break-word\";container.style.whiteSpace=\"pre-wrap\";}container.style.lineHeight=String(lineHeight);container.innerText=text;// Baseline is important for positioning text on canvas\ndocument.body.appendChild(container);var span=document.createElement(\"span\");span.style.display=\"inline-block\";span.style.overflow=\"hidden\";span.style.width=\"1px\";span.style.height=\"1px\";container.appendChild(span);var baseline=span.offsetTop+span.offsetHeight;var height=container.offsetHeight;if(isSafari){var canvasHeight=getTextHeight(text,parseFloat(font),lineHeight);var fontSize=parseFloat(font);// In Safari the font size gets rounded off when rendering hence calculating the safari height and shifting the baseline if it differs\n// from the actual canvas height\nvar domHeight=getTextHeight(text,Math.round(fontSize),lineHeight);if(canvasHeight>height){baseline+=canvasHeight-domHeight;}if(height>canvasHeight){baseline-=domHeight-canvasHeight;}}document.body.removeChild(container);return baseline;};/**\n * To get unitless line-height (if unknown) we can calculate it by dividing\n * height-per-line by fontSize.\n */export var detectLineHeight=function detectLineHeight(textElement){var lineCount=splitIntoLines(textElement.text).length;return textElement.height/lineCount/textElement.fontSize;};/**\n * We calculate the line height from the font size and the unitless line height,\n * aligning with the W3C spec.\n */export var getLineHeightInPx=function getLineHeightInPx(fontSize,lineHeight){return fontSize*lineHeight;};// FIXME rename to getApproxMinContainerHeight\nexport var getApproxMinLineHeight=function getApproxMinLineHeight(fontSize,lineHeight){return getLineHeightInPx(fontSize,lineHeight)+BOUND_TEXT_PADDING*2;};var canvas;var getLineWidth=function getLineWidth(text,font){if(!canvas){canvas=document.createElement(\"canvas\");}var canvas2dContext=canvas.getContext(\"2d\");canvas2dContext.font=font;var width=canvas2dContext.measureText(text).width;// since in test env the canvas measureText algo\n// doesn't measure text and instead just returns number of\n// characters hence we assume that each letteris 10px\nif(isTestEnv()){return width*10;}return width;};export var getTextWidth=function getTextWidth(text,font){var lines=splitIntoLines(text);var width=0;lines.forEach(function(line){width=Math.max(width,getLineWidth(line,font));});return width;};export var getTextHeight=function getTextHeight(text,fontSize,lineHeight){var lineCount=splitIntoLines(text).length;return getLineHeightInPx(fontSize,lineHeight)*lineCount;};export var parseTokens=function parseTokens(text){// Splitting words containing \"-\" as those are treated as separate words\n// by css wrapping algorithm eg non-profit => non-, profit\nvar words=text.split(\"-\");if(words.length>1){// non-proft org => ['non-', 'profit org']\nwords.forEach(function(word,index){if(index!==words.length-1){words[index]=word+=\"-\";}});}// Joining the words with space and splitting them again with space to get the\n// final list of tokens\n// ['non-', 'profit org'] =>,'non- proft org' => ['non-','profit','org']\nreturn words.join(\" \").split(\" \");};export var wrapText=function wrapText(text,font,maxWidth){// if maxWidth is not finite or NaN which can happen in case of bugs in\n// computation, we need to make sure we don't continue as we'll end up\n// in an infinite loop\nif(!Number.isFinite(maxWidth)||maxWidth<0){return text;}var lines=[];var originalLines=text.split(\"\\n\");var spaceWidth=getLineWidth(\" \",font);var currentLine=\"\";var currentLineWidthTillNow=0;var push=function push(str){if(str.trim()){lines.push(str);}};var resetParams=function resetParams(){currentLine=\"\";currentLineWidthTillNow=0;};originalLines.forEach(function(originalLine){var currentLineWidth=getTextWidth(originalLine,font);// Push the line if its <= maxWidth\nif(currentLineWidth<=maxWidth){lines.push(originalLine);return;// continue\n}var words=parseTokens(originalLine);resetParams();var index=0;while(index<words.length){var currentWordWidth=getLineWidth(words[index],font);// This will only happen when single word takes entire width\nif(currentWordWidth===maxWidth){push(words[index]);index++;}// Start breaking longer words exceeding max width\nelse if(currentWordWidth>maxWidth){// push current line since the current word exceeds the max width\n// so will be appended in next line\npush(currentLine);resetParams();while(words[index].length>0){var currentChar=String.fromCodePoint(words[index].codePointAt(0));var width=charWidth.calculate(currentChar,font);currentLineWidthTillNow+=width;words[index]=words[index].slice(currentChar.length);if(currentLineWidthTillNow>=maxWidth){push(currentLine);currentLine=currentChar;currentLineWidthTillNow=width;}else{currentLine+=currentChar;}}// push current line if appending space exceeds max width\nif(currentLineWidthTillNow+spaceWidth>=maxWidth){push(currentLine);resetParams();// space needs to be appended before next word\n// as currentLine contains chars which couldn't be appended\n// to previous line unless the line ends with hyphen to sync\n// with css word-wrap\n}else if(!currentLine.endsWith(\"-\")){currentLine+=\" \";currentLineWidthTillNow+=spaceWidth;}index++;}else{// Start appending words in a line till max width reached\nwhile(currentLineWidthTillNow<maxWidth&&index<words.length){var word=words[index];currentLineWidthTillNow=getLineWidth(currentLine+word,font);if(currentLineWidthTillNow>maxWidth){push(currentLine);resetParams();break;}index++;// if word ends with \"-\" then we don't need to add space\n// to sync with css word-wrap\nvar shouldAppendSpace=!word.endsWith(\"-\");currentLine+=word;if(shouldAppendSpace){currentLine+=\" \";}// Push the word if appending space exceeds max width\nif(currentLineWidthTillNow+spaceWidth>=maxWidth){if(shouldAppendSpace){lines.push(currentLine.slice(0,-1));}else{lines.push(currentLine);}resetParams();break;}}}}if(currentLine.slice(-1)===\" \"){// only remove last trailing space which we have added when joining words\ncurrentLine=currentLine.slice(0,-1);push(currentLine);}});return lines.join(\"\\n\");};export var charWidth=function(){var cachedCharWidth={};var calculate=function calculate(char,font){var ascii=char.charCodeAt(0);if(!cachedCharWidth[font]){cachedCharWidth[font]=[];}if(!cachedCharWidth[font][ascii]){var width=getLineWidth(char,font);cachedCharWidth[font][ascii]=width;}return cachedCharWidth[font][ascii];};var getCache=function getCache(font){return cachedCharWidth[font];};return{calculate:calculate,getCache:getCache};}();var DUMMY_TEXT=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".toLocaleUpperCase();// FIXME rename to getApproxMinContainerWidth\nexport var getApproxMinLineWidth=function getApproxMinLineWidth(font,lineHeight){var maxCharWidth=getMaxCharWidth(font);if(maxCharWidth===0){return measureText(DUMMY_TEXT.split(\"\").join(\"\\n\"),font,lineHeight).width+BOUND_TEXT_PADDING*2;}return maxCharWidth+BOUND_TEXT_PADDING*2;};export var getMinCharWidth=function getMinCharWidth(font){var cache=charWidth.getCache(font);if(!cache){return 0;}var cacheWithOutEmpty=cache.filter(function(val){return val!==undefined;});return Math.min.apply(Math,_toConsumableArray(cacheWithOutEmpty));};export var getMaxCharWidth=function getMaxCharWidth(font){var cache=charWidth.getCache(font);if(!cache){return 0;}var cacheWithOutEmpty=cache.filter(function(val){return val!==undefined;});return Math.max.apply(Math,_toConsumableArray(cacheWithOutEmpty));};export var getApproxCharsToFitInWidth=function getApproxCharsToFitInWidth(font,width){// Generally lower case is used so converting to lower case\nvar dummyText=DUMMY_TEXT.toLocaleLowerCase();var batchLength=6;var index=0;var widthTillNow=0;var str=\"\";while(widthTillNow<=width){var batch=dummyText.substr(index,index+batchLength);str+=batch;widthTillNow+=getLineWidth(str,font);if(index===dummyText.length-1){index=0;}index=index+batchLength;}while(widthTillNow>width){str=str.substr(0,str.length-1);widthTillNow=getLineWidth(str,font);}return str.length;};export var getBoundTextElementId=function getBoundTextElementId(container){var _container$boundEleme,_container$boundEleme2,_container$boundEleme3;return container!==null&&container!==void 0&&(_container$boundEleme=container.boundElements)!==null&&_container$boundEleme!==void 0&&_container$boundEleme.length?(container===null||container===void 0?void 0:(_container$boundEleme2=container.boundElements)===null||_container$boundEleme2===void 0?void 0:(_container$boundEleme3=_container$boundEleme2.filter(function(ele){return ele.type===\"text\";})[0])===null||_container$boundEleme3===void 0?void 0:_container$boundEleme3.id)||null:null;};export var getBoundTextElement=function getBoundTextElement(element){if(!element){return null;}var boundTextElementId=getBoundTextElementId(element);if(boundTextElementId){var _Scene$getScene;return((_Scene$getScene=Scene.getScene(element))===null||_Scene$getScene===void 0?void 0:_Scene$getScene.getElement(boundTextElementId))||null;}return null;};export var getContainerElement=function getContainerElement(element){if(!element){return null;}if(element.containerId){var _Scene$getScene2;return((_Scene$getScene2=Scene.getScene(element))===null||_Scene$getScene2===void 0?void 0:_Scene$getScene2.getElement(element.containerId))||null;}return null;};export var getContainerDims=function getContainerDims(element){var MIN_WIDTH=300;if(isArrowElement(element)){var width=Math.max(element.width,MIN_WIDTH);var height=element.height;return{width:width,height:height};}return{width:element.width,height:element.height};};export var getContainerCenter=function getContainerCenter(container,appState){if(!isArrowElement(container)){return{x:container.x+container.width/2,y:container.y+container.height/2};}var points=LinearElementEditor.getPointsGlobalCoordinates(container);if(points.length%2===1){var _index=Math.floor(container.points.length/2);var midPoint=LinearElementEditor.getPointGlobalCoordinates(container,container.points[_index]);return{x:midPoint[0],y:midPoint[1]};}var index=container.points.length/2-1;var midSegmentMidpoint=LinearElementEditor.getEditorMidPoints(container,appState)[index];if(!midSegmentMidpoint){midSegmentMidpoint=LinearElementEditor.getSegmentMidPoint(container,points[index],points[index+1],index+1);}return{x:midSegmentMidpoint[0],y:midSegmentMidpoint[1]};};export var getContainerCoords=function getContainerCoords(container){var offsetX=BOUND_TEXT_PADDING;var offsetY=BOUND_TEXT_PADDING;if(container.type===\"ellipse\"){// The derivation of coordinates is explained in https://github.com/excalidraw/excalidraw/pull/6172\noffsetX+=container.width/2*(1-Math.sqrt(2)/2);offsetY+=container.height/2*(1-Math.sqrt(2)/2);}// The derivation of coordinates is explained in https://github.com/excalidraw/excalidraw/pull/6265\nif(container.type===\"diamond\"){offsetX+=container.width/4;offsetY+=container.height/4;}return{x:container.x+offsetX,y:container.y+offsetY};};export var getTextElementAngle=function getTextElementAngle(textElement){var container=getContainerElement(textElement);if(!container||isArrowElement(container)){return textElement.angle;}return container.angle;};export var getBoundTextElementOffset=function getBoundTextElementOffset(boundTextElement){var container=getContainerElement(boundTextElement);if(!container||!boundTextElement){return 0;}if(isArrowElement(container)){return BOUND_TEXT_PADDING*8;}return BOUND_TEXT_PADDING;};export var getBoundTextElementPosition=function getBoundTextElementPosition(container,boundTextElement){if(isArrowElement(container)){return LinearElementEditor.getBoundTextElementPosition(container,boundTextElement);}};export var shouldAllowVerticalAlign=function shouldAllowVerticalAlign(selectedElements){return selectedElements.some(function(element){var hasBoundContainer=isBoundToContainer(element);if(hasBoundContainer){var container=getContainerElement(element);if(isTextElement(element)&&isArrowElement(container)){return false;}return true;}return false;});};export var suppportsHorizontalAlign=function suppportsHorizontalAlign(selectedElements){return selectedElements.some(function(element){var hasBoundContainer=isBoundToContainer(element);if(hasBoundContainer){var container=getContainerElement(element);if(isTextElement(element)&&isArrowElement(container)){return false;}return true;}return isTextElement(element);});};export var getTextBindableContainerAtPosition=function getTextBindableContainerAtPosition(elements,appState,x,y){var selectedElements=getSelectedElements(elements,appState);if(selectedElements.length===1){return isTextBindableContainer(selectedElements[0],false)?selectedElements[0]:null;}var hitElement=null;// We need to to hit testing from front (end of the array) to back (beginning of the array)\nfor(var index=elements.length-1;index>=0;--index){if(elements[index].isDeleted){continue;}var _getElementAbsoluteCo=getElementAbsoluteCoords(elements[index]),_getElementAbsoluteCo2=_slicedToArray(_getElementAbsoluteCo,4),x1=_getElementAbsoluteCo2[0],y1=_getElementAbsoluteCo2[1],x2=_getElementAbsoluteCo2[2],y2=_getElementAbsoluteCo2[3];if(isArrowElement(elements[index])&&isHittingElementNotConsideringBoundingBox(elements[index],appState,null,[x,y])){hitElement=elements[index];break;}else if(x1<x&&x<x2&&y1<y&&y<y2){hitElement=elements[index];break;}}return isTextBindableContainer(hitElement,false)?hitElement:null;};var VALID_CONTAINER_TYPES=new Set([\"rectangle\",\"ellipse\",\"diamond\",\"arrow\"]);export var isValidTextContainer=function isValidTextContainer(element){return VALID_CONTAINER_TYPES.has(element.type);};export var computeContainerDimensionForBoundText=function computeContainerDimensionForBoundText(dimension,containerType){dimension=Math.ceil(dimension);var padding=BOUND_TEXT_PADDING*2;if(containerType===\"ellipse\"){return Math.round((dimension+padding)/Math.sqrt(2)*2);}if(containerType===\"arrow\"){return dimension+padding*8;}if(containerType===\"diamond\"){return 2*(dimension+padding);}return dimension+padding;};export var getBoundTextMaxWidth=function getBoundTextMaxWidth(container){var width=getContainerDims(container).width;if(isArrowElement(container)){return width-BOUND_TEXT_PADDING*8*2;}if(container.type===\"ellipse\"){// The width of the largest rectangle inscribed inside an ellipse is\n// Math.round((ellipse.width / 2) * Math.sqrt(2)) which is derived from\n// equation of an ellipse -https://github.com/excalidraw/excalidraw/pull/6172\nreturn Math.round(width/2*Math.sqrt(2))-BOUND_TEXT_PADDING*2;}if(container.type===\"diamond\"){// The width of the largest rectangle inscribed inside a rhombus is\n// Math.round(width / 2) - https://github.com/excalidraw/excalidraw/pull/6265\nreturn Math.round(width/2)-BOUND_TEXT_PADDING*2;}return width-BOUND_TEXT_PADDING*2;};export var getBoundTextMaxHeight=function getBoundTextMaxHeight(container,boundTextElement){var height=getContainerDims(container).height;if(isArrowElement(container)){var containerHeight=height-BOUND_TEXT_PADDING*8*2;if(containerHeight<=0){return boundTextElement.height;}return height;}if(container.type===\"ellipse\"){// The height of the largest rectangle inscribed inside an ellipse is\n// Math.round((ellipse.height / 2) * Math.sqrt(2)) which is derived from\n// equation of an ellipse - https://github.com/excalidraw/excalidraw/pull/6172\nreturn Math.round(height/2*Math.sqrt(2))-BOUND_TEXT_PADDING*2;}if(container.type===\"diamond\"){// The height of the largest rectangle inscribed inside a rhombus is\n// Math.round(height / 2) - https://github.com/excalidraw/excalidraw/pull/6265\nreturn Math.round(height/2)-BOUND_TEXT_PADDING*2;}return height-BOUND_TEXT_PADDING*2;};export var isMeasureTextSupported=function isMeasureTextSupported(){var width=getTextWidth(DUMMY_TEXT,getFontString({fontSize:DEFAULT_FONT_SIZE,fontFamily:DEFAULT_FONT_FAMILY}));return width>0;};/**\n * Unitless line height\n *\n * In previous versions we used `normal` line height, which browsers interpret\n * differently, and based on font-family and font-size.\n *\n * To make line heights consistent across browsers we hardcode the values for\n * each of our fonts based on most common average line-heights.\n * See https://github.com/excalidraw/excalidraw/pull/6360#issuecomment-1477635971\n * where the values come from.\n */var DEFAULT_LINE_HEIGHT=(_DEFAULT_LINE_HEIGHT={},_defineProperty(_DEFAULT_LINE_HEIGHT,FONT_FAMILY.Virgil,1.25),_defineProperty(_DEFAULT_LINE_HEIGHT,FONT_FAMILY.Helvetica,1.15),_defineProperty(_DEFAULT_LINE_HEIGHT,FONT_FAMILY.Cascadia,1.2),_DEFAULT_LINE_HEIGHT);export var getDefaultLineHeight=function getDefaultLineHeight(fontFamily){if(fontFamily in DEFAULT_LINE_HEIGHT){return DEFAULT_LINE_HEIGHT[fontFamily];}return DEFAULT_LINE_HEIGHT[DEFAULT_FONT_FAMILY];};","map":{"version":3,"names":["getFontString","arrayToMap","isTestEnv","mutateElement","BOUND_TEXT_PADDING","DEFAULT_FONT_FAMILY","DEFAULT_FONT_SIZE","FONT_FAMILY","isSafari","TEXT_ALIGN","VERTICAL_ALIGN","Scene","isTextElement","isBoundToContainer","isArrowElement","LinearElementEditor","isTextBindableContainer","getElementAbsoluteCoords","getSelectedElements","isHittingElementNotConsideringBoundingBox","resetOriginalContainerCache","updateOriginalContainerCache","normalizeText","text","replace","splitIntoLines","split","redrawTextBoundingBox","textElement","container","maxWidth","undefined","boundTextUpdates","x","y","width","height","baseline","getBoundTextMaxWidth","wrapText","originalText","metrics","measureText","lineHeight","containerDims","getContainerDims","maxContainerHeight","getBoundTextMaxHeight","nextHeight","computeContainerDimensionForBoundText","type","id","updatedTextElement","_objectSpread","_computeBoundTextPosi","computeBoundTextPosition","bindTextToShapeAfterDuplication","sceneElements","oldElements","oldIdToDuplicatedId","sceneElementMap","forEach","element","newElementId","get","boundTextElementId","getBoundTextElementId","newTextElementId","newContainer","boundElements","filter","boundElement","concat","newTextElement","containerId","handleBindTextResize","transformHandleType","getScene","getElement","nextWidth","maxHeight","containerHeight","nextBaseLine","diff","updatedY","boundTextElement","getBoundTextElementPosition","containerCoords","getContainerCoords","maxContainerWidth","verticalAlign","TOP","BOTTOM","textAlign","LEFT","RIGHT","font","map","join","fontSize","parseFloat","getTextHeight","getTextWidth","measureBaseline","wrapInContainer","document","createElement","style","position","whiteSpace","minHeight","overflow","wordBreak","String","innerText","body","appendChild","span","display","offsetTop","offsetHeight","canvasHeight","domHeight","Math","round","removeChild","detectLineHeight","lineCount","length","getLineHeightInPx","getApproxMinLineHeight","canvas","getLineWidth","canvas2dContext","getContext","lines","line","max","parseTokens","words","word","index","Number","isFinite","originalLines","spaceWidth","currentLine","currentLineWidthTillNow","push","str","trim","resetParams","originalLine","currentLineWidth","currentWordWidth","currentChar","fromCodePoint","codePointAt","charWidth","calculate","slice","endsWith","shouldAppendSpace","cachedCharWidth","char","ascii","charCodeAt","getCache","DUMMY_TEXT","toLocaleUpperCase","getApproxMinLineWidth","maxCharWidth","getMaxCharWidth","getMinCharWidth","cache","cacheWithOutEmpty","val","min","apply","_toConsumableArray","getApproxCharsToFitInWidth","dummyText","toLocaleLowerCase","batchLength","widthTillNow","batch","substr","_container$boundEleme","_container$boundEleme2","_container$boundEleme3","ele","getBoundTextElement","_Scene$getScene","getContainerElement","_Scene$getScene2","MIN_WIDTH","getContainerCenter","appState","points","getPointsGlobalCoordinates","floor","midPoint","getPointGlobalCoordinates","midSegmentMidpoint","getEditorMidPoints","getSegmentMidPoint","offsetX","offsetY","sqrt","getTextElementAngle","angle","getBoundTextElementOffset","shouldAllowVerticalAlign","selectedElements","some","hasBoundContainer","suppportsHorizontalAlign","getTextBindableContainerAtPosition","elements","hitElement","isDeleted","_getElementAbsoluteCo","_getElementAbsoluteCo2","_slicedToArray","x1","y1","x2","y2","VALID_CONTAINER_TYPES","Set","isValidTextContainer","has","dimension","containerType","ceil","padding","isMeasureTextSupported","fontFamily","DEFAULT_LINE_HEIGHT","_DEFAULT_LINE_HEIGHT","_defineProperty","Virgil","Helvetica","Cascadia","getDefaultLineHeight"],"sources":["D:/project/excalidraw-cn/src/element/textElement.ts"],"sourcesContent":["import { getFontString, arrayToMap, isTestEnv } from \"../utils\";\nimport {\n  ExcalidrawElement,\n  ExcalidrawTextContainer,\n  ExcalidrawTextElement,\n  ExcalidrawTextElementWithContainer,\n  FontFamilyValues,\n  FontString,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\nimport { mutateElement } from \"./mutateElement\";\nimport {\n  BOUND_TEXT_PADDING,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  FONT_FAMILY,\n  isSafari,\n  TEXT_ALIGN,\n  VERTICAL_ALIGN,\n} from \"../constants\";\nimport { MaybeTransformHandleType } from \"./transformHandles\";\nimport Scene from \"../scene/Scene\";\nimport { isTextElement } from \".\";\nimport { isBoundToContainer, isArrowElement } from \"./typeChecks\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { AppState } from \"../types\";\nimport { isTextBindableContainer } from \"./typeChecks\";\nimport { getElementAbsoluteCoords } from \"../element\";\nimport { getSelectedElements } from \"../scene\";\nimport { isHittingElementNotConsideringBoundingBox } from \"./collision\";\nimport {\n  resetOriginalContainerCache,\n  updateOriginalContainerCache,\n} from \"./textWysiwyg\";\nimport { ExtractSetType } from \"../utility-types\";\n\nexport const normalizeText = (text: string) => {\n  return (\n    text\n      // replace tabs with spaces so they render and measure correctly\n      .replace(/\\t/g, \"        \")\n      // normalize newlines\n      .replace(/\\r?\\n|\\r/g, \"\\n\")\n  );\n};\n\nexport const splitIntoLines = (text: string) => {\n  return normalizeText(text).split(\"\\n\");\n};\n\nexport const redrawTextBoundingBox = (\n  textElement: ExcalidrawTextElement,\n  container: ExcalidrawElement | null,\n) => {\n  let maxWidth = undefined;\n  const boundTextUpdates = {\n    x: textElement.x,\n    y: textElement.y,\n    text: textElement.text,\n    width: textElement.width,\n    height: textElement.height,\n    baseline: textElement.baseline,\n  };\n\n  boundTextUpdates.text = textElement.text;\n\n  if (container) {\n    maxWidth = getBoundTextMaxWidth(container);\n    boundTextUpdates.text = wrapText(\n      textElement.originalText,\n      getFontString(textElement),\n      maxWidth,\n    );\n  }\n  const metrics = measureText(\n    boundTextUpdates.text,\n    getFontString(textElement),\n    textElement.lineHeight,\n  );\n\n  boundTextUpdates.width = metrics.width;\n  boundTextUpdates.height = metrics.height;\n  boundTextUpdates.baseline = metrics.baseline;\n\n  if (container) {\n    const containerDims = getContainerDims(container);\n    const maxContainerHeight = getBoundTextMaxHeight(\n      container,\n      textElement as ExcalidrawTextElementWithContainer,\n    );\n\n    let nextHeight = containerDims.height;\n    if (metrics.height > maxContainerHeight) {\n      nextHeight = computeContainerDimensionForBoundText(\n        metrics.height,\n        container.type,\n      );\n      mutateElement(container, { height: nextHeight });\n      updateOriginalContainerCache(container.id, nextHeight);\n    }\n    const updatedTextElement = {\n      ...textElement,\n      ...boundTextUpdates,\n    } as ExcalidrawTextElementWithContainer;\n    const { x, y } = computeBoundTextPosition(container, updatedTextElement);\n    boundTextUpdates.x = x;\n    boundTextUpdates.y = y;\n  }\n\n  mutateElement(textElement, boundTextUpdates);\n};\n\nexport const bindTextToShapeAfterDuplication = (\n  sceneElements: ExcalidrawElement[],\n  oldElements: ExcalidrawElement[],\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n): void => {\n  const sceneElementMap = arrayToMap(sceneElements) as Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement\n  >;\n  oldElements.forEach((element) => {\n    const newElementId = oldIdToDuplicatedId.get(element.id) as string;\n    const boundTextElementId = getBoundTextElementId(element);\n\n    if (boundTextElementId) {\n      const newTextElementId = oldIdToDuplicatedId.get(boundTextElementId);\n      if (newTextElementId) {\n        const newContainer = sceneElementMap.get(newElementId);\n        if (newContainer) {\n          mutateElement(newContainer, {\n            boundElements: (element.boundElements || [])\n              .filter(\n                (boundElement) =>\n                  boundElement.id !== newTextElementId &&\n                  boundElement.id !== boundTextElementId,\n              )\n              .concat({\n                type: \"text\",\n                id: newTextElementId,\n              }),\n          });\n        }\n        const newTextElement = sceneElementMap.get(newTextElementId);\n        if (newTextElement && isTextElement(newTextElement)) {\n          mutateElement(newTextElement, {\n            containerId: newContainer ? newElementId : null,\n          });\n        }\n      }\n    }\n  });\n};\n\nexport const handleBindTextResize = (\n  container: NonDeletedExcalidrawElement,\n  transformHandleType: MaybeTransformHandleType,\n) => {\n  const boundTextElementId = getBoundTextElementId(container);\n  if (!boundTextElementId) {\n    return;\n  }\n  resetOriginalContainerCache(container.id);\n  let textElement = Scene.getScene(container)!.getElement(\n    boundTextElementId,\n  ) as ExcalidrawTextElement;\n  if (textElement && textElement.text) {\n    if (!container) {\n      return;\n    }\n\n    textElement = Scene.getScene(container)!.getElement(\n      boundTextElementId,\n    ) as ExcalidrawTextElement;\n    let text = textElement.text;\n    let nextHeight = textElement.height;\n    let nextWidth = textElement.width;\n    const containerDims = getContainerDims(container);\n    const maxWidth = getBoundTextMaxWidth(container);\n    const maxHeight = getBoundTextMaxHeight(\n      container,\n      textElement as ExcalidrawTextElementWithContainer,\n    );\n    let containerHeight = containerDims.height;\n    let nextBaseLine = textElement.baseline;\n    if (transformHandleType !== \"n\" && transformHandleType !== \"s\") {\n      if (text) {\n        text = wrapText(\n          textElement.originalText,\n          getFontString(textElement),\n          maxWidth,\n        );\n      }\n      const metrics = measureText(\n        text,\n        getFontString(textElement),\n        textElement.lineHeight,\n      );\n      nextHeight = metrics.height;\n      nextWidth = metrics.width;\n      nextBaseLine = metrics.baseline;\n    }\n    // increase height in case text element height exceeds\n    if (nextHeight > maxHeight) {\n      containerHeight = computeContainerDimensionForBoundText(\n        nextHeight,\n        container.type,\n      );\n\n      const diff = containerHeight - containerDims.height;\n      // fix the y coord when resizing from ne/nw/n\n      const updatedY =\n        !isArrowElement(container) &&\n        (transformHandleType === \"ne\" ||\n          transformHandleType === \"nw\" ||\n          transformHandleType === \"n\")\n          ? container.y - diff\n          : container.y;\n      mutateElement(container, {\n        height: containerHeight,\n        y: updatedY,\n      });\n    }\n\n    mutateElement(textElement, {\n      text,\n      width: nextWidth,\n      height: nextHeight,\n      baseline: nextBaseLine,\n    });\n\n    if (!isArrowElement(container)) {\n      mutateElement(\n        textElement,\n        computeBoundTextPosition(\n          container,\n          textElement as ExcalidrawTextElementWithContainer,\n        ),\n      );\n    }\n  }\n};\n\nexport const computeBoundTextPosition = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n) => {\n  if (isArrowElement(container)) {\n    return LinearElementEditor.getBoundTextElementPosition(\n      container,\n      boundTextElement,\n    );\n  }\n  const containerCoords = getContainerCoords(container);\n  const maxContainerHeight = getBoundTextMaxHeight(container, boundTextElement);\n  const maxContainerWidth = getBoundTextMaxWidth(container);\n\n  let x;\n  let y;\n  if (boundTextElement.verticalAlign === VERTICAL_ALIGN.TOP) {\n    y = containerCoords.y;\n  } else if (boundTextElement.verticalAlign === VERTICAL_ALIGN.BOTTOM) {\n    y = containerCoords.y + (maxContainerHeight - boundTextElement.height);\n  } else {\n    y =\n      containerCoords.y +\n      (maxContainerHeight / 2 - boundTextElement.height / 2);\n  }\n  if (boundTextElement.textAlign === TEXT_ALIGN.LEFT) {\n    x = containerCoords.x;\n  } else if (boundTextElement.textAlign === TEXT_ALIGN.RIGHT) {\n    x = containerCoords.x + (maxContainerWidth - boundTextElement.width);\n  } else {\n    x =\n      containerCoords.x + (maxContainerWidth / 2 - boundTextElement.width / 2);\n  }\n  return { x, y };\n};\n\n// https://github.com/grassator/canvas-text-editor/blob/master/lib/FontMetrics.js\n\nexport const measureText = (\n  text: string,\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  text = text\n    .split(\"\\n\")\n    // replace empty lines with single space because leading/trailing empty\n    // lines would be stripped from computation\n    .map((x) => x || \" \")\n    .join(\"\\n\");\n  const fontSize = parseFloat(font);\n  const height = getTextHeight(text, fontSize, lineHeight);\n  const width = getTextWidth(text, font);\n  const baseline = measureBaseline(text, font, lineHeight);\n  return { width, height, baseline };\n};\n\nexport const measureBaseline = (\n  text: string,\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n  wrapInContainer?: boolean,\n) => {\n  const container = document.createElement(\"div\");\n  container.style.position = \"absolute\";\n  container.style.whiteSpace = \"pre\";\n  container.style.font = font;\n  container.style.minHeight = \"1em\";\n  if (wrapInContainer) {\n    container.style.overflow = \"hidden\";\n    container.style.wordBreak = \"break-word\";\n    container.style.whiteSpace = \"pre-wrap\";\n  }\n\n  container.style.lineHeight = String(lineHeight);\n\n  container.innerText = text;\n\n  // Baseline is important for positioning text on canvas\n  document.body.appendChild(container);\n\n  const span = document.createElement(\"span\");\n  span.style.display = \"inline-block\";\n  span.style.overflow = \"hidden\";\n  span.style.width = \"1px\";\n  span.style.height = \"1px\";\n  container.appendChild(span);\n  let baseline = span.offsetTop + span.offsetHeight;\n  const height = container.offsetHeight;\n\n  if (isSafari) {\n    const canvasHeight = getTextHeight(text, parseFloat(font), lineHeight);\n    const fontSize = parseFloat(font);\n    // In Safari the font size gets rounded off when rendering hence calculating the safari height and shifting the baseline if it differs\n    // from the actual canvas height\n    const domHeight = getTextHeight(text, Math.round(fontSize), lineHeight);\n    if (canvasHeight > height) {\n      baseline += canvasHeight - domHeight;\n    }\n\n    if (height > canvasHeight) {\n      baseline -= domHeight - canvasHeight;\n    }\n  }\n  document.body.removeChild(container);\n  return baseline;\n};\n\n/**\n * To get unitless line-height (if unknown) we can calculate it by dividing\n * height-per-line by fontSize.\n */\nexport const detectLineHeight = (textElement: ExcalidrawTextElement) => {\n  const lineCount = splitIntoLines(textElement.text).length;\n  return (textElement.height /\n    lineCount /\n    textElement.fontSize) as ExcalidrawTextElement[\"lineHeight\"];\n};\n\n/**\n * We calculate the line height from the font size and the unitless line height,\n * aligning with the W3C spec.\n */\nexport const getLineHeightInPx = (\n  fontSize: ExcalidrawTextElement[\"fontSize\"],\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  return fontSize * lineHeight;\n};\n\n// FIXME rename to getApproxMinContainerHeight\nexport const getApproxMinLineHeight = (\n  fontSize: ExcalidrawTextElement[\"fontSize\"],\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  return getLineHeightInPx(fontSize, lineHeight) + BOUND_TEXT_PADDING * 2;\n};\n\nlet canvas: HTMLCanvasElement | undefined;\n\nconst getLineWidth = (text: string, font: FontString) => {\n  if (!canvas) {\n    canvas = document.createElement(\"canvas\");\n  }\n  const canvas2dContext = canvas.getContext(\"2d\")!;\n  canvas2dContext.font = font;\n  const width = canvas2dContext.measureText(text).width;\n\n  // since in test env the canvas measureText algo\n  // doesn't measure text and instead just returns number of\n  // characters hence we assume that each letteris 10px\n  if (isTestEnv()) {\n    return width * 10;\n  }\n  return width;\n};\n\nexport const getTextWidth = (text: string, font: FontString) => {\n  const lines = splitIntoLines(text);\n  let width = 0;\n  lines.forEach((line) => {\n    width = Math.max(width, getLineWidth(line, font));\n  });\n  return width;\n};\n\nexport const getTextHeight = (\n  text: string,\n  fontSize: number,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  const lineCount = splitIntoLines(text).length;\n  return getLineHeightInPx(fontSize, lineHeight) * lineCount;\n};\n\nexport const parseTokens = (text: string) => {\n  // Splitting words containing \"-\" as those are treated as separate words\n  // by css wrapping algorithm eg non-profit => non-, profit\n  const words = text.split(\"-\");\n  if (words.length > 1) {\n    // non-proft org => ['non-', 'profit org']\n    words.forEach((word, index) => {\n      if (index !== words.length - 1) {\n        words[index] = word += \"-\";\n      }\n    });\n  }\n  // Joining the words with space and splitting them again with space to get the\n  // final list of tokens\n  // ['non-', 'profit org'] =>,'non- proft org' => ['non-','profit','org']\n  return words.join(\" \").split(\" \");\n};\n\nexport const wrapText = (text: string, font: FontString, maxWidth: number) => {\n  // if maxWidth is not finite or NaN which can happen in case of bugs in\n  // computation, we need to make sure we don't continue as we'll end up\n  // in an infinite loop\n  if (!Number.isFinite(maxWidth) || maxWidth < 0) {\n    return text;\n  }\n\n  const lines: Array<string> = [];\n  const originalLines = text.split(\"\\n\");\n  const spaceWidth = getLineWidth(\" \", font);\n\n  let currentLine = \"\";\n  let currentLineWidthTillNow = 0;\n\n  const push = (str: string) => {\n    if (str.trim()) {\n      lines.push(str);\n    }\n  };\n\n  const resetParams = () => {\n    currentLine = \"\";\n    currentLineWidthTillNow = 0;\n  };\n  originalLines.forEach((originalLine) => {\n    const currentLineWidth = getTextWidth(originalLine, font);\n\n    // Push the line if its <= maxWidth\n    if (currentLineWidth <= maxWidth) {\n      lines.push(originalLine);\n      return; // continue\n    }\n\n    const words = parseTokens(originalLine);\n    resetParams();\n\n    let index = 0;\n\n    while (index < words.length) {\n      const currentWordWidth = getLineWidth(words[index], font);\n\n      // This will only happen when single word takes entire width\n      if (currentWordWidth === maxWidth) {\n        push(words[index]);\n        index++;\n      }\n\n      // Start breaking longer words exceeding max width\n      else if (currentWordWidth > maxWidth) {\n        // push current line since the current word exceeds the max width\n        // so will be appended in next line\n\n        push(currentLine);\n\n        resetParams();\n\n        while (words[index].length > 0) {\n          const currentChar = String.fromCodePoint(\n            words[index].codePointAt(0)!,\n          );\n          const width = charWidth.calculate(currentChar, font);\n          currentLineWidthTillNow += width;\n          words[index] = words[index].slice(currentChar.length);\n\n          if (currentLineWidthTillNow >= maxWidth) {\n            push(currentLine);\n            currentLine = currentChar;\n            currentLineWidthTillNow = width;\n          } else {\n            currentLine += currentChar;\n          }\n        }\n        // push current line if appending space exceeds max width\n        if (currentLineWidthTillNow + spaceWidth >= maxWidth) {\n          push(currentLine);\n          resetParams();\n          // space needs to be appended before next word\n          // as currentLine contains chars which couldn't be appended\n          // to previous line unless the line ends with hyphen to sync\n          // with css word-wrap\n        } else if (!currentLine.endsWith(\"-\")) {\n          currentLine += \" \";\n          currentLineWidthTillNow += spaceWidth;\n        }\n        index++;\n      } else {\n        // Start appending words in a line till max width reached\n        while (currentLineWidthTillNow < maxWidth && index < words.length) {\n          const word = words[index];\n          currentLineWidthTillNow = getLineWidth(currentLine + word, font);\n\n          if (currentLineWidthTillNow > maxWidth) {\n            push(currentLine);\n            resetParams();\n\n            break;\n          }\n          index++;\n\n          // if word ends with \"-\" then we don't need to add space\n          // to sync with css word-wrap\n          const shouldAppendSpace = !word.endsWith(\"-\");\n          currentLine += word;\n\n          if (shouldAppendSpace) {\n            currentLine += \" \";\n          }\n\n          // Push the word if appending space exceeds max width\n          if (currentLineWidthTillNow + spaceWidth >= maxWidth) {\n            if (shouldAppendSpace) {\n              lines.push(currentLine.slice(0, -1));\n            } else {\n              lines.push(currentLine);\n            }\n            resetParams();\n            break;\n          }\n        }\n      }\n    }\n    if (currentLine.slice(-1) === \" \") {\n      // only remove last trailing space which we have added when joining words\n      currentLine = currentLine.slice(0, -1);\n      push(currentLine);\n    }\n  });\n  return lines.join(\"\\n\");\n};\n\nexport const charWidth = (() => {\n  const cachedCharWidth: { [key: FontString]: Array<number> } = {};\n\n  const calculate = (char: string, font: FontString) => {\n    const ascii = char.charCodeAt(0);\n    if (!cachedCharWidth[font]) {\n      cachedCharWidth[font] = [];\n    }\n    if (!cachedCharWidth[font][ascii]) {\n      const width = getLineWidth(char, font);\n      cachedCharWidth[font][ascii] = width;\n    }\n\n    return cachedCharWidth[font][ascii];\n  };\n\n  const getCache = (font: FontString) => {\n    return cachedCharWidth[font];\n  };\n  return {\n    calculate,\n    getCache,\n  };\n})();\n\nconst DUMMY_TEXT = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".toLocaleUpperCase();\n\n// FIXME rename to getApproxMinContainerWidth\nexport const getApproxMinLineWidth = (\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  const maxCharWidth = getMaxCharWidth(font);\n  if (maxCharWidth === 0) {\n    return (\n      measureText(DUMMY_TEXT.split(\"\").join(\"\\n\"), font, lineHeight).width +\n      BOUND_TEXT_PADDING * 2\n    );\n  }\n  return maxCharWidth + BOUND_TEXT_PADDING * 2;\n};\n\nexport const getMinCharWidth = (font: FontString) => {\n  const cache = charWidth.getCache(font);\n  if (!cache) {\n    return 0;\n  }\n  const cacheWithOutEmpty = cache.filter((val) => val !== undefined);\n\n  return Math.min(...cacheWithOutEmpty);\n};\n\nexport const getMaxCharWidth = (font: FontString) => {\n  const cache = charWidth.getCache(font);\n  if (!cache) {\n    return 0;\n  }\n  const cacheWithOutEmpty = cache.filter((val) => val !== undefined);\n  return Math.max(...cacheWithOutEmpty);\n};\n\nexport const getApproxCharsToFitInWidth = (font: FontString, width: number) => {\n  // Generally lower case is used so converting to lower case\n  const dummyText = DUMMY_TEXT.toLocaleLowerCase();\n  const batchLength = 6;\n  let index = 0;\n  let widthTillNow = 0;\n  let str = \"\";\n  while (widthTillNow <= width) {\n    const batch = dummyText.substr(index, index + batchLength);\n    str += batch;\n    widthTillNow += getLineWidth(str, font);\n    if (index === dummyText.length - 1) {\n      index = 0;\n    }\n    index = index + batchLength;\n  }\n\n  while (widthTillNow > width) {\n    str = str.substr(0, str.length - 1);\n    widthTillNow = getLineWidth(str, font);\n  }\n  return str.length;\n};\n\nexport const getBoundTextElementId = (container: ExcalidrawElement | null) => {\n  return container?.boundElements?.length\n    ? container?.boundElements?.filter((ele) => ele.type === \"text\")[0]?.id ||\n        null\n    : null;\n};\n\nexport const getBoundTextElement = (element: ExcalidrawElement | null) => {\n  if (!element) {\n    return null;\n  }\n  const boundTextElementId = getBoundTextElementId(element);\n  if (boundTextElementId) {\n    return (\n      (Scene.getScene(element)?.getElement(\n        boundTextElementId,\n      ) as ExcalidrawTextElementWithContainer) || null\n    );\n  }\n  return null;\n};\n\nexport const getContainerElement = (\n  element:\n    | (ExcalidrawElement & {\n        containerId: ExcalidrawElement[\"id\"] | null;\n      })\n    | null,\n) => {\n  if (!element) {\n    return null;\n  }\n  if (element.containerId) {\n    return Scene.getScene(element)?.getElement(element.containerId) || null;\n  }\n  return null;\n};\n\nexport const getContainerDims = (element: ExcalidrawElement) => {\n  const MIN_WIDTH = 300;\n  if (isArrowElement(element)) {\n    const width = Math.max(element.width, MIN_WIDTH);\n    const height = element.height;\n    return { width, height };\n  }\n  return { width: element.width, height: element.height };\n};\n\nexport const getContainerCenter = (\n  container: ExcalidrawElement,\n  appState: AppState,\n) => {\n  if (!isArrowElement(container)) {\n    return {\n      x: container.x + container.width / 2,\n      y: container.y + container.height / 2,\n    };\n  }\n  const points = LinearElementEditor.getPointsGlobalCoordinates(container);\n  if (points.length % 2 === 1) {\n    const index = Math.floor(container.points.length / 2);\n    const midPoint = LinearElementEditor.getPointGlobalCoordinates(\n      container,\n      container.points[index],\n    );\n    return { x: midPoint[0], y: midPoint[1] };\n  }\n  const index = container.points.length / 2 - 1;\n  let midSegmentMidpoint = LinearElementEditor.getEditorMidPoints(\n    container,\n    appState,\n  )[index];\n  if (!midSegmentMidpoint) {\n    midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(\n      container,\n      points[index],\n      points[index + 1],\n      index + 1,\n    );\n  }\n  return { x: midSegmentMidpoint[0], y: midSegmentMidpoint[1] };\n};\n\nexport const getContainerCoords = (container: NonDeletedExcalidrawElement) => {\n  let offsetX = BOUND_TEXT_PADDING;\n  let offsetY = BOUND_TEXT_PADDING;\n\n  if (container.type === \"ellipse\") {\n    // The derivation of coordinates is explained in https://github.com/excalidraw/excalidraw/pull/6172\n    offsetX += (container.width / 2) * (1 - Math.sqrt(2) / 2);\n    offsetY += (container.height / 2) * (1 - Math.sqrt(2) / 2);\n  }\n  // The derivation of coordinates is explained in https://github.com/excalidraw/excalidraw/pull/6265\n  if (container.type === \"diamond\") {\n    offsetX += container.width / 4;\n    offsetY += container.height / 4;\n  }\n  return {\n    x: container.x + offsetX,\n    y: container.y + offsetY,\n  };\n};\n\nexport const getTextElementAngle = (textElement: ExcalidrawTextElement) => {\n  const container = getContainerElement(textElement);\n  if (!container || isArrowElement(container)) {\n    return textElement.angle;\n  }\n  return container.angle;\n};\n\nexport const getBoundTextElementOffset = (\n  boundTextElement: ExcalidrawTextElement | null,\n) => {\n  const container = getContainerElement(boundTextElement);\n  if (!container || !boundTextElement) {\n    return 0;\n  }\n  if (isArrowElement(container)) {\n    return BOUND_TEXT_PADDING * 8;\n  }\n\n  return BOUND_TEXT_PADDING;\n};\n\nexport const getBoundTextElementPosition = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n) => {\n  if (isArrowElement(container)) {\n    return LinearElementEditor.getBoundTextElementPosition(\n      container,\n      boundTextElement,\n    );\n  }\n};\n\nexport const shouldAllowVerticalAlign = (\n  selectedElements: NonDeletedExcalidrawElement[],\n) => {\n  return selectedElements.some((element) => {\n    const hasBoundContainer = isBoundToContainer(element);\n    if (hasBoundContainer) {\n      const container = getContainerElement(element);\n      if (isTextElement(element) && isArrowElement(container)) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  });\n};\n\nexport const suppportsHorizontalAlign = (\n  selectedElements: NonDeletedExcalidrawElement[],\n) => {\n  return selectedElements.some((element) => {\n    const hasBoundContainer = isBoundToContainer(element);\n    if (hasBoundContainer) {\n      const container = getContainerElement(element);\n      if (isTextElement(element) && isArrowElement(container)) {\n        return false;\n      }\n      return true;\n    }\n\n    return isTextElement(element);\n  });\n};\n\nexport const getTextBindableContainerAtPosition = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  x: number,\n  y: number,\n): ExcalidrawTextContainer | null => {\n  const selectedElements = getSelectedElements(elements, appState);\n  if (selectedElements.length === 1) {\n    return isTextBindableContainer(selectedElements[0], false)\n      ? selectedElements[0]\n      : null;\n  }\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  for (let index = elements.length - 1; index >= 0; --index) {\n    if (elements[index].isDeleted) {\n      continue;\n    }\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(elements[index]);\n    if (\n      isArrowElement(elements[index]) &&\n      isHittingElementNotConsideringBoundingBox(\n        elements[index],\n        appState,\n        null,\n        [x, y],\n      )\n    ) {\n      hitElement = elements[index];\n      break;\n    } else if (x1 < x && x < x2 && y1 < y && y < y2) {\n      hitElement = elements[index];\n      break;\n    }\n  }\n\n  return isTextBindableContainer(hitElement, false) ? hitElement : null;\n};\n\nconst VALID_CONTAINER_TYPES = new Set([\n  \"rectangle\",\n  \"ellipse\",\n  \"diamond\",\n  \"arrow\",\n]);\n\nexport const isValidTextContainer = (element: ExcalidrawElement) =>\n  VALID_CONTAINER_TYPES.has(element.type);\n\nexport const computeContainerDimensionForBoundText = (\n  dimension: number,\n  containerType: ExtractSetType<typeof VALID_CONTAINER_TYPES>,\n) => {\n  dimension = Math.ceil(dimension);\n  const padding = BOUND_TEXT_PADDING * 2;\n\n  if (containerType === \"ellipse\") {\n    return Math.round(((dimension + padding) / Math.sqrt(2)) * 2);\n  }\n  if (containerType === \"arrow\") {\n    return dimension + padding * 8;\n  }\n  if (containerType === \"diamond\") {\n    return 2 * (dimension + padding);\n  }\n  return dimension + padding;\n};\n\nexport const getBoundTextMaxWidth = (container: ExcalidrawElement) => {\n  const width = getContainerDims(container).width;\n  if (isArrowElement(container)) {\n    return width - BOUND_TEXT_PADDING * 8 * 2;\n  }\n\n  if (container.type === \"ellipse\") {\n    // The width of the largest rectangle inscribed inside an ellipse is\n    // Math.round((ellipse.width / 2) * Math.sqrt(2)) which is derived from\n    // equation of an ellipse -https://github.com/excalidraw/excalidraw/pull/6172\n    return Math.round((width / 2) * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;\n  }\n  if (container.type === \"diamond\") {\n    // The width of the largest rectangle inscribed inside a rhombus is\n    // Math.round(width / 2) - https://github.com/excalidraw/excalidraw/pull/6265\n    return Math.round(width / 2) - BOUND_TEXT_PADDING * 2;\n  }\n  return width - BOUND_TEXT_PADDING * 2;\n};\n\nexport const getBoundTextMaxHeight = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n) => {\n  const height = getContainerDims(container).height;\n  if (isArrowElement(container)) {\n    const containerHeight = height - BOUND_TEXT_PADDING * 8 * 2;\n    if (containerHeight <= 0) {\n      return boundTextElement.height;\n    }\n    return height;\n  }\n  if (container.type === \"ellipse\") {\n    // The height of the largest rectangle inscribed inside an ellipse is\n    // Math.round((ellipse.height / 2) * Math.sqrt(2)) which is derived from\n    // equation of an ellipse - https://github.com/excalidraw/excalidraw/pull/6172\n    return Math.round((height / 2) * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;\n  }\n  if (container.type === \"diamond\") {\n    // The height of the largest rectangle inscribed inside a rhombus is\n    // Math.round(height / 2) - https://github.com/excalidraw/excalidraw/pull/6265\n    return Math.round(height / 2) - BOUND_TEXT_PADDING * 2;\n  }\n  return height - BOUND_TEXT_PADDING * 2;\n};\n\nexport const isMeasureTextSupported = () => {\n  const width = getTextWidth(\n    DUMMY_TEXT,\n    getFontString({\n      fontSize: DEFAULT_FONT_SIZE,\n      fontFamily: DEFAULT_FONT_FAMILY,\n    }),\n  );\n  return width > 0;\n};\n\n/**\n * Unitless line height\n *\n * In previous versions we used `normal` line height, which browsers interpret\n * differently, and based on font-family and font-size.\n *\n * To make line heights consistent across browsers we hardcode the values for\n * each of our fonts based on most common average line-heights.\n * See https://github.com/excalidraw/excalidraw/pull/6360#issuecomment-1477635971\n * where the values come from.\n */\nconst DEFAULT_LINE_HEIGHT = {\n  // ~1.25 is the average for Virgil in WebKit and Blink.\n  // Gecko (FF) uses ~1.28.\n  [FONT_FAMILY.Virgil]: 1.25 as ExcalidrawTextElement[\"lineHeight\"],\n  // ~1.15 is the average for Virgil in WebKit and Blink.\n  // Gecko if all over the place.\n  [FONT_FAMILY.Helvetica]: 1.15 as ExcalidrawTextElement[\"lineHeight\"],\n  // ~1.2 is the average for Virgil in WebKit and Blink, and kinda Gecko too\n  [FONT_FAMILY.Cascadia]: 1.2 as ExcalidrawTextElement[\"lineHeight\"],\n};\n\nexport const getDefaultLineHeight = (fontFamily: FontFamilyValues) => {\n  if (fontFamily in DEFAULT_LINE_HEIGHT) {\n    return DEFAULT_LINE_HEIGHT[fontFamily];\n  }\n  return DEFAULT_LINE_HEIGHT[DEFAULT_FONT_FAMILY];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}