{"ast":null,"code":"import { updateBoundElements } from \"./binding\";\nimport { getCommonBounds } from \"./bounds\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nimport { getBoundTextElement } from \"./textElement\";\nimport { isSelectedViaGroup } from \"../groups\";\nimport { isFrameElement } from \"./typeChecks\";\nexport const dragSelectedElements = function (pointerDownState, selectedElements, pointerX, pointerY) {\n  let lockDirection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let distanceX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  let distanceY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  let appState = arguments.length > 7 ? arguments[7] : undefined;\n  let scene = arguments.length > 8 ? arguments[8] : undefined;\n  const [x1, y1] = getCommonBounds(selectedElements);\n  const offset = {\n    x: pointerX - x1,\n    y: pointerY - y1\n  };\n\n  // we do not want a frame and its elements to be selected at the same time\n  // but when it happens (due to some bug), we want to avoid updating element\n  // in the frame twice, hence the use of set\n  const elementsToUpdate = new Set(selectedElements);\n  const frames = selectedElements.filter(e => isFrameElement(e)).map(f => f.id);\n  if (frames.length > 0) {\n    const elementsInFrames = scene.getNonDeletedElements().filter(e => e.frameId !== null).filter(e => frames.includes(e.frameId));\n    elementsInFrames.forEach(element => elementsToUpdate.add(element));\n  }\n  elementsToUpdate.forEach(element => {\n    updateElementCoords(lockDirection, distanceX, distanceY, pointerDownState, element, offset);\n    // update coords of bound text only if we're dragging the container directly\n    // (we don't drag the group that it's part of)\n    if (\n    // container isn't part of any group\n    // (perf optim so we don't check `isSelectedViaGroup()` in every case)\n    !element.groupIds.length ||\n    // container is part of a group, but we're dragging the container directly\n    appState.editingGroupId && !isSelectedViaGroup(appState, element)) {\n      const textElement = getBoundTextElement(element);\n      if (textElement && (\n      // when container is added to a frame, so will its bound text\n      // so the text is already in `elementsToUpdate` and we should avoid\n      // updating its coords again\n      !textElement.frameId || !frames.includes(textElement.frameId))) {\n        updateElementCoords(lockDirection, distanceX, distanceY, pointerDownState, textElement, offset);\n      }\n    }\n    updateBoundElements(element, {\n      simultaneouslyUpdated: Array.from(elementsToUpdate)\n    });\n  });\n};\nconst updateElementCoords = (lockDirection, distanceX, distanceY, pointerDownState, element, offset) => {\n  let x;\n  let y;\n  if (lockDirection) {\n    const lockX = lockDirection && distanceX < distanceY;\n    const lockY = lockDirection && distanceX > distanceY;\n    const original = pointerDownState.originalElements.get(element.id);\n    x = lockX && original ? original.x : element.x + offset.x;\n    y = lockY && original ? original.y : element.y + offset.y;\n  } else {\n    x = element.x + offset.x;\n    y = element.y + offset.y;\n  }\n  mutateElement(element, {\n    x,\n    y\n  });\n};\nexport const getDragOffsetXY = (selectedElements, x, y) => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  return [x - x1, y - y1];\n};\nexport const dragNewElement = (draggingElement, elementType, originX, originY, x, y, width, height, shouldMaintainAspectRatio, shouldResizeFromCenter, widthAspectRatio) => {\n  if (shouldMaintainAspectRatio && draggingElement.type !== \"selection\") {\n    if (widthAspectRatio) {\n      height = width / widthAspectRatio;\n    } else {\n      // Depending on where the cursor is at (x, y) relative to where the starting point is\n      // (originX, originY), we use ONLY width or height to control size increase.\n      // This allows the cursor to always \"stick\" to one of the sides of the bounding box.\n      if (Math.abs(y - originY) > Math.abs(x - originX)) {\n        ({\n          width,\n          height\n        } = getPerfectElementSize(elementType, height, x < originX ? -width : width));\n      } else {\n        ({\n          width,\n          height\n        } = getPerfectElementSize(elementType, width, y < originY ? -height : height));\n      }\n      if (height < 0) {\n        height = -height;\n      }\n    }\n  }\n  let newX = x < originX ? originX - width : originX;\n  let newY = y < originY ? originY - height : originY;\n  if (shouldResizeFromCenter) {\n    width += width;\n    height += height;\n    newX = originX - width / 2;\n    newY = originY - height / 2;\n  }\n  if (width !== 0 && height !== 0) {\n    mutateElement(draggingElement, {\n      x: newX,\n      y: newY,\n      width,\n      height\n    });\n  }\n};","map":{"version":3,"names":["updateBoundElements","getCommonBounds","mutateElement","getPerfectElementSize","getBoundTextElement","isSelectedViaGroup","isFrameElement","dragSelectedElements","pointerDownState","selectedElements","pointerX","pointerY","lockDirection","arguments","length","undefined","distanceX","distanceY","appState","scene","x1","y1","offset","x","y","elementsToUpdate","Set","frames","filter","e","map","f","id","elementsInFrames","getNonDeletedElements","frameId","includes","forEach","element","add","updateElementCoords","groupIds","editingGroupId","textElement","simultaneouslyUpdated","Array","from","lockX","lockY","original","originalElements","get","getDragOffsetXY","dragNewElement","draggingElement","elementType","originX","originY","width","height","shouldMaintainAspectRatio","shouldResizeFromCenter","widthAspectRatio","type","Math","abs","newX","newY"],"sources":["D:/project/excalidraw-cn/src/element/dragElements.ts"],"sourcesContent":["import { updateBoundElements } from \"./binding\";\nimport { getCommonBounds } from \"./bounds\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nimport { NonDeletedExcalidrawElement } from \"./types\";\nimport { AppState, PointerDownState } from \"../types\";\nimport { getBoundTextElement } from \"./textElement\";\nimport { isSelectedViaGroup } from \"../groups\";\nimport Scene from \"../scene/Scene\";\nimport { isFrameElement } from \"./typeChecks\";\n\nexport const dragSelectedElements = (\n  pointerDownState: PointerDownState,\n  selectedElements: NonDeletedExcalidrawElement[],\n  pointerX: number,\n  pointerY: number,\n  lockDirection: boolean = false,\n  distanceX: number = 0,\n  distanceY: number = 0,\n  appState: AppState,\n  scene: Scene,\n) => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  const offset = { x: pointerX - x1, y: pointerY - y1 };\n\n  // we do not want a frame and its elements to be selected at the same time\n  // but when it happens (due to some bug), we want to avoid updating element\n  // in the frame twice, hence the use of set\n  const elementsToUpdate = new Set<NonDeletedExcalidrawElement>(\n    selectedElements,\n  );\n  const frames = selectedElements\n    .filter((e) => isFrameElement(e))\n    .map((f) => f.id);\n\n  if (frames.length > 0) {\n    const elementsInFrames = scene\n      .getNonDeletedElements()\n      .filter((e) => e.frameId !== null)\n      .filter((e) => frames.includes(e.frameId!));\n\n    elementsInFrames.forEach((element) => elementsToUpdate.add(element));\n  }\n\n  elementsToUpdate.forEach((element) => {\n    updateElementCoords(\n      lockDirection,\n      distanceX,\n      distanceY,\n      pointerDownState,\n      element,\n      offset,\n    );\n    // update coords of bound text only if we're dragging the container directly\n    // (we don't drag the group that it's part of)\n    if (\n      // container isn't part of any group\n      // (perf optim so we don't check `isSelectedViaGroup()` in every case)\n      !element.groupIds.length ||\n      // container is part of a group, but we're dragging the container directly\n      (appState.editingGroupId && !isSelectedViaGroup(appState, element))\n    ) {\n      const textElement = getBoundTextElement(element);\n      if (\n        textElement &&\n        // when container is added to a frame, so will its bound text\n        // so the text is already in `elementsToUpdate` and we should avoid\n        // updating its coords again\n        (!textElement.frameId || !frames.includes(textElement.frameId))\n      ) {\n        updateElementCoords(\n          lockDirection,\n          distanceX,\n          distanceY,\n          pointerDownState,\n          textElement,\n          offset,\n        );\n      }\n    }\n    updateBoundElements(element, {\n      simultaneouslyUpdated: Array.from(elementsToUpdate),\n    });\n  });\n};\n\nconst updateElementCoords = (\n  lockDirection: boolean,\n  distanceX: number,\n  distanceY: number,\n  pointerDownState: PointerDownState,\n  element: NonDeletedExcalidrawElement,\n  offset: { x: number; y: number },\n) => {\n  let x: number;\n  let y: number;\n  if (lockDirection) {\n    const lockX = lockDirection && distanceX < distanceY;\n    const lockY = lockDirection && distanceX > distanceY;\n    const original = pointerDownState.originalElements.get(element.id);\n    x = lockX && original ? original.x : element.x + offset.x;\n    y = lockY && original ? original.y : element.y + offset.y;\n  } else {\n    x = element.x + offset.x;\n    y = element.y + offset.y;\n  }\n\n  mutateElement(element, {\n    x,\n    y,\n  });\n};\nexport const getDragOffsetXY = (\n  selectedElements: NonDeletedExcalidrawElement[],\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  return [x - x1, y - y1];\n};\n\nexport const dragNewElement = (\n  draggingElement: NonDeletedExcalidrawElement,\n  elementType: AppState[\"activeTool\"][\"type\"],\n  originX: number,\n  originY: number,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  shouldMaintainAspectRatio: boolean,\n  shouldResizeFromCenter: boolean,\n  /** whether to keep given aspect ratio when `isResizeWithSidesSameLength` is\n      true */\n  widthAspectRatio?: number | null,\n) => {\n  if (shouldMaintainAspectRatio && draggingElement.type !== \"selection\") {\n    if (widthAspectRatio) {\n      height = width / widthAspectRatio;\n    } else {\n      // Depending on where the cursor is at (x, y) relative to where the starting point is\n      // (originX, originY), we use ONLY width or height to control size increase.\n      // This allows the cursor to always \"stick\" to one of the sides of the bounding box.\n      if (Math.abs(y - originY) > Math.abs(x - originX)) {\n        ({ width, height } = getPerfectElementSize(\n          elementType,\n          height,\n          x < originX ? -width : width,\n        ));\n      } else {\n        ({ width, height } = getPerfectElementSize(\n          elementType,\n          width,\n          y < originY ? -height : height,\n        ));\n      }\n\n      if (height < 0) {\n        height = -height;\n      }\n    }\n  }\n\n  let newX = x < originX ? originX - width : originX;\n  let newY = y < originY ? originY - height : originY;\n\n  if (shouldResizeFromCenter) {\n    width += width;\n    height += height;\n    newX = originX - width / 2;\n    newY = originY - height / 2;\n  }\n\n  if (width !== 0 && height !== 0) {\n    mutateElement(draggingElement, {\n      x: newX,\n      y: newY,\n      width,\n      height,\n    });\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}