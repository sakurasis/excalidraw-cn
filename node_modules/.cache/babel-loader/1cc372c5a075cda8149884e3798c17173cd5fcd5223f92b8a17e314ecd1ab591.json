{"ast":null,"code":"import _toConsumableArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _createForOfIteratorHelper from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import _objectSpread from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{KEYS}from\"../keys\";import{register}from\"./register\";import{duplicateElement,getNonDeletedElements}from\"../element\";import{isSomeElementSelected}from\"../scene\";import{ToolButton}from\"../components/ToolButton\";import{t}from\"../i18n\";import{arrayToMap,getShortcutKey}from\"../utils\";import{LinearElementEditor}from\"../element/linearElementEditor\";import{selectGroupsForSelectedElements,getSelectedGroupForElement,getElementsInGroup}from\"../groups\";import{fixBindingsAfterDuplication}from\"../element/binding\";import{GRID_SIZE}from\"../constants\";import{bindTextToShapeAfterDuplication,getBoundTextElement}from\"../element/textElement\";import{isBoundToContainer,isFrameElement}from\"../element/typeChecks\";import{normalizeElementOrder}from\"../element/sortElements\";import{DuplicateIcon}from\"../components/icons\";import{bindElementsToFramesAfterDuplication,getFrameElements}from\"../frame\";import{excludeElementsInFramesFromSelection,getSelectedElements}from\"../scene/selection\";import{jsx as _jsx}from\"react/jsx-runtime\";export var actionDuplicateSelection=register({name:\"duplicateSelection\",trackEvent:{category:\"element\"},perform:function perform(elements,appState){// duplicate selected point(s) if editing a line\nif(appState.editingLinearElement){var ret=LinearElementEditor.duplicateSelectedPoints(appState);if(!ret){return false;}return{elements:elements,appState:ret.appState,commitToHistory:true};}return _objectSpread(_objectSpread({},duplicateElements(elements,appState)),{},{commitToHistory:true});},contextItemLabel:\"labels.duplicateSelection\",keyTest:function keyTest(event){return event[KEYS.CTRL_OR_CMD]&&event.key===KEYS.D;},PanelComponent:function PanelComponent(_ref){var elements=_ref.elements,appState=_ref.appState,updateData=_ref.updateData;return/*#__PURE__*/_jsx(ToolButton,{type:\"button\",icon:DuplicateIcon,title:\"\".concat(t(\"labels.duplicateSelection\"),\" \\u2014 \").concat(getShortcutKey(\"CtrlOrCmd+D\")),\"aria-label\":t(\"labels.duplicateSelection\"),onClick:function onClick(){return updateData(null);},visible:isSomeElementSelected(getNonDeletedElements(elements),appState)});}});var duplicateElements=function duplicateElements(elements,appState){// ---------------------------------------------------------------------------\n// step (1)\nvar sortedElements=normalizeElementOrder(elements);var groupIdMap=new Map();var newElements=[];var oldElements=[];var oldIdToDuplicatedId=new Map();var duplicateAndOffsetElement=function duplicateAndOffsetElement(element){var newElement=duplicateElement(appState.editingGroupId,groupIdMap,element,{x:element.x+GRID_SIZE/2,y:element.y+GRID_SIZE/2});oldIdToDuplicatedId.set(element.id,newElement.id);oldElements.push(element);newElements.push(newElement);return newElement;};var idsOfElementsToDuplicate=arrayToMap(getSelectedElements(sortedElements,appState,{includeBoundTextElement:true,includeElementsInFrames:true}));// Ids of elements that have already been processed so we don't push them\n// into the array twice if we end up backtracking when retrieving\n// discontiguous group of elements (can happen due to a bug, or in edge\n// cases such as a group containing deleted elements which were not selected).\n//\n// This is not enough to prevent duplicates, so we do a second loop afterwards\n// to remove them.\n//\n// For convenience we mark even the newly created ones even though we don't\n// loop over them.\nvar processedIds=new Map();var markAsProcessed=function markAsProcessed(elements){var _iterator=_createForOfIteratorHelper(elements),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var element=_step.value;processedIds.set(element.id,true);}}catch(err){_iterator.e(err);}finally{_iterator.f();}return elements;};var elementsWithClones=[];var index=-1;while(++index<sortedElements.length){var element=sortedElements[index];if(processedIds.get(element.id)){continue;}var boundTextElement=getBoundTextElement(element);var isElementAFrame=isFrameElement(element);if(idsOfElementsToDuplicate.get(element.id)){// if a group or a container/bound-text or frame, duplicate atomically\nif(element.groupIds.length||boundTextElement||isElementAFrame){var groupId=getSelectedGroupForElement(appState,element);if(groupId){// TODO:\n// remove `.flatMap...`\n// if the elements in a frame are grouped when the frame is grouped\nvar groupElements=getElementsInGroup(sortedElements,groupId).flatMap(function(element){return isFrameElement(element)?[].concat(_toConsumableArray(getFrameElements(elements,element.id)),[element]):[element];});elementsWithClones.push.apply(elementsWithClones,_toConsumableArray(markAsProcessed([].concat(_toConsumableArray(groupElements),_toConsumableArray(groupElements.map(function(element){return duplicateAndOffsetElement(element);}))))));continue;}if(boundTextElement){elementsWithClones.push.apply(elementsWithClones,_toConsumableArray(markAsProcessed([element,boundTextElement,duplicateAndOffsetElement(element),duplicateAndOffsetElement(boundTextElement)])));continue;}if(isElementAFrame){var elementsInFrame=getFrameElements(sortedElements,element.id);elementsWithClones.push.apply(elementsWithClones,_toConsumableArray(markAsProcessed([].concat(_toConsumableArray(elementsInFrame),[element],_toConsumableArray(elementsInFrame.map(function(e){return duplicateAndOffsetElement(e);})),[duplicateAndOffsetElement(element)]))));continue;}}// since elements in frames have a lower z-index than the frame itself,\n// they will be looped first and if their frames are selected as well,\n// they will have been copied along with the frame atomically in the\n// above branch, so we must skip those elements here\n//\n// now, for elements do not belong any frames or elements whose frames\n// are selected (or elements that are left out from the above\n// steps for whatever reason) we (should at least) duplicate them here\nif(!element.frameId||!idsOfElementsToDuplicate.has(element.frameId)){elementsWithClones.push.apply(elementsWithClones,_toConsumableArray(markAsProcessed([element,duplicateAndOffsetElement(element)])));}}else{elementsWithClones.push.apply(elementsWithClones,_toConsumableArray(markAsProcessed([element])));}}// step (2)\n// second pass to remove duplicates. We loop from the end as it's likelier\n// that the last elements are in the correct order (contiguous or otherwise).\n// Thus we need to reverse as the last step (3).\nvar finalElementsReversed=[];var finalElementIds=new Map();index=elementsWithClones.length;while(--index>=0){var _element=elementsWithClones[index];if(!finalElementIds.get(_element.id)){finalElementIds.set(_element.id,true);finalElementsReversed.push(_element);}}// step (3)\nvar finalElements=finalElementsReversed.reverse();// ---------------------------------------------------------------------------\nbindTextToShapeAfterDuplication(elementsWithClones,oldElements,oldIdToDuplicatedId);fixBindingsAfterDuplication(elementsWithClones,oldElements,oldIdToDuplicatedId);bindElementsToFramesAfterDuplication(finalElements,oldElements,oldIdToDuplicatedId);var nextElementsToSelect=excludeElementsInFramesFromSelection(newElements);return{elements:finalElements,appState:selectGroupsForSelectedElements(_objectSpread(_objectSpread({},appState),{},{selectedGroupIds:{},selectedElementIds:nextElementsToSelect.reduce(function(acc,element){if(!isBoundToContainer(element)){acc[element.id]=true;}return acc;},{})}),getNonDeletedElements(finalElements),appState,null)};};","map":{"version":3,"names":["KEYS","register","duplicateElement","getNonDeletedElements","isSomeElementSelected","ToolButton","t","arrayToMap","getShortcutKey","LinearElementEditor","selectGroupsForSelectedElements","getSelectedGroupForElement","getElementsInGroup","fixBindingsAfterDuplication","GRID_SIZE","bindTextToShapeAfterDuplication","getBoundTextElement","isBoundToContainer","isFrameElement","normalizeElementOrder","DuplicateIcon","bindElementsToFramesAfterDuplication","getFrameElements","excludeElementsInFramesFromSelection","getSelectedElements","jsx","_jsx","actionDuplicateSelection","name","trackEvent","category","perform","elements","appState","editingLinearElement","ret","duplicateSelectedPoints","commitToHistory","_objectSpread","duplicateElements","contextItemLabel","keyTest","event","CTRL_OR_CMD","key","D","PanelComponent","_ref","updateData","type","icon","title","concat","onClick","visible","sortedElements","groupIdMap","Map","newElements","oldElements","oldIdToDuplicatedId","duplicateAndOffsetElement","element","newElement","editingGroupId","x","y","set","id","push","idsOfElementsToDuplicate","includeBoundTextElement","includeElementsInFrames","processedIds","markAsProcessed","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","err","e","f","elementsWithClones","index","length","get","boundTextElement","isElementAFrame","groupIds","groupId","groupElements","flatMap","_toConsumableArray","apply","map","elementsInFrame","frameId","has","finalElementsReversed","finalElementIds","finalElements","reverse","nextElementsToSelect","selectedGroupIds","selectedElementIds","reduce","acc"],"sources":["D:/project/excalidraw-cn/src/actions/actionDuplicateSelection.tsx"],"sourcesContent":["import { KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { duplicateElement, getNonDeletedElements } from \"../element\";\nimport { isSomeElementSelected } from \"../scene\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { t } from \"../i18n\";\nimport { arrayToMap, getShortcutKey } from \"../utils\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport {\n  selectGroupsForSelectedElements,\n  getSelectedGroupForElement,\n  getElementsInGroup,\n} from \"../groups\";\nimport { AppState } from \"../types\";\nimport { fixBindingsAfterDuplication } from \"../element/binding\";\nimport { ActionResult } from \"./types\";\nimport { GRID_SIZE } from \"../constants\";\nimport {\n  bindTextToShapeAfterDuplication,\n  getBoundTextElement,\n} from \"../element/textElement\";\nimport { isBoundToContainer, isFrameElement } from \"../element/typeChecks\";\nimport { normalizeElementOrder } from \"../element/sortElements\";\nimport { DuplicateIcon } from \"../components/icons\";\nimport {\n  bindElementsToFramesAfterDuplication,\n  getFrameElements,\n} from \"../frame\";\nimport {\n  excludeElementsInFramesFromSelection,\n  getSelectedElements,\n} from \"../scene/selection\";\n\nexport const actionDuplicateSelection = register({\n  name: \"duplicateSelection\",\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState) => {\n    // duplicate selected point(s) if editing a line\n    if (appState.editingLinearElement) {\n      const ret = LinearElementEditor.duplicateSelectedPoints(appState);\n\n      if (!ret) {\n        return false;\n      }\n\n      return {\n        elements,\n        appState: ret.appState,\n        commitToHistory: true,\n      };\n    }\n\n    return {\n      ...duplicateElements(elements, appState),\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.duplicateSelection\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.D,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={DuplicateIcon}\n      title={`${t(\"labels.duplicateSelection\")} â€” ${getShortcutKey(\n        \"CtrlOrCmd+D\",\n      )}`}\n      aria-label={t(\"labels.duplicateSelection\")}\n      onClick={() => updateData(null)}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nconst duplicateElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n): Partial<ActionResult> => {\n  // ---------------------------------------------------------------------------\n\n  // step (1)\n\n  const sortedElements = normalizeElementOrder(elements);\n  const groupIdMap = new Map();\n  const newElements: ExcalidrawElement[] = [];\n  const oldElements: ExcalidrawElement[] = [];\n  const oldIdToDuplicatedId = new Map();\n\n  const duplicateAndOffsetElement = (element: ExcalidrawElement) => {\n    const newElement = duplicateElement(\n      appState.editingGroupId,\n      groupIdMap,\n      element,\n      {\n        x: element.x + GRID_SIZE / 2,\n        y: element.y + GRID_SIZE / 2,\n      },\n    );\n    oldIdToDuplicatedId.set(element.id, newElement.id);\n    oldElements.push(element);\n    newElements.push(newElement);\n    return newElement;\n  };\n\n  const idsOfElementsToDuplicate = arrayToMap(\n    getSelectedElements(sortedElements, appState, {\n      includeBoundTextElement: true,\n      includeElementsInFrames: true,\n    }),\n  );\n\n  // Ids of elements that have already been processed so we don't push them\n  // into the array twice if we end up backtracking when retrieving\n  // discontiguous group of elements (can happen due to a bug, or in edge\n  // cases such as a group containing deleted elements which were not selected).\n  //\n  // This is not enough to prevent duplicates, so we do a second loop afterwards\n  // to remove them.\n  //\n  // For convenience we mark even the newly created ones even though we don't\n  // loop over them.\n  const processedIds = new Map<ExcalidrawElement[\"id\"], true>();\n\n  const markAsProcessed = (elements: ExcalidrawElement[]) => {\n    for (const element of elements) {\n      processedIds.set(element.id, true);\n    }\n    return elements;\n  };\n\n  const elementsWithClones: ExcalidrawElement[] = [];\n\n  let index = -1;\n\n  while (++index < sortedElements.length) {\n    const element = sortedElements[index];\n\n    if (processedIds.get(element.id)) {\n      continue;\n    }\n\n    const boundTextElement = getBoundTextElement(element);\n    const isElementAFrame = isFrameElement(element);\n\n    if (idsOfElementsToDuplicate.get(element.id)) {\n      // if a group or a container/bound-text or frame, duplicate atomically\n      if (element.groupIds.length || boundTextElement || isElementAFrame) {\n        const groupId = getSelectedGroupForElement(appState, element);\n        if (groupId) {\n          // TODO:\n          // remove `.flatMap...`\n          // if the elements in a frame are grouped when the frame is grouped\n          const groupElements = getElementsInGroup(\n            sortedElements,\n            groupId,\n          ).flatMap((element) =>\n            isFrameElement(element)\n              ? [...getFrameElements(elements, element.id), element]\n              : [element],\n          );\n\n          elementsWithClones.push(\n            ...markAsProcessed([\n              ...groupElements,\n              ...groupElements.map((element) =>\n                duplicateAndOffsetElement(element),\n              ),\n            ]),\n          );\n          continue;\n        }\n        if (boundTextElement) {\n          elementsWithClones.push(\n            ...markAsProcessed([\n              element,\n              boundTextElement,\n              duplicateAndOffsetElement(element),\n              duplicateAndOffsetElement(boundTextElement),\n            ]),\n          );\n          continue;\n        }\n        if (isElementAFrame) {\n          const elementsInFrame = getFrameElements(sortedElements, element.id);\n\n          elementsWithClones.push(\n            ...markAsProcessed([\n              ...elementsInFrame,\n              element,\n              ...elementsInFrame.map((e) => duplicateAndOffsetElement(e)),\n              duplicateAndOffsetElement(element),\n            ]),\n          );\n\n          continue;\n        }\n      }\n      // since elements in frames have a lower z-index than the frame itself,\n      // they will be looped first and if their frames are selected as well,\n      // they will have been copied along with the frame atomically in the\n      // above branch, so we must skip those elements here\n      //\n      // now, for elements do not belong any frames or elements whose frames\n      // are selected (or elements that are left out from the above\n      // steps for whatever reason) we (should at least) duplicate them here\n      if (!element.frameId || !idsOfElementsToDuplicate.has(element.frameId)) {\n        elementsWithClones.push(\n          ...markAsProcessed([element, duplicateAndOffsetElement(element)]),\n        );\n      }\n    } else {\n      elementsWithClones.push(...markAsProcessed([element]));\n    }\n  }\n\n  // step (2)\n\n  // second pass to remove duplicates. We loop from the end as it's likelier\n  // that the last elements are in the correct order (contiguous or otherwise).\n  // Thus we need to reverse as the last step (3).\n\n  const finalElementsReversed: ExcalidrawElement[] = [];\n\n  const finalElementIds = new Map<ExcalidrawElement[\"id\"], true>();\n  index = elementsWithClones.length;\n\n  while (--index >= 0) {\n    const element = elementsWithClones[index];\n    if (!finalElementIds.get(element.id)) {\n      finalElementIds.set(element.id, true);\n      finalElementsReversed.push(element);\n    }\n  }\n\n  // step (3)\n\n  const finalElements = finalElementsReversed.reverse();\n\n  // ---------------------------------------------------------------------------\n\n  bindTextToShapeAfterDuplication(\n    elementsWithClones,\n    oldElements,\n    oldIdToDuplicatedId,\n  );\n  fixBindingsAfterDuplication(\n    elementsWithClones,\n    oldElements,\n    oldIdToDuplicatedId,\n  );\n  bindElementsToFramesAfterDuplication(\n    finalElements,\n    oldElements,\n    oldIdToDuplicatedId,\n  );\n\n  const nextElementsToSelect =\n    excludeElementsInFramesFromSelection(newElements);\n\n  return {\n    elements: finalElements,\n    appState: selectGroupsForSelectedElements(\n      {\n        ...appState,\n        selectedGroupIds: {},\n        selectedElementIds: nextElementsToSelect.reduce(\n          (acc: Record<ExcalidrawElement[\"id\"], true>, element) => {\n            if (!isBoundToContainer(element)) {\n              acc[element.id] = true;\n            }\n            return acc;\n          },\n          {},\n        ),\n      },\n      getNonDeletedElements(finalElements),\n      appState,\n      null,\n    ),\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}