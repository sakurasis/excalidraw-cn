{"ast":null,"code":"import { newElementWith } from \"./element/mutateElement\";\nimport { getMaximumGroups } from \"./groups\";\nimport { getCommonBoundingBox } from \"./element/bounds\";\nexport const distributeElements = (selectedElements, distribution) => {\n  const [start, mid, end, extent] = distribution.axis === \"x\" ? [\"minX\", \"midX\", \"maxX\", \"width\"] : [\"minY\", \"midY\", \"maxY\", \"height\"];\n  const bounds = getCommonBoundingBox(selectedElements);\n  const groups = getMaximumGroups(selectedElements).map(group => [group, getCommonBoundingBox(group)]).sort((a, b) => a[1][mid] - b[1][mid]);\n  let span = 0;\n  for (const group of groups) {\n    span += group[1][extent];\n  }\n  const step = (bounds[extent] - span) / (groups.length - 1);\n  if (step < 0) {\n    // If we have a negative step, we'll need to distribute from centers\n    // rather than from gaps. Buckle up, this is a weird one.\n\n    // Get indices of boxes that define start and end of our bounding box\n    const index0 = groups.findIndex(g => g[1][start] === bounds[start]);\n    const index1 = groups.findIndex(g => g[1][end] === bounds[end]);\n\n    // Get our step, based on the distance between the center points of our\n    // start and end boxes\n    const step = (groups[index1][1][mid] - groups[index0][1][mid]) / (groups.length - 1);\n    let pos = groups[index0][1][mid];\n    return groups.flatMap((_ref, index) => {\n      let [group, box] = _ref;\n      const translation = {\n        x: 0,\n        y: 0\n      };\n\n      // Don't move our start and end boxes\n      if (index !== index0 && index !== index1) {\n        pos += step;\n        translation[distribution.axis] = pos - box[mid];\n      }\n      return group.map(element => newElementWith(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y\n      }));\n    });\n  }\n\n  // Distribute from gaps\n\n  let pos = bounds[start];\n  return groups.flatMap(_ref2 => {\n    let [group, box] = _ref2;\n    const translation = {\n      x: 0,\n      y: 0\n    };\n    translation[distribution.axis] = pos - box[start];\n    pos += step;\n    pos += box[extent];\n    return group.map(element => newElementWith(element, {\n      x: element.x + translation.x,\n      y: element.y + translation.y\n    }));\n  });\n};","map":{"version":3,"names":["newElementWith","getMaximumGroups","getCommonBoundingBox","distributeElements","selectedElements","distribution","start","mid","end","extent","axis","bounds","groups","map","group","sort","a","b","span","step","length","index0","findIndex","g","index1","pos","flatMap","_ref","index","box","translation","x","y","element","_ref2"],"sources":["D:/project/excalidraw-cn/src/distribute.ts"],"sourcesContent":["import { ExcalidrawElement } from \"./element/types\";\nimport { newElementWith } from \"./element/mutateElement\";\nimport { getMaximumGroups } from \"./groups\";\nimport { getCommonBoundingBox } from \"./element/bounds\";\n\nexport interface Distribution {\n  space: \"between\";\n  axis: \"x\" | \"y\";\n}\n\nexport const distributeElements = (\n  selectedElements: ExcalidrawElement[],\n  distribution: Distribution,\n): ExcalidrawElement[] => {\n  const [start, mid, end, extent] =\n    distribution.axis === \"x\"\n      ? ([\"minX\", \"midX\", \"maxX\", \"width\"] as const)\n      : ([\"minY\", \"midY\", \"maxY\", \"height\"] as const);\n\n  const bounds = getCommonBoundingBox(selectedElements);\n  const groups = getMaximumGroups(selectedElements)\n    .map((group) => [group, getCommonBoundingBox(group)] as const)\n    .sort((a, b) => a[1][mid] - b[1][mid]);\n\n  let span = 0;\n  for (const group of groups) {\n    span += group[1][extent];\n  }\n\n  const step = (bounds[extent] - span) / (groups.length - 1);\n\n  if (step < 0) {\n    // If we have a negative step, we'll need to distribute from centers\n    // rather than from gaps. Buckle up, this is a weird one.\n\n    // Get indices of boxes that define start and end of our bounding box\n    const index0 = groups.findIndex((g) => g[1][start] === bounds[start]);\n    const index1 = groups.findIndex((g) => g[1][end] === bounds[end]);\n\n    // Get our step, based on the distance between the center points of our\n    // start and end boxes\n    const step =\n      (groups[index1][1][mid] - groups[index0][1][mid]) / (groups.length - 1);\n\n    let pos = groups[index0][1][mid];\n\n    return groups.flatMap(([group, box], index) => {\n      const translation = {\n        x: 0,\n        y: 0,\n      };\n\n      // Don't move our start and end boxes\n      if (index !== index0 && index !== index1) {\n        pos += step;\n        translation[distribution.axis] = pos - box[mid];\n      }\n\n      return group.map((element) =>\n        newElementWith(element, {\n          x: element.x + translation.x,\n          y: element.y + translation.y,\n        }),\n      );\n    });\n  }\n\n  // Distribute from gaps\n\n  let pos = bounds[start];\n\n  return groups.flatMap(([group, box]) => {\n    const translation = {\n      x: 0,\n      y: 0,\n    };\n\n    translation[distribution.axis] = pos - box[start];\n\n    pos += step;\n    pos += box[extent];\n\n    return group.map((element) =>\n      newElementWith(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y,\n      }),\n    );\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}