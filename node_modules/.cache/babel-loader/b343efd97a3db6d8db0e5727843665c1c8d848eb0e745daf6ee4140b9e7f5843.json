{"ast":null,"code":"import { COLOR_PALETTE, DEFAULT_CHART_COLOR_INDEX, getAllColorsSpecificShade } from \"./colors\";\nimport { DEFAULT_FONT_FAMILY, DEFAULT_FONT_SIZE, ENV, VERTICAL_ALIGN } from \"./constants\";\nimport { newElement, newLinearElement, newTextElement } from \"./element\";\nimport { randomId } from \"./random\";\nconst BAR_WIDTH = 32;\nconst BAR_GAP = 12;\nconst BAR_HEIGHT = 256;\nconst GRID_OPACITY = 50;\nexport const NOT_SPREADSHEET = \"NOT_SPREADSHEET\";\nexport const VALID_SPREADSHEET = \"VALID_SPREADSHEET\";\n/**\n * @private exported for testing\n */\nexport const tryParseNumber = s => {\n  const match = /^([-+]?)[$€£¥₩]?([-+]?)([\\d.,]+)[%]?$/.exec(s);\n  if (!match) {\n    return null;\n  }\n  return parseFloat(`${(match[1] || match[2]) + match[3]}`.replace(/,/g, \"\"));\n};\nconst isNumericColumn = (lines, columnIndex) => lines.slice(1).every(line => tryParseNumber(line[columnIndex]) !== null);\n\n/**\n * @private exported for testing\n */\nexport const tryParseCells = cells => {\n  const numCols = cells[0].length;\n  if (numCols > 2) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"More than 2 columns\"\n    };\n  }\n  if (numCols === 1) {\n    if (!isNumericColumn(cells, 0)) {\n      return {\n        type: NOT_SPREADSHEET,\n        reason: \"Value is not numeric\"\n      };\n    }\n    const hasHeader = tryParseNumber(cells[0][0]) === null;\n    const values = (hasHeader ? cells.slice(1) : cells).map(line => tryParseNumber(line[0]));\n    if (values.length < 2) {\n      return {\n        type: NOT_SPREADSHEET,\n        reason: \"Less than two rows\"\n      };\n    }\n    return {\n      type: VALID_SPREADSHEET,\n      spreadsheet: {\n        title: hasHeader ? cells[0][0] : null,\n        labels: null,\n        values: values\n      }\n    };\n  }\n  const labelColumnNumeric = isNumericColumn(cells, 0);\n  const valueColumnNumeric = isNumericColumn(cells, 1);\n  if (!labelColumnNumeric && !valueColumnNumeric) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"Value is not numeric\"\n    };\n  }\n  const [labelColumnIndex, valueColumnIndex] = valueColumnNumeric ? [0, 1] : [1, 0];\n  const hasHeader = tryParseNumber(cells[0][valueColumnIndex]) === null;\n  const rows = hasHeader ? cells.slice(1) : cells;\n  if (rows.length < 2) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"Less than 2 rows\"\n    };\n  }\n  return {\n    type: VALID_SPREADSHEET,\n    spreadsheet: {\n      title: hasHeader ? cells[0][valueColumnIndex] : null,\n      labels: rows.map(row => row[labelColumnIndex]),\n      values: rows.map(row => tryParseNumber(row[valueColumnIndex]))\n    }\n  };\n};\nconst transposeCells = cells => {\n  const nextCells = [];\n  for (let col = 0; col < cells[0].length; col++) {\n    const nextCellRow = [];\n    for (let row = 0; row < cells.length; row++) {\n      nextCellRow.push(cells[row][col]);\n    }\n    nextCells.push(nextCellRow);\n  }\n  return nextCells;\n};\nexport const tryParseSpreadsheet = text => {\n  // Copy/paste from excel, spreadsheets, tsv, csv.\n  // For now we only accept 2 columns with an optional header\n\n  // Check for tab separated values\n  let lines = text.trim().split(\"\\n\").map(line => line.trim().split(\"\\t\"));\n\n  // Check for comma separated files\n  if (lines.length && lines[0].length !== 2) {\n    lines = text.trim().split(\"\\n\").map(line => line.trim().split(\",\"));\n  }\n  if (lines.length === 0) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"No values\"\n    };\n  }\n  const numColsFirstLine = lines[0].length;\n  const isSpreadsheet = lines.every(line => line.length === numColsFirstLine);\n  if (!isSpreadsheet) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"All rows don't have same number of columns\"\n    };\n  }\n  const result = tryParseCells(lines);\n  if (result.type !== VALID_SPREADSHEET) {\n    const transposedResults = tryParseCells(transposeCells(lines));\n    if (transposedResults.type === VALID_SPREADSHEET) {\n      return transposedResults;\n    }\n  }\n  return result;\n};\nconst bgColors = getAllColorsSpecificShade(DEFAULT_CHART_COLOR_INDEX);\n\n// Put all the common properties here so when the whole chart is selected\n// the properties dialog shows the correct selected values\nconst commonProps = {\n  fillStyle: \"hachure\",\n  fontFamily: DEFAULT_FONT_FAMILY,\n  fontSize: DEFAULT_FONT_SIZE,\n  opacity: 100,\n  roughness: 1,\n  strokeColor: COLOR_PALETTE.black,\n  roundness: null,\n  strokeStyle: \"solid\",\n  strokeWidth: 1,\n  verticalAlign: VERTICAL_ALIGN.MIDDLE,\n  locked: false\n};\nconst getChartDimensions = spreadsheet => {\n  const chartWidth = (BAR_WIDTH + BAR_GAP) * spreadsheet.values.length + BAR_GAP;\n  const chartHeight = BAR_HEIGHT + BAR_GAP * 2;\n  return {\n    chartWidth,\n    chartHeight\n  };\n};\nconst chartXLabels = (spreadsheet, x, y, groupId, backgroundColor) => {\n  var _spreadsheet$labels;\n  return ((_spreadsheet$labels = spreadsheet.labels) === null || _spreadsheet$labels === void 0 ? void 0 : _spreadsheet$labels.map((label, index) => {\n    return newTextElement({\n      groupIds: [groupId],\n      backgroundColor,\n      ...commonProps,\n      text: label.length > 8 ? `${label.slice(0, 5)}...` : label,\n      x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP * 2,\n      y: y + BAR_GAP / 2,\n      width: BAR_WIDTH,\n      angle: 5.87,\n      fontSize: 16,\n      textAlign: \"center\",\n      verticalAlign: \"top\"\n    });\n  })) || [];\n};\nconst chartYLabels = (spreadsheet, x, y, groupId, backgroundColor) => {\n  const minYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_GAP,\n    text: \"0\",\n    textAlign: \"right\"\n  });\n  const maxYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_HEIGHT - minYLabel.height / 2,\n    text: Math.max(...spreadsheet.values).toLocaleString(),\n    textAlign: \"right\"\n  });\n  return [minYLabel, maxYLabel];\n};\nconst chartLines = (spreadsheet, x, y, groupId, backgroundColor) => {\n  const {\n    chartWidth,\n    chartHeight\n  } = getChartDimensions(spreadsheet);\n  const xLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    startArrowhead: null,\n    endArrowhead: null,\n    width: chartWidth,\n    points: [[0, 0], [chartWidth, 0]]\n  });\n  const yLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    startArrowhead: null,\n    endArrowhead: null,\n    height: chartHeight,\n    points: [[0, 0], [0, -chartHeight]]\n  });\n  const maxLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y: y - BAR_HEIGHT - BAR_GAP,\n    startArrowhead: null,\n    endArrowhead: null,\n    strokeStyle: \"dotted\",\n    width: chartWidth,\n    opacity: GRID_OPACITY,\n    points: [[0, 0], [chartWidth, 0]]\n  });\n  return [xLine, yLine, maxLine];\n};\n\n// For the maths behind it https://excalidraw.com/#json=6320864370884608,O_5xfD-Agh32tytHpRJx1g\nconst chartBaseElements = (spreadsheet, x, y, groupId, backgroundColor, debug) => {\n  const {\n    chartWidth,\n    chartHeight\n  } = getChartDimensions(spreadsheet);\n  const title = spreadsheet.title ? newTextElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    text: spreadsheet.title,\n    x: x + chartWidth / 2,\n    y: y - BAR_HEIGHT - BAR_GAP * 2 - DEFAULT_FONT_SIZE,\n    roundness: null,\n    textAlign: \"center\"\n  }) : null;\n  const debugRect = debug ? newElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"rectangle\",\n    x,\n    y: y - chartHeight,\n    width: chartWidth,\n    height: chartHeight,\n    strokeColor: COLOR_PALETTE.black,\n    fillStyle: \"solid\",\n    opacity: 6\n  }) : null;\n  return [...(debugRect ? [debugRect] : []), ...(title ? [title] : []), ...chartXLabels(spreadsheet, x, y, groupId, backgroundColor), ...chartYLabels(spreadsheet, x, y, groupId, backgroundColor), ...chartLines(spreadsheet, x, y, groupId, backgroundColor)];\n};\nconst chartTypeBar = (spreadsheet, x, y) => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n  const bars = spreadsheet.values.map((value, index) => {\n    const barHeight = value / max * BAR_HEIGHT;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"rectangle\",\n      x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP,\n      y: y - barHeight - BAR_GAP,\n      width: BAR_WIDTH,\n      height: barHeight\n    });\n  });\n  return [...bars, ...chartBaseElements(spreadsheet, x, y, groupId, backgroundColor, process.env.NODE_ENV === ENV.DEVELOPMENT)];\n};\nconst chartTypeLine = (spreadsheet, x, y) => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n  let index = 0;\n  const points = [];\n  for (const value of spreadsheet.values) {\n    const cx = index * (BAR_WIDTH + BAR_GAP);\n    const cy = -(value / max) * BAR_HEIGHT;\n    points.push([cx, cy]);\n    index++;\n  }\n  const maxX = Math.max(...points.map(element => element[0]));\n  const maxY = Math.max(...points.map(element => element[1]));\n  const minX = Math.min(...points.map(element => element[0]));\n  const minY = Math.min(...points.map(element => element[1]));\n  const line = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x: x + BAR_GAP + BAR_WIDTH / 2,\n    y: y - BAR_GAP,\n    startArrowhead: null,\n    endArrowhead: null,\n    height: maxY - minY,\n    width: maxX - minX,\n    strokeWidth: 2,\n    points: points\n  });\n  const dots = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = -(value / max) * BAR_HEIGHT + BAR_GAP / 2;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      fillStyle: \"solid\",\n      strokeWidth: 2,\n      type: \"ellipse\",\n      x: x + cx + BAR_WIDTH / 2,\n      y: y + cy - BAR_GAP * 2,\n      width: BAR_GAP,\n      height: BAR_GAP\n    });\n  });\n  const lines = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = value / max * BAR_HEIGHT + BAR_GAP / 2 + BAR_GAP;\n    return newLinearElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"line\",\n      x: x + cx + BAR_WIDTH / 2 + BAR_GAP / 2,\n      y: y - cy,\n      startArrowhead: null,\n      endArrowhead: null,\n      height: cy,\n      strokeStyle: \"dotted\",\n      opacity: GRID_OPACITY,\n      points: [[0, 0], [0, cy]]\n    });\n  });\n  return [...chartBaseElements(spreadsheet, x, y, groupId, backgroundColor, process.env.NODE_ENV === ENV.DEVELOPMENT), line, ...lines, ...dots];\n};\nexport const renderSpreadsheet = (chartType, spreadsheet, x, y) => {\n  if (chartType === \"line\") {\n    return chartTypeLine(spreadsheet, x, y);\n  }\n  return chartTypeBar(spreadsheet, x, y);\n};","map":{"version":3,"names":["COLOR_PALETTE","DEFAULT_CHART_COLOR_INDEX","getAllColorsSpecificShade","DEFAULT_FONT_FAMILY","DEFAULT_FONT_SIZE","ENV","VERTICAL_ALIGN","newElement","newLinearElement","newTextElement","randomId","BAR_WIDTH","BAR_GAP","BAR_HEIGHT","GRID_OPACITY","NOT_SPREADSHEET","VALID_SPREADSHEET","tryParseNumber","s","match","exec","parseFloat","replace","isNumericColumn","lines","columnIndex","slice","every","line","tryParseCells","cells","numCols","length","type","reason","hasHeader","values","map","spreadsheet","title","labels","labelColumnNumeric","valueColumnNumeric","labelColumnIndex","valueColumnIndex","rows","row","transposeCells","nextCells","col","nextCellRow","push","tryParseSpreadsheet","text","trim","split","numColsFirstLine","isSpreadsheet","result","transposedResults","bgColors","commonProps","fillStyle","fontFamily","fontSize","opacity","roughness","strokeColor","black","roundness","strokeStyle","strokeWidth","verticalAlign","MIDDLE","locked","getChartDimensions","chartWidth","chartHeight","chartXLabels","x","y","groupId","backgroundColor","_spreadsheet$labels","label","index","groupIds","width","angle","textAlign","chartYLabels","minYLabel","maxYLabel","height","Math","max","toLocaleString","chartLines","xLine","startArrowhead","endArrowhead","points","yLine","maxLine","chartBaseElements","debug","debugRect","chartTypeBar","floor","random","bars","value","barHeight","process","env","NODE_ENV","DEVELOPMENT","chartTypeLine","cx","cy","maxX","element","maxY","minX","min","minY","dots","renderSpreadsheet","chartType"],"sources":["D:/project/excalidraw-cn/src/charts.ts"],"sourcesContent":["import {\n  COLOR_PALETTE,\n  DEFAULT_CHART_COLOR_INDEX,\n  getAllColorsSpecificShade,\n} from \"./colors\";\nimport {\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  ENV,\n  VERTICAL_ALIGN,\n} from \"./constants\";\nimport { newElement, newLinearElement, newTextElement } from \"./element\";\nimport { NonDeletedExcalidrawElement } from \"./element/types\";\nimport { randomId } from \"./random\";\n\nexport type ChartElements = readonly NonDeletedExcalidrawElement[];\n\nconst BAR_WIDTH = 32;\nconst BAR_GAP = 12;\nconst BAR_HEIGHT = 256;\nconst GRID_OPACITY = 50;\n\nexport interface Spreadsheet {\n  title: string | null;\n  labels: string[] | null;\n  values: number[];\n}\n\nexport const NOT_SPREADSHEET = \"NOT_SPREADSHEET\";\nexport const VALID_SPREADSHEET = \"VALID_SPREADSHEET\";\n\ntype ParseSpreadsheetResult =\n  | { type: typeof NOT_SPREADSHEET; reason: string }\n  | { type: typeof VALID_SPREADSHEET; spreadsheet: Spreadsheet };\n\n/**\n * @private exported for testing\n */\nexport const tryParseNumber = (s: string): number | null => {\n  const match = /^([-+]?)[$€£¥₩]?([-+]?)([\\d.,]+)[%]?$/.exec(s);\n  if (!match) {\n    return null;\n  }\n  return parseFloat(`${(match[1] || match[2]) + match[3]}`.replace(/,/g, \"\"));\n};\n\nconst isNumericColumn = (lines: string[][], columnIndex: number) =>\n  lines.slice(1).every((line) => tryParseNumber(line[columnIndex]) !== null);\n\n/**\n * @private exported for testing\n */\nexport const tryParseCells = (cells: string[][]): ParseSpreadsheetResult => {\n  const numCols = cells[0].length;\n\n  if (numCols > 2) {\n    return { type: NOT_SPREADSHEET, reason: \"More than 2 columns\" };\n  }\n\n  if (numCols === 1) {\n    if (!isNumericColumn(cells, 0)) {\n      return { type: NOT_SPREADSHEET, reason: \"Value is not numeric\" };\n    }\n\n    const hasHeader = tryParseNumber(cells[0][0]) === null;\n    const values = (hasHeader ? cells.slice(1) : cells).map((line) =>\n      tryParseNumber(line[0]),\n    );\n\n    if (values.length < 2) {\n      return { type: NOT_SPREADSHEET, reason: \"Less than two rows\" };\n    }\n\n    return {\n      type: VALID_SPREADSHEET,\n      spreadsheet: {\n        title: hasHeader ? cells[0][0] : null,\n        labels: null,\n        values: values as number[],\n      },\n    };\n  }\n\n  const labelColumnNumeric = isNumericColumn(cells, 0);\n  const valueColumnNumeric = isNumericColumn(cells, 1);\n\n  if (!labelColumnNumeric && !valueColumnNumeric) {\n    return { type: NOT_SPREADSHEET, reason: \"Value is not numeric\" };\n  }\n\n  const [labelColumnIndex, valueColumnIndex] = valueColumnNumeric\n    ? [0, 1]\n    : [1, 0];\n  const hasHeader = tryParseNumber(cells[0][valueColumnIndex]) === null;\n  const rows = hasHeader ? cells.slice(1) : cells;\n\n  if (rows.length < 2) {\n    return { type: NOT_SPREADSHEET, reason: \"Less than 2 rows\" };\n  }\n\n  return {\n    type: VALID_SPREADSHEET,\n    spreadsheet: {\n      title: hasHeader ? cells[0][valueColumnIndex] : null,\n      labels: rows.map((row) => row[labelColumnIndex]),\n      values: rows.map((row) => tryParseNumber(row[valueColumnIndex])!),\n    },\n  };\n};\n\nconst transposeCells = (cells: string[][]) => {\n  const nextCells: string[][] = [];\n  for (let col = 0; col < cells[0].length; col++) {\n    const nextCellRow: string[] = [];\n    for (let row = 0; row < cells.length; row++) {\n      nextCellRow.push(cells[row][col]);\n    }\n    nextCells.push(nextCellRow);\n  }\n  return nextCells;\n};\n\nexport const tryParseSpreadsheet = (text: string): ParseSpreadsheetResult => {\n  // Copy/paste from excel, spreadsheets, tsv, csv.\n  // For now we only accept 2 columns with an optional header\n\n  // Check for tab separated values\n  let lines = text\n    .trim()\n    .split(\"\\n\")\n    .map((line) => line.trim().split(\"\\t\"));\n\n  // Check for comma separated files\n  if (lines.length && lines[0].length !== 2) {\n    lines = text\n      .trim()\n      .split(\"\\n\")\n      .map((line) => line.trim().split(\",\"));\n  }\n\n  if (lines.length === 0) {\n    return { type: NOT_SPREADSHEET, reason: \"No values\" };\n  }\n\n  const numColsFirstLine = lines[0].length;\n  const isSpreadsheet = lines.every((line) => line.length === numColsFirstLine);\n\n  if (!isSpreadsheet) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"All rows don't have same number of columns\",\n    };\n  }\n\n  const result = tryParseCells(lines);\n  if (result.type !== VALID_SPREADSHEET) {\n    const transposedResults = tryParseCells(transposeCells(lines));\n    if (transposedResults.type === VALID_SPREADSHEET) {\n      return transposedResults;\n    }\n  }\n  return result;\n};\n\nconst bgColors = getAllColorsSpecificShade(DEFAULT_CHART_COLOR_INDEX);\n\n// Put all the common properties here so when the whole chart is selected\n// the properties dialog shows the correct selected values\nconst commonProps = {\n  fillStyle: \"hachure\",\n  fontFamily: DEFAULT_FONT_FAMILY,\n  fontSize: DEFAULT_FONT_SIZE,\n  opacity: 100,\n  roughness: 1,\n  strokeColor: COLOR_PALETTE.black,\n  roundness: null,\n  strokeStyle: \"solid\",\n  strokeWidth: 1,\n  verticalAlign: VERTICAL_ALIGN.MIDDLE,\n  locked: false,\n} as const;\n\nconst getChartDimensions = (spreadsheet: Spreadsheet) => {\n  const chartWidth =\n    (BAR_WIDTH + BAR_GAP) * spreadsheet.values.length + BAR_GAP;\n  const chartHeight = BAR_HEIGHT + BAR_GAP * 2;\n  return { chartWidth, chartHeight };\n};\n\nconst chartXLabels = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  return (\n    spreadsheet.labels?.map((label, index) => {\n      return newTextElement({\n        groupIds: [groupId],\n        backgroundColor,\n        ...commonProps,\n        text: label.length > 8 ? `${label.slice(0, 5)}...` : label,\n        x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP * 2,\n        y: y + BAR_GAP / 2,\n        width: BAR_WIDTH,\n        angle: 5.87,\n        fontSize: 16,\n        textAlign: \"center\",\n        verticalAlign: \"top\",\n      });\n    }) || []\n  );\n};\n\nconst chartYLabels = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  const minYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_GAP,\n    text: \"0\",\n    textAlign: \"right\",\n  });\n\n  const maxYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_HEIGHT - minYLabel.height / 2,\n    text: Math.max(...spreadsheet.values).toLocaleString(),\n    textAlign: \"right\",\n  });\n\n  return [minYLabel, maxYLabel];\n};\n\nconst chartLines = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  const { chartWidth, chartHeight } = getChartDimensions(spreadsheet);\n  const xLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    startArrowhead: null,\n    endArrowhead: null,\n    width: chartWidth,\n    points: [\n      [0, 0],\n      [chartWidth, 0],\n    ],\n  });\n\n  const yLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    startArrowhead: null,\n    endArrowhead: null,\n    height: chartHeight,\n    points: [\n      [0, 0],\n      [0, -chartHeight],\n    ],\n  });\n\n  const maxLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y: y - BAR_HEIGHT - BAR_GAP,\n    startArrowhead: null,\n    endArrowhead: null,\n    strokeStyle: \"dotted\",\n    width: chartWidth,\n    opacity: GRID_OPACITY,\n    points: [\n      [0, 0],\n      [chartWidth, 0],\n    ],\n  });\n\n  return [xLine, yLine, maxLine];\n};\n\n// For the maths behind it https://excalidraw.com/#json=6320864370884608,O_5xfD-Agh32tytHpRJx1g\nconst chartBaseElements = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n  debug?: boolean,\n): ChartElements => {\n  const { chartWidth, chartHeight } = getChartDimensions(spreadsheet);\n\n  const title = spreadsheet.title\n    ? newTextElement({\n        backgroundColor,\n        groupIds: [groupId],\n        ...commonProps,\n        text: spreadsheet.title,\n        x: x + chartWidth / 2,\n        y: y - BAR_HEIGHT - BAR_GAP * 2 - DEFAULT_FONT_SIZE,\n        roundness: null,\n        textAlign: \"center\",\n      })\n    : null;\n\n  const debugRect = debug\n    ? newElement({\n        backgroundColor,\n        groupIds: [groupId],\n        ...commonProps,\n        type: \"rectangle\",\n        x,\n        y: y - chartHeight,\n        width: chartWidth,\n        height: chartHeight,\n        strokeColor: COLOR_PALETTE.black,\n        fillStyle: \"solid\",\n        opacity: 6,\n      })\n    : null;\n\n  return [\n    ...(debugRect ? [debugRect] : []),\n    ...(title ? [title] : []),\n    ...chartXLabels(spreadsheet, x, y, groupId, backgroundColor),\n    ...chartYLabels(spreadsheet, x, y, groupId, backgroundColor),\n    ...chartLines(spreadsheet, x, y, groupId, backgroundColor),\n  ];\n};\n\nconst chartTypeBar = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n\n  const bars = spreadsheet.values.map((value, index) => {\n    const barHeight = (value / max) * BAR_HEIGHT;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"rectangle\",\n      x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP,\n      y: y - barHeight - BAR_GAP,\n      width: BAR_WIDTH,\n      height: barHeight,\n    });\n  });\n\n  return [\n    ...bars,\n    ...chartBaseElements(\n      spreadsheet,\n      x,\n      y,\n      groupId,\n      backgroundColor,\n      process.env.NODE_ENV === ENV.DEVELOPMENT,\n    ),\n  ];\n};\n\nconst chartTypeLine = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n\n  let index = 0;\n  const points = [];\n  for (const value of spreadsheet.values) {\n    const cx = index * (BAR_WIDTH + BAR_GAP);\n    const cy = -(value / max) * BAR_HEIGHT;\n    points.push([cx, cy]);\n    index++;\n  }\n\n  const maxX = Math.max(...points.map((element) => element[0]));\n  const maxY = Math.max(...points.map((element) => element[1]));\n  const minX = Math.min(...points.map((element) => element[0]));\n  const minY = Math.min(...points.map((element) => element[1]));\n\n  const line = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x: x + BAR_GAP + BAR_WIDTH / 2,\n    y: y - BAR_GAP,\n    startArrowhead: null,\n    endArrowhead: null,\n    height: maxY - minY,\n    width: maxX - minX,\n    strokeWidth: 2,\n    points: points as any,\n  });\n\n  const dots = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = -(value / max) * BAR_HEIGHT + BAR_GAP / 2;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      fillStyle: \"solid\",\n      strokeWidth: 2,\n      type: \"ellipse\",\n      x: x + cx + BAR_WIDTH / 2,\n      y: y + cy - BAR_GAP * 2,\n      width: BAR_GAP,\n      height: BAR_GAP,\n    });\n  });\n\n  const lines = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = (value / max) * BAR_HEIGHT + BAR_GAP / 2 + BAR_GAP;\n    return newLinearElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"line\",\n      x: x + cx + BAR_WIDTH / 2 + BAR_GAP / 2,\n      y: y - cy,\n      startArrowhead: null,\n      endArrowhead: null,\n      height: cy,\n      strokeStyle: \"dotted\",\n      opacity: GRID_OPACITY,\n      points: [\n        [0, 0],\n        [0, cy],\n      ],\n    });\n  });\n\n  return [\n    ...chartBaseElements(\n      spreadsheet,\n      x,\n      y,\n      groupId,\n      backgroundColor,\n      process.env.NODE_ENV === ENV.DEVELOPMENT,\n    ),\n    line,\n    ...lines,\n    ...dots,\n  ];\n};\n\nexport const renderSpreadsheet = (\n  chartType: string,\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  if (chartType === \"line\") {\n    return chartTypeLine(spreadsheet, x, y);\n  }\n  return chartTypeBar(spreadsheet, x, y);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}