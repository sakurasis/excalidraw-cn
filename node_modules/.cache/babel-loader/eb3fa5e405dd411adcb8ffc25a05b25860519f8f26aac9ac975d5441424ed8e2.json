{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar keyCount = 0;\nfunction atom(read, write) {\n  var key = \"atom\".concat(++keyCount);\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = function (get) {\n      return get(config);\n    };\n    config.write = function (get, set, arg) {\n      return set(config, typeof arg === \"function\" ? arg(get(config)) : arg);\n    };\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nvar hasInitialValue = function hasInitialValue(atom) {\n  return \"init\" in atom;\n};\nvar isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n  return !!atom.write;\n};\nvar cancelPromiseMap = /* @__PURE__ */new WeakMap();\nvar registerCancelPromise = function registerCancelPromise(promise, cancel) {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(function () {}).finally(function () {\n    return cancelPromiseMap.delete(promise);\n  });\n};\nvar cancelPromise = function cancelPromise(promise, next) {\n  var cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nvar resolvePromise = function resolvePromise(promise, value) {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nvar rejectPromise = function rejectPromise(promise, e) {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nvar isEqualAtomValue = function isEqualAtomValue(a, b) {\n  return \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\n};\nvar isEqualAtomError = function isEqualAtomError(a, b) {\n  return \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\n};\nvar hasPromiseAtomValue = function hasPromiseAtomValue(a) {\n  return \"v\" in a && a.v instanceof Promise;\n};\nvar returnAtomValue = function returnAtomValue(atomState) {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nvar createStore = function createStore() {\n  var atomStateMap = /* @__PURE__ */new WeakMap();\n  var mountedMap = /* @__PURE__ */new WeakMap();\n  var pendingMap = /* @__PURE__ */new Map();\n  var stateListeners;\n  var mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */new Set();\n    mountedAtoms = /* @__PURE__ */new Set();\n  }\n  var getAtomState = function getAtomState(atom) {\n    return atomStateMap.get(atom);\n  };\n  var setAtomState = function setAtomState(atom, atomState) {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    var prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      var next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  var updateDependencies = function updateDependencies(atom, nextAtomState, depSet) {\n    var dependencies = /* @__PURE__ */new Map();\n    var changed = false;\n    depSet.forEach(function (a) {\n      var aState = a === atom ? nextAtomState : getAtomState(a);\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  var setAtomValue = function setAtomValue(atom, value, depSet) {\n    var prevAtomState = getAtomState(atom);\n    var nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */new Map(),\n      v: value\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  var setAtomError = function setAtomError(atom, error, depSet) {\n    var prevAtomState = getAtomState(atom);\n    var nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */new Map(),\n      e: error\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  var readAtomState = function readAtomState(atom) {\n    var atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          a = _ref2[0],\n          s = _ref2[1];\n        return a === atom || getAtomState(a) === s;\n      })) {\n        return atomState;\n      }\n    }\n    var depSet = /* @__PURE__ */new Set();\n    var isSync = true;\n    var getter = function getter(a) {\n      depSet.add(a);\n      if (a === atom) {\n        var aState2 = getAtomState(a);\n        if (aState2) {\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      var aState = readAtomState(a);\n      return returnAtomValue(aState);\n    };\n    var controller;\n    var setSelf;\n    var options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = function setSelf() {\n            if ((import.meta.env && import.meta.env.MODE) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return writeAtom.apply(void 0, [atom].concat(args));\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      var value = atom.read(getter, options);\n      if (value instanceof Promise) {\n        var continuePromise;\n        var promise = new Promise(function (resolve, reject) {\n          var settled = false;\n          value.then(function (v) {\n            if (!settled) {\n              resolvePromise(promise, v);\n              resolve(v);\n            }\n          }, function (e) {\n            if (!settled) {\n              rejectPromise(promise, e);\n              reject(e);\n            }\n          }).finally(function () {\n            if (!settled) {\n              settled = true;\n              setAtomValue(atom, promise, depSet);\n            }\n          });\n          continuePromise = function continuePromise(next) {\n            if (!settled) {\n              settled = true;\n              next.then(function (v) {\n                return resolvePromise(promise, v);\n              }, function (e) {\n                return rejectPromise(promise, e);\n              });\n              resolve(next);\n            }\n          };\n        });\n        promise.status = \"pending\";\n        registerCancelPromise(promise, function (next) {\n          if (next) {\n            continuePromise(next);\n          }\n          controller == null ? void 0 : controller.abort();\n        });\n        return setAtomValue(atom, promise, depSet);\n      }\n      return setAtomValue(atom, value, depSet);\n    } catch (error) {\n      return setAtomError(atom, error, depSet);\n    } finally {\n      isSync = false;\n    }\n  };\n  var readAtom = function readAtom(atom) {\n    return returnAtomValue(readAtomState(atom));\n  };\n  var addAtom = function addAtom(atom) {\n    var mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  };\n  var delAtom = function delAtom(atom) {\n    var mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  var recomputeDependents = function recomputeDependents(atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(function (dependent) {\n      if (dependent !== atom) {\n        var prevAtomState = getAtomState(dependent);\n        var nextAtomState = readAtomState(dependent);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(dependent);\n        }\n      }\n    });\n  };\n  var writeAtomState = function writeAtomState(atom) {\n    var isSync = true;\n    var getter = function getter(a) {\n      return returnAtomValue(readAtomState(a));\n    };\n    var setter = function setter(a) {\n      var r;\n      for (var _len3 = arguments.length, args2 = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args2[_key3 - 1] = arguments[_key3];\n      }\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        var prevAtomState = getAtomState(a);\n        var nextAtomState = setAtomValue(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState.apply(void 0, [a].concat(args2));\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    var result = atom.write.apply(atom, [getter, setter].concat(args));\n    isSync = false;\n    return result;\n  };\n  var writeAtom = function writeAtom(atom) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    var result = writeAtomState.apply(void 0, [atom].concat(args));\n    flushPending();\n    return result;\n  };\n  var mountAtom = function mountAtom(atom, initialDependent) {\n    var mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach(function (_, a) {\n      var aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var onUnmount = atom.onMount(function () {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n        return writeAtom.apply(void 0, [atom].concat(args));\n      });\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  var unmountAtom = function unmountAtom(atom) {\n    var _a;\n    var onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    var atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  var mountDependencies = function mountDependencies(atom, atomState, prevDependencies) {\n    var depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach(function (_, a) {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  var flushPending = function flushPending() {\n    while (pendingMap.size) {\n      var pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          atom = _ref4[0],\n          prevAtomState = _ref4[1];\n        var atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          var mounted = mountedMap.get(atom);\n          if (mounted && !(\n          // TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach(function (listener) {\n              return listener();\n            });\n          }\n        } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach(function (l) {\n        return l();\n      });\n    }\n  };\n  var subscribeAtom = function subscribeAtom(atom, listener) {\n    var mounted = addAtom(atom);\n    flushPending();\n    var listeners = mounted.l;\n    listeners.add(listener);\n    return function () {\n      listeners.delete(listener);\n      delAtom(atom);\n    };\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change)\n      dev_subscribe_state: function dev_subscribe_state(l) {\n        stateListeners.add(l);\n        return function () {\n          stateListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: function dev_get_mounted_atoms() {\n        return mountedAtoms.values();\n      },\n      dev_get_atom_state: function dev_get_atom_state(a) {\n        return atomStateMap.get(a);\n      },\n      dev_get_mounted: function dev_get_mounted(a) {\n        return mountedMap.get(a);\n      },\n      dev_restore_atoms: function dev_restore_atoms(values) {\n        var _iterator = _createForOfIteratorHelper(values),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              _atom = _step$value[0],\n              value = _step$value[1];\n            if (hasInitialValue(_atom)) {\n              setAtomValue(_atom, value);\n              recomputeDependents(_atom);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        flushPending();\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nvar defaultStore;\nvar getDefaultStore = function getDefaultStore() {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\nexport { atom, createStore, getDefaultStore };","map":{"version":3,"names":["keyCount","atom","read","write","key","concat","config","toString","init","get","set","arg","hasInitialValue","isActuallyWritableAtom","cancelPromiseMap","WeakMap","registerCancelPromise","promise","cancel","catch","finally","delete","cancelPromise","next","resolvePromise","value","status","rejectPromise","e","reason","isEqualAtomValue","a","b","Object","is","v","isEqualAtomError","hasPromiseAtomValue","Promise","returnAtomValue","atomState","createStore","atomStateMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","import","meta","env","MODE","Set","getAtomState","setAtomState","freeze","prevAtomState","has","resolve","reject","updateDependencies","nextAtomState","depSet","dependencies","changed","forEach","aState","d","console","warn","size","setAtomValue","setAtomError","error","readAtomState","_","Array","from","every","_ref","_ref2","_slicedToArray","s","isSync","getter","add","aState2","Error","controller","setSelf","options","signal","AbortController","_len","arguments","length","args","_key","writeAtom","apply","continuePromise","settled","then","abort","readAtom","addAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","unmountAtom","recomputeDependents","dependent","writeAtomState","setter","r","_len3","args2","_key3","flushPending","_len2","_key2","result","_len4","_key4","initialDependent","aMounted","onMount","onUnmount","_len5","_key5","u","_a","mountDependencies","prevDependencies","keys","pending","clear","_ref3","_ref4","listener","subscribeAtom","listeners","sub","dev_subscribe_state","dev_get_mounted_atoms","values","dev_get_atom_state","dev_get_mounted","dev_restore_atoms","_iterator","_createForOfIteratorHelper","_step","n","done","_step$value","err","f","defaultStore","getDefaultStore"],"sources":["D:/project/excalidraw-cn/node_modules/jotai/esm/vanilla.mjs"],"sourcesContent":["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, arg) => set(\n      config,\n      typeof arg === \"function\" ? arg(get(config)) : arg\n    );\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isEqualAtomValue = (a, b) => \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => \"v\" in a && a.v instanceof Promise;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, depSet) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    depSet.forEach((a) => {\n      const aState = a === atom ? nextAtomState : getAtomState(a);\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomError = (atom, error, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom) => {\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(\n        ([a, s]) => a === atom || getAtomState(a) === s\n      )) {\n        return atomState;\n      }\n    }\n    const depSet = /* @__PURE__ */ new Set();\n    let isSync = true;\n    const getter = (a) => {\n      depSet.add(a);\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env && import.meta.env.MODE) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const value = atom.read(getter, options);\n      if (value instanceof Promise) {\n        let continuePromise;\n        const promise = new Promise((resolve, reject) => {\n          let settled = false;\n          value.then(\n            (v) => {\n              if (!settled) {\n                resolvePromise(promise, v);\n                resolve(v);\n              }\n            },\n            (e) => {\n              if (!settled) {\n                rejectPromise(promise, e);\n                reject(e);\n              }\n            }\n          ).finally(() => {\n            if (!settled) {\n              settled = true;\n              setAtomValue(atom, promise, depSet);\n            }\n          });\n          continuePromise = (next) => {\n            if (!settled) {\n              settled = true;\n              next.then(\n                (v) => resolvePromise(promise, v),\n                (e) => rejectPromise(promise, e)\n              );\n              resolve(next);\n            }\n          };\n        });\n        promise.status = \"pending\";\n        registerCancelPromise(promise, (next) => {\n          if (next) {\n            continuePromise(next);\n          }\n          controller == null ? void 0 : controller.abort();\n        });\n        return setAtomValue(atom, promise, depSet);\n      }\n      return setAtomValue(atom, value, depSet);\n    } catch (error) {\n      return setAtomError(atom, error, depSet);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        const prevAtomState = getAtomState(dependent);\n        const nextAtomState = readAtomState(dependent);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(dependent);\n        }\n      }\n    });\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValue(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    flushPending();\n    return result;\n  };\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const onUnmount = atom.onMount((...args) => writeAtom(atom, ...args));\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          const mounted = mountedMap.get(atom);\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n          }\n        } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n    };\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change)\n      dev_subscribe_state: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, value] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValue(atom, value);\n            recomputeDependents(atom);\n          }\n        }\n        flushPending();\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}