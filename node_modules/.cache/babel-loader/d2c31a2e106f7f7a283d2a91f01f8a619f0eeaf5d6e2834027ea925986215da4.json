{"ast":null,"code":"import _objectSpread from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _classCallCheck from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createClass.js\";import{isLinearElement}from\"./element/typeChecks\";import{deepCopyElement}from\"./element/newElement\";var clearAppStatePropertiesForHistory=function clearAppStatePropertiesForHistory(appState){return{selectedElementIds:appState.selectedElementIds,selectedGroupIds:appState.selectedGroupIds,viewBackgroundColor:appState.viewBackgroundColor,editingLinearElement:appState.editingLinearElement,editingGroupId:appState.editingGroupId,name:appState.name};};var History=/*#__PURE__*/function(){function History(){var _this=this;_classCallCheck(this,History);this.elementCache=new Map();this.recording=true;this.stateHistory=[];this.redoStack=[];this.lastEntry=null;this.generateEntry=function(appState,elements){return _this.dehydrateHistoryEntry({appState:clearAppStatePropertiesForHistory(appState),elements:elements.reduce(function(elements,element){if(isLinearElement(element)&&appState.multiElement&&appState.multiElement.id===element.id){// don't store multi-point arrow if still has only one point\nif(appState.multiElement&&appState.multiElement.id===element.id&&element.points.length<2){return elements;}elements.push(_objectSpread(_objectSpread({},element),{},{// don't store last point if not committed\npoints:element.lastCommittedPoint!==element.points[element.points.length-1]?element.points.slice(0,-1):element.points}));}else{elements.push(element);}return elements;},[])});};}_createClass(History,[{key:\"hydrateHistoryEntry\",value:function hydrateHistoryEntry(_ref){var _this2=this;var appState=_ref.appState,elements=_ref.elements;return{appState:JSON.parse(appState),elements:elements.map(function(dehydratedExcalidrawElement){var _this2$elementCache$g;var element=(_this2$elementCache$g=_this2.elementCache.get(dehydratedExcalidrawElement.id))===null||_this2$elementCache$g===void 0?void 0:_this2$elementCache$g.get(dehydratedExcalidrawElement.versionNonce);if(!element){throw new Error(\"Element not found: \".concat(dehydratedExcalidrawElement.id,\":\").concat(dehydratedExcalidrawElement.versionNonce));}return element;})};}},{key:\"dehydrateHistoryEntry\",value:function dehydrateHistoryEntry(_ref2){var _this3=this;var appState=_ref2.appState,elements=_ref2.elements;return{appState:JSON.stringify(appState),elements:elements.map(function(element){if(!_this3.elementCache.has(element.id)){_this3.elementCache.set(element.id,new Map());}var versions=_this3.elementCache.get(element.id);if(!versions.has(element.versionNonce)){versions.set(element.versionNonce,deepCopyElement(element));}return{id:element.id,versionNonce:element.versionNonce};})};}},{key:\"getSnapshotForTest\",value:function getSnapshotForTest(){var _this4=this;return{recording:this.recording,stateHistory:this.stateHistory.map(function(dehydratedHistoryEntry){return _this4.hydrateHistoryEntry(dehydratedHistoryEntry);}),redoStack:this.redoStack.map(function(dehydratedHistoryEntry){return _this4.hydrateHistoryEntry(dehydratedHistoryEntry);})};}},{key:\"clear\",value:function clear(){this.stateHistory.length=0;this.redoStack.length=0;this.lastEntry=null;this.elementCache.clear();}},{key:\"shouldCreateEntry\",value:function shouldCreateEntry(nextEntry){var lastEntry=this.lastEntry;if(!lastEntry){return true;}if(nextEntry.elements.length!==lastEntry.elements.length){return true;}// loop from right to left as changes are likelier to happen on new elements\nfor(var i=nextEntry.elements.length-1;i>-1;i--){var prev=nextEntry.elements[i];var next=lastEntry.elements[i];if(!prev||!next||prev.id!==next.id||prev.versionNonce!==next.versionNonce){return true;}}// note: this is safe because entry's appState is guaranteed no excess props\nvar key;for(key in nextEntry.appState){if(key===\"editingLinearElement\"){var _nextEntry$appState$k,_lastEntry$appState$k;if(((_nextEntry$appState$k=nextEntry.appState[key])===null||_nextEntry$appState$k===void 0?void 0:_nextEntry$appState$k.elementId)===((_lastEntry$appState$k=lastEntry.appState[key])===null||_lastEntry$appState$k===void 0?void 0:_lastEntry$appState$k.elementId)){continue;}}if(key===\"selectedElementIds\"||key===\"selectedGroupIds\"){continue;}if(nextEntry.appState[key]!==lastEntry.appState[key]){return true;}}return false;}},{key:\"pushEntry\",value:function pushEntry(appState,elements){var newEntryDehydrated=this.generateEntry(appState,elements);var newEntry=this.hydrateHistoryEntry(newEntryDehydrated);if(newEntry){if(!this.shouldCreateEntry(newEntry)){return;}this.stateHistory.push(newEntryDehydrated);this.lastEntry=newEntry;// As a new entry was pushed, we invalidate the redo stack\nthis.clearRedoStack();}}},{key:\"clearRedoStack\",value:function clearRedoStack(){this.redoStack.splice(0,this.redoStack.length);}},{key:\"redoOnce\",value:function redoOnce(){if(this.redoStack.length===0){return null;}var entryToRestore=this.redoStack.pop();if(entryToRestore!==undefined){this.stateHistory.push(entryToRestore);return this.hydrateHistoryEntry(entryToRestore);}return null;}},{key:\"undoOnce\",value:function undoOnce(){if(this.stateHistory.length===1){return null;}var currentEntry=this.stateHistory.pop();var entryToRestore=this.stateHistory[this.stateHistory.length-1];if(currentEntry!==undefined){this.redoStack.push(currentEntry);return this.hydrateHistoryEntry(entryToRestore);}return null;}/**\n   * Updates history's `lastEntry` to latest app state. This is necessary\n   *  when doing undo/redo which itself doesn't commit to history, but updates\n   *  app state in a way that would break `shouldCreateEntry` which relies on\n   *  `lastEntry` to reflect last comittable history state.\n   * We can't update `lastEntry` from within history when calling undo/redo\n   *  because the action potentially mutates appState/elements before storing\n   *  it.\n   */},{key:\"setCurrentState\",value:function setCurrentState(appState,elements){this.lastEntry=this.hydrateHistoryEntry(this.generateEntry(appState,elements));}// Suspicious that this is called so many places. Seems error-prone.\n},{key:\"resumeRecording\",value:function resumeRecording(){this.recording=true;}},{key:\"record\",value:function record(state,elements){if(this.recording){this.pushEntry(state,elements);this.recording=false;}}}]);return History;}();export default History;","map":{"version":3,"names":["isLinearElement","deepCopyElement","clearAppStatePropertiesForHistory","appState","selectedElementIds","selectedGroupIds","viewBackgroundColor","editingLinearElement","editingGroupId","name","History","_this","_classCallCheck","elementCache","Map","recording","stateHistory","redoStack","lastEntry","generateEntry","elements","dehydrateHistoryEntry","reduce","element","multiElement","id","points","length","push","_objectSpread","lastCommittedPoint","slice","_createClass","key","value","hydrateHistoryEntry","_ref","_this2","JSON","parse","map","dehydratedExcalidrawElement","_this2$elementCache$g","get","versionNonce","Error","concat","_ref2","_this3","stringify","has","set","versions","getSnapshotForTest","_this4","dehydratedHistoryEntry","clear","shouldCreateEntry","nextEntry","i","prev","next","_nextEntry$appState$k","_lastEntry$appState$k","elementId","pushEntry","newEntryDehydrated","newEntry","clearRedoStack","splice","redoOnce","entryToRestore","pop","undefined","undoOnce","currentEntry","setCurrentState","resumeRecording","record","state"],"sources":["D:/project/excalidraw-cn/src/history.ts"],"sourcesContent":["import { AppState } from \"./types\";\nimport { ExcalidrawElement } from \"./element/types\";\nimport { isLinearElement } from \"./element/typeChecks\";\nimport { deepCopyElement } from \"./element/newElement\";\nimport { Mutable } from \"./utility-types\";\n\nexport interface HistoryEntry {\n  appState: ReturnType<typeof clearAppStatePropertiesForHistory>;\n  elements: ExcalidrawElement[];\n}\n\ninterface DehydratedExcalidrawElement {\n  id: string;\n  versionNonce: number;\n}\n\ninterface DehydratedHistoryEntry {\n  appState: string;\n  elements: DehydratedExcalidrawElement[];\n}\n\nconst clearAppStatePropertiesForHistory = (appState: AppState) => {\n  return {\n    selectedElementIds: appState.selectedElementIds,\n    selectedGroupIds: appState.selectedGroupIds,\n    viewBackgroundColor: appState.viewBackgroundColor,\n    editingLinearElement: appState.editingLinearElement,\n    editingGroupId: appState.editingGroupId,\n    name: appState.name,\n  };\n};\n\nclass History {\n  private elementCache = new Map<string, Map<number, ExcalidrawElement>>();\n  private recording: boolean = true;\n  private stateHistory: DehydratedHistoryEntry[] = [];\n  private redoStack: DehydratedHistoryEntry[] = [];\n  private lastEntry: HistoryEntry | null = null;\n\n  private hydrateHistoryEntry({\n    appState,\n    elements,\n  }: DehydratedHistoryEntry): HistoryEntry {\n    return {\n      appState: JSON.parse(appState),\n      elements: elements.map((dehydratedExcalidrawElement) => {\n        const element = this.elementCache\n          .get(dehydratedExcalidrawElement.id)\n          ?.get(dehydratedExcalidrawElement.versionNonce);\n        if (!element) {\n          throw new Error(\n            `Element not found: ${dehydratedExcalidrawElement.id}:${dehydratedExcalidrawElement.versionNonce}`,\n          );\n        }\n        return element;\n      }),\n    };\n  }\n\n  private dehydrateHistoryEntry({\n    appState,\n    elements,\n  }: HistoryEntry): DehydratedHistoryEntry {\n    return {\n      appState: JSON.stringify(appState),\n      elements: elements.map((element: ExcalidrawElement) => {\n        if (!this.elementCache.has(element.id)) {\n          this.elementCache.set(element.id, new Map());\n        }\n        const versions = this.elementCache.get(element.id)!;\n        if (!versions.has(element.versionNonce)) {\n          versions.set(element.versionNonce, deepCopyElement(element));\n        }\n        return {\n          id: element.id,\n          versionNonce: element.versionNonce,\n        };\n      }),\n    };\n  }\n\n  getSnapshotForTest() {\n    return {\n      recording: this.recording,\n      stateHistory: this.stateHistory.map((dehydratedHistoryEntry) =>\n        this.hydrateHistoryEntry(dehydratedHistoryEntry),\n      ),\n      redoStack: this.redoStack.map((dehydratedHistoryEntry) =>\n        this.hydrateHistoryEntry(dehydratedHistoryEntry),\n      ),\n    };\n  }\n\n  clear() {\n    this.stateHistory.length = 0;\n    this.redoStack.length = 0;\n    this.lastEntry = null;\n    this.elementCache.clear();\n  }\n\n  private generateEntry = (\n    appState: AppState,\n    elements: readonly ExcalidrawElement[],\n  ): DehydratedHistoryEntry =>\n    this.dehydrateHistoryEntry({\n      appState: clearAppStatePropertiesForHistory(appState),\n      elements: elements.reduce((elements, element) => {\n        if (\n          isLinearElement(element) &&\n          appState.multiElement &&\n          appState.multiElement.id === element.id\n        ) {\n          // don't store multi-point arrow if still has only one point\n          if (\n            appState.multiElement &&\n            appState.multiElement.id === element.id &&\n            element.points.length < 2\n          ) {\n            return elements;\n          }\n\n          elements.push({\n            ...element,\n            // don't store last point if not committed\n            points:\n              element.lastCommittedPoint !==\n              element.points[element.points.length - 1]\n                ? element.points.slice(0, -1)\n                : element.points,\n          });\n        } else {\n          elements.push(element);\n        }\n        return elements;\n      }, [] as Mutable<typeof elements>),\n    });\n\n  shouldCreateEntry(nextEntry: HistoryEntry): boolean {\n    const { lastEntry } = this;\n\n    if (!lastEntry) {\n      return true;\n    }\n\n    if (nextEntry.elements.length !== lastEntry.elements.length) {\n      return true;\n    }\n\n    // loop from right to left as changes are likelier to happen on new elements\n    for (let i = nextEntry.elements.length - 1; i > -1; i--) {\n      const prev = nextEntry.elements[i];\n      const next = lastEntry.elements[i];\n      if (\n        !prev ||\n        !next ||\n        prev.id !== next.id ||\n        prev.versionNonce !== next.versionNonce\n      ) {\n        return true;\n      }\n    }\n\n    // note: this is safe because entry's appState is guaranteed no excess props\n    let key: keyof typeof nextEntry.appState;\n    for (key in nextEntry.appState) {\n      if (key === \"editingLinearElement\") {\n        if (\n          nextEntry.appState[key]?.elementId ===\n          lastEntry.appState[key]?.elementId\n        ) {\n          continue;\n        }\n      }\n      if (key === \"selectedElementIds\" || key === \"selectedGroupIds\") {\n        continue;\n      }\n      if (nextEntry.appState[key] !== lastEntry.appState[key]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  pushEntry(appState: AppState, elements: readonly ExcalidrawElement[]) {\n    const newEntryDehydrated = this.generateEntry(appState, elements);\n    const newEntry: HistoryEntry = this.hydrateHistoryEntry(newEntryDehydrated);\n\n    if (newEntry) {\n      if (!this.shouldCreateEntry(newEntry)) {\n        return;\n      }\n\n      this.stateHistory.push(newEntryDehydrated);\n      this.lastEntry = newEntry;\n      // As a new entry was pushed, we invalidate the redo stack\n      this.clearRedoStack();\n    }\n  }\n\n  clearRedoStack() {\n    this.redoStack.splice(0, this.redoStack.length);\n  }\n\n  redoOnce(): HistoryEntry | null {\n    if (this.redoStack.length === 0) {\n      return null;\n    }\n\n    const entryToRestore = this.redoStack.pop();\n\n    if (entryToRestore !== undefined) {\n      this.stateHistory.push(entryToRestore);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  undoOnce(): HistoryEntry | null {\n    if (this.stateHistory.length === 1) {\n      return null;\n    }\n\n    const currentEntry = this.stateHistory.pop();\n\n    const entryToRestore = this.stateHistory[this.stateHistory.length - 1];\n\n    if (currentEntry !== undefined) {\n      this.redoStack.push(currentEntry);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  /**\n   * Updates history's `lastEntry` to latest app state. This is necessary\n   *  when doing undo/redo which itself doesn't commit to history, but updates\n   *  app state in a way that would break `shouldCreateEntry` which relies on\n   *  `lastEntry` to reflect last comittable history state.\n   * We can't update `lastEntry` from within history when calling undo/redo\n   *  because the action potentially mutates appState/elements before storing\n   *  it.\n   */\n  setCurrentState(appState: AppState, elements: readonly ExcalidrawElement[]) {\n    this.lastEntry = this.hydrateHistoryEntry(\n      this.generateEntry(appState, elements),\n    );\n  }\n\n  // Suspicious that this is called so many places. Seems error-prone.\n  resumeRecording() {\n    this.recording = true;\n  }\n\n  record(state: AppState, elements: readonly ExcalidrawElement[]) {\n    if (this.recording) {\n      this.pushEntry(state, elements);\n      this.recording = false;\n    }\n  }\n}\n\nexport default History;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}