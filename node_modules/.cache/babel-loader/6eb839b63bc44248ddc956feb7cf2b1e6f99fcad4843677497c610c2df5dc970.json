{"ast":null,"code":"import { getNonDeletedElements, getNonDeletedFrames, isNonDeletedElement } from \"../element\";\nimport { isFrameElement } from \"../element/typeChecks\";\nimport { getSelectedElements } from \"./selection\";\nconst hashSelectionOpts = opts => {\n  const keys = [\"includeBoundTextElement\", \"includeElementsInFrames\"];\n\n  // just to ensure we're hashing all expected keys\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  let hash = \"\";\n  for (const key of keys) {\n    hash += `${key}:${opts[key] ? \"1\" : \"0\"}`;\n  }\n  return hash;\n};\n\n// ideally this would be a branded type but it'd be insanely hard to work with\n// in our codebase\nconst isIdKey = elementKey => {\n  if (typeof elementKey === \"string\") {\n    return true;\n  }\n  return false;\n};\nclass Scene {\n  constructor() {\n    // ---------------------------------------------------------------------------\n    // instance methods/props\n    // ---------------------------------------------------------------------------\n    this.callbacks = new Set();\n    this.nonDeletedElements = [];\n    this.elements = [];\n    this.nonDeletedFrames = [];\n    this.frames = [];\n    this.elementsMap = new Map();\n    this.selectedElementsCache = {\n      selectedElementIds: null,\n      elements: null,\n      cache: new Map()\n    };\n    this.addNewElement = element => {\n      if (element.frameId) {\n        this.insertElementAtIndex(element, this.getElementIndex(element.frameId));\n      } else {\n        this.replaceAllElements([...this.elements, element]);\n      }\n    };\n  }\n  static mapElementToScene(elementKey, scene) {\n    if (isIdKey(elementKey)) {\n      // for cases where we don't have access to the element object\n      // (e.g. restore serialized appState with id references)\n      this.sceneMapById.set(elementKey, scene);\n    } else {\n      this.sceneMapByElement.set(elementKey, scene);\n      // if mapping element objects, also cache the id string when later\n      // looking up by id alone\n      this.sceneMapById.set(elementKey.id, scene);\n    }\n  }\n  static getScene(elementKey) {\n    if (isIdKey(elementKey)) {\n      return this.sceneMapById.get(elementKey) || null;\n    }\n    return this.sceneMapByElement.get(elementKey) || null;\n  }\n  getElementsIncludingDeleted() {\n    return this.elements;\n  }\n  getNonDeletedElements() {\n    return this.nonDeletedElements;\n  }\n  getFramesIncludingDeleted() {\n    return this.frames;\n  }\n  getSelectedElements(opts) {\n    const hash = hashSelectionOpts(opts);\n    const elements = (opts === null || opts === void 0 ? void 0 : opts.elements) || this.nonDeletedElements;\n    if (this.selectedElementsCache.elements === elements && this.selectedElementsCache.selectedElementIds === opts.selectedElementIds) {\n      const cached = this.selectedElementsCache.cache.get(hash);\n      if (cached) {\n        return cached;\n      }\n    } else if ((opts === null || opts === void 0 ? void 0 : opts.elements) == null) {\n      // if we're operating on latest scene elements and the cache is not\n      //  storing the latest elements, clear the cache\n      this.selectedElementsCache.cache.clear();\n    }\n    const selectedElements = getSelectedElements(elements, {\n      selectedElementIds: opts.selectedElementIds\n    }, opts);\n\n    // cache only if we're not using custom elements\n    if ((opts === null || opts === void 0 ? void 0 : opts.elements) == null) {\n      this.selectedElementsCache.selectedElementIds = opts.selectedElementIds;\n      this.selectedElementsCache.elements = this.nonDeletedElements;\n      this.selectedElementsCache.cache.set(hash, selectedElements);\n    }\n    return selectedElements;\n  }\n  getNonDeletedFrames() {\n    return this.nonDeletedFrames;\n  }\n  getElement(id) {\n    return this.elementsMap.get(id) || null;\n  }\n  getNonDeletedElement(id) {\n    const element = this.getElement(id);\n    if (element && isNonDeletedElement(element)) {\n      return element;\n    }\n    return null;\n  }\n\n  /**\n   * A utility method to help with updating all scene elements, with the added\n   * performance optimization of not renewing the array if no change is made.\n   *\n   * Maps all current excalidraw elements, invoking the callback for each\n   * element. The callback should either return a new mapped element, or the\n   * original element if no changes are made. If no changes are made to any\n   * element, this results in a no-op. Otherwise, the newly mapped elements\n   * are set as the next scene's elements.\n   *\n   * @returns whether a change was made\n   */\n  mapElements(iteratee) {\n    let didChange = false;\n    const newElements = this.elements.map(element => {\n      const nextElement = iteratee(element);\n      if (nextElement !== element) {\n        didChange = true;\n      }\n      return nextElement;\n    });\n    if (didChange) {\n      this.replaceAllElements(newElements);\n    }\n    return didChange;\n  }\n  replaceAllElements(nextElements) {\n    this.elements = nextElements;\n    const nextFrames = [];\n    this.elementsMap.clear();\n    nextElements.forEach(element => {\n      if (isFrameElement(element)) {\n        nextFrames.push(element);\n      }\n      this.elementsMap.set(element.id, element);\n      Scene.mapElementToScene(element, this);\n    });\n    this.nonDeletedElements = getNonDeletedElements(this.elements);\n    this.frames = nextFrames;\n    this.nonDeletedFrames = getNonDeletedFrames(this.frames);\n    this.informMutation();\n  }\n  informMutation() {\n    for (const callback of Array.from(this.callbacks)) {\n      callback();\n    }\n  }\n  addCallback(cb) {\n    if (this.callbacks.has(cb)) {\n      throw new Error();\n    }\n    this.callbacks.add(cb);\n    return () => {\n      if (!this.callbacks.has(cb)) {\n        throw new Error();\n      }\n      this.callbacks.delete(cb);\n    };\n  }\n  destroy() {\n    this.nonDeletedElements = [];\n    this.elements = [];\n    this.nonDeletedFrames = [];\n    this.frames = [];\n    this.elementsMap.clear();\n    this.selectedElementsCache.selectedElementIds = null;\n    this.selectedElementsCache.elements = null;\n    this.selectedElementsCache.cache.clear();\n    Scene.sceneMapById.forEach((scene, elementKey) => {\n      if (scene === this) {\n        Scene.sceneMapById.delete(elementKey);\n      }\n    });\n\n    // done not for memory leaks, but to guard against possible late fires\n    // (I guess?)\n    this.callbacks.clear();\n  }\n  insertElementAtIndex(element, index) {\n    if (!Number.isFinite(index) || index < 0) {\n      throw new Error(\"insertElementAtIndex can only be called with index >= 0\");\n    }\n    const nextElements = [...this.elements.slice(0, index), element, ...this.elements.slice(index)];\n    this.replaceAllElements(nextElements);\n  }\n  insertElementsAtIndex(elements, index) {\n    if (!Number.isFinite(index) || index < 0) {\n      throw new Error(\"insertElementAtIndex can only be called with index >= 0\");\n    }\n    const nextElements = [...this.elements.slice(0, index), ...elements, ...this.elements.slice(index)];\n    this.replaceAllElements(nextElements);\n  }\n  getElementIndex(elementId) {\n    return this.elements.findIndex(element => element.id === elementId);\n  }\n}\n// ---------------------------------------------------------------------------\n// static methods/props\n// ---------------------------------------------------------------------------\nScene.sceneMapByElement = new WeakMap();\nScene.sceneMapById = new Map();\nexport default Scene;","map":{"version":3,"names":["getNonDeletedElements","getNonDeletedFrames","isNonDeletedElement","isFrameElement","getSelectedElements","hashSelectionOpts","opts","keys","hash","key","isIdKey","elementKey","Scene","constructor","callbacks","Set","nonDeletedElements","elements","nonDeletedFrames","frames","elementsMap","Map","selectedElementsCache","selectedElementIds","cache","addNewElement","element","frameId","insertElementAtIndex","getElementIndex","replaceAllElements","mapElementToScene","scene","sceneMapById","set","sceneMapByElement","id","getScene","get","getElementsIncludingDeleted","getFramesIncludingDeleted","cached","clear","selectedElements","getElement","getNonDeletedElement","mapElements","iteratee","didChange","newElements","map","nextElement","nextElements","nextFrames","forEach","push","informMutation","callback","Array","from","addCallback","cb","has","Error","add","delete","destroy","index","Number","isFinite","slice","insertElementsAtIndex","elementId","findIndex","WeakMap"],"sources":["D:/project/excalidraw-cn/src/scene/Scene.ts"],"sourcesContent":["import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ExcalidrawFrameElement,\n} from \"../element/types\";\nimport {\n  getNonDeletedElements,\n  getNonDeletedFrames,\n  isNonDeletedElement,\n} from \"../element\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { isFrameElement } from \"../element/typeChecks\";\nimport { getSelectedElements } from \"./selection\";\nimport { AppState } from \"../types\";\nimport { Assert, SameType } from \"../utility-types\";\n\ntype ElementIdKey = InstanceType<typeof LinearElementEditor>[\"elementId\"];\ntype ElementKey = ExcalidrawElement | ElementIdKey;\n\ntype SceneStateCallback = () => void;\ntype SceneStateCallbackRemover = () => void;\n\ntype SelectionHash = string & { __brand: \"selectionHash\" };\n\nconst hashSelectionOpts = (\n  opts: Parameters<InstanceType<typeof Scene>[\"getSelectedElements\"]>[0],\n) => {\n  const keys = [\"includeBoundTextElement\", \"includeElementsInFrames\"] as const;\n\n  type HashableKeys = Omit<typeof opts, \"selectedElementIds\" | \"elements\">;\n\n  // just to ensure we're hashing all expected keys\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  type _ = Assert<\n    SameType<\n      Required<HashableKeys>,\n      Pick<Required<HashableKeys>, typeof keys[number]>\n    >\n  >;\n\n  let hash = \"\";\n  for (const key of keys) {\n    hash += `${key}:${opts[key] ? \"1\" : \"0\"}`;\n  }\n  return hash as SelectionHash;\n};\n\n// ideally this would be a branded type but it'd be insanely hard to work with\n// in our codebase\nexport type ExcalidrawElementsIncludingDeleted = readonly ExcalidrawElement[];\n\nconst isIdKey = (elementKey: ElementKey): elementKey is ElementIdKey => {\n  if (typeof elementKey === \"string\") {\n    return true;\n  }\n  return false;\n};\n\nclass Scene {\n  // ---------------------------------------------------------------------------\n  // static methods/props\n  // ---------------------------------------------------------------------------\n\n  private static sceneMapByElement = new WeakMap<ExcalidrawElement, Scene>();\n  private static sceneMapById = new Map<string, Scene>();\n\n  static mapElementToScene(elementKey: ElementKey, scene: Scene) {\n    if (isIdKey(elementKey)) {\n      // for cases where we don't have access to the element object\n      // (e.g. restore serialized appState with id references)\n      this.sceneMapById.set(elementKey, scene);\n    } else {\n      this.sceneMapByElement.set(elementKey, scene);\n      // if mapping element objects, also cache the id string when later\n      // looking up by id alone\n      this.sceneMapById.set(elementKey.id, scene);\n    }\n  }\n\n  static getScene(elementKey: ElementKey): Scene | null {\n    if (isIdKey(elementKey)) {\n      return this.sceneMapById.get(elementKey) || null;\n    }\n    return this.sceneMapByElement.get(elementKey) || null;\n  }\n\n  // ---------------------------------------------------------------------------\n  // instance methods/props\n  // ---------------------------------------------------------------------------\n\n  private callbacks: Set<SceneStateCallback> = new Set();\n\n  private nonDeletedElements: readonly NonDeletedExcalidrawElement[] = [];\n  private elements: readonly ExcalidrawElement[] = [];\n  private nonDeletedFrames: readonly NonDeleted<ExcalidrawFrameElement>[] = [];\n  private frames: readonly ExcalidrawFrameElement[] = [];\n  private elementsMap = new Map<ExcalidrawElement[\"id\"], ExcalidrawElement>();\n  private selectedElementsCache: {\n    selectedElementIds: AppState[\"selectedElementIds\"] | null;\n    elements: readonly NonDeletedExcalidrawElement[] | null;\n    cache: Map<SelectionHash, NonDeletedExcalidrawElement[]>;\n  } = {\n    selectedElementIds: null,\n    elements: null,\n    cache: new Map(),\n  };\n\n  getElementsIncludingDeleted() {\n    return this.elements;\n  }\n\n  getNonDeletedElements(): readonly NonDeletedExcalidrawElement[] {\n    return this.nonDeletedElements;\n  }\n\n  getFramesIncludingDeleted() {\n    return this.frames;\n  }\n\n  getSelectedElements(opts: {\n    // NOTE can be ommitted by making Scene constructor require App instance\n    selectedElementIds: AppState[\"selectedElementIds\"];\n    /**\n     * for specific cases where you need to use elements not from current\n     * scene state. This in effect will likely result in cache-miss, and\n     * the cache won't be updated in this case.\n     */\n    elements?: readonly ExcalidrawElement[];\n    // selection-related options\n    includeBoundTextElement?: boolean;\n    includeElementsInFrames?: boolean;\n  }): NonDeleted<ExcalidrawElement>[] {\n    const hash = hashSelectionOpts(opts);\n\n    const elements = opts?.elements || this.nonDeletedElements;\n    if (\n      this.selectedElementsCache.elements === elements &&\n      this.selectedElementsCache.selectedElementIds === opts.selectedElementIds\n    ) {\n      const cached = this.selectedElementsCache.cache.get(hash);\n      if (cached) {\n        return cached;\n      }\n    } else if (opts?.elements == null) {\n      // if we're operating on latest scene elements and the cache is not\n      //  storing the latest elements, clear the cache\n      this.selectedElementsCache.cache.clear();\n    }\n\n    const selectedElements = getSelectedElements(\n      elements,\n      { selectedElementIds: opts.selectedElementIds },\n      opts,\n    );\n\n    // cache only if we're not using custom elements\n    if (opts?.elements == null) {\n      this.selectedElementsCache.selectedElementIds = opts.selectedElementIds;\n      this.selectedElementsCache.elements = this.nonDeletedElements;\n      this.selectedElementsCache.cache.set(hash, selectedElements);\n    }\n\n    return selectedElements;\n  }\n\n  getNonDeletedFrames(): readonly NonDeleted<ExcalidrawFrameElement>[] {\n    return this.nonDeletedFrames;\n  }\n\n  getElement<T extends ExcalidrawElement>(id: T[\"id\"]): T | null {\n    return (this.elementsMap.get(id) as T | undefined) || null;\n  }\n\n  getNonDeletedElement(\n    id: ExcalidrawElement[\"id\"],\n  ): NonDeleted<ExcalidrawElement> | null {\n    const element = this.getElement(id);\n    if (element && isNonDeletedElement(element)) {\n      return element;\n    }\n    return null;\n  }\n\n  /**\n   * A utility method to help with updating all scene elements, with the added\n   * performance optimization of not renewing the array if no change is made.\n   *\n   * Maps all current excalidraw elements, invoking the callback for each\n   * element. The callback should either return a new mapped element, or the\n   * original element if no changes are made. If no changes are made to any\n   * element, this results in a no-op. Otherwise, the newly mapped elements\n   * are set as the next scene's elements.\n   *\n   * @returns whether a change was made\n   */\n  mapElements(\n    iteratee: (element: ExcalidrawElement) => ExcalidrawElement,\n  ): boolean {\n    let didChange = false;\n    const newElements = this.elements.map((element) => {\n      const nextElement = iteratee(element);\n      if (nextElement !== element) {\n        didChange = true;\n      }\n      return nextElement;\n    });\n    if (didChange) {\n      this.replaceAllElements(newElements);\n    }\n    return didChange;\n  }\n\n  replaceAllElements(nextElements: readonly ExcalidrawElement[]) {\n    this.elements = nextElements;\n    const nextFrames: ExcalidrawFrameElement[] = [];\n    this.elementsMap.clear();\n    nextElements.forEach((element) => {\n      if (isFrameElement(element)) {\n        nextFrames.push(element);\n      }\n      this.elementsMap.set(element.id, element);\n      Scene.mapElementToScene(element, this);\n    });\n    this.nonDeletedElements = getNonDeletedElements(this.elements);\n    this.frames = nextFrames;\n    this.nonDeletedFrames = getNonDeletedFrames(this.frames);\n\n    this.informMutation();\n  }\n\n  informMutation() {\n    for (const callback of Array.from(this.callbacks)) {\n      callback();\n    }\n  }\n\n  addCallback(cb: SceneStateCallback): SceneStateCallbackRemover {\n    if (this.callbacks.has(cb)) {\n      throw new Error();\n    }\n\n    this.callbacks.add(cb);\n\n    return () => {\n      if (!this.callbacks.has(cb)) {\n        throw new Error();\n      }\n      this.callbacks.delete(cb);\n    };\n  }\n\n  destroy() {\n    this.nonDeletedElements = [];\n    this.elements = [];\n    this.nonDeletedFrames = [];\n    this.frames = [];\n    this.elementsMap.clear();\n    this.selectedElementsCache.selectedElementIds = null;\n    this.selectedElementsCache.elements = null;\n    this.selectedElementsCache.cache.clear();\n\n    Scene.sceneMapById.forEach((scene, elementKey) => {\n      if (scene === this) {\n        Scene.sceneMapById.delete(elementKey);\n      }\n    });\n\n    // done not for memory leaks, but to guard against possible late fires\n    // (I guess?)\n    this.callbacks.clear();\n  }\n\n  insertElementAtIndex(element: ExcalidrawElement, index: number) {\n    if (!Number.isFinite(index) || index < 0) {\n      throw new Error(\n        \"insertElementAtIndex can only be called with index >= 0\",\n      );\n    }\n    const nextElements = [\n      ...this.elements.slice(0, index),\n      element,\n      ...this.elements.slice(index),\n    ];\n    this.replaceAllElements(nextElements);\n  }\n\n  insertElementsAtIndex(elements: ExcalidrawElement[], index: number) {\n    if (!Number.isFinite(index) || index < 0) {\n      throw new Error(\n        \"insertElementAtIndex can only be called with index >= 0\",\n      );\n    }\n    const nextElements = [\n      ...this.elements.slice(0, index),\n      ...elements,\n      ...this.elements.slice(index),\n    ];\n\n    this.replaceAllElements(nextElements);\n  }\n\n  addNewElement = (element: ExcalidrawElement) => {\n    if (element.frameId) {\n      this.insertElementAtIndex(element, this.getElementIndex(element.frameId));\n    } else {\n      this.replaceAllElements([...this.elements, element]);\n    }\n  };\n\n  getElementIndex(elementId: string) {\n    return this.elements.findIndex((element) => element.id === elementId);\n  }\n}\n\nexport default Scene;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}