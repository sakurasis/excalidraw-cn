{"ast":null,"code":"import _slicedToArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import{updateBoundElements}from\"./binding\";import{getCommonBounds}from\"./bounds\";import{mutateElement}from\"./mutateElement\";import{getPerfectElementSize}from\"./sizeHelpers\";import{getBoundTextElement}from\"./textElement\";import{isSelectedViaGroup}from\"../groups\";import{isFrameElement}from\"./typeChecks\";export var dragSelectedElements=function dragSelectedElements(pointerDownState,selectedElements,pointerX,pointerY){var lockDirection=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;var distanceX=arguments.length>5&&arguments[5]!==undefined?arguments[5]:0;var distanceY=arguments.length>6&&arguments[6]!==undefined?arguments[6]:0;var appState=arguments.length>7?arguments[7]:undefined;var scene=arguments.length>8?arguments[8]:undefined;var _getCommonBounds=getCommonBounds(selectedElements),_getCommonBounds2=_slicedToArray(_getCommonBounds,2),x1=_getCommonBounds2[0],y1=_getCommonBounds2[1];var offset={x:pointerX-x1,y:pointerY-y1};// we do not want a frame and its elements to be selected at the same time\n// but when it happens (due to some bug), we want to avoid updating element\n// in the frame twice, hence the use of set\nvar elementsToUpdate=new Set(selectedElements);var frames=selectedElements.filter(function(e){return isFrameElement(e);}).map(function(f){return f.id;});if(frames.length>0){var elementsInFrames=scene.getNonDeletedElements().filter(function(e){return e.frameId!==null;}).filter(function(e){return frames.includes(e.frameId);});elementsInFrames.forEach(function(element){return elementsToUpdate.add(element);});}elementsToUpdate.forEach(function(element){updateElementCoords(lockDirection,distanceX,distanceY,pointerDownState,element,offset);// update coords of bound text only if we're dragging the container directly\n// (we don't drag the group that it's part of)\nif(// container isn't part of any group\n// (perf optim so we don't check `isSelectedViaGroup()` in every case)\n!element.groupIds.length||// container is part of a group, but we're dragging the container directly\nappState.editingGroupId&&!isSelectedViaGroup(appState,element)){var textElement=getBoundTextElement(element);if(textElement&&(// when container is added to a frame, so will its bound text\n// so the text is already in `elementsToUpdate` and we should avoid\n// updating its coords again\n!textElement.frameId||!frames.includes(textElement.frameId))){updateElementCoords(lockDirection,distanceX,distanceY,pointerDownState,textElement,offset);}}updateBoundElements(element,{simultaneouslyUpdated:Array.from(elementsToUpdate)});});};var updateElementCoords=function updateElementCoords(lockDirection,distanceX,distanceY,pointerDownState,element,offset){var x;var y;if(lockDirection){var lockX=lockDirection&&distanceX<distanceY;var lockY=lockDirection&&distanceX>distanceY;var original=pointerDownState.originalElements.get(element.id);x=lockX&&original?original.x:element.x+offset.x;y=lockY&&original?original.y:element.y+offset.y;}else{x=element.x+offset.x;y=element.y+offset.y;}mutateElement(element,{x:x,y:y});};export var getDragOffsetXY=function getDragOffsetXY(selectedElements,x,y){var _getCommonBounds3=getCommonBounds(selectedElements),_getCommonBounds4=_slicedToArray(_getCommonBounds3,2),x1=_getCommonBounds4[0],y1=_getCommonBounds4[1];return[x-x1,y-y1];};export var dragNewElement=function dragNewElement(draggingElement,elementType,originX,originY,x,y,width,height,shouldMaintainAspectRatio,shouldResizeFromCenter,widthAspectRatio){if(shouldMaintainAspectRatio&&draggingElement.type!==\"selection\"){if(widthAspectRatio){height=width/widthAspectRatio;}else{// Depending on where the cursor is at (x, y) relative to where the starting point is\n// (originX, originY), we use ONLY width or height to control size increase.\n// This allows the cursor to always \"stick\" to one of the sides of the bounding box.\nif(Math.abs(y-originY)>Math.abs(x-originX)){var _getPerfectElementSiz=getPerfectElementSize(elementType,height,x<originX?-width:width);width=_getPerfectElementSiz.width;height=_getPerfectElementSiz.height;}else{var _getPerfectElementSiz2=getPerfectElementSize(elementType,width,y<originY?-height:height);width=_getPerfectElementSiz2.width;height=_getPerfectElementSiz2.height;}if(height<0){height=-height;}}}var newX=x<originX?originX-width:originX;var newY=y<originY?originY-height:originY;if(shouldResizeFromCenter){width+=width;height+=height;newX=originX-width/2;newY=originY-height/2;}if(width!==0&&height!==0){mutateElement(draggingElement,{x:newX,y:newY,width:width,height:height});}};","map":{"version":3,"names":["updateBoundElements","getCommonBounds","mutateElement","getPerfectElementSize","getBoundTextElement","isSelectedViaGroup","isFrameElement","dragSelectedElements","pointerDownState","selectedElements","pointerX","pointerY","lockDirection","arguments","length","undefined","distanceX","distanceY","appState","scene","_getCommonBounds","_getCommonBounds2","_slicedToArray","x1","y1","offset","x","y","elementsToUpdate","Set","frames","filter","e","map","f","id","elementsInFrames","getNonDeletedElements","frameId","includes","forEach","element","add","updateElementCoords","groupIds","editingGroupId","textElement","simultaneouslyUpdated","Array","from","lockX","lockY","original","originalElements","get","getDragOffsetXY","_getCommonBounds3","_getCommonBounds4","dragNewElement","draggingElement","elementType","originX","originY","width","height","shouldMaintainAspectRatio","shouldResizeFromCenter","widthAspectRatio","type","Math","abs","_getPerfectElementSiz","_getPerfectElementSiz2","newX","newY"],"sources":["D:/project/excalidraw-cn/src/element/dragElements.ts"],"sourcesContent":["import { updateBoundElements } from \"./binding\";\nimport { getCommonBounds } from \"./bounds\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nimport { NonDeletedExcalidrawElement } from \"./types\";\nimport { AppState, PointerDownState } from \"../types\";\nimport { getBoundTextElement } from \"./textElement\";\nimport { isSelectedViaGroup } from \"../groups\";\nimport Scene from \"../scene/Scene\";\nimport { isFrameElement } from \"./typeChecks\";\n\nexport const dragSelectedElements = (\n  pointerDownState: PointerDownState,\n  selectedElements: NonDeletedExcalidrawElement[],\n  pointerX: number,\n  pointerY: number,\n  lockDirection: boolean = false,\n  distanceX: number = 0,\n  distanceY: number = 0,\n  appState: AppState,\n  scene: Scene,\n) => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  const offset = { x: pointerX - x1, y: pointerY - y1 };\n\n  // we do not want a frame and its elements to be selected at the same time\n  // but when it happens (due to some bug), we want to avoid updating element\n  // in the frame twice, hence the use of set\n  const elementsToUpdate = new Set<NonDeletedExcalidrawElement>(\n    selectedElements,\n  );\n  const frames = selectedElements\n    .filter((e) => isFrameElement(e))\n    .map((f) => f.id);\n\n  if (frames.length > 0) {\n    const elementsInFrames = scene\n      .getNonDeletedElements()\n      .filter((e) => e.frameId !== null)\n      .filter((e) => frames.includes(e.frameId!));\n\n    elementsInFrames.forEach((element) => elementsToUpdate.add(element));\n  }\n\n  elementsToUpdate.forEach((element) => {\n    updateElementCoords(\n      lockDirection,\n      distanceX,\n      distanceY,\n      pointerDownState,\n      element,\n      offset,\n    );\n    // update coords of bound text only if we're dragging the container directly\n    // (we don't drag the group that it's part of)\n    if (\n      // container isn't part of any group\n      // (perf optim so we don't check `isSelectedViaGroup()` in every case)\n      !element.groupIds.length ||\n      // container is part of a group, but we're dragging the container directly\n      (appState.editingGroupId && !isSelectedViaGroup(appState, element))\n    ) {\n      const textElement = getBoundTextElement(element);\n      if (\n        textElement &&\n        // when container is added to a frame, so will its bound text\n        // so the text is already in `elementsToUpdate` and we should avoid\n        // updating its coords again\n        (!textElement.frameId || !frames.includes(textElement.frameId))\n      ) {\n        updateElementCoords(\n          lockDirection,\n          distanceX,\n          distanceY,\n          pointerDownState,\n          textElement,\n          offset,\n        );\n      }\n    }\n    updateBoundElements(element, {\n      simultaneouslyUpdated: Array.from(elementsToUpdate),\n    });\n  });\n};\n\nconst updateElementCoords = (\n  lockDirection: boolean,\n  distanceX: number,\n  distanceY: number,\n  pointerDownState: PointerDownState,\n  element: NonDeletedExcalidrawElement,\n  offset: { x: number; y: number },\n) => {\n  let x: number;\n  let y: number;\n  if (lockDirection) {\n    const lockX = lockDirection && distanceX < distanceY;\n    const lockY = lockDirection && distanceX > distanceY;\n    const original = pointerDownState.originalElements.get(element.id);\n    x = lockX && original ? original.x : element.x + offset.x;\n    y = lockY && original ? original.y : element.y + offset.y;\n  } else {\n    x = element.x + offset.x;\n    y = element.y + offset.y;\n  }\n\n  mutateElement(element, {\n    x,\n    y,\n  });\n};\nexport const getDragOffsetXY = (\n  selectedElements: NonDeletedExcalidrawElement[],\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  return [x - x1, y - y1];\n};\n\nexport const dragNewElement = (\n  draggingElement: NonDeletedExcalidrawElement,\n  elementType: AppState[\"activeTool\"][\"type\"],\n  originX: number,\n  originY: number,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  shouldMaintainAspectRatio: boolean,\n  shouldResizeFromCenter: boolean,\n  /** whether to keep given aspect ratio when `isResizeWithSidesSameLength` is\n      true */\n  widthAspectRatio?: number | null,\n) => {\n  if (shouldMaintainAspectRatio && draggingElement.type !== \"selection\") {\n    if (widthAspectRatio) {\n      height = width / widthAspectRatio;\n    } else {\n      // Depending on where the cursor is at (x, y) relative to where the starting point is\n      // (originX, originY), we use ONLY width or height to control size increase.\n      // This allows the cursor to always \"stick\" to one of the sides of the bounding box.\n      if (Math.abs(y - originY) > Math.abs(x - originX)) {\n        ({ width, height } = getPerfectElementSize(\n          elementType,\n          height,\n          x < originX ? -width : width,\n        ));\n      } else {\n        ({ width, height } = getPerfectElementSize(\n          elementType,\n          width,\n          y < originY ? -height : height,\n        ));\n      }\n\n      if (height < 0) {\n        height = -height;\n      }\n    }\n  }\n\n  let newX = x < originX ? originX - width : originX;\n  let newY = y < originY ? originY - height : originY;\n\n  if (shouldResizeFromCenter) {\n    width += width;\n    height += height;\n    newX = originX - width / 2;\n    newY = originY - height / 2;\n  }\n\n  if (width !== 0 && height !== 0) {\n    mutateElement(draggingElement, {\n      x: newX,\n      y: newY,\n      width,\n      height,\n    });\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}