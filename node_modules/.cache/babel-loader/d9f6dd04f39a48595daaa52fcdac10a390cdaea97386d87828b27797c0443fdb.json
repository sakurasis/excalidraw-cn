{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { Severity } from '@sentry/types';\nimport { addExceptionMechanism, addExceptionTypeValue, isDOMError, isDOMException, isError, isErrorEvent, isEvent, isPlainObject, SyncPromise } from '@sentry/utils';\nimport { eventFromPlainObject, eventFromStacktrace, prepareFramesForEvent } from './parsers';\nimport { computeStackTrace } from './tracekit';\n/**\n * Builds and Event from a Exception\n * @hidden\n */\nexport function eventFromException(options, exception, hint) {\n  var syntheticException = hint && hint.syntheticException || undefined;\n  var event = eventFromUnknownInput(exception, syntheticException, {\n    attachStacktrace: options.attachStacktrace\n  });\n  addExceptionMechanism(event, {\n    handled: true,\n    type: 'generic'\n  });\n  event.level = Severity.Error;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return SyncPromise.resolve(event);\n}\n/**\n * Builds and Event from a Message\n * @hidden\n */\nexport function eventFromMessage(options, message, level, hint) {\n  if (level === void 0) {\n    level = Severity.Info;\n  }\n  var syntheticException = hint && hint.syntheticException || undefined;\n  var event = eventFromString(message, syntheticException, {\n    attachStacktrace: options.attachStacktrace\n  });\n  event.level = level;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return SyncPromise.resolve(event);\n}\n/**\n * @hidden\n */\nexport function eventFromUnknownInput(exception, syntheticException, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var event;\n  if (isErrorEvent(exception) && exception.error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    var errorEvent = exception;\n    // eslint-disable-next-line no-param-reassign\n    exception = errorEvent.error;\n    event = eventFromStacktrace(computeStackTrace(exception));\n    return event;\n  }\n  if (isDOMError(exception) || isDOMException(exception)) {\n    // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)\n    // then we just extract the name, code, and message, as they don't provide anything else\n    // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n    // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n    var domException = exception;\n    var name_1 = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n    var message = domException.message ? name_1 + \": \" + domException.message : name_1;\n    event = eventFromString(message, syntheticException, options);\n    addExceptionTypeValue(event, message);\n    if ('code' in domException) {\n      event.tags = __assign(__assign({}, event.tags), {\n        'DOMException.code': \"\" + domException.code\n      });\n    }\n    return event;\n  }\n  if (isError(exception)) {\n    // we have a real Error object, do nothing\n    event = eventFromStacktrace(computeStackTrace(exception));\n    return event;\n  }\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it is plain Object or Event, serialize it manually and extract options\n    // This will allow us to group events based on top-level keys\n    // which is much better than creating new group when any key/value change\n    var objectException = exception;\n    event = eventFromPlainObject(objectException, syntheticException, options.rejection);\n    addExceptionMechanism(event, {\n      synthetic: true\n    });\n    return event;\n  }\n  // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n  event = eventFromString(exception, syntheticException, options);\n  addExceptionTypeValue(event, \"\" + exception, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true\n  });\n  return event;\n}\n/**\n * @hidden\n */\nexport function eventFromString(input, syntheticException, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var event = {\n    message: input\n  };\n  if (options.attachStacktrace && syntheticException) {\n    var stacktrace = computeStackTrace(syntheticException);\n    var frames_1 = prepareFramesForEvent(stacktrace.stack);\n    event.stacktrace = {\n      frames: frames_1\n    };\n  }\n  return event;\n}","map":{"version":3,"names":["Severity","addExceptionMechanism","addExceptionTypeValue","isDOMError","isDOMException","isError","isErrorEvent","isEvent","isPlainObject","SyncPromise","eventFromPlainObject","eventFromStacktrace","prepareFramesForEvent","computeStackTrace","eventFromException","options","exception","hint","syntheticException","undefined","event","eventFromUnknownInput","attachStacktrace","handled","type","level","Error","event_id","resolve","eventFromMessage","message","Info","eventFromString","error","errorEvent","domException","name_1","name","tags","__assign","code","objectException","rejection","synthetic","input","stacktrace","frames_1","stack","frames"],"sources":["D:\\project\\excalidraw-cn\\node_modules\\@sentry\\browser\\src\\eventbuilder.ts"],"sourcesContent":["import { Event, EventHint, Options, Severity } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  isDOMError,\n  isDOMException,\n  isError,\n  isErrorEvent,\n  isEvent,\n  isPlainObject,\n  SyncPromise,\n} from '@sentry/utils';\n\nimport { eventFromPlainObject, eventFromStacktrace, prepareFramesForEvent } from './parsers';\nimport { computeStackTrace } from './tracekit';\n\n/**\n * Builds and Event from a Exception\n * @hidden\n */\nexport function eventFromException(options: Options, exception: unknown, hint?: EventHint): PromiseLike<Event> {\n  const syntheticException = (hint && hint.syntheticException) || undefined;\n  const event = eventFromUnknownInput(exception, syntheticException, {\n    attachStacktrace: options.attachStacktrace,\n  });\n  addExceptionMechanism(event, {\n    handled: true,\n    type: 'generic',\n  });\n  event.level = Severity.Error;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return SyncPromise.resolve(event);\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nexport function eventFromMessage(\n  options: Options,\n  message: string,\n  level: Severity = Severity.Info,\n  hint?: EventHint,\n): PromiseLike<Event> {\n  const syntheticException = (hint && hint.syntheticException) || undefined;\n  const event = eventFromString(message, syntheticException, {\n    attachStacktrace: options.attachStacktrace,\n  });\n  event.level = level;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return SyncPromise.resolve(event);\n}\n\n/**\n * @hidden\n */\nexport function eventFromUnknownInput(\n  exception: unknown,\n  syntheticException?: Error,\n  options: {\n    rejection?: boolean;\n    attachStacktrace?: boolean;\n  } = {},\n): Event {\n  let event: Event;\n\n  if (isErrorEvent(exception as ErrorEvent) && (exception as ErrorEvent).error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    const errorEvent = exception as ErrorEvent;\n    // eslint-disable-next-line no-param-reassign\n    exception = errorEvent.error;\n    event = eventFromStacktrace(computeStackTrace(exception as Error));\n    return event;\n  }\n  if (isDOMError(exception as DOMError) || isDOMException(exception as DOMException)) {\n    // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)\n    // then we just extract the name, code, and message, as they don't provide anything else\n    // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n    // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n    const domException = exception as DOMException;\n    const name = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n    const message = domException.message ? `${name}: ${domException.message}` : name;\n\n    event = eventFromString(message, syntheticException, options);\n    addExceptionTypeValue(event, message);\n    if ('code' in domException) {\n      event.tags = { ...event.tags, 'DOMException.code': `${domException.code}` };\n    }\n\n    return event;\n  }\n  if (isError(exception as Error)) {\n    // we have a real Error object, do nothing\n    event = eventFromStacktrace(computeStackTrace(exception as Error));\n    return event;\n  }\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it is plain Object or Event, serialize it manually and extract options\n    // This will allow us to group events based on top-level keys\n    // which is much better than creating new group when any key/value change\n    const objectException = exception as Record<string, unknown>;\n    event = eventFromPlainObject(objectException, syntheticException, options.rejection);\n    addExceptionMechanism(event, {\n      synthetic: true,\n    });\n    return event;\n  }\n\n  // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n  event = eventFromString(exception as string, syntheticException, options);\n  addExceptionTypeValue(event, `${exception}`, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true,\n  });\n\n  return event;\n}\n\n/**\n * @hidden\n */\nexport function eventFromString(\n  input: string,\n  syntheticException?: Error,\n  options: {\n    attachStacktrace?: boolean;\n  } = {},\n): Event {\n  const event: Event = {\n    message: input,\n  };\n\n  if (options.attachStacktrace && syntheticException) {\n    const stacktrace = computeStackTrace(syntheticException);\n    const frames = prepareFramesForEvent(stacktrace.stack);\n    event.stacktrace = {\n      frames,\n    };\n  }\n\n  return event;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}