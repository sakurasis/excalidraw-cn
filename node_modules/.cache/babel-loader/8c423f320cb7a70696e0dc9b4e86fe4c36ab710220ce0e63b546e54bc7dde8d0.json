{"ast":null,"code":"import _toConsumableArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _createForOfIteratorHelper from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import{arrayToMapWithIndex}from\"../utils\";var normalizeGroupElementOrder=function normalizeGroupElementOrder(elements){var origElements=elements.slice();var sortedElements=new Set();var orderInnerGroups=function orderInnerGroups(elements){var _elements$,_elements$$groupIds;var firstGroupSig=(_elements$=elements[0])===null||_elements$===void 0?void 0:(_elements$$groupIds=_elements$.groupIds)===null||_elements$$groupIds===void 0?void 0:_elements$$groupIds.join(\"\");var aGroup=[elements[0]];var bGroup=[];var _iterator=_createForOfIteratorHelper(elements.slice(1)),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var _element$groupIds;var element=_step.value;if(((_element$groupIds=element.groupIds)===null||_element$groupIds===void 0?void 0:_element$groupIds.join(\"\"))===firstGroupSig){aGroup.push(element);}else{bGroup.push(element);}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return bGroup.length?[].concat(aGroup,_toConsumableArray(orderInnerGroups(bGroup))):aGroup;};var groupHandledElements=new Map();origElements.forEach(function(element,idx){var _element$groupIds2;if(groupHandledElements.has(element.id)){return;}if((_element$groupIds2=element.groupIds)!==null&&_element$groupIds2!==void 0&&_element$groupIds2.length){var topGroup=element.groupIds[element.groupIds.length-1];var groupElements=origElements.slice(idx).filter(function(element){var _element$groupIds3;var ret=element===null||element===void 0?void 0:(_element$groupIds3=element.groupIds)===null||_element$groupIds3===void 0?void 0:_element$groupIds3.some(function(id){return id===topGroup;});if(ret){groupHandledElements.set(element.id,true);}return ret;});var _iterator2=_createForOfIteratorHelper(orderInnerGroups(groupElements)),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var elem=_step2.value;sortedElements.add(elem);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}else{sortedElements.add(element);}});// if there's a bug which resulted in losing some of the elements, return\n// original instead as that's better than losing data\nif(sortedElements.size!==elements.length){console.error(\"normalizeGroupElementOrder: lost some elements... bailing!\");return elements;}return _toConsumableArray(sortedElements);};/**\n * In theory, when we have text elements bound to a container, they\n * should be right after the container element in the elements array.\n * However, this is not guaranteed due to old and potential future bugs.\n *\n * This function sorts containers and their bound texts together. It prefers\n * original z-index of container (i.e. it moves bound text elements after\n * containers).\n */var normalizeBoundElementsOrder=function normalizeBoundElementsOrder(elements){var elementsMap=arrayToMapWithIndex(elements);var origElements=elements.slice();var sortedElements=new Set();origElements.forEach(function(element,idx){var _element$boundElement;if(!element){return;}if((_element$boundElement=element.boundElements)!==null&&_element$boundElement!==void 0&&_element$boundElement.length){sortedElements.add(element);origElements[idx]=null;element.boundElements.forEach(function(boundElement){var child=elementsMap.get(boundElement.id);if(child&&boundElement.type===\"text\"){sortedElements.add(child[0]);origElements[child[1]]=null;}});}else if(element.type===\"text\"&&element.containerId){var _parent$0$boundElemen;var parent=elementsMap.get(element.containerId);if(!(parent!==null&&parent!==void 0&&(_parent$0$boundElemen=parent[0].boundElements)!==null&&_parent$0$boundElemen!==void 0&&_parent$0$boundElemen.find(function(x){return x.id===element.id;}))){sortedElements.add(element);origElements[idx]=null;// if element has a container and container lists it, skip this element\n// as it'll be taken care of by the container\n}}else{sortedElements.add(element);origElements[idx]=null;}});// if there's a bug which resulted in losing some of the elements, return\n// original instead as that's better than losing data\nif(sortedElements.size!==elements.length){console.error(\"normalizeBoundElementsOrder: lost some elements... bailing!\");return elements;}return _toConsumableArray(sortedElements);};export var normalizeElementOrder=function normalizeElementOrder(elements){// console.time();\nvar ret=normalizeBoundElementsOrder(normalizeGroupElementOrder(elements));// console.timeEnd();\nreturn ret;};","map":{"version":3,"names":["arrayToMapWithIndex","normalizeGroupElementOrder","elements","origElements","slice","sortedElements","Set","orderInnerGroups","_elements$","_elements$$groupIds","firstGroupSig","groupIds","join","aGroup","bGroup","_iterator","_createForOfIteratorHelper","_step","s","n","done","_element$groupIds","element","value","push","err","e","f","length","concat","_toConsumableArray","groupHandledElements","Map","forEach","idx","_element$groupIds2","has","id","topGroup","groupElements","filter","_element$groupIds3","ret","some","set","_iterator2","_step2","elem","add","size","console","error","normalizeBoundElementsOrder","elementsMap","_element$boundElement","boundElements","boundElement","child","get","type","containerId","_parent$0$boundElemen","parent","find","x","normalizeElementOrder"],"sources":["D:/project/excalidraw-cn/src/element/sortElements.ts"],"sourcesContent":["import { arrayToMapWithIndex } from \"../utils\";\nimport { ExcalidrawElement } from \"./types\";\n\nconst normalizeGroupElementOrder = (elements: readonly ExcalidrawElement[]) => {\n  const origElements: ExcalidrawElement[] = elements.slice();\n  const sortedElements = new Set<ExcalidrawElement>();\n\n  const orderInnerGroups = (\n    elements: readonly ExcalidrawElement[],\n  ): ExcalidrawElement[] => {\n    const firstGroupSig = elements[0]?.groupIds?.join(\"\");\n    const aGroup: ExcalidrawElement[] = [elements[0]];\n    const bGroup: ExcalidrawElement[] = [];\n    for (const element of elements.slice(1)) {\n      if (element.groupIds?.join(\"\") === firstGroupSig) {\n        aGroup.push(element);\n      } else {\n        bGroup.push(element);\n      }\n    }\n    return bGroup.length ? [...aGroup, ...orderInnerGroups(bGroup)] : aGroup;\n  };\n\n  const groupHandledElements = new Map<string, true>();\n\n  origElements.forEach((element, idx) => {\n    if (groupHandledElements.has(element.id)) {\n      return;\n    }\n    if (element.groupIds?.length) {\n      const topGroup = element.groupIds[element.groupIds.length - 1];\n      const groupElements = origElements.slice(idx).filter((element) => {\n        const ret = element?.groupIds?.some((id) => id === topGroup);\n        if (ret) {\n          groupHandledElements.set(element!.id, true);\n        }\n        return ret;\n      });\n\n      for (const elem of orderInnerGroups(groupElements)) {\n        sortedElements.add(elem);\n      }\n    } else {\n      sortedElements.add(element);\n    }\n  });\n\n  // if there's a bug which resulted in losing some of the elements, return\n  // original instead as that's better than losing data\n  if (sortedElements.size !== elements.length) {\n    console.error(\"normalizeGroupElementOrder: lost some elements... bailing!\");\n    return elements;\n  }\n\n  return [...sortedElements];\n};\n\n/**\n * In theory, when we have text elements bound to a container, they\n * should be right after the container element in the elements array.\n * However, this is not guaranteed due to old and potential future bugs.\n *\n * This function sorts containers and their bound texts together. It prefers\n * original z-index of container (i.e. it moves bound text elements after\n * containers).\n */\nconst normalizeBoundElementsOrder = (\n  elements: readonly ExcalidrawElement[],\n) => {\n  const elementsMap = arrayToMapWithIndex(elements);\n\n  const origElements: (ExcalidrawElement | null)[] = elements.slice();\n  const sortedElements = new Set<ExcalidrawElement>();\n\n  origElements.forEach((element, idx) => {\n    if (!element) {\n      return;\n    }\n    if (element.boundElements?.length) {\n      sortedElements.add(element);\n      origElements[idx] = null;\n      element.boundElements.forEach((boundElement) => {\n        const child = elementsMap.get(boundElement.id);\n        if (child && boundElement.type === \"text\") {\n          sortedElements.add(child[0]);\n          origElements[child[1]] = null;\n        }\n      });\n    } else if (element.type === \"text\" && element.containerId) {\n      const parent = elementsMap.get(element.containerId);\n      if (!parent?.[0].boundElements?.find((x) => x.id === element.id)) {\n        sortedElements.add(element);\n        origElements[idx] = null;\n\n        // if element has a container and container lists it, skip this element\n        // as it'll be taken care of by the container\n      }\n    } else {\n      sortedElements.add(element);\n      origElements[idx] = null;\n    }\n  });\n\n  // if there's a bug which resulted in losing some of the elements, return\n  // original instead as that's better than losing data\n  if (sortedElements.size !== elements.length) {\n    console.error(\n      \"normalizeBoundElementsOrder: lost some elements... bailing!\",\n    );\n    return elements;\n  }\n\n  return [...sortedElements];\n};\n\nexport const normalizeElementOrder = (\n  elements: readonly ExcalidrawElement[],\n) => {\n  // console.time();\n  const ret = normalizeBoundElementsOrder(normalizeGroupElementOrder(elements));\n  // console.timeEnd();\n  return ret;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}