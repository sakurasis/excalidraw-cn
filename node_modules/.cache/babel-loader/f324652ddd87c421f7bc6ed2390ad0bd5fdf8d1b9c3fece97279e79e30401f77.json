{"ast":null,"code":"import _toConsumableArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";export var getSizeFromPoints=function getSizeFromPoints(points){var xs=points.map(function(point){return point[0];});var ys=points.map(function(point){return point[1];});return{width:Math.max.apply(Math,_toConsumableArray(xs))-Math.min.apply(Math,_toConsumableArray(xs)),height:Math.max.apply(Math,_toConsumableArray(ys))-Math.min.apply(Math,_toConsumableArray(ys))};};/** @arg dimension, 0 for rescaling only x, 1 for y */export var rescalePoints=function rescalePoints(dimension,newSize,points,normalize){var coordinates=points.map(function(point){return point[dimension];});var maxCoordinate=Math.max.apply(Math,_toConsumableArray(coordinates));var minCoordinate=Math.min.apply(Math,_toConsumableArray(coordinates));var size=maxCoordinate-minCoordinate;var scale=size===0?1:newSize/size;var nextMinCoordinate=Infinity;var scaledPoints=points.map(function(point){var newCoordinate=point[dimension]*scale;var newPoint=_toConsumableArray(point);newPoint[dimension]=newCoordinate;if(newCoordinate<nextMinCoordinate){nextMinCoordinate=newCoordinate;}return newPoint;});if(!normalize){return scaledPoints;}if(scaledPoints.length===2){// we don't translate two-point lines\nreturn scaledPoints;}var translation=minCoordinate-nextMinCoordinate;var nextPoints=scaledPoints.map(function(scaledPoint){return scaledPoint.map(function(value,currentDimension){return currentDimension===dimension?value+translation:value;});});return nextPoints;};","map":{"version":3,"names":["getSizeFromPoints","points","xs","map","point","ys","width","Math","max","apply","_toConsumableArray","min","height","rescalePoints","dimension","newSize","normalize","coordinates","maxCoordinate","minCoordinate","size","scale","nextMinCoordinate","Infinity","scaledPoints","newCoordinate","newPoint","length","translation","nextPoints","scaledPoint","value","currentDimension"],"sources":["D:/project/excalidraw-cn/src/points.ts"],"sourcesContent":["import { Point } from \"./types\";\n\nexport const getSizeFromPoints = (points: readonly Point[]) => {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys),\n  };\n};\n\n/** @arg dimension, 0 for rescaling only x, 1 for y */\nexport const rescalePoints = (\n  dimension: 0 | 1,\n  newSize: number,\n  points: readonly Point[],\n  normalize: boolean,\n): Point[] => {\n  const coordinates = points.map((point) => point[dimension]);\n  const maxCoordinate = Math.max(...coordinates);\n  const minCoordinate = Math.min(...coordinates);\n  const size = maxCoordinate - minCoordinate;\n  const scale = size === 0 ? 1 : newSize / size;\n\n  let nextMinCoordinate = Infinity;\n\n  const scaledPoints = points.map((point): Point => {\n    const newCoordinate = point[dimension] * scale;\n    const newPoint = [...point];\n    newPoint[dimension] = newCoordinate;\n    if (newCoordinate < nextMinCoordinate) {\n      nextMinCoordinate = newCoordinate;\n    }\n    return newPoint as unknown as Point;\n  });\n\n  if (!normalize) {\n    return scaledPoints;\n  }\n\n  if (scaledPoints.length === 2) {\n    // we don't translate two-point lines\n    return scaledPoints;\n  }\n\n  const translation = minCoordinate - nextMinCoordinate;\n\n  const nextPoints = scaledPoints.map(\n    (scaledPoint) =>\n      scaledPoint.map((value, currentDimension) => {\n        return currentDimension === dimension ? value + translation : value;\n      }) as [number, number],\n  );\n  return nextPoints;\n};\n"],"mappings":"sHAEA,MAAO,IAAM,CAAAA,iBAAiB,CAAG,QAApB,CAAAA,iBAAiBA,CAAIC,MAAwB,CAAK,CAC7D,GAAM,CAAAC,EAAE,CAAGD,MAAM,CAACE,GAAG,CAAC,SAACC,KAAK,QAAK,CAAAA,KAAK,CAAC,CAAC,CAAC,GAAC,CAC1C,GAAM,CAAAC,EAAE,CAAGJ,MAAM,CAACE,GAAG,CAAC,SAACC,KAAK,QAAK,CAAAA,KAAK,CAAC,CAAC,CAAC,GAAC,CAC1C,MAAO,CACLE,KAAK,CAAEC,IAAI,CAACC,GAAG,CAAAC,KAAA,CAARF,IAAI,CAAAG,kBAAA,CAAQR,EAAE,EAAC,CAAGK,IAAI,CAACI,GAAG,CAAAF,KAAA,CAARF,IAAI,CAAAG,kBAAA,CAAQR,EAAE,EAAC,CACxCU,MAAM,CAAEL,IAAI,CAACC,GAAG,CAAAC,KAAA,CAARF,IAAI,CAAAG,kBAAA,CAAQL,EAAE,EAAC,CAAGE,IAAI,CAACI,GAAG,CAAAF,KAAA,CAARF,IAAI,CAAAG,kBAAA,CAAQL,EAAE,EAC1C,CAAC,CACH,CAAC,CAED,sDACA,MAAO,IAAM,CAAAQ,aAAa,CAAG,QAAhB,CAAAA,aAAaA,CACxBC,SAAgB,CAChBC,OAAe,CACfd,MAAwB,CACxBe,SAAkB,CACN,CACZ,GAAM,CAAAC,WAAW,CAAGhB,MAAM,CAACE,GAAG,CAAC,SAACC,KAAK,QAAK,CAAAA,KAAK,CAACU,SAAS,CAAC,GAAC,CAC3D,GAAM,CAAAI,aAAa,CAAGX,IAAI,CAACC,GAAG,CAAAC,KAAA,CAARF,IAAI,CAAAG,kBAAA,CAAQO,WAAW,EAAC,CAC9C,GAAM,CAAAE,aAAa,CAAGZ,IAAI,CAACI,GAAG,CAAAF,KAAA,CAARF,IAAI,CAAAG,kBAAA,CAAQO,WAAW,EAAC,CAC9C,GAAM,CAAAG,IAAI,CAAGF,aAAa,CAAGC,aAAa,CAC1C,GAAM,CAAAE,KAAK,CAAGD,IAAI,GAAK,CAAC,CAAG,CAAC,CAAGL,OAAO,CAAGK,IAAI,CAE7C,GAAI,CAAAE,iBAAiB,CAAGC,QAAQ,CAEhC,GAAM,CAAAC,YAAY,CAAGvB,MAAM,CAACE,GAAG,CAAC,SAACC,KAAK,CAAY,CAChD,GAAM,CAAAqB,aAAa,CAAGrB,KAAK,CAACU,SAAS,CAAC,CAAGO,KAAK,CAC9C,GAAM,CAAAK,QAAQ,CAAAhB,kBAAA,CAAON,KAAK,CAAC,CAC3BsB,QAAQ,CAACZ,SAAS,CAAC,CAAGW,aAAa,CACnC,GAAIA,aAAa,CAAGH,iBAAiB,CAAE,CACrCA,iBAAiB,CAAGG,aAAa,CACnC,CACA,MAAO,CAAAC,QAAQ,CACjB,CAAC,CAAC,CAEF,GAAI,CAACV,SAAS,CAAE,CACd,MAAO,CAAAQ,YAAY,CACrB,CAEA,GAAIA,YAAY,CAACG,MAAM,GAAK,CAAC,CAAE,CAC7B;AACA,MAAO,CAAAH,YAAY,CACrB,CAEA,GAAM,CAAAI,WAAW,CAAGT,aAAa,CAAGG,iBAAiB,CAErD,GAAM,CAAAO,UAAU,CAAGL,YAAY,CAACrB,GAAG,CACjC,SAAC2B,WAAW,QACV,CAAAA,WAAW,CAAC3B,GAAG,CAAC,SAAC4B,KAAK,CAAEC,gBAAgB,CAAK,CAC3C,MAAO,CAAAA,gBAAgB,GAAKlB,SAAS,CAAGiB,KAAK,CAAGH,WAAW,CAAGG,KAAK,CACrE,CAAC,CAAC,EAAoB,CACzB,CACD,MAAO,CAAAF,UAAU,CACnB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}