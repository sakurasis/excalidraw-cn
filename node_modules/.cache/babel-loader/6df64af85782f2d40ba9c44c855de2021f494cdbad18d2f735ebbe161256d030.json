{"ast":null,"code":"import _defineProperty from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";import _objectSpread from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _slicedToArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import{getElementAtPosition}from\"../scene\";import{isBindableElement,isBindingElement,isLinearElement}from\"./typeChecks\";import{bindingBorderTest,distanceToBindableElement,maxBindingGap,determineFocusDistance,intersectElementWithLine,determineFocusPoint}from\"./collision\";import{mutateElement}from\"./mutateElement\";import Scene from\"../scene/Scene\";import{LinearElementEditor}from\"./linearElementEditor\";import{arrayToMap,tupleToCoors}from\"../utils\";import{KEYS}from\"../keys\";import{getBoundTextElement,handleBindTextResize}from\"./textElement\";export var shouldEnableBindingForPointerEvent=function shouldEnableBindingForPointerEvent(event){return!event[KEYS.CTRL_OR_CMD];};export var isBindingEnabled=function isBindingEnabled(appState){return appState.isBindingEnabled;};var getNonDeletedElements=function getNonDeletedElements(scene,ids){var result=[];ids.forEach(function(id){var element=scene.getNonDeletedElement(id);if(element!=null){result.push(element);}});return result;};export var bindOrUnbindLinearElement=function bindOrUnbindLinearElement(linearElement,startBindingElement,endBindingElement){var boundToElementIds=new Set();var unboundFromElementIds=new Set();bindOrUnbindLinearElementEdge(linearElement,startBindingElement,endBindingElement,\"start\",boundToElementIds,unboundFromElementIds);bindOrUnbindLinearElementEdge(linearElement,endBindingElement,startBindingElement,\"end\",boundToElementIds,unboundFromElementIds);var onlyUnbound=Array.from(unboundFromElementIds).filter(function(id){return!boundToElementIds.has(id);});getNonDeletedElements(Scene.getScene(linearElement),onlyUnbound).forEach(function(element){var _element$boundElement;mutateElement(element,{boundElements:(_element$boundElement=element.boundElements)===null||_element$boundElement===void 0?void 0:_element$boundElement.filter(function(element){return element.type!==\"arrow\"||element.id!==linearElement.id;})});});};var bindOrUnbindLinearElementEdge=function bindOrUnbindLinearElementEdge(linearElement,bindableElement,otherEdgeBindableElement,startOrEnd,boundToElementIds,unboundFromElementIds){if(bindableElement!==\"keep\"){if(bindableElement!=null){// Don't bind if we're trying to bind or are already bound to the same\n// element on the other edge already (\"start\" edge takes precedence).\nif(otherEdgeBindableElement==null||(otherEdgeBindableElement===\"keep\"?!isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(linearElement,bindableElement,startOrEnd):startOrEnd===\"start\"||otherEdgeBindableElement.id!==bindableElement.id)){bindLinearElement(linearElement,bindableElement,startOrEnd);boundToElementIds.add(bindableElement.id);}}else{var unbound=unbindLinearElement(linearElement,startOrEnd);if(unbound!=null){unboundFromElementIds.add(unbound);}}}};export var bindOrUnbindSelectedElements=function bindOrUnbindSelectedElements(elements){elements.forEach(function(element){if(isBindingElement(element)){bindOrUnbindLinearElement(element,getElligibleElementForBindingElement(element,\"start\"),getElligibleElementForBindingElement(element,\"end\"));}else if(isBindableElement(element)){maybeBindBindableElement(element);}});};var maybeBindBindableElement=function maybeBindBindableElement(bindableElement){getElligibleElementsForBindableElementAndWhere(bindableElement).forEach(function(_ref){var _ref2=_slicedToArray(_ref,2),linearElement=_ref2[0],where=_ref2[1];return bindOrUnbindLinearElement(linearElement,where===\"end\"?\"keep\":bindableElement,where===\"start\"?\"keep\":bindableElement);});};export var maybeBindLinearElement=function maybeBindLinearElement(linearElement,appState,scene,pointerCoords){if(appState.startBoundElement!=null){bindLinearElement(linearElement,appState.startBoundElement,\"start\");}var hoveredElement=getHoveredElementForBinding(pointerCoords,scene);if(hoveredElement!=null&&!isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(linearElement,hoveredElement,\"end\")){bindLinearElement(linearElement,hoveredElement,\"end\");}};var bindLinearElement=function bindLinearElement(linearElement,hoveredElement,startOrEnd){mutateElement(linearElement,_defineProperty({},startOrEnd===\"start\"?\"startBinding\":\"endBinding\",_objectSpread({elementId:hoveredElement.id},calculateFocusAndGap(linearElement,hoveredElement,startOrEnd))));var boundElementsMap=arrayToMap(hoveredElement.boundElements||[]);if(!boundElementsMap.has(linearElement.id)){mutateElement(hoveredElement,{boundElements:(hoveredElement.boundElements||[]).concat({id:linearElement.id,type:\"arrow\"})});}};// Don't bind both ends of a simple segment\nvar isLinearElementSimpleAndAlreadyBoundOnOppositeEdge=function isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(linearElement,bindableElement,startOrEnd){var otherBinding=linearElement[startOrEnd===\"start\"?\"endBinding\":\"startBinding\"];return isLinearElementSimpleAndAlreadyBound(linearElement,otherBinding===null||otherBinding===void 0?void 0:otherBinding.elementId,bindableElement);};export var isLinearElementSimpleAndAlreadyBound=function isLinearElementSimpleAndAlreadyBound(linearElement,alreadyBoundToId,bindableElement){return alreadyBoundToId===bindableElement.id&&linearElement.points.length<3;};export var unbindLinearElements=function unbindLinearElements(elements){elements.forEach(function(element){if(isBindingElement(element)){bindOrUnbindLinearElement(element,null,null);}});};var unbindLinearElement=function unbindLinearElement(linearElement,startOrEnd){var field=startOrEnd===\"start\"?\"startBinding\":\"endBinding\";var binding=linearElement[field];if(binding==null){return null;}mutateElement(linearElement,_defineProperty({},field,null));return binding.elementId;};export var getHoveredElementForBinding=function getHoveredElementForBinding(pointerCoords,scene){var hoveredElement=getElementAtPosition(scene.getNonDeletedElements(),function(element){return isBindableElement(element,false)&&bindingBorderTest(element,pointerCoords);});return hoveredElement;};var calculateFocusAndGap=function calculateFocusAndGap(linearElement,hoveredElement,startOrEnd){var direction=startOrEnd===\"start\"?-1:1;var edgePointIndex=direction===-1?0:linearElement.points.length-1;var adjacentPointIndex=edgePointIndex-direction;var edgePoint=LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement,edgePointIndex);var adjacentPoint=LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement,adjacentPointIndex);return{focus:determineFocusDistance(hoveredElement,adjacentPoint,edgePoint),gap:Math.max(1,distanceToBindableElement(hoveredElement,edgePoint))};};// Supports translating, rotating and scaling `changedElement` with bound\n// linear elements.\n// Because scaling involves moving the focus points as well, it is\n// done before the `changedElement` is updated, and the `newSize` is passed\n// in explicitly.\nexport var updateBoundElements=function updateBoundElements(changedElement,options){var _changedElement$bound;var boundLinearElements=((_changedElement$bound=changedElement.boundElements)!==null&&_changedElement$bound!==void 0?_changedElement$bound:[]).filter(function(el){return el.type===\"arrow\";});if(boundLinearElements.length===0){return;}var _ref3=options!==null&&options!==void 0?options:{},newSize=_ref3.newSize,simultaneouslyUpdated=_ref3.simultaneouslyUpdated;var simultaneouslyUpdatedElementIds=getSimultaneouslyUpdatedElementIds(simultaneouslyUpdated);getNonDeletedElements(Scene.getScene(changedElement),boundLinearElements.map(function(el){return el.id;})).forEach(function(element){if(!isLinearElement(element)){return;}var bindableElement=changedElement;// In case the boundElements are stale\nif(!doesNeedUpdate(element,bindableElement)){return;}var startBinding=maybeCalculateNewGapWhenScaling(bindableElement,element.startBinding,newSize);var endBinding=maybeCalculateNewGapWhenScaling(bindableElement,element.endBinding,newSize);// `linearElement` is being moved/scaled already, just update the binding\nif(simultaneouslyUpdatedElementIds.has(element.id)){mutateElement(element,{startBinding:startBinding,endBinding:endBinding});return;}updateBoundPoint(element,\"start\",startBinding,changedElement);updateBoundPoint(element,\"end\",endBinding,changedElement);var boundText=getBoundTextElement(element);if(boundText){handleBindTextResize(element,false);}});};var doesNeedUpdate=function doesNeedUpdate(boundElement,changedElement){var _boundElement$startBi,_boundElement$endBind;return((_boundElement$startBi=boundElement.startBinding)===null||_boundElement$startBi===void 0?void 0:_boundElement$startBi.elementId)===changedElement.id||((_boundElement$endBind=boundElement.endBinding)===null||_boundElement$endBind===void 0?void 0:_boundElement$endBind.elementId)===changedElement.id;};var getSimultaneouslyUpdatedElementIds=function getSimultaneouslyUpdatedElementIds(simultaneouslyUpdated){return new Set((simultaneouslyUpdated||[]).map(function(element){return element.id;}));};var updateBoundPoint=function updateBoundPoint(linearElement,startOrEnd,binding,changedElement){if(binding==null||// We only need to update the other end if this is a 2 point line element\nbinding.elementId!==changedElement.id&&linearElement.points.length>2){return;}var bindingElement=Scene.getScene(linearElement).getElement(binding.elementId);if(bindingElement==null){// We're not cleaning up after deleted elements atm., so handle this case\nreturn;}var direction=startOrEnd===\"start\"?-1:1;var edgePointIndex=direction===-1?0:linearElement.points.length-1;var adjacentPointIndex=edgePointIndex-direction;var adjacentPoint=LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement,adjacentPointIndex);var focusPointAbsolute=determineFocusPoint(bindingElement,binding.focus,adjacentPoint);var newEdgePoint;// The linear element was not originally pointing inside the bound shape,\n// we can point directly at the focus point\nif(binding.gap===0){newEdgePoint=focusPointAbsolute;}else{var intersections=intersectElementWithLine(bindingElement,adjacentPoint,focusPointAbsolute,binding.gap);if(intersections.length===0){// This should never happen, since focusPoint should always be\n// inside the element, but just in case, bail out\nnewEdgePoint=focusPointAbsolute;}else{// Guaranteed to intersect because focusPoint is always inside the shape\nnewEdgePoint=intersections[0];}}LinearElementEditor.movePoints(linearElement,[{index:edgePointIndex,point:LinearElementEditor.pointFromAbsoluteCoords(linearElement,newEdgePoint)}],_defineProperty({},startOrEnd===\"start\"?\"startBinding\":\"endBinding\",binding));};var maybeCalculateNewGapWhenScaling=function maybeCalculateNewGapWhenScaling(changedElement,currentBinding,newSize){if(currentBinding==null||newSize==null){return currentBinding;}var gap=currentBinding.gap,focus=currentBinding.focus,elementId=currentBinding.elementId;var newWidth=newSize.width,newHeight=newSize.height;var width=changedElement.width,height=changedElement.height;var newGap=Math.max(1,Math.min(maxBindingGap(changedElement,newWidth,newHeight),gap*(newWidth<newHeight?newWidth/width:newHeight/height)));return{elementId:elementId,gap:newGap,focus:focus};};export var getEligibleElementsForBinding=function getEligibleElementsForBinding(elements){var includedElementIds=new Set(elements.map(function(_ref4){var id=_ref4.id;return id;}));return elements.flatMap(function(element){return isBindingElement(element,false)?getElligibleElementsForBindingElement(element).filter(function(element){return!includedElementIds.has(element.id);}):isBindableElement(element,false)?getElligibleElementsForBindableElementAndWhere(element).filter(function(binding){return!includedElementIds.has(binding[0].id);}):[];});};var getElligibleElementsForBindingElement=function getElligibleElementsForBindingElement(linearElement){return[getElligibleElementForBindingElement(linearElement,\"start\"),getElligibleElementForBindingElement(linearElement,\"end\")].filter(function(element){return element!=null;});};var getElligibleElementForBindingElement=function getElligibleElementForBindingElement(linearElement,startOrEnd){return getHoveredElementForBinding(getLinearElementEdgeCoors(linearElement,startOrEnd),Scene.getScene(linearElement));};var getLinearElementEdgeCoors=function getLinearElementEdgeCoors(linearElement,startOrEnd){var index=startOrEnd===\"start\"?0:-1;return tupleToCoors(LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement,index));};var getElligibleElementsForBindableElementAndWhere=function getElligibleElementsForBindableElementAndWhere(bindableElement){return Scene.getScene(bindableElement).getNonDeletedElements().map(function(element){if(!isBindingElement(element,false)){return null;}var canBindStart=isLinearElementEligibleForNewBindingByBindable(element,\"start\",bindableElement);var canBindEnd=isLinearElementEligibleForNewBindingByBindable(element,\"end\",bindableElement);if(!canBindStart&&!canBindEnd){return null;}return[element,canBindStart&&canBindEnd?\"both\":canBindStart?\"start\":\"end\",bindableElement];}).filter(function(maybeElement){return maybeElement!=null;});};var isLinearElementEligibleForNewBindingByBindable=function isLinearElementEligibleForNewBindingByBindable(linearElement,startOrEnd,bindableElement){var existingBinding=linearElement[startOrEnd===\"start\"?\"startBinding\":\"endBinding\"];return existingBinding==null&&!isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(linearElement,bindableElement,startOrEnd)&&bindingBorderTest(bindableElement,getLinearElementEdgeCoors(linearElement,startOrEnd));};// We need to:\n// 1: Update elements not selected to point to duplicated elements\n// 2: Update duplicated elements to point to other duplicated elements\nexport var fixBindingsAfterDuplication=function fixBindingsAfterDuplication(sceneElements,oldElements,oldIdToDuplicatedId,duplicatesServeAsOld){// First collect all the binding/bindable elements, so we only update\n// each once, regardless of whether they were duplicated or not.\nvar allBoundElementIds=new Set();var allBindableElementIds=new Set();var shouldReverseRoles=duplicatesServeAsOld===\"duplicatesServeAsOld\";oldElements.forEach(function(oldElement){var boundElements=oldElement.boundElements;if(boundElements!=null&&boundElements.length>0){boundElements.forEach(function(boundElement){if(shouldReverseRoles&&!oldIdToDuplicatedId.has(boundElement.id)){allBoundElementIds.add(boundElement.id);}});allBindableElementIds.add(oldIdToDuplicatedId.get(oldElement.id));}if(isBindingElement(oldElement)){if(oldElement.startBinding!=null){var elementId=oldElement.startBinding.elementId;if(shouldReverseRoles&&!oldIdToDuplicatedId.has(elementId)){allBindableElementIds.add(elementId);}}if(oldElement.endBinding!=null){var _elementId=oldElement.endBinding.elementId;if(shouldReverseRoles&&!oldIdToDuplicatedId.has(_elementId)){allBindableElementIds.add(_elementId);}}if(oldElement.startBinding!=null||oldElement.endBinding!=null){allBoundElementIds.add(oldIdToDuplicatedId.get(oldElement.id));}}});// Update the linear elements\nsceneElements.filter(function(_ref5){var id=_ref5.id;return allBoundElementIds.has(id);}).forEach(function(element){var startBinding=element.startBinding,endBinding=element.endBinding;mutateElement(element,{startBinding:newBindingAfterDuplication(startBinding,oldIdToDuplicatedId),endBinding:newBindingAfterDuplication(endBinding,oldIdToDuplicatedId)});});// Update the bindable shapes\nsceneElements.filter(function(_ref6){var id=_ref6.id;return allBindableElementIds.has(id);}).forEach(function(bindableElement){var boundElements=bindableElement.boundElements;if(boundElements!=null&&boundElements.length>0){mutateElement(bindableElement,{boundElements:boundElements.map(function(boundElement){return oldIdToDuplicatedId.has(boundElement.id)?{id:oldIdToDuplicatedId.get(boundElement.id),type:boundElement.type}:boundElement;})});}});};var newBindingAfterDuplication=function newBindingAfterDuplication(binding,oldIdToDuplicatedId){var _oldIdToDuplicatedId$;if(binding==null){return null;}var elementId=binding.elementId,focus=binding.focus,gap=binding.gap;return{focus:focus,gap:gap,elementId:(_oldIdToDuplicatedId$=oldIdToDuplicatedId.get(elementId))!==null&&_oldIdToDuplicatedId$!==void 0?_oldIdToDuplicatedId$:elementId};};export var fixBindingsAfterDeletion=function fixBindingsAfterDeletion(sceneElements,deletedElements){var deletedElementIds=new Set(deletedElements.map(function(element){return element.id;}));// non-deleted which bindings need to be updated\nvar affectedElements=new Set();deletedElements.forEach(function(deletedElement){if(isBindableElement(deletedElement)){var _deletedElement$bound;(_deletedElement$bound=deletedElement.boundElements)===null||_deletedElement$bound===void 0?void 0:_deletedElement$bound.forEach(function(element){if(!deletedElementIds.has(element.id)){affectedElements.add(element.id);}});}else if(isBindingElement(deletedElement)){if(deletedElement.startBinding){affectedElements.add(deletedElement.startBinding.elementId);}if(deletedElement.endBinding){affectedElements.add(deletedElement.endBinding.elementId);}}});sceneElements.filter(function(_ref7){var id=_ref7.id;return affectedElements.has(id);}).forEach(function(element){if(isBindableElement(element)){mutateElement(element,{boundElements:newBoundElementsAfterDeletion(element.boundElements,deletedElementIds)});}else if(isBindingElement(element)){mutateElement(element,{startBinding:newBindingAfterDeletion(element.startBinding,deletedElementIds),endBinding:newBindingAfterDeletion(element.endBinding,deletedElementIds)});}});};var newBindingAfterDeletion=function newBindingAfterDeletion(binding,deletedElementIds){if(binding==null||deletedElementIds.has(binding.elementId)){return null;}return binding;};var newBoundElementsAfterDeletion=function newBoundElementsAfterDeletion(boundElements,deletedElementIds){if(!boundElements){return null;}return boundElements.filter(function(ele){return!deletedElementIds.has(ele.id);});};","map":{"version":3,"names":["getElementAtPosition","isBindableElement","isBindingElement","isLinearElement","bindingBorderTest","distanceToBindableElement","maxBindingGap","determineFocusDistance","intersectElementWithLine","determineFocusPoint","mutateElement","Scene","LinearElementEditor","arrayToMap","tupleToCoors","KEYS","getBoundTextElement","handleBindTextResize","shouldEnableBindingForPointerEvent","event","CTRL_OR_CMD","isBindingEnabled","appState","getNonDeletedElements","scene","ids","result","forEach","id","element","getNonDeletedElement","push","bindOrUnbindLinearElement","linearElement","startBindingElement","endBindingElement","boundToElementIds","Set","unboundFromElementIds","bindOrUnbindLinearElementEdge","onlyUnbound","Array","from","filter","has","getScene","_element$boundElement","boundElements","type","bindableElement","otherEdgeBindableElement","startOrEnd","isLinearElementSimpleAndAlreadyBoundOnOppositeEdge","bindLinearElement","add","unbound","unbindLinearElement","bindOrUnbindSelectedElements","elements","getElligibleElementForBindingElement","maybeBindBindableElement","getElligibleElementsForBindableElementAndWhere","_ref","_ref2","_slicedToArray","where","maybeBindLinearElement","pointerCoords","startBoundElement","hoveredElement","getHoveredElementForBinding","_defineProperty","_objectSpread","elementId","calculateFocusAndGap","boundElementsMap","concat","otherBinding","isLinearElementSimpleAndAlreadyBound","alreadyBoundToId","points","length","unbindLinearElements","field","binding","direction","edgePointIndex","adjacentPointIndex","edgePoint","getPointAtIndexGlobalCoordinates","adjacentPoint","focus","gap","Math","max","updateBoundElements","changedElement","options","_changedElement$bound","boundLinearElements","el","_ref3","newSize","simultaneouslyUpdated","simultaneouslyUpdatedElementIds","getSimultaneouslyUpdatedElementIds","map","doesNeedUpdate","startBinding","maybeCalculateNewGapWhenScaling","endBinding","updateBoundPoint","boundText","boundElement","_boundElement$startBi","_boundElement$endBind","bindingElement","getElement","focusPointAbsolute","newEdgePoint","intersections","movePoints","index","point","pointFromAbsoluteCoords","currentBinding","newWidth","width","newHeight","height","newGap","min","getEligibleElementsForBinding","includedElementIds","_ref4","flatMap","getElligibleElementsForBindingElement","getLinearElementEdgeCoors","canBindStart","isLinearElementEligibleForNewBindingByBindable","canBindEnd","maybeElement","existingBinding","fixBindingsAfterDuplication","sceneElements","oldElements","oldIdToDuplicatedId","duplicatesServeAsOld","allBoundElementIds","allBindableElementIds","shouldReverseRoles","oldElement","get","_ref5","newBindingAfterDuplication","_ref6","_oldIdToDuplicatedId$","fixBindingsAfterDeletion","deletedElements","deletedElementIds","affectedElements","deletedElement","_deletedElement$bound","_ref7","newBoundElementsAfterDeletion","newBindingAfterDeletion","ele"],"sources":["D:/project/excalidraw-cn/src/element/binding.ts"],"sourcesContent":["import {\n  ExcalidrawLinearElement,\n  ExcalidrawBindableElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n  PointBinding,\n  ExcalidrawElement,\n} from \"./types\";\nimport { getElementAtPosition } from \"../scene\";\nimport { AppState } from \"../types\";\nimport {\n  isBindableElement,\n  isBindingElement,\n  isLinearElement,\n} from \"./typeChecks\";\nimport {\n  bindingBorderTest,\n  distanceToBindableElement,\n  maxBindingGap,\n  determineFocusDistance,\n  intersectElementWithLine,\n  determineFocusPoint,\n} from \"./collision\";\nimport { mutateElement } from \"./mutateElement\";\nimport Scene from \"../scene/Scene\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { arrayToMap, tupleToCoors } from \"../utils\";\nimport { KEYS } from \"../keys\";\nimport { getBoundTextElement, handleBindTextResize } from \"./textElement\";\n\nexport type SuggestedBinding =\n  | NonDeleted<ExcalidrawBindableElement>\n  | SuggestedPointBinding;\n\nexport type SuggestedPointBinding = [\n  NonDeleted<ExcalidrawLinearElement>,\n  \"start\" | \"end\" | \"both\",\n  NonDeleted<ExcalidrawBindableElement>,\n];\n\nexport const shouldEnableBindingForPointerEvent = (\n  event: React.PointerEvent<HTMLElement>,\n) => {\n  return !event[KEYS.CTRL_OR_CMD];\n};\n\nexport const isBindingEnabled = (appState: AppState): boolean => {\n  return appState.isBindingEnabled;\n};\n\nconst getNonDeletedElements = (\n  scene: Scene,\n  ids: readonly ExcalidrawElement[\"id\"][],\n): NonDeleted<ExcalidrawElement>[] => {\n  const result: NonDeleted<ExcalidrawElement>[] = [];\n  ids.forEach((id) => {\n    const element = scene.getNonDeletedElement(id);\n    if (element != null) {\n      result.push(element);\n    }\n  });\n  return result;\n};\n\nexport const bindOrUnbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startBindingElement: ExcalidrawBindableElement | null | \"keep\",\n  endBindingElement: ExcalidrawBindableElement | null | \"keep\",\n): void => {\n  const boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  const unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    startBindingElement,\n    endBindingElement,\n    \"start\",\n    boundToElementIds,\n    unboundFromElementIds,\n  );\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    endBindingElement,\n    startBindingElement,\n    \"end\",\n    boundToElementIds,\n    unboundFromElementIds,\n  );\n\n  const onlyUnbound = Array.from(unboundFromElementIds).filter(\n    (id) => !boundToElementIds.has(id),\n  );\n\n  getNonDeletedElements(Scene.getScene(linearElement)!, onlyUnbound).forEach(\n    (element) => {\n      mutateElement(element, {\n        boundElements: element.boundElements?.filter(\n          (element) =>\n            element.type !== \"arrow\" || element.id !== linearElement.id,\n        ),\n      });\n    },\n  );\n};\n\nconst bindOrUnbindLinearElementEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement | null | \"keep\",\n  otherEdgeBindableElement: ExcalidrawBindableElement | null | \"keep\",\n  startOrEnd: \"start\" | \"end\",\n  // Is mutated\n  boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n  // Is mutated\n  unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n): void => {\n  if (bindableElement !== \"keep\") {\n    if (bindableElement != null) {\n      // Don't bind if we're trying to bind or are already bound to the same\n      // element on the other edge already (\"start\" edge takes precedence).\n      if (\n        otherEdgeBindableElement == null ||\n        (otherEdgeBindableElement === \"keep\"\n          ? !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n              linearElement,\n              bindableElement,\n              startOrEnd,\n            )\n          : startOrEnd === \"start\" ||\n            otherEdgeBindableElement.id !== bindableElement.id)\n      ) {\n        bindLinearElement(linearElement, bindableElement, startOrEnd);\n        boundToElementIds.add(bindableElement.id);\n      }\n    } else {\n      const unbound = unbindLinearElement(linearElement, startOrEnd);\n      if (unbound != null) {\n        unboundFromElementIds.add(unbound);\n      }\n    }\n  }\n};\n\nexport const bindOrUnbindSelectedElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): void => {\n  elements.forEach((element) => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(\n        element,\n        getElligibleElementForBindingElement(element, \"start\"),\n        getElligibleElementForBindingElement(element, \"end\"),\n      );\n    } else if (isBindableElement(element)) {\n      maybeBindBindableElement(element);\n    }\n  });\n};\n\nconst maybeBindBindableElement = (\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): void => {\n  getElligibleElementsForBindableElementAndWhere(bindableElement).forEach(\n    ([linearElement, where]) =>\n      bindOrUnbindLinearElement(\n        linearElement,\n        where === \"end\" ? \"keep\" : bindableElement,\n        where === \"start\" ? \"keep\" : bindableElement,\n      ),\n  );\n};\n\nexport const maybeBindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  appState: AppState,\n  scene: Scene,\n  pointerCoords: { x: number; y: number },\n): void => {\n  if (appState.startBoundElement != null) {\n    bindLinearElement(linearElement, appState.startBoundElement, \"start\");\n  }\n  const hoveredElement = getHoveredElementForBinding(pointerCoords, scene);\n  if (\n    hoveredElement != null &&\n    !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n      linearElement,\n      hoveredElement,\n      \"end\",\n    )\n  ) {\n    bindLinearElement(linearElement, hoveredElement, \"end\");\n  }\n};\n\nconst bindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): void => {\n  mutateElement(linearElement, {\n    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: {\n      elementId: hoveredElement.id,\n      ...calculateFocusAndGap(linearElement, hoveredElement, startOrEnd),\n    } as PointBinding,\n  });\n\n  const boundElementsMap = arrayToMap(hoveredElement.boundElements || []);\n  if (!boundElementsMap.has(linearElement.id)) {\n    mutateElement(hoveredElement, {\n      boundElements: (hoveredElement.boundElements || []).concat({\n        id: linearElement.id,\n        type: \"arrow\",\n      }),\n    });\n  }\n};\n\n// Don't bind both ends of a simple segment\nconst isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): boolean => {\n  const otherBinding =\n    linearElement[startOrEnd === \"start\" ? \"endBinding\" : \"startBinding\"];\n  return isLinearElementSimpleAndAlreadyBound(\n    linearElement,\n    otherBinding?.elementId,\n    bindableElement,\n  );\n};\n\nexport const isLinearElementSimpleAndAlreadyBound = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  alreadyBoundToId: ExcalidrawBindableElement[\"id\"] | undefined,\n  bindableElement: ExcalidrawBindableElement,\n): boolean => {\n  return (\n    alreadyBoundToId === bindableElement.id && linearElement.points.length < 3\n  );\n};\n\nexport const unbindLinearElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): void => {\n  elements.forEach((element) => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(element, null, null);\n    }\n  });\n};\n\nconst unbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): ExcalidrawBindableElement[\"id\"] | null => {\n  const field = startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\";\n  const binding = linearElement[field];\n  if (binding == null) {\n    return null;\n  }\n  mutateElement(linearElement, { [field]: null });\n  return binding.elementId;\n};\n\nexport const getHoveredElementForBinding = (\n  pointerCoords: {\n    x: number;\n    y: number;\n  },\n  scene: Scene,\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  const hoveredElement = getElementAtPosition(\n    scene.getNonDeletedElements(),\n    (element) =>\n      isBindableElement(element, false) &&\n      bindingBorderTest(element, pointerCoords),\n  );\n  return hoveredElement as NonDeleted<ExcalidrawBindableElement> | null;\n};\n\nconst calculateFocusAndGap = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): { focus: number; gap: number } => {\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    edgePointIndex,\n  );\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n  );\n  return {\n    focus: determineFocusDistance(hoveredElement, adjacentPoint, edgePoint),\n    gap: Math.max(1, distanceToBindableElement(hoveredElement, edgePoint)),\n  };\n};\n\n// Supports translating, rotating and scaling `changedElement` with bound\n// linear elements.\n// Because scaling involves moving the focus points as well, it is\n// done before the `changedElement` is updated, and the `newSize` is passed\n// in explicitly.\nexport const updateBoundElements = (\n  changedElement: NonDeletedExcalidrawElement,\n  options?: {\n    simultaneouslyUpdated?: readonly ExcalidrawElement[];\n    newSize?: { width: number; height: number };\n  },\n) => {\n  const boundLinearElements = (changedElement.boundElements ?? []).filter(\n    (el) => el.type === \"arrow\",\n  );\n  if (boundLinearElements.length === 0) {\n    return;\n  }\n  const { newSize, simultaneouslyUpdated } = options ?? {};\n  const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(\n    simultaneouslyUpdated,\n  );\n\n  getNonDeletedElements(\n    Scene.getScene(changedElement)!,\n    boundLinearElements.map((el) => el.id),\n  ).forEach((element) => {\n    if (!isLinearElement(element)) {\n      return;\n    }\n\n    const bindableElement = changedElement as ExcalidrawBindableElement;\n    // In case the boundElements are stale\n    if (!doesNeedUpdate(element, bindableElement)) {\n      return;\n    }\n    const startBinding = maybeCalculateNewGapWhenScaling(\n      bindableElement,\n      element.startBinding,\n      newSize,\n    );\n    const endBinding = maybeCalculateNewGapWhenScaling(\n      bindableElement,\n      element.endBinding,\n      newSize,\n    );\n    // `linearElement` is being moved/scaled already, just update the binding\n    if (simultaneouslyUpdatedElementIds.has(element.id)) {\n      mutateElement(element, { startBinding, endBinding });\n      return;\n    }\n    updateBoundPoint(\n      element,\n      \"start\",\n      startBinding,\n      changedElement as ExcalidrawBindableElement,\n    );\n    updateBoundPoint(\n      element,\n      \"end\",\n      endBinding,\n      changedElement as ExcalidrawBindableElement,\n    );\n    const boundText = getBoundTextElement(element);\n    if (boundText) {\n      handleBindTextResize(element, false);\n    }\n  });\n};\n\nconst doesNeedUpdate = (\n  boundElement: NonDeleted<ExcalidrawLinearElement>,\n  changedElement: ExcalidrawBindableElement,\n) => {\n  return (\n    boundElement.startBinding?.elementId === changedElement.id ||\n    boundElement.endBinding?.elementId === changedElement.id\n  );\n};\n\nconst getSimultaneouslyUpdatedElementIds = (\n  simultaneouslyUpdated: readonly ExcalidrawElement[] | undefined,\n): Set<ExcalidrawElement[\"id\"]> => {\n  return new Set((simultaneouslyUpdated || []).map((element) => element.id));\n};\n\nconst updateBoundPoint = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  binding: PointBinding | null | undefined,\n  changedElement: ExcalidrawBindableElement,\n): void => {\n  if (\n    binding == null ||\n    // We only need to update the other end if this is a 2 point line element\n    (binding.elementId !== changedElement.id && linearElement.points.length > 2)\n  ) {\n    return;\n  }\n  const bindingElement = Scene.getScene(linearElement)!.getElement(\n    binding.elementId,\n  ) as ExcalidrawBindableElement | null;\n  if (bindingElement == null) {\n    // We're not cleaning up after deleted elements atm., so handle this case\n    return;\n  }\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n  );\n  const focusPointAbsolute = determineFocusPoint(\n    bindingElement,\n    binding.focus,\n    adjacentPoint,\n  );\n  let newEdgePoint;\n  // The linear element was not originally pointing inside the bound shape,\n  // we can point directly at the focus point\n  if (binding.gap === 0) {\n    newEdgePoint = focusPointAbsolute;\n  } else {\n    const intersections = intersectElementWithLine(\n      bindingElement,\n      adjacentPoint,\n      focusPointAbsolute,\n      binding.gap,\n    );\n    if (intersections.length === 0) {\n      // This should never happen, since focusPoint should always be\n      // inside the element, but just in case, bail out\n      newEdgePoint = focusPointAbsolute;\n    } else {\n      // Guaranteed to intersect because focusPoint is always inside the shape\n      newEdgePoint = intersections[0];\n    }\n  }\n  LinearElementEditor.movePoints(\n    linearElement,\n    [\n      {\n        index: edgePointIndex,\n        point: LinearElementEditor.pointFromAbsoluteCoords(\n          linearElement,\n          newEdgePoint,\n        ),\n      },\n    ],\n    { [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: binding },\n  );\n};\n\nconst maybeCalculateNewGapWhenScaling = (\n  changedElement: ExcalidrawBindableElement,\n  currentBinding: PointBinding | null | undefined,\n  newSize: { width: number; height: number } | undefined,\n): PointBinding | null | undefined => {\n  if (currentBinding == null || newSize == null) {\n    return currentBinding;\n  }\n  const { gap, focus, elementId } = currentBinding;\n  const { width: newWidth, height: newHeight } = newSize;\n  const { width, height } = changedElement;\n  const newGap = Math.max(\n    1,\n    Math.min(\n      maxBindingGap(changedElement, newWidth, newHeight),\n      gap * (newWidth < newHeight ? newWidth / width : newHeight / height),\n    ),\n  );\n  return { elementId, gap: newGap, focus };\n};\n\nexport const getEligibleElementsForBinding = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): SuggestedBinding[] => {\n  const includedElementIds = new Set(elements.map(({ id }) => id));\n  return elements.flatMap((element) =>\n    isBindingElement(element, false)\n      ? (getElligibleElementsForBindingElement(\n          element as NonDeleted<ExcalidrawLinearElement>,\n        ).filter(\n          (element) => !includedElementIds.has(element.id),\n        ) as SuggestedBinding[])\n      : isBindableElement(element, false)\n      ? getElligibleElementsForBindableElementAndWhere(element).filter(\n          (binding) => !includedElementIds.has(binding[0].id),\n        )\n      : [],\n  );\n};\n\nconst getElligibleElementsForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n): NonDeleted<ExcalidrawBindableElement>[] => {\n  return [\n    getElligibleElementForBindingElement(linearElement, \"start\"),\n    getElligibleElementForBindingElement(linearElement, \"end\"),\n  ].filter(\n    (element): element is NonDeleted<ExcalidrawBindableElement> =>\n      element != null,\n  );\n};\n\nconst getElligibleElementForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  return getHoveredElementForBinding(\n    getLinearElementEdgeCoors(linearElement, startOrEnd),\n    Scene.getScene(linearElement)!,\n  );\n};\n\nconst getLinearElementEdgeCoors = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): { x: number; y: number } => {\n  const index = startOrEnd === \"start\" ? 0 : -1;\n  return tupleToCoors(\n    LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, index),\n  );\n};\n\nconst getElligibleElementsForBindableElementAndWhere = (\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): SuggestedPointBinding[] => {\n  return Scene.getScene(bindableElement)!\n    .getNonDeletedElements()\n    .map((element) => {\n      if (!isBindingElement(element, false)) {\n        return null;\n      }\n      const canBindStart = isLinearElementEligibleForNewBindingByBindable(\n        element,\n        \"start\",\n        bindableElement,\n      );\n      const canBindEnd = isLinearElementEligibleForNewBindingByBindable(\n        element,\n        \"end\",\n        bindableElement,\n      );\n      if (!canBindStart && !canBindEnd) {\n        return null;\n      }\n      return [\n        element,\n        canBindStart && canBindEnd ? \"both\" : canBindStart ? \"start\" : \"end\",\n        bindableElement,\n      ];\n    })\n    .filter((maybeElement) => maybeElement != null) as SuggestedPointBinding[];\n};\n\nconst isLinearElementEligibleForNewBindingByBindable = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): boolean => {\n  const existingBinding =\n    linearElement[startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"];\n  return (\n    existingBinding == null &&\n    !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n      linearElement,\n      bindableElement,\n      startOrEnd,\n    ) &&\n    bindingBorderTest(\n      bindableElement,\n      getLinearElementEdgeCoors(linearElement, startOrEnd),\n    )\n  );\n};\n\n// We need to:\n// 1: Update elements not selected to point to duplicated elements\n// 2: Update duplicated elements to point to other duplicated elements\nexport const fixBindingsAfterDuplication = (\n  sceneElements: readonly ExcalidrawElement[],\n  oldElements: readonly ExcalidrawElement[],\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n  // There are three copying mechanisms: Copy-paste, duplication and alt-drag.\n  // Only when alt-dragging the new \"duplicates\" act as the \"old\", while\n  // the \"old\" elements act as the \"new copy\" - essentially working reverse\n  // to the other two.\n  duplicatesServeAsOld?: \"duplicatesServeAsOld\" | undefined,\n): void => {\n  // First collect all the binding/bindable elements, so we only update\n  // each once, regardless of whether they were duplicated or not.\n  const allBoundElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  const allBindableElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  const shouldReverseRoles = duplicatesServeAsOld === \"duplicatesServeAsOld\";\n  oldElements.forEach((oldElement) => {\n    const { boundElements } = oldElement;\n    if (boundElements != null && boundElements.length > 0) {\n      boundElements.forEach((boundElement) => {\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(boundElement.id)) {\n          allBoundElementIds.add(boundElement.id);\n        }\n      });\n      allBindableElementIds.add(oldIdToDuplicatedId.get(oldElement.id)!);\n    }\n    if (isBindingElement(oldElement)) {\n      if (oldElement.startBinding != null) {\n        const { elementId } = oldElement.startBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.endBinding != null) {\n        const { elementId } = oldElement.endBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.startBinding != null || oldElement.endBinding != null) {\n        allBoundElementIds.add(oldIdToDuplicatedId.get(oldElement.id)!);\n      }\n    }\n  });\n\n  // Update the linear elements\n  (\n    sceneElements.filter(({ id }) =>\n      allBoundElementIds.has(id),\n    ) as ExcalidrawLinearElement[]\n  ).forEach((element) => {\n    const { startBinding, endBinding } = element;\n    mutateElement(element, {\n      startBinding: newBindingAfterDuplication(\n        startBinding,\n        oldIdToDuplicatedId,\n      ),\n      endBinding: newBindingAfterDuplication(endBinding, oldIdToDuplicatedId),\n    });\n  });\n\n  // Update the bindable shapes\n  sceneElements\n    .filter(({ id }) => allBindableElementIds.has(id))\n    .forEach((bindableElement) => {\n      const { boundElements } = bindableElement;\n      if (boundElements != null && boundElements.length > 0) {\n        mutateElement(bindableElement, {\n          boundElements: boundElements.map((boundElement) =>\n            oldIdToDuplicatedId.has(boundElement.id)\n              ? {\n                  id: oldIdToDuplicatedId.get(boundElement.id)!,\n                  type: boundElement.type,\n                }\n              : boundElement,\n          ),\n        });\n      }\n    });\n};\n\nconst newBindingAfterDuplication = (\n  binding: PointBinding | null,\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n): PointBinding | null => {\n  if (binding == null) {\n    return null;\n  }\n  const { elementId, focus, gap } = binding;\n  return {\n    focus,\n    gap,\n    elementId: oldIdToDuplicatedId.get(elementId) ?? elementId,\n  };\n};\n\nexport const fixBindingsAfterDeletion = (\n  sceneElements: readonly ExcalidrawElement[],\n  deletedElements: readonly ExcalidrawElement[],\n): void => {\n  const deletedElementIds = new Set(\n    deletedElements.map((element) => element.id),\n  );\n  // non-deleted which bindings need to be updated\n  const affectedElements: Set<ExcalidrawElement[\"id\"]> = new Set();\n  deletedElements.forEach((deletedElement) => {\n    if (isBindableElement(deletedElement)) {\n      deletedElement.boundElements?.forEach((element) => {\n        if (!deletedElementIds.has(element.id)) {\n          affectedElements.add(element.id);\n        }\n      });\n    } else if (isBindingElement(deletedElement)) {\n      if (deletedElement.startBinding) {\n        affectedElements.add(deletedElement.startBinding.elementId);\n      }\n      if (deletedElement.endBinding) {\n        affectedElements.add(deletedElement.endBinding.elementId);\n      }\n    }\n  });\n  sceneElements\n    .filter(({ id }) => affectedElements.has(id))\n    .forEach((element) => {\n      if (isBindableElement(element)) {\n        mutateElement(element, {\n          boundElements: newBoundElementsAfterDeletion(\n            element.boundElements,\n            deletedElementIds,\n          ),\n        });\n      } else if (isBindingElement(element)) {\n        mutateElement(element, {\n          startBinding: newBindingAfterDeletion(\n            element.startBinding,\n            deletedElementIds,\n          ),\n          endBinding: newBindingAfterDeletion(\n            element.endBinding,\n            deletedElementIds,\n          ),\n        });\n      }\n    });\n};\n\nconst newBindingAfterDeletion = (\n  binding: PointBinding | null,\n  deletedElementIds: Set<ExcalidrawElement[\"id\"]>,\n): PointBinding | null => {\n  if (binding == null || deletedElementIds.has(binding.elementId)) {\n    return null;\n  }\n  return binding;\n};\n\nconst newBoundElementsAfterDeletion = (\n  boundElements: ExcalidrawElement[\"boundElements\"],\n  deletedElementIds: Set<ExcalidrawElement[\"id\"]>,\n) => {\n  if (!boundElements) {\n    return null;\n  }\n  return boundElements.filter((ele) => !deletedElementIds.has(ele.id));\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}