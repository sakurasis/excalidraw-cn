{"ast":null,"code":"var _jsxFileName = \"D:\\\\project\\\\excalidraw-cn\\\\src\\\\excalidraw-app\\\\collab\\\\Collab.tsx\";\nimport throttle from \"lodash.throttle\";\nimport { PureComponent } from \"react\";\nimport { ErrorDialog } from \"../../components/ErrorDialog\";\nimport { APP_NAME, ENV, EVENT } from \"../../constants\";\nimport { getSceneVersion, restoreElements } from \"../../packages/excalidraw/index\";\nimport { preventUnload, resolvablePromise, withBatchedUpdates } from \"../../utils\";\nimport { CURSOR_SYNC_TIMEOUT, FILE_UPLOAD_MAX_BYTES, FIREBASE_STORAGE_PREFIXES, INITIAL_SCENE_UPDATE_TIMEOUT, LOAD_IMAGES_TIMEOUT, WS_SCENE_EVENT_TYPES, SYNC_FULL_SCENE_INTERVAL_MS } from \"../app_constants\";\nimport { generateCollaborationLinkData, getCollaborationLink, getCollabServer, getSyncableElements } from \"../data\";\nimport { isSavedToFirebase, loadFilesFromFirebase, loadFromFirebase, saveFilesToFirebase, saveToFirebase } from \"../data/firebase\";\nimport { importUsernameFromLocalStorage, saveUsernameToLocalStorage } from \"../data/localStorage\";\nimport Portal from \"./Portal\";\nimport RoomDialog from \"./RoomDialog\";\nimport { t } from \"../../i18n\";\nimport { UserIdleState } from \"../../types\";\nimport { IDLE_THRESHOLD, ACTIVE_THRESHOLD } from \"../../constants\";\nimport { encodeFilesForUpload, FileManager, updateStaleImageStatuses } from \"../data/FileManager\";\nimport { AbortError } from \"../../errors\";\nimport { isImageElement, isInitializedImageElement } from \"../../element/typeChecks\";\nimport { newElementWith } from \"../../element/mutateElement\";\nimport { reconcileElements as _reconcileElements } from \"./reconciliation\";\nimport { decryptData } from \"../../data/encryption\";\nimport { resetBrowserStateVersions } from \"../data/tabSync\";\nimport { LocalData } from \"../data/LocalData\";\nimport { atom, useAtom } from \"jotai\";\nimport { appJotaiStore } from \"../app-jotai\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport const collabAPIAtom = atom(null);\nexport const collabDialogShownAtom = atom(false);\nexport const isCollaboratingAtom = atom(false);\nexport const isOfflineAtom = atom(false);\nclass Collab extends PureComponent {\n  constructor(props) {\n    var _this;\n    super(props);\n    _this = this;\n    this.portal = void 0;\n    this.fileManager = void 0;\n    this.excalidrawAPI = void 0;\n    this.activeIntervalId = void 0;\n    this.idleTimeoutId = void 0;\n    this.socketInitializationTimer = void 0;\n    this.lastBroadcastedOrReceivedSceneVersion = -1;\n    this.collaborators = new Map();\n    this.onOfflineStatusToggle = () => {\n      appJotaiStore.set(isOfflineAtom, !window.navigator.onLine);\n    };\n    this.isCollaborating = () => appJotaiStore.get(isCollaboratingAtom);\n    this.setIsCollaborating = isCollaborating => {\n      appJotaiStore.set(isCollaboratingAtom, isCollaborating);\n    };\n    this.onUnload = () => {\n      this.destroySocketClient({\n        isUnload: true\n      });\n    };\n    this.beforeUnload = withBatchedUpdates(event => {\n      const syncableElements = getSyncableElements(this.getSceneElementsIncludingDeleted());\n      if (this.isCollaborating() && (this.fileManager.shouldPreventUnload(syncableElements) || !isSavedToFirebase(this.portal, syncableElements))) {\n        // this won't run in time if user decides to leave the site, but\n        //  the purpose is to run in immediately after user decides to stay\n        this.saveCollabRoomToFirebase(syncableElements);\n        preventUnload(event);\n      }\n    });\n    this.saveCollabRoomToFirebase = async syncableElements => {\n      try {\n        const savedData = await saveToFirebase(this.portal, syncableElements, this.excalidrawAPI.getAppState());\n        if (this.isCollaborating() && savedData && savedData.reconciledElements) {\n          this.handleRemoteSceneUpdate(this.reconcileElements(savedData.reconciledElements));\n        }\n      } catch (error) {\n        this.setState({\n          // firestore doesn't return a specific error code when size exceeded\n          errorMessage: /is longer than.*?bytes/.test(error.message) ? t(\"errors.collabSaveFailed_sizeExceeded\") : t(\"errors.collabSaveFailed\")\n        });\n        console.error(error);\n      }\n    };\n    this.stopCollaboration = function () {\n      let keepRemoteState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      _this.queueBroadcastAllElements.cancel();\n      _this.queueSaveToFirebase.cancel();\n      _this.loadImageFiles.cancel();\n      _this.saveCollabRoomToFirebase(getSyncableElements(_this.excalidrawAPI.getSceneElementsIncludingDeleted()));\n      if (_this.portal.socket && _this.fallbackInitializationHandler) {\n        _this.portal.socket.off(\"connect_error\", _this.fallbackInitializationHandler);\n      }\n      if (!keepRemoteState) {\n        LocalData.fileStorage.reset();\n        _this.destroySocketClient();\n      } else if (window.confirm(t(\"alerts.collabStopOverridePrompt\"))) {\n        // hack to ensure that we prefer we disregard any new browser state\n        // that could have been saved in other tabs while we were collaborating\n        resetBrowserStateVersions();\n        window.history.pushState({}, APP_NAME, window.location.origin);\n        _this.destroySocketClient();\n        LocalData.fileStorage.reset();\n        const elements = _this.excalidrawAPI.getSceneElementsIncludingDeleted().map(element => {\n          if (isImageElement(element) && element.status === \"saved\") {\n            return newElementWith(element, {\n              status: \"pending\"\n            });\n          }\n          return element;\n        });\n        _this.excalidrawAPI.updateScene({\n          elements,\n          commitToHistory: false\n        });\n      }\n    };\n    this.destroySocketClient = opts => {\n      this.lastBroadcastedOrReceivedSceneVersion = -1;\n      this.portal.close();\n      this.fileManager.reset();\n      if (!(opts !== null && opts !== void 0 && opts.isUnload)) {\n        this.setIsCollaborating(false);\n        this.setState({\n          activeRoomLink: \"\"\n        });\n        this.collaborators = new Map();\n        this.excalidrawAPI.updateScene({\n          collaborators: this.collaborators\n        });\n        LocalData.resumeSave(\"collaboration\");\n      }\n    };\n    this.fetchImageFilesFromFirebase = async opts => {\n      const unfetchedImages = opts.elements.filter(element => {\n        return isInitializedImageElement(element) && !this.fileManager.isFileHandled(element.fileId) && !element.isDeleted && (opts.forceFetchFiles ? element.status !== \"pending\" || Date.now() - element.updated > 10000 : element.status === \"saved\");\n      }).map(element => element.fileId);\n      return await this.fileManager.getFiles(unfetchedImages);\n    };\n    this.decryptPayload = async (iv, encryptedData, decryptionKey) => {\n      try {\n        const decrypted = await decryptData(iv, encryptedData, decryptionKey);\n        const decodedData = new TextDecoder(\"utf-8\").decode(new Uint8Array(decrypted));\n        return JSON.parse(decodedData);\n      } catch (error) {\n        window.alert(t(\"alerts.decryptFailed\"));\n        console.error(error);\n        return {\n          type: \"INVALID_RESPONSE\"\n        };\n      }\n    };\n    this.fallbackInitializationHandler = null;\n    this.startCollaboration = async existingRoomLinkData => {\n      if (!this.state.username) {\n        import(\"@excalidraw/random-username\").then(_ref => {\n          let {\n            getRandomUsername\n          } = _ref;\n          const username = getRandomUsername();\n          this.onUsernameChange(username);\n        });\n      }\n      if (this.portal.socket) {\n        return null;\n      }\n      let roomId;\n      let roomKey;\n      if (existingRoomLinkData) {\n        ({\n          roomId,\n          roomKey\n        } = existingRoomLinkData);\n      } else {\n        ({\n          roomId,\n          roomKey\n        } = await generateCollaborationLinkData());\n        window.history.pushState({}, APP_NAME, getCollaborationLink({\n          roomId,\n          roomKey\n        }));\n      }\n      const scenePromise = resolvablePromise();\n      this.setIsCollaborating(true);\n      LocalData.pauseSave(\"collaboration\");\n      const {\n        default: socketIOClient\n      } = await import( /* webpackChunkName: \"socketIoClient\" */\"socket.io-client\");\n      const fallbackInitializationHandler = () => {\n        this.initializeRoom({\n          roomLinkData: existingRoomLinkData,\n          fetchScene: true\n        }).then(scene => {\n          scenePromise.resolve(scene);\n        });\n      };\n      this.fallbackInitializationHandler = fallbackInitializationHandler;\n      try {\n        const socketServerData = await getCollabServer();\n        this.portal.socket = this.portal.open(socketIOClient(socketServerData.url, {\n          transports: socketServerData.polling ? [\"websocket\", \"polling\"] : [\"websocket\"]\n        }), roomId, roomKey);\n        this.portal.socket.once(\"connect_error\", fallbackInitializationHandler);\n      } catch (error) {\n        console.error(error);\n        this.setState({\n          errorMessage: error.message\n        });\n        return null;\n      }\n      if (!existingRoomLinkData) {\n        const elements = this.excalidrawAPI.getSceneElements().map(element => {\n          if (isImageElement(element) && element.status === \"saved\") {\n            return newElementWith(element, {\n              status: \"pending\"\n            });\n          }\n          return element;\n        });\n        // remove deleted elements from elements array & history to ensure we don't\n        // expose potentially sensitive user data in case user manually deletes\n        // existing elements (or clears scene), which would otherwise be persisted\n        // to database even if deleted before creating the room.\n        this.excalidrawAPI.history.clear();\n        this.excalidrawAPI.updateScene({\n          elements,\n          commitToHistory: true\n        });\n        this.saveCollabRoomToFirebase(getSyncableElements(elements));\n      }\n\n      // fallback in case you're not alone in the room but still don't receive\n      // initial SCENE_INIT message\n      this.socketInitializationTimer = window.setTimeout(fallbackInitializationHandler, INITIAL_SCENE_UPDATE_TIMEOUT);\n\n      // All socket listeners are moving to Portal\n      this.portal.socket.on(\"client-broadcast\", async (encryptedData, iv) => {\n        if (!this.portal.roomKey) {\n          return;\n        }\n        const decryptedData = await this.decryptPayload(iv, encryptedData, this.portal.roomKey);\n        switch (decryptedData.type) {\n          case \"INVALID_RESPONSE\":\n            return;\n          case WS_SCENE_EVENT_TYPES.INIT:\n            {\n              if (!this.portal.socketInitialized) {\n                this.initializeRoom({\n                  fetchScene: false\n                });\n                const remoteElements = decryptedData.payload.elements;\n                const reconciledElements = this.reconcileElements(remoteElements);\n                this.handleRemoteSceneUpdate(reconciledElements, {\n                  init: true\n                });\n                // noop if already resolved via init from firebase\n                scenePromise.resolve({\n                  elements: reconciledElements,\n                  scrollToContent: true\n                });\n              }\n              break;\n            }\n          case WS_SCENE_EVENT_TYPES.UPDATE:\n            this.handleRemoteSceneUpdate(this.reconcileElements(decryptedData.payload.elements));\n            break;\n          case \"MOUSE_LOCATION\":\n            {\n              const {\n                pointer,\n                button,\n                username,\n                selectedElementIds\n              } = decryptedData.payload;\n              const socketId = decryptedData.payload.socketId ||\n              // @ts-ignore legacy, see #2094 (#2097)\n              decryptedData.payload.socketID;\n              const collaborators = new Map(this.collaborators);\n              const user = collaborators.get(socketId) || {};\n              user.pointer = pointer;\n              user.button = button;\n              user.selectedElementIds = selectedElementIds;\n              user.username = username;\n              collaborators.set(socketId, user);\n              this.excalidrawAPI.updateScene({\n                collaborators\n              });\n              break;\n            }\n          case \"IDLE_STATUS\":\n            {\n              const {\n                userState,\n                socketId,\n                username\n              } = decryptedData.payload;\n              const collaborators = new Map(this.collaborators);\n              const user = collaborators.get(socketId) || {};\n              user.userState = userState;\n              user.username = username;\n              this.excalidrawAPI.updateScene({\n                collaborators\n              });\n              break;\n            }\n        }\n      });\n      this.portal.socket.on(\"first-in-room\", async () => {\n        if (this.portal.socket) {\n          this.portal.socket.off(\"first-in-room\");\n        }\n        const sceneData = await this.initializeRoom({\n          fetchScene: true,\n          roomLinkData: existingRoomLinkData\n        });\n        scenePromise.resolve(sceneData);\n      });\n      this.initializeIdleDetector();\n      this.setState({\n        activeRoomLink: window.location.href\n      });\n      return scenePromise;\n    };\n    this.initializeRoom = async _ref2 => {\n      let {\n        fetchScene,\n        roomLinkData\n      } = _ref2;\n      clearTimeout(this.socketInitializationTimer);\n      if (this.portal.socket && this.fallbackInitializationHandler) {\n        this.portal.socket.off(\"connect_error\", this.fallbackInitializationHandler);\n      }\n      if (fetchScene && roomLinkData && this.portal.socket) {\n        this.excalidrawAPI.resetScene();\n        try {\n          const elements = await loadFromFirebase(roomLinkData.roomId, roomLinkData.roomKey, this.portal.socket);\n          if (elements) {\n            this.setLastBroadcastedOrReceivedSceneVersion(getSceneVersion(elements));\n            return {\n              elements,\n              scrollToContent: true\n            };\n          }\n        } catch (error) {\n          // log the error and move on. other peers will sync us the scene.\n          console.error(error);\n        } finally {\n          this.portal.socketInitialized = true;\n        }\n      } else {\n        this.portal.socketInitialized = true;\n      }\n      return null;\n    };\n    this.reconcileElements = remoteElements => {\n      const localElements = this.getSceneElementsIncludingDeleted();\n      const appState = this.excalidrawAPI.getAppState();\n      remoteElements = restoreElements(remoteElements, null);\n      const reconciledElements = _reconcileElements(localElements, remoteElements, appState);\n\n      // Avoid broadcasting to the rest of the collaborators the scene\n      // we just received!\n      // Note: this needs to be set before updating the scene as it\n      // synchronously calls render.\n      this.setLastBroadcastedOrReceivedSceneVersion(getSceneVersion(reconciledElements));\n      return reconciledElements;\n    };\n    this.loadImageFiles = throttle(async () => {\n      const {\n        loadedFiles,\n        erroredFiles\n      } = await this.fetchImageFilesFromFirebase({\n        elements: this.excalidrawAPI.getSceneElementsIncludingDeleted()\n      });\n      this.excalidrawAPI.addFiles(loadedFiles);\n      updateStaleImageStatuses({\n        excalidrawAPI: this.excalidrawAPI,\n        erroredFiles,\n        elements: this.excalidrawAPI.getSceneElementsIncludingDeleted()\n      });\n    }, LOAD_IMAGES_TIMEOUT);\n    this.handleRemoteSceneUpdate = function (elements) {\n      let {\n        init = false\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      _this.excalidrawAPI.updateScene({\n        elements,\n        commitToHistory: !!init\n      });\n\n      // We haven't yet implemented multiplayer undo functionality, so we clear the undo stack\n      // when we receive any messages from another peer. This UX can be pretty rough -- if you\n      // undo, a user makes a change, and then try to redo, your element(s) will be lost. However,\n      // right now we think this is the right tradeoff.\n      _this.excalidrawAPI.history.clear();\n      _this.loadImageFiles();\n    };\n    this.onPointerMove = () => {\n      if (this.idleTimeoutId) {\n        window.clearTimeout(this.idleTimeoutId);\n        this.idleTimeoutId = null;\n      }\n      this.idleTimeoutId = window.setTimeout(this.reportIdle, IDLE_THRESHOLD);\n      if (!this.activeIntervalId) {\n        this.activeIntervalId = window.setInterval(this.reportActive, ACTIVE_THRESHOLD);\n      }\n    };\n    this.onVisibilityChange = () => {\n      if (document.hidden) {\n        if (this.idleTimeoutId) {\n          window.clearTimeout(this.idleTimeoutId);\n          this.idleTimeoutId = null;\n        }\n        if (this.activeIntervalId) {\n          window.clearInterval(this.activeIntervalId);\n          this.activeIntervalId = null;\n        }\n        this.onIdleStateChange(UserIdleState.AWAY);\n      } else {\n        this.idleTimeoutId = window.setTimeout(this.reportIdle, IDLE_THRESHOLD);\n        this.activeIntervalId = window.setInterval(this.reportActive, ACTIVE_THRESHOLD);\n        this.onIdleStateChange(UserIdleState.ACTIVE);\n      }\n    };\n    this.reportIdle = () => {\n      this.onIdleStateChange(UserIdleState.IDLE);\n      if (this.activeIntervalId) {\n        window.clearInterval(this.activeIntervalId);\n        this.activeIntervalId = null;\n      }\n    };\n    this.reportActive = () => {\n      this.onIdleStateChange(UserIdleState.ACTIVE);\n    };\n    this.initializeIdleDetector = () => {\n      document.addEventListener(EVENT.POINTER_MOVE, this.onPointerMove);\n      document.addEventListener(EVENT.VISIBILITY_CHANGE, this.onVisibilityChange);\n    };\n    this.setLastBroadcastedOrReceivedSceneVersion = version => {\n      this.lastBroadcastedOrReceivedSceneVersion = version;\n    };\n    this.getLastBroadcastedOrReceivedSceneVersion = () => {\n      return this.lastBroadcastedOrReceivedSceneVersion;\n    };\n    this.getSceneElementsIncludingDeleted = () => {\n      return this.excalidrawAPI.getSceneElementsIncludingDeleted();\n    };\n    this.onPointerUpdate = throttle(payload => {\n      payload.pointersMap.size < 2 && this.portal.socket && this.portal.broadcastMouseLocation(payload);\n    }, CURSOR_SYNC_TIMEOUT);\n    this.onIdleStateChange = userState => {\n      this.portal.broadcastIdleChange(userState);\n    };\n    this.broadcastElements = elements => {\n      if (getSceneVersion(elements) > this.getLastBroadcastedOrReceivedSceneVersion()) {\n        this.portal.broadcastScene(WS_SCENE_EVENT_TYPES.UPDATE, elements, false);\n        this.lastBroadcastedOrReceivedSceneVersion = getSceneVersion(elements);\n        this.queueBroadcastAllElements();\n      }\n    };\n    this.syncElements = elements => {\n      this.broadcastElements(elements);\n      this.queueSaveToFirebase();\n    };\n    this.queueBroadcastAllElements = throttle(() => {\n      this.portal.broadcastScene(WS_SCENE_EVENT_TYPES.UPDATE, this.excalidrawAPI.getSceneElementsIncludingDeleted(), true);\n      const currentVersion = this.getLastBroadcastedOrReceivedSceneVersion();\n      const newVersion = Math.max(currentVersion, getSceneVersion(this.getSceneElementsIncludingDeleted()));\n      this.setLastBroadcastedOrReceivedSceneVersion(newVersion);\n    }, SYNC_FULL_SCENE_INTERVAL_MS);\n    this.queueSaveToFirebase = throttle(() => {\n      if (this.portal.socketInitialized) {\n        this.saveCollabRoomToFirebase(getSyncableElements(this.excalidrawAPI.getSceneElementsIncludingDeleted()));\n      }\n    }, SYNC_FULL_SCENE_INTERVAL_MS, {\n      leading: false\n    });\n    this.handleClose = () => {\n      appJotaiStore.set(collabDialogShownAtom, false);\n    };\n    this.setUsername = username => {\n      this.setState({\n        username\n      });\n    };\n    this.onUsernameChange = username => {\n      this.setUsername(username);\n      saveUsernameToLocalStorage(username);\n    };\n    this.state = {\n      errorMessage: \"\",\n      username: importUsernameFromLocalStorage() || \"\",\n      activeRoomLink: \"\"\n    };\n    this.portal = new Portal(this);\n    this.fileManager = new FileManager({\n      getFiles: async fileIds => {\n        const {\n          roomId,\n          roomKey\n        } = this.portal;\n        if (!roomId || !roomKey) {\n          throw new AbortError();\n        }\n        return loadFilesFromFirebase(`files/rooms/${roomId}`, roomKey, fileIds);\n      },\n      saveFiles: async _ref3 => {\n        let {\n          addedFiles\n        } = _ref3;\n        const {\n          roomId,\n          roomKey\n        } = this.portal;\n        if (!roomId || !roomKey) {\n          throw new AbortError();\n        }\n        return saveFilesToFirebase({\n          prefix: `${FIREBASE_STORAGE_PREFIXES.collabFiles}/${roomId}`,\n          files: await encodeFilesForUpload({\n            files: addedFiles,\n            encryptionKey: roomKey,\n            maxBytes: FILE_UPLOAD_MAX_BYTES\n          })\n        });\n      }\n    });\n    this.excalidrawAPI = props.excalidrawAPI;\n    this.activeIntervalId = null;\n    this.idleTimeoutId = null;\n  }\n  componentDidMount() {\n    window.addEventListener(EVENT.BEFORE_UNLOAD, this.beforeUnload);\n    window.addEventListener(\"online\", this.onOfflineStatusToggle);\n    window.addEventListener(\"offline\", this.onOfflineStatusToggle);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload);\n    this.onOfflineStatusToggle();\n    const collabAPI = {\n      isCollaborating: this.isCollaborating,\n      onPointerUpdate: this.onPointerUpdate,\n      startCollaboration: this.startCollaboration,\n      syncElements: this.syncElements,\n      fetchImageFilesFromFirebase: this.fetchImageFilesFromFirebase,\n      stopCollaboration: this.stopCollaboration,\n      setUsername: this.setUsername\n    };\n    appJotaiStore.set(collabAPIAtom, collabAPI);\n    if (process.env.NODE_ENV === ENV.TEST || process.env.NODE_ENV === ENV.DEVELOPMENT) {\n      window.collab = window.collab || {};\n      Object.defineProperties(window, {\n        collab: {\n          configurable: true,\n          value: this\n        }\n      });\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener(\"online\", this.onOfflineStatusToggle);\n    window.removeEventListener(\"offline\", this.onOfflineStatusToggle);\n    window.removeEventListener(EVENT.BEFORE_UNLOAD, this.beforeUnload);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload);\n    window.removeEventListener(EVENT.POINTER_MOVE, this.onPointerMove);\n    window.removeEventListener(EVENT.VISIBILITY_CHANGE, this.onVisibilityChange);\n    if (this.activeIntervalId) {\n      window.clearInterval(this.activeIntervalId);\n      this.activeIntervalId = null;\n    }\n    if (this.idleTimeoutId) {\n      window.clearTimeout(this.idleTimeoutId);\n      this.idleTimeoutId = null;\n    }\n  }\n  setCollaborators(sockets) {\n    const collaborators = new Map();\n    for (const socketId of sockets) {\n      if (this.collaborators.has(socketId)) {\n        collaborators.set(socketId, this.collaborators.get(socketId));\n      } else {\n        collaborators.set(socketId, {});\n      }\n    }\n    this.collaborators = collaborators;\n    this.excalidrawAPI.updateScene({\n      collaborators\n    });\n  }\n  render() {\n    const {\n      username,\n      errorMessage,\n      activeRoomLink\n    } = this.state;\n    const {\n      modalIsShown\n    } = this.props;\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [modalIsShown && /*#__PURE__*/_jsxDEV(RoomDialog, {\n        handleClose: this.handleClose,\n        activeRoomLink: activeRoomLink,\n        username: username,\n        onUsernameChange: this.onUsernameChange,\n        onRoomCreate: () => this.startCollaboration(null),\n        onRoomDestroy: this.stopCollaboration,\n        setErrorMessage: errorMessage => {\n          this.setState({\n            errorMessage\n          });\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 835,\n        columnNumber: 11\n      }, this), errorMessage && /*#__PURE__*/_jsxDEV(ErrorDialog, {\n        onClose: () => this.setState({\n          errorMessage: \"\"\n        }),\n        children: errorMessage\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 848,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true);\n  }\n}\nif (process.env.NODE_ENV === ENV.TEST || process.env.NODE_ENV === ENV.DEVELOPMENT) {\n  window.collab = window.collab || {};\n}\nconst _Collab = props => {\n  const [collabDialogShown] = useAtom(collabDialogShownAtom);\n  return /*#__PURE__*/_jsxDEV(Collab, {\n    ...props,\n    modalIsShown: collabDialogShown\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 872,\n    columnNumber: 10\n  }, this);\n};\nexport default _Collab;","map":{"version":3,"names":["throttle","PureComponent","ErrorDialog","APP_NAME","ENV","EVENT","getSceneVersion","restoreElements","preventUnload","resolvablePromise","withBatchedUpdates","CURSOR_SYNC_TIMEOUT","FILE_UPLOAD_MAX_BYTES","FIREBASE_STORAGE_PREFIXES","INITIAL_SCENE_UPDATE_TIMEOUT","LOAD_IMAGES_TIMEOUT","WS_SCENE_EVENT_TYPES","SYNC_FULL_SCENE_INTERVAL_MS","generateCollaborationLinkData","getCollaborationLink","getCollabServer","getSyncableElements","isSavedToFirebase","loadFilesFromFirebase","loadFromFirebase","saveFilesToFirebase","saveToFirebase","importUsernameFromLocalStorage","saveUsernameToLocalStorage","Portal","RoomDialog","t","UserIdleState","IDLE_THRESHOLD","ACTIVE_THRESHOLD","encodeFilesForUpload","FileManager","updateStaleImageStatuses","AbortError","isImageElement","isInitializedImageElement","newElementWith","reconcileElements","_reconcileElements","decryptData","resetBrowserStateVersions","LocalData","atom","useAtom","appJotaiStore","jsxDEV","_jsxDEV","Fragment","_Fragment","collabAPIAtom","collabDialogShownAtom","isCollaboratingAtom","isOfflineAtom","Collab","constructor","props","_this","this","portal","fileManager","excalidrawAPI","activeIntervalId","idleTimeoutId","socketInitializationTimer","lastBroadcastedOrReceivedSceneVersion","collaborators","Map","onOfflineStatusToggle","set","window","navigator","onLine","isCollaborating","get","setIsCollaborating","onUnload","destroySocketClient","isUnload","beforeUnload","event","syncableElements","getSceneElementsIncludingDeleted","shouldPreventUnload","saveCollabRoomToFirebase","savedData","getAppState","reconciledElements","handleRemoteSceneUpdate","error","setState","errorMessage","test","message","console","stopCollaboration","keepRemoteState","arguments","length","undefined","queueBroadcastAllElements","cancel","queueSaveToFirebase","loadImageFiles","socket","fallbackInitializationHandler","off","fileStorage","reset","confirm","history","pushState","location","origin","elements","map","element","status","updateScene","commitToHistory","opts","close","activeRoomLink","resumeSave","fetchImageFilesFromFirebase","unfetchedImages","filter","isFileHandled","fileId","isDeleted","forceFetchFiles","Date","now","updated","getFiles","decryptPayload","iv","encryptedData","decryptionKey","decrypted","decodedData","TextDecoder","decode","Uint8Array","JSON","parse","alert","type","startCollaboration","existingRoomLinkData","state","username","then","_ref","getRandomUsername","onUsernameChange","roomId","roomKey","scenePromise","pauseSave","default","socketIOClient","initializeRoom","roomLinkData","fetchScene","scene","resolve","socketServerData","open","url","transports","polling","once","getSceneElements","clear","setTimeout","on","decryptedData","INIT","socketInitialized","remoteElements","payload","init","scrollToContent","UPDATE","pointer","button","selectedElementIds","socketId","socketID","user","userState","sceneData","initializeIdleDetector","href","_ref2","clearTimeout","resetScene","setLastBroadcastedOrReceivedSceneVersion","localElements","appState","loadedFiles","erroredFiles","addFiles","onPointerMove","reportIdle","setInterval","reportActive","onVisibilityChange","document","hidden","clearInterval","onIdleStateChange","AWAY","ACTIVE","IDLE","addEventListener","POINTER_MOVE","VISIBILITY_CHANGE","version","getLastBroadcastedOrReceivedSceneVersion","onPointerUpdate","pointersMap","size","broadcastMouseLocation","broadcastIdleChange","broadcastElements","broadcastScene","syncElements","currentVersion","newVersion","Math","max","leading","handleClose","setUsername","fileIds","saveFiles","_ref3","addedFiles","prefix","collabFiles","files","encryptionKey","maxBytes","componentDidMount","BEFORE_UNLOAD","UNLOAD","collabAPI","process","env","NODE_ENV","TEST","DEVELOPMENT","collab","Object","defineProperties","configurable","value","componentWillUnmount","removeEventListener","setCollaborators","sockets","has","render","modalIsShown","children","onRoomCreate","onRoomDestroy","setErrorMessage","fileName","_jsxFileName","lineNumber","columnNumber","onClose","_Collab","collabDialogShown"],"sources":["D:/project/excalidraw-cn/src/excalidraw-app/collab/Collab.tsx"],"sourcesContent":["import throttle from \"lodash.throttle\";\nimport { PureComponent } from \"react\";\nimport { ExcalidrawImperativeAPI } from \"../../types\";\nimport { ErrorDialog } from \"../../components/ErrorDialog\";\nimport { APP_NAME, ENV, EVENT } from \"../../constants\";\nimport { ImportedDataState } from \"../../data/types\";\nimport {\n  ExcalidrawElement,\n  InitializedExcalidrawImageElement,\n} from \"../../element/types\";\nimport {\n  getSceneVersion,\n  restoreElements,\n} from \"../../packages/excalidraw/index\";\nimport { Collaborator, Gesture } from \"../../types\";\nimport {\n  preventUnload,\n  resolvablePromise,\n  withBatchedUpdates,\n} from \"../../utils\";\nimport {\n  CURSOR_SYNC_TIMEOUT,\n  FILE_UPLOAD_MAX_BYTES,\n  FIREBASE_STORAGE_PREFIXES,\n  INITIAL_SCENE_UPDATE_TIMEOUT,\n  LOAD_IMAGES_TIMEOUT,\n  WS_SCENE_EVENT_TYPES,\n  SYNC_FULL_SCENE_INTERVAL_MS,\n} from \"../app_constants\";\nimport {\n  generateCollaborationLinkData,\n  getCollaborationLink,\n  getCollabServer,\n  getSyncableElements,\n  SocketUpdateDataSource,\n  SyncableExcalidrawElement,\n} from \"../data\";\nimport {\n  isSavedToFirebase,\n  loadFilesFromFirebase,\n  loadFromFirebase,\n  saveFilesToFirebase,\n  saveToFirebase,\n} from \"../data/firebase\";\nimport {\n  importUsernameFromLocalStorage,\n  saveUsernameToLocalStorage,\n} from \"../data/localStorage\";\nimport Portal from \"./Portal\";\nimport RoomDialog from \"./RoomDialog\";\nimport { t } from \"../../i18n\";\nimport { UserIdleState } from \"../../types\";\nimport { IDLE_THRESHOLD, ACTIVE_THRESHOLD } from \"../../constants\";\nimport {\n  encodeFilesForUpload,\n  FileManager,\n  updateStaleImageStatuses,\n} from \"../data/FileManager\";\nimport { AbortError } from \"../../errors\";\nimport {\n  isImageElement,\n  isInitializedImageElement,\n} from \"../../element/typeChecks\";\nimport { newElementWith } from \"../../element/mutateElement\";\nimport {\n  ReconciledElements,\n  reconcileElements as _reconcileElements,\n} from \"./reconciliation\";\nimport { decryptData } from \"../../data/encryption\";\nimport { resetBrowserStateVersions } from \"../data/tabSync\";\nimport { LocalData } from \"../data/LocalData\";\nimport { atom, useAtom } from \"jotai\";\nimport { appJotaiStore } from \"../app-jotai\";\n\nexport const collabAPIAtom = atom<CollabAPI | null>(null);\nexport const collabDialogShownAtom = atom(false);\nexport const isCollaboratingAtom = atom(false);\nexport const isOfflineAtom = atom(false);\n\ninterface CollabState {\n  errorMessage: string;\n  username: string;\n  activeRoomLink: string;\n}\n\ntype CollabInstance = InstanceType<typeof Collab>;\n\nexport interface CollabAPI {\n  /** function so that we can access the latest value from stale callbacks */\n  isCollaborating: () => boolean;\n  onPointerUpdate: CollabInstance[\"onPointerUpdate\"];\n  startCollaboration: CollabInstance[\"startCollaboration\"];\n  stopCollaboration: CollabInstance[\"stopCollaboration\"];\n  syncElements: CollabInstance[\"syncElements\"];\n  fetchImageFilesFromFirebase: CollabInstance[\"fetchImageFilesFromFirebase\"];\n  setUsername: (username: string) => void;\n}\n\ninterface PublicProps {\n  excalidrawAPI: ExcalidrawImperativeAPI;\n}\n\ntype Props = PublicProps & { modalIsShown: boolean };\n\nclass Collab extends PureComponent<Props, CollabState> {\n  portal: Portal;\n  fileManager: FileManager;\n  excalidrawAPI: Props[\"excalidrawAPI\"];\n  activeIntervalId: number | null;\n  idleTimeoutId: number | null;\n\n  private socketInitializationTimer?: number;\n  private lastBroadcastedOrReceivedSceneVersion: number = -1;\n  private collaborators = new Map<string, Collaborator>();\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      errorMessage: \"\",\n      username: importUsernameFromLocalStorage() || \"\",\n      activeRoomLink: \"\",\n    };\n    this.portal = new Portal(this);\n    this.fileManager = new FileManager({\n      getFiles: async (fileIds) => {\n        const { roomId, roomKey } = this.portal;\n        if (!roomId || !roomKey) {\n          throw new AbortError();\n        }\n\n        return loadFilesFromFirebase(`files/rooms/${roomId}`, roomKey, fileIds);\n      },\n      saveFiles: async ({ addedFiles }) => {\n        const { roomId, roomKey } = this.portal;\n        if (!roomId || !roomKey) {\n          throw new AbortError();\n        }\n\n        return saveFilesToFirebase({\n          prefix: `${FIREBASE_STORAGE_PREFIXES.collabFiles}/${roomId}`,\n          files: await encodeFilesForUpload({\n            files: addedFiles,\n            encryptionKey: roomKey,\n            maxBytes: FILE_UPLOAD_MAX_BYTES,\n          }),\n        });\n      },\n    });\n    this.excalidrawAPI = props.excalidrawAPI;\n    this.activeIntervalId = null;\n    this.idleTimeoutId = null;\n  }\n\n  componentDidMount() {\n    window.addEventListener(EVENT.BEFORE_UNLOAD, this.beforeUnload);\n    window.addEventListener(\"online\", this.onOfflineStatusToggle);\n    window.addEventListener(\"offline\", this.onOfflineStatusToggle);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload);\n\n    this.onOfflineStatusToggle();\n\n    const collabAPI: CollabAPI = {\n      isCollaborating: this.isCollaborating,\n      onPointerUpdate: this.onPointerUpdate,\n      startCollaboration: this.startCollaboration,\n      syncElements: this.syncElements,\n      fetchImageFilesFromFirebase: this.fetchImageFilesFromFirebase,\n      stopCollaboration: this.stopCollaboration,\n      setUsername: this.setUsername,\n    };\n\n    appJotaiStore.set(collabAPIAtom, collabAPI);\n\n    if (\n      process.env.NODE_ENV === ENV.TEST ||\n      process.env.NODE_ENV === ENV.DEVELOPMENT\n    ) {\n      window.collab = window.collab || ({} as Window[\"collab\"]);\n      Object.defineProperties(window, {\n        collab: {\n          configurable: true,\n          value: this,\n        },\n      });\n    }\n  }\n\n  onOfflineStatusToggle = () => {\n    appJotaiStore.set(isOfflineAtom, !window.navigator.onLine);\n  };\n\n  componentWillUnmount() {\n    window.removeEventListener(\"online\", this.onOfflineStatusToggle);\n    window.removeEventListener(\"offline\", this.onOfflineStatusToggle);\n    window.removeEventListener(EVENT.BEFORE_UNLOAD, this.beforeUnload);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload);\n    window.removeEventListener(EVENT.POINTER_MOVE, this.onPointerMove);\n    window.removeEventListener(\n      EVENT.VISIBILITY_CHANGE,\n      this.onVisibilityChange,\n    );\n    if (this.activeIntervalId) {\n      window.clearInterval(this.activeIntervalId);\n      this.activeIntervalId = null;\n    }\n    if (this.idleTimeoutId) {\n      window.clearTimeout(this.idleTimeoutId);\n      this.idleTimeoutId = null;\n    }\n  }\n\n  isCollaborating = () => appJotaiStore.get(isCollaboratingAtom)!;\n\n  private setIsCollaborating = (isCollaborating: boolean) => {\n    appJotaiStore.set(isCollaboratingAtom, isCollaborating);\n  };\n\n  private onUnload = () => {\n    this.destroySocketClient({ isUnload: true });\n  };\n\n  private beforeUnload = withBatchedUpdates((event: BeforeUnloadEvent) => {\n    const syncableElements = getSyncableElements(\n      this.getSceneElementsIncludingDeleted(),\n    );\n\n    if (\n      this.isCollaborating() &&\n      (this.fileManager.shouldPreventUnload(syncableElements) ||\n        !isSavedToFirebase(this.portal, syncableElements))\n    ) {\n      // this won't run in time if user decides to leave the site, but\n      //  the purpose is to run in immediately after user decides to stay\n      this.saveCollabRoomToFirebase(syncableElements);\n\n      preventUnload(event);\n    }\n  });\n\n  saveCollabRoomToFirebase = async (\n    syncableElements: readonly SyncableExcalidrawElement[],\n  ) => {\n    try {\n      const savedData = await saveToFirebase(\n        this.portal,\n        syncableElements,\n        this.excalidrawAPI.getAppState(),\n      );\n\n      if (this.isCollaborating() && savedData && savedData.reconciledElements) {\n        this.handleRemoteSceneUpdate(\n          this.reconcileElements(savedData.reconciledElements),\n        );\n      }\n    } catch (error: any) {\n      this.setState({\n        // firestore doesn't return a specific error code when size exceeded\n        errorMessage: /is longer than.*?bytes/.test(error.message)\n          ? t(\"errors.collabSaveFailed_sizeExceeded\")\n          : t(\"errors.collabSaveFailed\"),\n      });\n      console.error(error);\n    }\n  };\n\n  stopCollaboration = (keepRemoteState = true) => {\n    this.queueBroadcastAllElements.cancel();\n    this.queueSaveToFirebase.cancel();\n    this.loadImageFiles.cancel();\n\n    this.saveCollabRoomToFirebase(\n      getSyncableElements(\n        this.excalidrawAPI.getSceneElementsIncludingDeleted(),\n      ),\n    );\n\n    if (this.portal.socket && this.fallbackInitializationHandler) {\n      this.portal.socket.off(\n        \"connect_error\",\n        this.fallbackInitializationHandler,\n      );\n    }\n\n    if (!keepRemoteState) {\n      LocalData.fileStorage.reset();\n      this.destroySocketClient();\n    } else if (window.confirm(t(\"alerts.collabStopOverridePrompt\"))) {\n      // hack to ensure that we prefer we disregard any new browser state\n      // that could have been saved in other tabs while we were collaborating\n      resetBrowserStateVersions();\n\n      window.history.pushState({}, APP_NAME, window.location.origin);\n      this.destroySocketClient();\n\n      LocalData.fileStorage.reset();\n\n      const elements = this.excalidrawAPI\n        .getSceneElementsIncludingDeleted()\n        .map((element) => {\n          if (isImageElement(element) && element.status === \"saved\") {\n            return newElementWith(element, { status: \"pending\" });\n          }\n          return element;\n        });\n\n      this.excalidrawAPI.updateScene({\n        elements,\n        commitToHistory: false,\n      });\n    }\n  };\n\n  private destroySocketClient = (opts?: { isUnload: boolean }) => {\n    this.lastBroadcastedOrReceivedSceneVersion = -1;\n    this.portal.close();\n    this.fileManager.reset();\n    if (!opts?.isUnload) {\n      this.setIsCollaborating(false);\n      this.setState({\n        activeRoomLink: \"\",\n      });\n      this.collaborators = new Map();\n      this.excalidrawAPI.updateScene({\n        collaborators: this.collaborators,\n      });\n      LocalData.resumeSave(\"collaboration\");\n    }\n  };\n\n  private fetchImageFilesFromFirebase = async (opts: {\n    elements: readonly ExcalidrawElement[];\n    /**\n     * Indicates whether to fetch files that are errored or pending and older\n     * than 10 seconds.\n     *\n     * Use this as a machanism to fetch files which may be ok but for some\n     * reason their status was not updated correctly.\n     */\n    forceFetchFiles?: boolean;\n  }) => {\n    const unfetchedImages = opts.elements\n      .filter((element) => {\n        return (\n          isInitializedImageElement(element) &&\n          !this.fileManager.isFileHandled(element.fileId) &&\n          !element.isDeleted &&\n          (opts.forceFetchFiles\n            ? element.status !== \"pending\" ||\n              Date.now() - element.updated > 10000\n            : element.status === \"saved\")\n        );\n      })\n      .map((element) => (element as InitializedExcalidrawImageElement).fileId);\n\n    return await this.fileManager.getFiles(unfetchedImages);\n  };\n\n  private decryptPayload = async (\n    iv: Uint8Array,\n    encryptedData: ArrayBuffer,\n    decryptionKey: string,\n  ) => {\n    try {\n      const decrypted = await decryptData(iv, encryptedData, decryptionKey);\n\n      const decodedData = new TextDecoder(\"utf-8\").decode(\n        new Uint8Array(decrypted),\n      );\n      return JSON.parse(decodedData);\n    } catch (error) {\n      window.alert(t(\"alerts.decryptFailed\"));\n      console.error(error);\n      return {\n        type: \"INVALID_RESPONSE\",\n      };\n    }\n  };\n\n  private fallbackInitializationHandler: null | (() => any) = null;\n\n  startCollaboration = async (\n    existingRoomLinkData: null | { roomId: string; roomKey: string },\n  ): Promise<ImportedDataState | null> => {\n    if (!this.state.username) {\n      import(\"@excalidraw/random-username\").then(({ getRandomUsername }) => {\n        const username = getRandomUsername();\n        this.onUsernameChange(username);\n      });\n    }\n\n    if (this.portal.socket) {\n      return null;\n    }\n\n    let roomId;\n    let roomKey;\n\n    if (existingRoomLinkData) {\n      ({ roomId, roomKey } = existingRoomLinkData);\n    } else {\n      ({ roomId, roomKey } = await generateCollaborationLinkData());\n      window.history.pushState(\n        {},\n        APP_NAME,\n        getCollaborationLink({ roomId, roomKey }),\n      );\n    }\n\n    const scenePromise = resolvablePromise<ImportedDataState | null>();\n\n    this.setIsCollaborating(true);\n    LocalData.pauseSave(\"collaboration\");\n\n    const { default: socketIOClient } = await import(\n      /* webpackChunkName: \"socketIoClient\" */ \"socket.io-client\"\n    );\n\n    const fallbackInitializationHandler = () => {\n      this.initializeRoom({\n        roomLinkData: existingRoomLinkData,\n        fetchScene: true,\n      }).then((scene) => {\n        scenePromise.resolve(scene);\n      });\n    };\n    this.fallbackInitializationHandler = fallbackInitializationHandler;\n\n    try {\n      const socketServerData = await getCollabServer();\n\n      this.portal.socket = this.portal.open(\n        socketIOClient(socketServerData.url, {\n          transports: socketServerData.polling\n            ? [\"websocket\", \"polling\"]\n            : [\"websocket\"],\n        }),\n        roomId,\n        roomKey,\n      );\n\n      this.portal.socket.once(\"connect_error\", fallbackInitializationHandler);\n    } catch (error: any) {\n      console.error(error);\n      this.setState({ errorMessage: error.message });\n      return null;\n    }\n\n    if (!existingRoomLinkData) {\n      const elements = this.excalidrawAPI.getSceneElements().map((element) => {\n        if (isImageElement(element) && element.status === \"saved\") {\n          return newElementWith(element, { status: \"pending\" });\n        }\n        return element;\n      });\n      // remove deleted elements from elements array & history to ensure we don't\n      // expose potentially sensitive user data in case user manually deletes\n      // existing elements (or clears scene), which would otherwise be persisted\n      // to database even if deleted before creating the room.\n      this.excalidrawAPI.history.clear();\n      this.excalidrawAPI.updateScene({\n        elements,\n        commitToHistory: true,\n      });\n\n      this.saveCollabRoomToFirebase(getSyncableElements(elements));\n    }\n\n    // fallback in case you're not alone in the room but still don't receive\n    // initial SCENE_INIT message\n    this.socketInitializationTimer = window.setTimeout(\n      fallbackInitializationHandler,\n      INITIAL_SCENE_UPDATE_TIMEOUT,\n    );\n\n    // All socket listeners are moving to Portal\n    this.portal.socket.on(\n      \"client-broadcast\",\n      async (encryptedData: ArrayBuffer, iv: Uint8Array) => {\n        if (!this.portal.roomKey) {\n          return;\n        }\n\n        const decryptedData = await this.decryptPayload(\n          iv,\n          encryptedData,\n          this.portal.roomKey,\n        );\n\n        switch (decryptedData.type) {\n          case \"INVALID_RESPONSE\":\n            return;\n          case WS_SCENE_EVENT_TYPES.INIT: {\n            if (!this.portal.socketInitialized) {\n              this.initializeRoom({ fetchScene: false });\n              const remoteElements = decryptedData.payload.elements;\n              const reconciledElements = this.reconcileElements(remoteElements);\n              this.handleRemoteSceneUpdate(reconciledElements, {\n                init: true,\n              });\n              // noop if already resolved via init from firebase\n              scenePromise.resolve({\n                elements: reconciledElements,\n                scrollToContent: true,\n              });\n            }\n            break;\n          }\n          case WS_SCENE_EVENT_TYPES.UPDATE:\n            this.handleRemoteSceneUpdate(\n              this.reconcileElements(decryptedData.payload.elements),\n            );\n            break;\n          case \"MOUSE_LOCATION\": {\n            const { pointer, button, username, selectedElementIds } =\n              decryptedData.payload;\n            const socketId: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"socketId\"] =\n              decryptedData.payload.socketId ||\n              // @ts-ignore legacy, see #2094 (#2097)\n              decryptedData.payload.socketID;\n\n            const collaborators = new Map(this.collaborators);\n            const user = collaborators.get(socketId) || {}!;\n            user.pointer = pointer;\n            user.button = button;\n            user.selectedElementIds = selectedElementIds;\n            user.username = username;\n            collaborators.set(socketId, user);\n            this.excalidrawAPI.updateScene({\n              collaborators,\n            });\n            break;\n          }\n          case \"IDLE_STATUS\": {\n            const { userState, socketId, username } = decryptedData.payload;\n            const collaborators = new Map(this.collaborators);\n            const user = collaborators.get(socketId) || {}!;\n            user.userState = userState;\n            user.username = username;\n            this.excalidrawAPI.updateScene({\n              collaborators,\n            });\n            break;\n          }\n        }\n      },\n    );\n\n    this.portal.socket.on(\"first-in-room\", async () => {\n      if (this.portal.socket) {\n        this.portal.socket.off(\"first-in-room\");\n      }\n      const sceneData = await this.initializeRoom({\n        fetchScene: true,\n        roomLinkData: existingRoomLinkData,\n      });\n      scenePromise.resolve(sceneData);\n    });\n\n    this.initializeIdleDetector();\n\n    this.setState({\n      activeRoomLink: window.location.href,\n    });\n\n    return scenePromise;\n  };\n\n  private initializeRoom = async ({\n    fetchScene,\n    roomLinkData,\n  }:\n    | {\n        fetchScene: true;\n        roomLinkData: { roomId: string; roomKey: string } | null;\n      }\n    | { fetchScene: false; roomLinkData?: null }) => {\n    clearTimeout(this.socketInitializationTimer!);\n    if (this.portal.socket && this.fallbackInitializationHandler) {\n      this.portal.socket.off(\n        \"connect_error\",\n        this.fallbackInitializationHandler,\n      );\n    }\n    if (fetchScene && roomLinkData && this.portal.socket) {\n      this.excalidrawAPI.resetScene();\n\n      try {\n        const elements = await loadFromFirebase(\n          roomLinkData.roomId,\n          roomLinkData.roomKey,\n          this.portal.socket,\n        );\n        if (elements) {\n          this.setLastBroadcastedOrReceivedSceneVersion(\n            getSceneVersion(elements),\n          );\n\n          return {\n            elements,\n            scrollToContent: true,\n          };\n        }\n      } catch (error: any) {\n        // log the error and move on. other peers will sync us the scene.\n        console.error(error);\n      } finally {\n        this.portal.socketInitialized = true;\n      }\n    } else {\n      this.portal.socketInitialized = true;\n    }\n    return null;\n  };\n\n  private reconcileElements = (\n    remoteElements: readonly ExcalidrawElement[],\n  ): ReconciledElements => {\n    const localElements = this.getSceneElementsIncludingDeleted();\n    const appState = this.excalidrawAPI.getAppState();\n\n    remoteElements = restoreElements(remoteElements, null);\n\n    const reconciledElements = _reconcileElements(\n      localElements,\n      remoteElements,\n      appState,\n    );\n\n    // Avoid broadcasting to the rest of the collaborators the scene\n    // we just received!\n    // Note: this needs to be set before updating the scene as it\n    // synchronously calls render.\n    this.setLastBroadcastedOrReceivedSceneVersion(\n      getSceneVersion(reconciledElements),\n    );\n\n    return reconciledElements;\n  };\n\n  private loadImageFiles = throttle(async () => {\n    const { loadedFiles, erroredFiles } =\n      await this.fetchImageFilesFromFirebase({\n        elements: this.excalidrawAPI.getSceneElementsIncludingDeleted(),\n      });\n\n    this.excalidrawAPI.addFiles(loadedFiles);\n\n    updateStaleImageStatuses({\n      excalidrawAPI: this.excalidrawAPI,\n      erroredFiles,\n      elements: this.excalidrawAPI.getSceneElementsIncludingDeleted(),\n    });\n  }, LOAD_IMAGES_TIMEOUT);\n\n  private handleRemoteSceneUpdate = (\n    elements: ReconciledElements,\n    { init = false }: { init?: boolean } = {},\n  ) => {\n    this.excalidrawAPI.updateScene({\n      elements,\n      commitToHistory: !!init,\n    });\n\n    // We haven't yet implemented multiplayer undo functionality, so we clear the undo stack\n    // when we receive any messages from another peer. This UX can be pretty rough -- if you\n    // undo, a user makes a change, and then try to redo, your element(s) will be lost. However,\n    // right now we think this is the right tradeoff.\n    this.excalidrawAPI.history.clear();\n\n    this.loadImageFiles();\n  };\n\n  private onPointerMove = () => {\n    if (this.idleTimeoutId) {\n      window.clearTimeout(this.idleTimeoutId);\n      this.idleTimeoutId = null;\n    }\n\n    this.idleTimeoutId = window.setTimeout(this.reportIdle, IDLE_THRESHOLD);\n\n    if (!this.activeIntervalId) {\n      this.activeIntervalId = window.setInterval(\n        this.reportActive,\n        ACTIVE_THRESHOLD,\n      );\n    }\n  };\n\n  private onVisibilityChange = () => {\n    if (document.hidden) {\n      if (this.idleTimeoutId) {\n        window.clearTimeout(this.idleTimeoutId);\n        this.idleTimeoutId = null;\n      }\n      if (this.activeIntervalId) {\n        window.clearInterval(this.activeIntervalId);\n        this.activeIntervalId = null;\n      }\n      this.onIdleStateChange(UserIdleState.AWAY);\n    } else {\n      this.idleTimeoutId = window.setTimeout(this.reportIdle, IDLE_THRESHOLD);\n      this.activeIntervalId = window.setInterval(\n        this.reportActive,\n        ACTIVE_THRESHOLD,\n      );\n      this.onIdleStateChange(UserIdleState.ACTIVE);\n    }\n  };\n\n  private reportIdle = () => {\n    this.onIdleStateChange(UserIdleState.IDLE);\n    if (this.activeIntervalId) {\n      window.clearInterval(this.activeIntervalId);\n      this.activeIntervalId = null;\n    }\n  };\n\n  private reportActive = () => {\n    this.onIdleStateChange(UserIdleState.ACTIVE);\n  };\n\n  private initializeIdleDetector = () => {\n    document.addEventListener(EVENT.POINTER_MOVE, this.onPointerMove);\n    document.addEventListener(EVENT.VISIBILITY_CHANGE, this.onVisibilityChange);\n  };\n\n  setCollaborators(sockets: string[]) {\n    const collaborators: InstanceType<typeof Collab>[\"collaborators\"] =\n      new Map();\n    for (const socketId of sockets) {\n      if (this.collaborators.has(socketId)) {\n        collaborators.set(socketId, this.collaborators.get(socketId)!);\n      } else {\n        collaborators.set(socketId, {});\n      }\n    }\n    this.collaborators = collaborators;\n    this.excalidrawAPI.updateScene({ collaborators });\n  }\n\n  public setLastBroadcastedOrReceivedSceneVersion = (version: number) => {\n    this.lastBroadcastedOrReceivedSceneVersion = version;\n  };\n\n  public getLastBroadcastedOrReceivedSceneVersion = () => {\n    return this.lastBroadcastedOrReceivedSceneVersion;\n  };\n\n  public getSceneElementsIncludingDeleted = () => {\n    return this.excalidrawAPI.getSceneElementsIncludingDeleted();\n  };\n\n  onPointerUpdate = throttle(\n    (payload: {\n      pointer: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"pointer\"];\n      button: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"button\"];\n      pointersMap: Gesture[\"pointers\"];\n    }) => {\n      payload.pointersMap.size < 2 &&\n        this.portal.socket &&\n        this.portal.broadcastMouseLocation(payload);\n    },\n    CURSOR_SYNC_TIMEOUT,\n  );\n\n  onIdleStateChange = (userState: UserIdleState) => {\n    this.portal.broadcastIdleChange(userState);\n  };\n\n  broadcastElements = (elements: readonly ExcalidrawElement[]) => {\n    if (\n      getSceneVersion(elements) >\n      this.getLastBroadcastedOrReceivedSceneVersion()\n    ) {\n      this.portal.broadcastScene(WS_SCENE_EVENT_TYPES.UPDATE, elements, false);\n      this.lastBroadcastedOrReceivedSceneVersion = getSceneVersion(elements);\n      this.queueBroadcastAllElements();\n    }\n  };\n\n  syncElements = (elements: readonly ExcalidrawElement[]) => {\n    this.broadcastElements(elements);\n    this.queueSaveToFirebase();\n  };\n\n  queueBroadcastAllElements = throttle(() => {\n    this.portal.broadcastScene(\n      WS_SCENE_EVENT_TYPES.UPDATE,\n      this.excalidrawAPI.getSceneElementsIncludingDeleted(),\n      true,\n    );\n    const currentVersion = this.getLastBroadcastedOrReceivedSceneVersion();\n    const newVersion = Math.max(\n      currentVersion,\n      getSceneVersion(this.getSceneElementsIncludingDeleted()),\n    );\n    this.setLastBroadcastedOrReceivedSceneVersion(newVersion);\n  }, SYNC_FULL_SCENE_INTERVAL_MS);\n\n  queueSaveToFirebase = throttle(\n    () => {\n      if (this.portal.socketInitialized) {\n        this.saveCollabRoomToFirebase(\n          getSyncableElements(\n            this.excalidrawAPI.getSceneElementsIncludingDeleted(),\n          ),\n        );\n      }\n    },\n    SYNC_FULL_SCENE_INTERVAL_MS,\n    { leading: false },\n  );\n\n  handleClose = () => {\n    appJotaiStore.set(collabDialogShownAtom, false);\n  };\n\n  setUsername = (username: string) => {\n    this.setState({ username });\n  };\n\n  onUsernameChange = (username: string) => {\n    this.setUsername(username);\n    saveUsernameToLocalStorage(username);\n  };\n\n  render() {\n    const { username, errorMessage, activeRoomLink } = this.state;\n\n    const { modalIsShown } = this.props;\n\n    return (\n      <>\n        {modalIsShown && (\n          <RoomDialog\n            handleClose={this.handleClose}\n            activeRoomLink={activeRoomLink}\n            username={username}\n            onUsernameChange={this.onUsernameChange}\n            onRoomCreate={() => this.startCollaboration(null)}\n            onRoomDestroy={this.stopCollaboration}\n            setErrorMessage={(errorMessage) => {\n              this.setState({ errorMessage });\n            }}\n          />\n        )}\n        {errorMessage && (\n          <ErrorDialog onClose={() => this.setState({ errorMessage: \"\" })}>\n            {errorMessage}\n          </ErrorDialog>\n        )}\n      </>\n    );\n  }\n}\n\ndeclare global {\n  interface Window {\n    collab: InstanceType<typeof Collab>;\n  }\n}\n\nif (\n  process.env.NODE_ENV === ENV.TEST ||\n  process.env.NODE_ENV === ENV.DEVELOPMENT\n) {\n  window.collab = window.collab || ({} as Window[\"collab\"]);\n}\n\nconst _Collab: React.FC<PublicProps> = (props) => {\n  const [collabDialogShown] = useAtom(collabDialogShownAtom);\n  return <Collab {...props} modalIsShown={collabDialogShown} />;\n};\n\nexport default _Collab;\n\nexport type TCollabClass = Collab;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}