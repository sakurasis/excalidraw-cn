{"ast":null,"code":"import _regeneratorRuntime from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";import _asyncToGenerator from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import _objectSpread from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _slicedToArray from\"D:/project/excalidraw-cn/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import{CODES,KEYS}from\"../keys\";import{isWritableElement,getFontString,getFontFamilyString,isTestEnv}from\"../utils\";import Scene from\"../scene/Scene\";import{isArrowElement,isBoundToContainer,isTextElement}from\"./typeChecks\";import{CLASSES,isSafari}from\"../constants\";import{mutateElement}from\"./mutateElement\";import{getBoundTextElementId,getContainerDims,getContainerElement,getTextElementAngle,getTextWidth,normalizeText,redrawTextBoundingBox,wrapText,getBoundTextMaxHeight,getBoundTextMaxWidth,computeContainerDimensionForBoundText,detectLineHeight,computeBoundTextPosition}from\"./textElement\";import{actionDecreaseFontSize,actionIncreaseFontSize}from\"../actions/actionProperties\";import{actionZoomIn,actionZoomOut}from\"../actions/actionCanvas\";import{LinearElementEditor}from\"./linearElementEditor\";import{parseClipboard}from\"../clipboard\";var getTransform=function getTransform(width,height,angle,appState,maxWidth,maxHeight){var zoom=appState.zoom;var degree=180*angle/Math.PI;var translateX=width*(zoom.value-1)/2;var translateY=height*(zoom.value-1)/2;if(width>maxWidth&&zoom.value!==1){translateX=maxWidth*(zoom.value-1)/2;}if(height>maxHeight&&zoom.value!==1){translateY=maxHeight*(zoom.value-1)/2;}return\"translate(\".concat(translateX,\"px, \").concat(translateY,\"px) scale(\").concat(zoom.value,\") rotate(\").concat(degree,\"deg)\");};var originalContainerCache={};export var updateOriginalContainerCache=function updateOriginalContainerCache(id,height){var data=originalContainerCache[id]||(originalContainerCache[id]={height:height});data.height=height;return data;};export var resetOriginalContainerCache=function resetOriginalContainerCache(id){if(originalContainerCache[id]){delete originalContainerCache[id];}};export var getOriginalContainerHeightFromCache=function getOriginalContainerHeightFromCache(id){var _originalContainerCac,_originalContainerCac2;return(_originalContainerCac=(_originalContainerCac2=originalContainerCache[id])===null||_originalContainerCac2===void 0?void 0:_originalContainerCac2.height)!==null&&_originalContainerCac!==void 0?_originalContainerCac:null;};export var textWysiwyg=function textWysiwyg(_ref){var id=_ref.id,onChange=_ref.onChange,onSubmit=_ref.onSubmit,getViewportCoords=_ref.getViewportCoords,element=_ref.element,canvas=_ref.canvas,excalidrawContainer=_ref.excalidrawContainer,app=_ref.app;var textPropertiesUpdated=function textPropertiesUpdated(updatedTextElement,editable){if(!editable.style.fontFamily||!editable.style.fontSize){return false;}var currentFont=editable.style.fontFamily.replace(/\"/g,\"\");if(getFontFamilyString({fontFamily:updatedTextElement.fontFamily})!==currentFont){return true;}if(\"\".concat(updatedTextElement.fontSize,\"px\")!==editable.style.fontSize){return true;}return false;};var updateWysiwygStyle=function updateWysiwygStyle(){var _Scene$getScene;var appState=app.state;var updatedTextElement=(_Scene$getScene=Scene.getScene(element))===null||_Scene$getScene===void 0?void 0:_Scene$getScene.getElement(id);if(!updatedTextElement){return;}var textAlign=updatedTextElement.textAlign,verticalAlign=updatedTextElement.verticalAlign;if(updatedTextElement&&isTextElement(updatedTextElement)){var coordX=updatedTextElement.x;var coordY=updatedTextElement.y;var container=getContainerElement(updatedTextElement);var maxWidth=updatedTextElement.width;var maxHeight=updatedTextElement.height;var textElementWidth=updatedTextElement.width;// Set to element height by default since that's\n// what is going to be used for unbounded text\nvar textElementHeight=updatedTextElement.height;if(container&&updatedTextElement.containerId){if(isArrowElement(container)){var boundTextCoords=LinearElementEditor.getBoundTextElementPosition(container,updatedTextElement);coordX=boundTextCoords.x;coordY=boundTextCoords.y;}var propertiesUpdated=textPropertiesUpdated(updatedTextElement,editable);var containerDims=getContainerDims(container);var originalContainerData;if(propertiesUpdated){originalContainerData=updateOriginalContainerCache(container.id,containerDims.height);}else{originalContainerData=originalContainerCache[container.id];if(!originalContainerData){originalContainerData=updateOriginalContainerCache(container.id,containerDims.height);}}maxWidth=getBoundTextMaxWidth(container);maxHeight=getBoundTextMaxHeight(container,updatedTextElement);// autogrow container height if text exceeds\nif(!isArrowElement(container)&&textElementHeight>maxHeight){var targetContainerHeight=computeContainerDimensionForBoundText(textElementHeight,container.type);mutateElement(container,{height:targetContainerHeight});return;}else if(// autoshrink container height until original container height\n// is reached when text is removed\n!isArrowElement(container)&&containerDims.height>originalContainerData.height&&textElementHeight<maxHeight){var _targetContainerHeight=computeContainerDimensionForBoundText(textElementHeight,container.type);mutateElement(container,{height:_targetContainerHeight});}else{var _computeBoundTextPosi=computeBoundTextPosition(container,updatedTextElement),_y=_computeBoundTextPosi.y;coordY=_y;}}var _getViewportCoords=getViewportCoords(coordX,coordY),_getViewportCoords2=_slicedToArray(_getViewportCoords,2),viewportX=_getViewportCoords2[0],viewportY=_getViewportCoords2[1];var initialSelectionStart=editable.selectionStart;var initialSelectionEnd=editable.selectionEnd;var initialLength=editable.value.length;// restore cursor position after value updated so it doesn't\n// go to the end of text when container auto expanded\nif(initialSelectionStart===initialSelectionEnd&&initialSelectionEnd!==initialLength){// get diff between length and selection end and shift\n// the cursor by \"diff\" times to position correctly\nvar diff=initialLength-initialSelectionEnd;editable.selectionStart=editable.value.length-diff;editable.selectionEnd=editable.value.length-diff;}if(!container){maxWidth=(appState.width-8-viewportX)/appState.zoom.value;textElementWidth=Math.min(textElementWidth,maxWidth);}else{textElementWidth+=0.5;}var lineHeight=updatedTextElement.lineHeight;// In Safari the font size gets rounded off when rendering hence calculating the line height by rounding off font size\nif(isSafari){lineHeight=detectLineHeight(_objectSpread(_objectSpread({},updatedTextElement),{},{fontSize:Math.round(updatedTextElement.fontSize)}));}// Make sure text editor height doesn't go beyond viewport\nvar editorMaxHeight=(appState.height-viewportY)/appState.zoom.value;Object.assign(editable.style,{font:getFontString(updatedTextElement),// must be defined *after* font ¯\\_(ツ)_/¯\nlineHeight:lineHeight,width:\"\".concat(textElementWidth,\"px\"),height:\"\".concat(textElementHeight,\"px\"),left:\"\".concat(viewportX,\"px\"),top:\"\".concat(viewportY,\"px\"),transform:getTransform(textElementWidth,textElementHeight,getTextElementAngle(updatedTextElement),appState,maxWidth,editorMaxHeight),textAlign:textAlign,verticalAlign:verticalAlign,color:updatedTextElement.strokeColor,opacity:updatedTextElement.opacity/100,filter:\"var(--theme-filter)\",maxHeight:\"\".concat(editorMaxHeight,\"px\")});editable.scrollTop=0;// For some reason updating font attribute doesn't set font family\n// hence updating font family explicitly for test environment\nif(isTestEnv()){editable.style.fontFamily=getFontFamilyString(updatedTextElement);}mutateElement(updatedTextElement,{x:coordX,y:coordY});}};var editable=document.createElement(\"textarea\");editable.dir=\"auto\";editable.tabIndex=0;editable.dataset.type=\"wysiwyg\";// prevent line wrapping on Safari\neditable.wrap=\"off\";editable.classList.add(\"excalidraw-wysiwyg\");var whiteSpace=\"pre\";var wordBreak=\"normal\";if(isBoundToContainer(element)){whiteSpace=\"pre-wrap\";wordBreak=\"break-word\";}Object.assign(editable.style,{position:\"absolute\",display:\"inline-block\",minHeight:\"1em\",backfaceVisibility:\"hidden\",margin:0,padding:0,border:0,outline:0,resize:\"none\",background:\"transparent\",overflow:\"hidden\",// must be specified because in dark mode canvas creates a stacking context\nzIndex:\"var(--zIndex-wysiwyg)\",wordBreak:wordBreak,// prevent line wrapping (`whitespace: nowrap` doesn't work on FF)\nwhiteSpace:whiteSpace,overflowWrap:\"break-word\",boxSizing:\"content-box\"});editable.value=element.originalText;updateWysiwygStyle();if(onChange){editable.onpaste=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(event){var clipboardData,data,container,font,wrappedText,width;return _regeneratorRuntime().wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:_context.next=2;return parseClipboard(event,true);case 2:clipboardData=_context.sent;if(clipboardData.text){_context.next=5;break;}return _context.abrupt(\"return\");case 5:data=normalizeText(clipboardData.text);if(data){_context.next=8;break;}return _context.abrupt(\"return\");case 8:container=getContainerElement(element);font=getFontString({fontSize:app.state.currentItemFontSize,fontFamily:app.state.currentItemFontFamily});if(container){wrappedText=wrapText(\"\".concat(editable.value).concat(data),font,getBoundTextMaxWidth(container));width=getTextWidth(wrappedText,font);editable.style.width=\"\".concat(width,\"px\");}case 11:case\"end\":return _context.stop();}},_callee);}));return function(_x){return _ref2.apply(this,arguments);};}();editable.oninput=function(){onChange(normalizeText(editable.value));};}editable.onkeydown=function(event){if(!event.shiftKey&&actionZoomIn.keyTest(event)){event.preventDefault();app.actionManager.executeAction(actionZoomIn);updateWysiwygStyle();}else if(!event.shiftKey&&actionZoomOut.keyTest(event)){event.preventDefault();app.actionManager.executeAction(actionZoomOut);updateWysiwygStyle();}else if(actionDecreaseFontSize.keyTest(event)){app.actionManager.executeAction(actionDecreaseFontSize);}else if(actionIncreaseFontSize.keyTest(event)){app.actionManager.executeAction(actionIncreaseFontSize);}else if(event.key===KEYS.ESCAPE){event.preventDefault();submittedViaKeyboard=true;handleSubmit();}else if(event.key===KEYS.ENTER&&event[KEYS.CTRL_OR_CMD]){event.preventDefault();if(event.isComposing||event.keyCode===229){return;}submittedViaKeyboard=true;handleSubmit();}else if(event.key===KEYS.TAB||event[KEYS.CTRL_OR_CMD]&&(event.code===CODES.BRACKET_LEFT||event.code===CODES.BRACKET_RIGHT)){event.preventDefault();if(event.isComposing){return;}else if(event.shiftKey||event.code===CODES.BRACKET_LEFT){outdent();}else{indent();}// We must send an input event to resize the element\neditable.dispatchEvent(new Event(\"input\"));}};var TAB_SIZE=4;var TAB=\" \".repeat(TAB_SIZE);var RE_LEADING_TAB=new RegExp(\"^ {1,\".concat(TAB_SIZE,\"}\"));var indent=function indent(){var selectionStart=editable.selectionStart,selectionEnd=editable.selectionEnd;var linesStartIndices=getSelectedLinesStartIndices();var value=editable.value;linesStartIndices.forEach(function(startIndex){var startValue=value.slice(0,startIndex);var endValue=value.slice(startIndex);value=\"\".concat(startValue).concat(TAB).concat(endValue);});editable.value=value;editable.selectionStart=selectionStart+TAB_SIZE;editable.selectionEnd=selectionEnd+TAB_SIZE*linesStartIndices.length;};var outdent=function outdent(){var selectionStart=editable.selectionStart,selectionEnd=editable.selectionEnd;var linesStartIndices=getSelectedLinesStartIndices();var removedTabs=[];var value=editable.value;linesStartIndices.forEach(function(startIndex){var tabMatch=value.slice(startIndex,startIndex+TAB_SIZE).match(RE_LEADING_TAB);if(tabMatch){var startValue=value.slice(0,startIndex);var endValue=value.slice(startIndex+tabMatch[0].length);// Delete a tab from the line\nvalue=\"\".concat(startValue).concat(endValue);removedTabs.push(startIndex);}});editable.value=value;if(removedTabs.length){if(selectionStart>removedTabs[removedTabs.length-1]){editable.selectionStart=Math.max(selectionStart-TAB_SIZE,removedTabs[removedTabs.length-1]);}else{// If the cursor is before the first tab removed, ex:\n// Line| #1\n//     Line #2\n// Lin|e #3\n// we should reset the selectionStart to his initial value.\neditable.selectionStart=selectionStart;}editable.selectionEnd=Math.max(editable.selectionStart,selectionEnd-TAB_SIZE*removedTabs.length);}};/**\n   * @returns indices of start positions of selected lines, in reverse order\n   */var getSelectedLinesStartIndices=function getSelectedLinesStartIndices(){var selectionStart=editable.selectionStart,selectionEnd=editable.selectionEnd,value=editable.value;// chars before selectionStart on the same line\nvar startOffset=value.slice(0,selectionStart).match(/[^\\n]*$/)[0].length;// put caret at the start of the line\nselectionStart=selectionStart-startOffset;var selected=value.slice(selectionStart,selectionEnd);return selected.split(\"\\n\").reduce(function(startIndices,line,idx,lines){return startIndices.concat(idx?// curr line index is prev line's start + prev line's length + \\n\nstartIndices[idx-1]+lines[idx-1].length+1:// first selected line\nselectionStart);},[]).reverse();};var stopEvent=function stopEvent(event){event.preventDefault();event.stopPropagation();};// using a state variable instead of passing it to the handleSubmit callback\n// so that we don't need to create separate a callback for event handlers\nvar submittedViaKeyboard=false;var handleSubmit=function handleSubmit(){var _Scene$getScene2;// cleanup must be run before onSubmit otherwise when app blurs the wysiwyg\n// it'd get stuck in an infinite loop of blur→onSubmit after we re-focus the\n// wysiwyg on update\ncleanup();var updateElement=(_Scene$getScene2=Scene.getScene(element))===null||_Scene$getScene2===void 0?void 0:_Scene$getScene2.getElement(element.id);if(!updateElement){return;}var text=editable.value;var container=getContainerElement(updateElement);if(container){text=updateElement.text;if(editable.value.trim()){var boundTextElementId=getBoundTextElementId(container);if(!boundTextElementId||boundTextElementId!==element.id){mutateElement(container,{boundElements:(container.boundElements||[]).concat({type:\"text\",id:element.id})});}}else{var _container$boundEleme;mutateElement(container,{boundElements:(_container$boundEleme=container.boundElements)===null||_container$boundEleme===void 0?void 0:_container$boundEleme.filter(function(ele){return!isTextElement(ele);})});}redrawTextBoundingBox(updateElement,container);}onSubmit({text:text,viaKeyboard:submittedViaKeyboard,originalText:editable.value});};var cleanup=function cleanup(){if(isDestroyed){return;}isDestroyed=true;// remove events to ensure they don't late-fire\neditable.onblur=null;editable.oninput=null;editable.onkeydown=null;if(observer){observer.disconnect();}window.removeEventListener(\"resize\",updateWysiwygStyle);window.removeEventListener(\"wheel\",stopEvent,true);window.removeEventListener(\"pointerdown\",onPointerDown);window.removeEventListener(\"pointerup\",bindBlurEvent);window.removeEventListener(\"blur\",handleSubmit);unbindUpdate();editable.remove();};var bindBlurEvent=function bindBlurEvent(event){window.removeEventListener(\"pointerup\",bindBlurEvent);// Deferred so that the pointerdown that initiates the wysiwyg doesn't\n// trigger the blur on ensuing pointerup.\n// Also to handle cases such as picking a color which would trigger a blur\n// in that same tick.\nvar target=event===null||event===void 0?void 0:event.target;var isTargetPickerTrigger=target instanceof HTMLElement&&target.classList.contains(\"active-color\");setTimeout(function(){editable.onblur=handleSubmit;if(isTargetPickerTrigger){var callback=function callback(mutationList,observer){var radixIsRemoved=mutationList.find(function(mutation){var _dataset;return mutation.removedNodes.length>0&&((_dataset=mutation.removedNodes[0].dataset)===null||_dataset===void 0?void 0:_dataset.radixPopperContentWrapper)!==undefined;});if(radixIsRemoved){// should work without this in theory\n// and i think it does actually but radix probably somewhere,\n// somehow sets the focus elsewhere\nsetTimeout(function(){editable.focus();});observer.disconnect();}};var _observer=new MutationObserver(callback);_observer.observe(document.querySelector(\".excalidraw-container\"),{childList:true});}// case: clicking on the same property → no change → no update → no focus\nif(!isTargetPickerTrigger){editable.focus();}});};// prevent blur when changing properties from the menu\nvar onPointerDown=function onPointerDown(event){var isTargetPickerTrigger=event.target instanceof HTMLElement&&event.target.classList.contains(\"active-color\");if((event.target instanceof HTMLElement||event.target instanceof SVGElement)&&event.target.closest(\".\".concat(CLASSES.SHAPE_ACTIONS_MENU))&&!isWritableElement(event.target)||isTargetPickerTrigger){editable.onblur=null;window.addEventListener(\"pointerup\",bindBlurEvent);// handle edge-case where pointerup doesn't fire e.g. due to user\n// alt-tabbing away\nwindow.addEventListener(\"blur\",handleSubmit);}};// handle updates of textElement properties of editing element\nvar unbindUpdate=Scene.getScene(element).addCallback(function(){var _document$activeEleme;updateWysiwygStyle();var isColorPickerActive=!!((_document$activeEleme=document.activeElement)!==null&&_document$activeEleme!==void 0&&_document$activeEleme.closest(\".color-picker-content\"));if(!isColorPickerActive){editable.focus();}});// ---------------------------------------------------------------------------\nvar isDestroyed=false;// select on init (focusing is done separately inside the bindBlurEvent()\n// because we need it to happen *after* the blur event from `pointerdown`)\neditable.select();bindBlurEvent();// reposition wysiwyg in case of canvas is resized. Using ResizeObserver\n// is preferred so we catch changes from host, where window may not resize.\nvar observer=null;if(canvas&&\"ResizeObserver\"in window){observer=new window.ResizeObserver(function(){updateWysiwygStyle();});observer.observe(canvas);}else{window.addEventListener(\"resize\",updateWysiwygStyle);}window.addEventListener(\"pointerdown\",onPointerDown);window.addEventListener(\"wheel\",stopEvent,{passive:false,capture:true});excalidrawContainer===null||excalidrawContainer===void 0?void 0:excalidrawContainer.querySelector(\".excalidraw-textEditorContainer\").appendChild(editable);};","map":{"version":3,"names":["CODES","KEYS","isWritableElement","getFontString","getFontFamilyString","isTestEnv","Scene","isArrowElement","isBoundToContainer","isTextElement","CLASSES","isSafari","mutateElement","getBoundTextElementId","getContainerDims","getContainerElement","getTextElementAngle","getTextWidth","normalizeText","redrawTextBoundingBox","wrapText","getBoundTextMaxHeight","getBoundTextMaxWidth","computeContainerDimensionForBoundText","detectLineHeight","computeBoundTextPosition","actionDecreaseFontSize","actionIncreaseFontSize","actionZoomIn","actionZoomOut","LinearElementEditor","parseClipboard","getTransform","width","height","angle","appState","maxWidth","maxHeight","zoom","degree","Math","PI","translateX","value","translateY","concat","originalContainerCache","updateOriginalContainerCache","id","data","resetOriginalContainerCache","getOriginalContainerHeightFromCache","_originalContainerCac","_originalContainerCac2","textWysiwyg","_ref","onChange","onSubmit","getViewportCoords","element","canvas","excalidrawContainer","app","textPropertiesUpdated","updatedTextElement","editable","style","fontFamily","fontSize","currentFont","replace","updateWysiwygStyle","_Scene$getScene","state","getScene","getElement","textAlign","verticalAlign","coordX","x","coordY","y","container","textElementWidth","textElementHeight","containerId","boundTextCoords","getBoundTextElementPosition","propertiesUpdated","containerDims","originalContainerData","targetContainerHeight","type","_computeBoundTextPosi","_getViewportCoords","_getViewportCoords2","_slicedToArray","viewportX","viewportY","initialSelectionStart","selectionStart","initialSelectionEnd","selectionEnd","initialLength","length","diff","min","lineHeight","_objectSpread","round","editorMaxHeight","Object","assign","font","left","top","transform","color","strokeColor","opacity","filter","scrollTop","document","createElement","dir","tabIndex","dataset","wrap","classList","add","whiteSpace","wordBreak","position","display","minHeight","backfaceVisibility","margin","padding","border","outline","resize","background","overflow","zIndex","overflowWrap","boxSizing","originalText","onpaste","_ref2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","event","clipboardData","wrappedText","_callee$","_context","prev","next","sent","text","abrupt","currentItemFontSize","currentItemFontFamily","stop","_x","apply","arguments","oninput","onkeydown","shiftKey","keyTest","preventDefault","actionManager","executeAction","key","ESCAPE","submittedViaKeyboard","handleSubmit","ENTER","CTRL_OR_CMD","isComposing","keyCode","TAB","code","BRACKET_LEFT","BRACKET_RIGHT","outdent","indent","dispatchEvent","Event","TAB_SIZE","repeat","RE_LEADING_TAB","RegExp","linesStartIndices","getSelectedLinesStartIndices","forEach","startIndex","startValue","slice","endValue","removedTabs","tabMatch","match","push","max","startOffset","selected","split","reduce","startIndices","line","idx","lines","reverse","stopEvent","stopPropagation","_Scene$getScene2","cleanup","updateElement","trim","boundTextElementId","boundElements","_container$boundEleme","ele","viaKeyboard","isDestroyed","onblur","observer","disconnect","window","removeEventListener","onPointerDown","bindBlurEvent","unbindUpdate","remove","target","isTargetPickerTrigger","HTMLElement","contains","setTimeout","callback","mutationList","radixIsRemoved","find","mutation","_dataset","removedNodes","radixPopperContentWrapper","undefined","focus","MutationObserver","observe","querySelector","childList","SVGElement","closest","SHAPE_ACTIONS_MENU","addEventListener","addCallback","_document$activeEleme","isColorPickerActive","activeElement","select","ResizeObserver","passive","capture","appendChild"],"sources":["D:/project/excalidraw-cn/src/element/textWysiwyg.tsx"],"sourcesContent":["import { CODES, KEYS } from \"../keys\";\nimport {\n  isWritableElement,\n  getFontString,\n  getFontFamilyString,\n  isTestEnv,\n} from \"../utils\";\nimport Scene from \"../scene/Scene\";\nimport {\n  isArrowElement,\n  isBoundToContainer,\n  isTextElement,\n} from \"./typeChecks\";\nimport { CLASSES, isSafari } from \"../constants\";\nimport {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElementWithContainer,\n  ExcalidrawTextElement,\n  ExcalidrawTextContainer,\n} from \"./types\";\nimport { AppState } from \"../types\";\nimport { mutateElement } from \"./mutateElement\";\nimport {\n  getBoundTextElementId,\n  getContainerDims,\n  getContainerElement,\n  getTextElementAngle,\n  getTextWidth,\n  normalizeText,\n  redrawTextBoundingBox,\n  wrapText,\n  getBoundTextMaxHeight,\n  getBoundTextMaxWidth,\n  computeContainerDimensionForBoundText,\n  detectLineHeight,\n  computeBoundTextPosition,\n} from \"./textElement\";\nimport {\n  actionDecreaseFontSize,\n  actionIncreaseFontSize,\n} from \"../actions/actionProperties\";\nimport { actionZoomIn, actionZoomOut } from \"../actions/actionCanvas\";\nimport App from \"../components/App\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { parseClipboard } from \"../clipboard\";\n\nconst getTransform = (\n  width: number,\n  height: number,\n  angle: number,\n  appState: AppState,\n  maxWidth: number,\n  maxHeight: number,\n) => {\n  const { zoom } = appState;\n  const degree = (180 * angle) / Math.PI;\n  let translateX = (width * (zoom.value - 1)) / 2;\n  let translateY = (height * (zoom.value - 1)) / 2;\n  if (width > maxWidth && zoom.value !== 1) {\n    translateX = (maxWidth * (zoom.value - 1)) / 2;\n  }\n  if (height > maxHeight && zoom.value !== 1) {\n    translateY = (maxHeight * (zoom.value - 1)) / 2;\n  }\n  return `translate(${translateX}px, ${translateY}px) scale(${zoom.value}) rotate(${degree}deg)`;\n};\n\nconst originalContainerCache: {\n  [id: ExcalidrawTextContainer[\"id\"]]:\n    | {\n        height: ExcalidrawTextContainer[\"height\"];\n      }\n    | undefined;\n} = {};\n\nexport const updateOriginalContainerCache = (\n  id: ExcalidrawTextContainer[\"id\"],\n  height: ExcalidrawTextContainer[\"height\"],\n) => {\n  const data =\n    originalContainerCache[id] || (originalContainerCache[id] = { height });\n  data.height = height;\n  return data;\n};\n\nexport const resetOriginalContainerCache = (\n  id: ExcalidrawTextContainer[\"id\"],\n) => {\n  if (originalContainerCache[id]) {\n    delete originalContainerCache[id];\n  }\n};\n\nexport const getOriginalContainerHeightFromCache = (\n  id: ExcalidrawTextContainer[\"id\"],\n) => {\n  return originalContainerCache[id]?.height ?? null;\n};\n\nexport const textWysiwyg = ({\n  id,\n  onChange,\n  onSubmit,\n  getViewportCoords,\n  element,\n  canvas,\n  excalidrawContainer,\n  app,\n}: {\n  id: ExcalidrawElement[\"id\"];\n  onChange?: (text: string) => void;\n  onSubmit: (data: {\n    text: string;\n    viaKeyboard: boolean;\n    originalText: string;\n  }) => void;\n  getViewportCoords: (x: number, y: number) => [number, number];\n  element: ExcalidrawTextElement;\n  canvas: HTMLCanvasElement | null;\n  excalidrawContainer: HTMLDivElement | null;\n  app: App;\n}) => {\n  const textPropertiesUpdated = (\n    updatedTextElement: ExcalidrawTextElement,\n    editable: HTMLTextAreaElement,\n  ) => {\n    if (!editable.style.fontFamily || !editable.style.fontSize) {\n      return false;\n    }\n    const currentFont = editable.style.fontFamily.replace(/\"/g, \"\");\n    if (\n      getFontFamilyString({ fontFamily: updatedTextElement.fontFamily }) !==\n      currentFont\n    ) {\n      return true;\n    }\n    if (`${updatedTextElement.fontSize}px` !== editable.style.fontSize) {\n      return true;\n    }\n    return false;\n  };\n\n  const updateWysiwygStyle = () => {\n    const appState = app.state;\n    const updatedTextElement =\n      Scene.getScene(element)?.getElement<ExcalidrawTextElement>(id);\n\n    if (!updatedTextElement) {\n      return;\n    }\n    const { textAlign, verticalAlign } = updatedTextElement;\n\n    if (updatedTextElement && isTextElement(updatedTextElement)) {\n      let coordX = updatedTextElement.x;\n      let coordY = updatedTextElement.y;\n      const container = getContainerElement(updatedTextElement);\n      let maxWidth = updatedTextElement.width;\n\n      let maxHeight = updatedTextElement.height;\n      let textElementWidth = updatedTextElement.width;\n      // Set to element height by default since that's\n      // what is going to be used for unbounded text\n      const textElementHeight = updatedTextElement.height;\n\n      if (container && updatedTextElement.containerId) {\n        if (isArrowElement(container)) {\n          const boundTextCoords =\n            LinearElementEditor.getBoundTextElementPosition(\n              container,\n              updatedTextElement as ExcalidrawTextElementWithContainer,\n            );\n          coordX = boundTextCoords.x;\n          coordY = boundTextCoords.y;\n        }\n        const propertiesUpdated = textPropertiesUpdated(\n          updatedTextElement,\n          editable,\n        );\n        const containerDims = getContainerDims(container);\n\n        let originalContainerData;\n        if (propertiesUpdated) {\n          originalContainerData = updateOriginalContainerCache(\n            container.id,\n            containerDims.height,\n          );\n        } else {\n          originalContainerData = originalContainerCache[container.id];\n          if (!originalContainerData) {\n            originalContainerData = updateOriginalContainerCache(\n              container.id,\n              containerDims.height,\n            );\n          }\n        }\n\n        maxWidth = getBoundTextMaxWidth(container);\n        maxHeight = getBoundTextMaxHeight(\n          container,\n          updatedTextElement as ExcalidrawTextElementWithContainer,\n        );\n\n        // autogrow container height if text exceeds\n        if (!isArrowElement(container) && textElementHeight > maxHeight) {\n          const targetContainerHeight = computeContainerDimensionForBoundText(\n            textElementHeight,\n            container.type,\n          );\n\n          mutateElement(container, { height: targetContainerHeight });\n          return;\n        } else if (\n          // autoshrink container height until original container height\n          // is reached when text is removed\n          !isArrowElement(container) &&\n          containerDims.height > originalContainerData.height &&\n          textElementHeight < maxHeight\n        ) {\n          const targetContainerHeight = computeContainerDimensionForBoundText(\n            textElementHeight,\n            container.type,\n          );\n          mutateElement(container, { height: targetContainerHeight });\n        } else {\n          const { y } = computeBoundTextPosition(\n            container,\n            updatedTextElement as ExcalidrawTextElementWithContainer,\n          );\n          coordY = y;\n        }\n      }\n      const [viewportX, viewportY] = getViewportCoords(coordX, coordY);\n      const initialSelectionStart = editable.selectionStart;\n      const initialSelectionEnd = editable.selectionEnd;\n      const initialLength = editable.value.length;\n\n      // restore cursor position after value updated so it doesn't\n      // go to the end of text when container auto expanded\n      if (\n        initialSelectionStart === initialSelectionEnd &&\n        initialSelectionEnd !== initialLength\n      ) {\n        // get diff between length and selection end and shift\n        // the cursor by \"diff\" times to position correctly\n        const diff = initialLength - initialSelectionEnd;\n        editable.selectionStart = editable.value.length - diff;\n        editable.selectionEnd = editable.value.length - diff;\n      }\n\n      if (!container) {\n        maxWidth = (appState.width - 8 - viewportX) / appState.zoom.value;\n        textElementWidth = Math.min(textElementWidth, maxWidth);\n      } else {\n        textElementWidth += 0.5;\n      }\n\n      let lineHeight = updatedTextElement.lineHeight;\n\n      // In Safari the font size gets rounded off when rendering hence calculating the line height by rounding off font size\n      if (isSafari) {\n        lineHeight = detectLineHeight({\n          ...updatedTextElement,\n          fontSize: Math.round(updatedTextElement.fontSize),\n        });\n      }\n\n      // Make sure text editor height doesn't go beyond viewport\n      const editorMaxHeight =\n        (appState.height - viewportY) / appState.zoom.value;\n      Object.assign(editable.style, {\n        font: getFontString(updatedTextElement),\n        // must be defined *after* font ¯\\_(ツ)_/¯\n        lineHeight,\n        width: `${textElementWidth}px`,\n        height: `${textElementHeight}px`,\n        left: `${viewportX}px`,\n        top: `${viewportY}px`,\n        transform: getTransform(\n          textElementWidth,\n          textElementHeight,\n          getTextElementAngle(updatedTextElement),\n          appState,\n          maxWidth,\n          editorMaxHeight,\n        ),\n        textAlign,\n        verticalAlign,\n        color: updatedTextElement.strokeColor,\n        opacity: updatedTextElement.opacity / 100,\n        filter: \"var(--theme-filter)\",\n        maxHeight: `${editorMaxHeight}px`,\n      });\n      editable.scrollTop = 0;\n      // For some reason updating font attribute doesn't set font family\n      // hence updating font family explicitly for test environment\n      if (isTestEnv()) {\n        editable.style.fontFamily = getFontFamilyString(updatedTextElement);\n      }\n      mutateElement(updatedTextElement, { x: coordX, y: coordY });\n    }\n  };\n\n  const editable = document.createElement(\"textarea\");\n\n  editable.dir = \"auto\";\n  editable.tabIndex = 0;\n  editable.dataset.type = \"wysiwyg\";\n  // prevent line wrapping on Safari\n  editable.wrap = \"off\";\n  editable.classList.add(\"excalidraw-wysiwyg\");\n\n  let whiteSpace = \"pre\";\n  let wordBreak = \"normal\";\n\n  if (isBoundToContainer(element)) {\n    whiteSpace = \"pre-wrap\";\n    wordBreak = \"break-word\";\n  }\n  Object.assign(editable.style, {\n    position: \"absolute\",\n    display: \"inline-block\",\n    minHeight: \"1em\",\n    backfaceVisibility: \"hidden\",\n    margin: 0,\n    padding: 0,\n    border: 0,\n    outline: 0,\n    resize: \"none\",\n    background: \"transparent\",\n    overflow: \"hidden\",\n    // must be specified because in dark mode canvas creates a stacking context\n    zIndex: \"var(--zIndex-wysiwyg)\",\n    wordBreak,\n    // prevent line wrapping (`whitespace: nowrap` doesn't work on FF)\n    whiteSpace,\n    overflowWrap: \"break-word\",\n    boxSizing: \"content-box\",\n  });\n  editable.value = element.originalText;\n  updateWysiwygStyle();\n\n  if (onChange) {\n    editable.onpaste = async (event) => {\n      const clipboardData = await parseClipboard(event, true);\n      if (!clipboardData.text) {\n        return;\n      }\n      const data = normalizeText(clipboardData.text);\n      if (!data) {\n        return;\n      }\n      const container = getContainerElement(element);\n\n      const font = getFontString({\n        fontSize: app.state.currentItemFontSize,\n        fontFamily: app.state.currentItemFontFamily,\n      });\n      if (container) {\n        const wrappedText = wrapText(\n          `${editable.value}${data}`,\n          font,\n          getBoundTextMaxWidth(container),\n        );\n        const width = getTextWidth(wrappedText, font);\n        editable.style.width = `${width}px`;\n      }\n    };\n\n    editable.oninput = () => {\n      onChange(normalizeText(editable.value));\n    };\n  }\n\n  editable.onkeydown = (event) => {\n    if (!event.shiftKey && actionZoomIn.keyTest(event)) {\n      event.preventDefault();\n      app.actionManager.executeAction(actionZoomIn);\n      updateWysiwygStyle();\n    } else if (!event.shiftKey && actionZoomOut.keyTest(event)) {\n      event.preventDefault();\n      app.actionManager.executeAction(actionZoomOut);\n      updateWysiwygStyle();\n    } else if (actionDecreaseFontSize.keyTest(event)) {\n      app.actionManager.executeAction(actionDecreaseFontSize);\n    } else if (actionIncreaseFontSize.keyTest(event)) {\n      app.actionManager.executeAction(actionIncreaseFontSize);\n    } else if (event.key === KEYS.ESCAPE) {\n      event.preventDefault();\n      submittedViaKeyboard = true;\n      handleSubmit();\n    } else if (event.key === KEYS.ENTER && event[KEYS.CTRL_OR_CMD]) {\n      event.preventDefault();\n      if (event.isComposing || event.keyCode === 229) {\n        return;\n      }\n      submittedViaKeyboard = true;\n      handleSubmit();\n    } else if (\n      event.key === KEYS.TAB ||\n      (event[KEYS.CTRL_OR_CMD] &&\n        (event.code === CODES.BRACKET_LEFT ||\n          event.code === CODES.BRACKET_RIGHT))\n    ) {\n      event.preventDefault();\n      if (event.isComposing) {\n        return;\n      } else if (event.shiftKey || event.code === CODES.BRACKET_LEFT) {\n        outdent();\n      } else {\n        indent();\n      }\n      // We must send an input event to resize the element\n      editable.dispatchEvent(new Event(\"input\"));\n    }\n  };\n\n  const TAB_SIZE = 4;\n  const TAB = \" \".repeat(TAB_SIZE);\n  const RE_LEADING_TAB = new RegExp(`^ {1,${TAB_SIZE}}`);\n  const indent = () => {\n    const { selectionStart, selectionEnd } = editable;\n    const linesStartIndices = getSelectedLinesStartIndices();\n\n    let value = editable.value;\n    linesStartIndices.forEach((startIndex: number) => {\n      const startValue = value.slice(0, startIndex);\n      const endValue = value.slice(startIndex);\n\n      value = `${startValue}${TAB}${endValue}`;\n    });\n\n    editable.value = value;\n\n    editable.selectionStart = selectionStart + TAB_SIZE;\n    editable.selectionEnd = selectionEnd + TAB_SIZE * linesStartIndices.length;\n  };\n\n  const outdent = () => {\n    const { selectionStart, selectionEnd } = editable;\n    const linesStartIndices = getSelectedLinesStartIndices();\n    const removedTabs: number[] = [];\n\n    let value = editable.value;\n    linesStartIndices.forEach((startIndex) => {\n      const tabMatch = value\n        .slice(startIndex, startIndex + TAB_SIZE)\n        .match(RE_LEADING_TAB);\n\n      if (tabMatch) {\n        const startValue = value.slice(0, startIndex);\n        const endValue = value.slice(startIndex + tabMatch[0].length);\n\n        // Delete a tab from the line\n        value = `${startValue}${endValue}`;\n        removedTabs.push(startIndex);\n      }\n    });\n\n    editable.value = value;\n\n    if (removedTabs.length) {\n      if (selectionStart > removedTabs[removedTabs.length - 1]) {\n        editable.selectionStart = Math.max(\n          selectionStart - TAB_SIZE,\n          removedTabs[removedTabs.length - 1],\n        );\n      } else {\n        // If the cursor is before the first tab removed, ex:\n        // Line| #1\n        //     Line #2\n        // Lin|e #3\n        // we should reset the selectionStart to his initial value.\n        editable.selectionStart = selectionStart;\n      }\n      editable.selectionEnd = Math.max(\n        editable.selectionStart,\n        selectionEnd - TAB_SIZE * removedTabs.length,\n      );\n    }\n  };\n\n  /**\n   * @returns indices of start positions of selected lines, in reverse order\n   */\n  const getSelectedLinesStartIndices = () => {\n    let { selectionStart, selectionEnd, value } = editable;\n\n    // chars before selectionStart on the same line\n    const startOffset = value.slice(0, selectionStart).match(/[^\\n]*$/)![0]\n      .length;\n    // put caret at the start of the line\n    selectionStart = selectionStart - startOffset;\n\n    const selected = value.slice(selectionStart, selectionEnd);\n\n    return selected\n      .split(\"\\n\")\n      .reduce(\n        (startIndices, line, idx, lines) =>\n          startIndices.concat(\n            idx\n              ? // curr line index is prev line's start + prev line's length + \\n\n                startIndices[idx - 1] + lines[idx - 1].length + 1\n              : // first selected line\n                selectionStart,\n          ),\n        [] as number[],\n      )\n      .reverse();\n  };\n\n  const stopEvent = (event: Event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  // using a state variable instead of passing it to the handleSubmit callback\n  // so that we don't need to create separate a callback for event handlers\n  let submittedViaKeyboard = false;\n  const handleSubmit = () => {\n    // cleanup must be run before onSubmit otherwise when app blurs the wysiwyg\n    // it'd get stuck in an infinite loop of blur→onSubmit after we re-focus the\n    // wysiwyg on update\n    cleanup();\n    const updateElement = Scene.getScene(element)?.getElement(\n      element.id,\n    ) as ExcalidrawTextElement;\n    if (!updateElement) {\n      return;\n    }\n    let text = editable.value;\n    const container = getContainerElement(updateElement);\n\n    if (container) {\n      text = updateElement.text;\n      if (editable.value.trim()) {\n        const boundTextElementId = getBoundTextElementId(container);\n        if (!boundTextElementId || boundTextElementId !== element.id) {\n          mutateElement(container, {\n            boundElements: (container.boundElements || []).concat({\n              type: \"text\",\n              id: element.id,\n            }),\n          });\n        }\n      } else {\n        mutateElement(container, {\n          boundElements: container.boundElements?.filter(\n            (ele) =>\n              !isTextElement(\n                ele as ExcalidrawTextElement | ExcalidrawLinearElement,\n              ),\n          ),\n        });\n      }\n      redrawTextBoundingBox(updateElement, container);\n    }\n\n    onSubmit({\n      text,\n      viaKeyboard: submittedViaKeyboard,\n      originalText: editable.value,\n    });\n  };\n\n  const cleanup = () => {\n    if (isDestroyed) {\n      return;\n    }\n    isDestroyed = true;\n    // remove events to ensure they don't late-fire\n    editable.onblur = null;\n    editable.oninput = null;\n    editable.onkeydown = null;\n\n    if (observer) {\n      observer.disconnect();\n    }\n\n    window.removeEventListener(\"resize\", updateWysiwygStyle);\n    window.removeEventListener(\"wheel\", stopEvent, true);\n    window.removeEventListener(\"pointerdown\", onPointerDown);\n    window.removeEventListener(\"pointerup\", bindBlurEvent);\n    window.removeEventListener(\"blur\", handleSubmit);\n\n    unbindUpdate();\n\n    editable.remove();\n  };\n\n  const bindBlurEvent = (event?: MouseEvent) => {\n    window.removeEventListener(\"pointerup\", bindBlurEvent);\n    // Deferred so that the pointerdown that initiates the wysiwyg doesn't\n    // trigger the blur on ensuing pointerup.\n    // Also to handle cases such as picking a color which would trigger a blur\n    // in that same tick.\n    const target = event?.target;\n\n    const isTargetPickerTrigger =\n      target instanceof HTMLElement &&\n      target.classList.contains(\"active-color\");\n\n    setTimeout(() => {\n      editable.onblur = handleSubmit;\n\n      if (isTargetPickerTrigger) {\n        const callback = (\n          mutationList: MutationRecord[],\n          observer: MutationObserver,\n        ) => {\n          const radixIsRemoved = mutationList.find(\n            (mutation) =>\n              mutation.removedNodes.length > 0 &&\n              (mutation.removedNodes[0] as HTMLElement).dataset\n                ?.radixPopperContentWrapper !== undefined,\n          );\n\n          if (radixIsRemoved) {\n            // should work without this in theory\n            // and i think it does actually but radix probably somewhere,\n            // somehow sets the focus elsewhere\n            setTimeout(() => {\n              editable.focus();\n            });\n\n            observer.disconnect();\n          }\n        };\n\n        const observer = new MutationObserver(callback);\n\n        observer.observe(document.querySelector(\".excalidraw-container\")!, {\n          childList: true,\n        });\n      }\n\n      // case: clicking on the same property → no change → no update → no focus\n      if (!isTargetPickerTrigger) {\n        editable.focus();\n      }\n    });\n  };\n\n  // prevent blur when changing properties from the menu\n  const onPointerDown = (event: MouseEvent) => {\n    const isTargetPickerTrigger =\n      event.target instanceof HTMLElement &&\n      event.target.classList.contains(\"active-color\");\n\n    if (\n      ((event.target instanceof HTMLElement ||\n        event.target instanceof SVGElement) &&\n        event.target.closest(`.${CLASSES.SHAPE_ACTIONS_MENU}`) &&\n        !isWritableElement(event.target)) ||\n      isTargetPickerTrigger\n    ) {\n      editable.onblur = null;\n      window.addEventListener(\"pointerup\", bindBlurEvent);\n      // handle edge-case where pointerup doesn't fire e.g. due to user\n      // alt-tabbing away\n      window.addEventListener(\"blur\", handleSubmit);\n    }\n  };\n\n  // handle updates of textElement properties of editing element\n  const unbindUpdate = Scene.getScene(element)!.addCallback(() => {\n    updateWysiwygStyle();\n    const isColorPickerActive = !!document.activeElement?.closest(\n      \".color-picker-content\",\n    );\n    if (!isColorPickerActive) {\n      editable.focus();\n    }\n  });\n\n  // ---------------------------------------------------------------------------\n\n  let isDestroyed = false;\n\n  // select on init (focusing is done separately inside the bindBlurEvent()\n  // because we need it to happen *after* the blur event from `pointerdown`)\n  editable.select();\n  bindBlurEvent();\n\n  // reposition wysiwyg in case of canvas is resized. Using ResizeObserver\n  // is preferred so we catch changes from host, where window may not resize.\n  let observer: ResizeObserver | null = null;\n  if (canvas && \"ResizeObserver\" in window) {\n    observer = new window.ResizeObserver(() => {\n      updateWysiwygStyle();\n    });\n    observer.observe(canvas);\n  } else {\n    window.addEventListener(\"resize\", updateWysiwygStyle);\n  }\n\n  window.addEventListener(\"pointerdown\", onPointerDown);\n  window.addEventListener(\"wheel\", stopEvent, {\n    passive: false,\n    capture: true,\n  });\n  excalidrawContainer\n    ?.querySelector(\".excalidraw-textEditorContainer\")!\n    .appendChild(editable);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}